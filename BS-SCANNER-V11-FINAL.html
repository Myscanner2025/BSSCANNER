<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta name="theme-color" content="#0a0a0f">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="BS SCANNER">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQlMgU2Nhbm5lciBWMSIsInNob3J0X25hbWUiOiJCUyBWMSIsImRlc2NyaXB0aW9uIjoiQnliaXQgQ3J5cHRvIFNpZ25hbCBTY2FubmVyIHdpdGggTXVsdGktQUkiLCJzdGFydF91cmwiOiIuIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzBhMGEwZiIsInRoZW1lX2NvbG9yIjoiIzBhMGEwZiIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAxMDAgMTAwJz48cmVjdCB3aWR0aD0nMTAwJyBoZWlnaHQ9JzEwMCcgZmlsbD0nJTIzMGEwYTBmJy8+PHRleHQgeD0nNTAnIHk9JzYwJyBmb250LXNpemU9JzQwJyB0ZXh0LWFuY2hvcj0nbWlkZGxlJyBmaWxsPSclMjNmZmQ3MDAnPuKaoTwvdGV4dD48L3N2Zz4iLCJzaXplcyI6IjE5MngxOTIiLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCJ9XX0=">
<title>BS Scanner V10.3 - STRUCTURE ENGINE + SMART BRAIN</title>
<style>
:root{
--bg1:#0a0a0f;--bg2:#12121a;--bg3:#1a1a25;--bg4:#22222f;
--border:#2a2a3a;--text:#ffffff;--text2:#ffffff;--text3:#ffffff;
--long:#00d9a0;--long-dim:rgba(0,217,160,0.15);
--short:#ff4757;--short-dim:rgba(255,71,87,0.15);
--purple:#a855f7;--purple-dim:rgba(168,85,247,0.15);
--blue:#3b82f6;--blue-dim:rgba(59,130,246,0.15);
--amber:#f59e0b;--amber-dim:rgba(245,158,11,0.15);
--cyan:#06b6d4;--cyan-dim:rgba(6,182,212,0.15);
--gold:#ffd700;--gold-dim:rgba(255,215,0,0.15)
}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,-apple-system,sans-serif;background:var(--bg1);color:var(--text);min-height:100vh;overflow-x:hidden}
.app{display:flex;flex-direction:column;min-height:100vh}

/* HEADER - 2 ROW LAYOUT */
.header{display:flex;flex-direction:column;padding:8px 10px;background:var(--bg2);border-bottom:1px solid var(--border);gap:6px}
.header-row1{display:flex;align-items:center;gap:6px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch;scrollbar-width:none;-ms-overflow-style:none;padding:6px 10px;background:var(--bg2);border-bottom:1px solid var(--border)}
.header-row1::-webkit-scrollbar{display:none}
/* Market Info Badge - Redesigned to match ENV bar */
.info-badge{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg3);border-radius:4px;font-size:11px;border:1px solid var(--border);flex-shrink:0;white-space:nowrap}
.info-badge .icon{font-size:12px}
.info-badge .label{color:var(--text3);margin-right:2px}
.info-badge .value{font-weight:700;color:var(--text)}
.info-badge.go{border-color:var(--long);background:var(--long-dim)}
.info-badge.go .value{color:var(--long)}
.info-badge.caution{border-color:var(--amber);background:var(--amber-dim)}
.info-badge.caution .value{color:var(--amber)}
.info-badge.nogo{border-color:var(--short);background:var(--short-dim)}
.info-badge.nogo .value{color:var(--short)}
/* Old m-badge kept for compatibility but hidden */
.m-badge{display:none}
.header-row2{display:flex;align-items:center;gap:8px}
.header-btns{display:flex;gap:4px;margin-left:auto;align-items:center}
.ai-dot{width:8px;height:8px;border-radius:50%;background:var(--text3);margin-right:4px}
.ai-dot.on{background:var(--long);box-shadow:0 0 8px var(--long)}
.ai-dot.error{background:var(--short);box-shadow:0 0 8px var(--short)}
.btn{padding:4px 8px;border-radius:4px;border:1px solid var(--border);background:var(--bg3);color:var(--text);font-size:10px;cursor:pointer;transition:all 0.2s}
.btn:hover{background:var(--bg4)}
.btn.active{background:var(--long-dim);border-color:var(--long);color:var(--long)}
.btn.scanning{background:linear-gradient(90deg,rgba(255,100,100,0.9),rgba(255,180,100,0.9),rgba(255,255,100,0.9),rgba(100,255,100,0.9),rgba(100,255,255,0.9),rgba(100,180,255,0.9),rgba(180,100,255,0.9),rgba(255,100,255,0.9),rgba(255,100,180,0.9),rgba(255,100,100,0.9));background-size:200% 100%;animation:rainbowFlow 2s linear infinite;border:none;color:#fff;font-weight:700;text-shadow:0 0 5px rgba(0,0,0,0.5);box-shadow:0 0 10px rgba(200,200,255,0.4),0 0 20px rgba(100,200,255,0.2)}
.btn.scan-done{background:linear-gradient(90deg,var(--long),rgba(0,255,170,0.8),var(--cyan),rgba(0,255,170,0.8),var(--long));background-size:200% 100%;animation:completePulse 3s ease-in-out infinite;border:none;color:#fff;font-weight:700;text-shadow:0 0 5px rgba(0,0,0,0.5);box-shadow:0 0 10px var(--long),0 0 20px rgba(0,255,170,0.3)}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.6}}

/* MARKET BADGES - WIDER & SCROLLABLE */
.m-badge{display:flex;align-items:center;gap:4px;padding:6px 10px;background:var(--bg3);border-radius:6px;border:1px solid var(--border);font-size:12px;min-width:85px;flex-shrink:0}
.m-badge-icon{font-size:14px}
.m-badge-value{font-weight:700;color:var(--text);font-size:12px;white-space:nowrap}
.m-badge.bull .m-badge-value{color:var(--long)}
.m-badge.bear .m-badge-value{color:var(--short)}
.m-badge.neutral .m-badge-value{color:var(--text)}
/* Season flash animations */
.m-badge.flash-bright-green{animation:flashBrightGreen 0.5s ease-in-out infinite}
.m-badge.flash-dim-green{animation:flashDimGreen 2s ease-in-out infinite}
.m-badge.flash-bright-red{animation:flashBrightRed 0.5s ease-in-out infinite}
.m-badge.flash-dim-red{animation:flashDimRed 2s ease-in-out infinite}
.m-badge.flash-bright-green .m-badge-value{color:#00ff88;text-shadow:0 0 8px #00ff88}
.m-badge.flash-dim-green .m-badge-value{color:#00d980;text-shadow:0 0 4px #00d980}
.m-badge.flash-bright-red .m-badge-value{color:#ff4757;text-shadow:0 0 8px #ff4757}
.m-badge.flash-dim-red .m-badge-value{color:#ff6b6b;text-shadow:0 0 4px #ff6b6b}
@keyframes flashBrightGreen{0%,100%{opacity:1}50%{opacity:0.3}}
@keyframes flashDimGreen{0%,100%{opacity:1}50%{opacity:0.6}}
@keyframes flashBrightRed{0%,100%{opacity:1}50%{opacity:0.3}}
@keyframes flashDimRed{0%,100%{opacity:1}50%{opacity:0.6}}

/* ENVIRONMENT BAR */
.env-bar{display:flex;align-items:center;gap:6px;padding:6px 10px;background:var(--bg2);border-bottom:1px solid var(--border);overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch;scrollbar-width:none;-ms-overflow-style:none}
.env-bar::-webkit-scrollbar{display:none}
.env-status{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg3);border-radius:4px;font-size:11px;flex-shrink:0;white-space:nowrap}
.env-status .icon{font-size:12px}
.env-status .label{color:var(--text3);margin-right:2px}
.env-status .value{font-weight:700}
.env-status.go{border:1px solid var(--long);background:var(--long-dim)}
.env-status.go .value{color:var(--long)}
.env-status.caution{border:1px solid var(--amber);background:var(--amber-dim)}
.env-status.caution .value{color:var(--amber)}
.env-status.risky{border:1px solid #ff8c00;background:rgba(255,140,0,0.15)}
.env-status.risky .value{color:#ff8c00}
.env-status.nogo{border:1px solid var(--short);background:var(--short-dim)}
.env-status.nogo .value{color:var(--short)}
.env-verdict{margin-left:auto;display:flex;align-items:center;gap:6px;padding:4px 10px;border-radius:4px;font-size:11px;font-weight:700}
.env-verdict.go{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}
.env-verdict.caution{background:var(--amber-dim);color:var(--amber);border:1px solid var(--amber)}
.env-verdict.risky{background:rgba(255,140,0,0.15);color:#ff8c00;border:1px solid #ff8c00}
.env-verdict.nogo{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.env-score{font-size:13px;font-weight:700}

/* V10.3 STRUCTURE BAR */
.structure-bar{display:flex;align-items:center;gap:6px;padding:5px 10px;background:linear-gradient(90deg,var(--bg2),rgba(0,229,255,0.05));border-bottom:1px solid rgba(0,229,255,0.3);overflow-x:auto;scrollbar-width:none}
.structure-bar::-webkit-scrollbar{display:none}
.str-status{display:flex;align-items:center;gap:4px;padding:3px 7px;background:var(--bg3);border-radius:4px;font-size:10px;flex-shrink:0;border:1px solid var(--border)}
.str-status .icon{font-size:11px}
.str-status .label{color:var(--text3);font-size:9px}
.str-status .value{font-weight:700;font-size:10px}
.str-status.valid{border-color:#00e5ff;background:rgba(0,229,255,0.1)}
.str-status.valid .value{color:#00e5ff}
.str-status.invalid{border-color:var(--short);background:var(--short-dim)}
.str-status.invalid .value{color:var(--short)}
.str-status.neutral{border-color:var(--amber);background:var(--amber-dim)}
.str-status.neutral .value{color:var(--amber)}
.str-verdict{margin-left:auto;display:flex;align-items:center;gap:6px;padding:4px 10px;border-radius:4px;font-size:10px;font-weight:700}
.str-verdict.valid{background:#00e5ff;color:#000}
.str-verdict.invalid{background:var(--short);color:#fff}
.str-verdict.neutral{background:var(--amber);color:#000}
.str-score{font-size:12px;font-weight:700}

/* SIGNAL CARD ENV ICONS */
.signal-env{display:flex;gap:2px;margin-top:4px;flex-wrap:wrap}
.signal-env .env-icon{font-size:10px;padding:1px 3px;border-radius:2px;background:var(--bg4)}
.signal-env .env-icon.ok{color:var(--long)}
.signal-env .env-icon.warn{color:var(--amber)}
.signal-env .env-icon.bad{color:var(--short)}

/* SIGNAL CARD STRUCTURE INFO */
.signal-structure{display:flex;gap:4px;margin-top:4px;flex-wrap:wrap;padding:4px 6px;background:var(--bg4);border-radius:4px}
.signal-structure .str-tag{font-size:8px;padding:2px 5px;border-radius:3px;display:flex;align-items:center;gap:2px}
.signal-structure .str-tag .icon{font-size:9px}
.signal-structure .str-tag.channel{background:rgba(0,229,255,0.1);color:#00e5ff}
.signal-structure .str-tag.trendline{background:rgba(168,85,247,0.1);color:#a855f7}
.signal-structure .str-tag.compression{background:var(--long-dim);color:var(--long)}
.signal-structure .str-tag.bias{background:var(--blue-dim);color:var(--blue)}
.signal-structure .str-tag.gate-pass{background:var(--long-dim);color:var(--long)}
.signal-structure .str-tag.gate-fail{background:var(--short-dim);color:var(--short)}

/* SMART MATRIX DISPLAY */
.smart-matrix{display:flex;align-items:center;gap:6px;padding:6px 8px;background:var(--bg4);border-radius:6px;margin-top:6px;flex-wrap:wrap}
.smart-matrix .regime-badge{font-size:9px;padding:2px 6px;border-radius:4px;font-weight:700;text-transform:uppercase}
.smart-matrix .regime-badge.uptrend{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}
.smart-matrix .regime-badge.downtrend{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.smart-matrix .regime-badge.ranging{background:var(--amber-dim);color:var(--amber);border:1px solid var(--amber)}
.smart-matrix .regime-badge.choppy{background:var(--purple-dim);color:var(--purple);border:1px solid var(--purple)}
.smart-matrix .regime-badge.transitional{background:var(--bg3);color:var(--text3);border:1px solid var(--border)}
.smart-matrix .weights{font-size:10px;color:var(--text2);font-family:monospace}
.smart-matrix .weights .w-zone{color:var(--cyan)}
.smart-matrix .weights .w-smc{color:var(--purple)}
.smart-matrix .weights .w-mom{color:var(--amber)}
.smart-matrix .dominant{font-size:9px;padding:2px 5px;border-radius:3px;background:var(--bg3);color:var(--text3)}
.smart-matrix .dominant.zone-lead{color:var(--cyan);border:1px solid var(--cyan)}
.smart-matrix .dominant.smc-lead{color:var(--purple);border:1px solid var(--purple)}
.smart-matrix .dominant.momentum-lead{color:var(--amber);border:1px solid var(--amber)}
.smart-matrix .dominant.balanced{color:var(--long);border:1px solid var(--long)}
.smart-matrix .agreement{font-size:9px;padding:2px 5px;border-radius:3px}
.smart-matrix .agreement.full{background:var(--long-dim);color:var(--long)}
.smart-matrix .agreement.majority{background:var(--cyan-dim);color:var(--cyan)}
.smart-matrix .agreement.conflict{background:var(--short-dim);color:var(--short)}

/* ═══════════════════════════════════════════════════════════════════════════════
   PHASE 1: TOP TIER REAL-TIME DATA STYLES
   ═══════════════════════════════════════════════════════════════════════════════ */

/* LIVE DATA BAR */
.live-data-bar{display:flex;align-items:center;gap:6px;padding:6px 10px;background:linear-gradient(180deg,var(--bg2) 0%,var(--bg3) 100%);border-bottom:1px solid var(--border);overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none}
.live-data-bar::-webkit-scrollbar{display:none}
.live-badge{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg4);border-radius:6px;font-size:10px;border:1px solid var(--border);flex-shrink:0;transition:all 0.3s}
.live-badge .icon{font-size:12px}
.live-badge .label{color:var(--text3);font-size:9px}
.live-badge .value{font-weight:700;font-family:monospace}
.live-badge.bullish{border-color:var(--long);background:var(--long-dim)}
.live-badge.bullish .value{color:var(--long)}
.live-badge.bearish{border-color:var(--short);background:var(--short-dim)}
.live-badge.bearish .value{color:var(--short)}
.live-badge.neutral{border-color:var(--amber);background:var(--amber-dim)}
.live-badge.neutral .value{color:var(--amber)}
.live-badge.flash{animation:liveFlash 0.5s ease-out}
@keyframes liveFlash{0%{transform:scale(1.1);box-shadow:0 0 15px var(--gold)}100%{transform:scale(1);box-shadow:none}}

/* LIQUIDATION SPECIFIC */
.liq-badge{position:relative;overflow:hidden}
.liq-badge::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.1),transparent);animation:liqShimmer 2s infinite}
@keyframes liqShimmer{0%{left:-100%}100%{left:100%}}
.liq-badge .liq-long{color:var(--long);font-weight:700}
.liq-badge .liq-short{color:var(--short);font-weight:700}
.liq-cascade{animation:cascadePulse 1s ease-in-out infinite}
@keyframes cascadePulse{0%,100%{box-shadow:0 0 5px var(--short)}50%{box-shadow:0 0 20px var(--short)}}

/* OI DELTA SPECIFIC */
.oi-badge .oi-up{color:var(--long)}
.oi-badge .oi-down{color:var(--short)}
.oi-badge .oi-bar{width:40px;height:4px;background:var(--bg2);border-radius:2px;overflow:hidden;margin-left:4px}
.oi-badge .oi-bar-fill{height:100%;border-radius:2px;transition:width 0.5s ease}
.oi-badge .oi-bar-fill.positive{background:linear-gradient(90deg,var(--long),#00ffaa)}
.oi-badge .oi-bar-fill.negative{background:linear-gradient(90deg,var(--short),#ff8888)}

/* WHALE ALERT SPECIFIC */
.whale-badge{position:relative}
.whale-badge.active{border-color:var(--gold);background:var(--gold-dim);animation:whaleGlow 1.5s ease-in-out infinite}
@keyframes whaleGlow{0%,100%{box-shadow:0 0 5px var(--gold)}50%{box-shadow:0 0 15px var(--gold)}}
.whale-alert-popup{position:fixed;top:80px;right:10px;background:var(--bg2);border:2px solid var(--gold);border-radius:8px;padding:10px 15px;z-index:1000;animation:whaleSlideIn 0.3s ease-out;box-shadow:0 4px 20px rgba(255,215,0,0.3)}
@keyframes whaleSlideIn{0%{transform:translateX(100%);opacity:0}100%{transform:translateX(0);opacity:1}}
.whale-alert-popup .whale-icon{font-size:20px;margin-right:8px}
.whale-alert-popup .whale-info{display:flex;flex-direction:column;gap:2px}
.whale-alert-popup .whale-coin{font-weight:700;font-size:12px}
.whale-alert-popup .whale-details{font-size:10px;color:var(--text3)}
.whale-alert-popup .whale-amount{font-size:14px;font-weight:700}
.whale-alert-popup .whale-amount.buy{color:var(--long)}
.whale-alert-popup .whale-amount.sell{color:var(--short)}

/* FUNDING RATE SPECIFIC */
.funding-badge .countdown{font-family:monospace;font-size:9px;color:var(--text3);margin-left:4px}
.funding-badge.positive .value{color:var(--long)}
.funding-badge.negative .value{color:var(--short)}
.funding-badge .funding-bar{width:50px;height:4px;background:var(--bg2);border-radius:2px;position:relative;margin-left:4px}
.funding-badge .funding-bar::before{content:'';position:absolute;left:50%;top:0;width:1px;height:100%;background:var(--text3)}
.funding-badge .funding-indicator{position:absolute;top:-1px;width:6px;height:6px;border-radius:50%;transition:left 0.3s}
.funding-badge .funding-indicator.positive{background:var(--long);left:75%}
.funding-badge .funding-indicator.negative{background:var(--short);left:25%}
.funding-badge .funding-indicator.neutral{background:var(--amber);left:50%}

/* SIGNAL CARD LIVE DATA */
.signal-live-data{display:flex;gap:4px;margin-top:4px;flex-wrap:wrap}
.signal-live-data .live-tag{font-size:8px;padding:2px 4px;border-radius:3px;background:var(--bg4)}
.signal-live-data .live-tag.liq-bullish{color:var(--long);border:1px solid var(--long)}
.signal-live-data .live-tag.liq-bearish{color:var(--short);border:1px solid var(--short)}
.signal-live-data .live-tag.oi-rising{color:var(--long);border:1px solid var(--long)}
.signal-live-data .live-tag.oi-falling{color:var(--short);border:1px solid var(--short)}
.signal-live-data .live-tag.whale-buy{color:var(--gold);border:1px solid var(--gold)}
.signal-live-data .live-tag.whale-sell{color:var(--purple);border:1px solid var(--purple)}
.signal-live-data .live-tag.funding-pos{color:var(--long)}
.signal-live-data .live-tag.funding-neg{color:var(--short)}

/* LIVE INDICATOR DOT */
.live-dot{width:6px;height:6px;border-radius:50%;background:var(--long);animation:livePulse 1.5s ease-in-out infinite;margin-right:4px}
@keyframes livePulse{0%,100%{opacity:1;transform:scale(1)}50%{opacity:0.5;transform:scale(0.8)}}
.live-dot.disconnected{background:var(--short);animation:none}
.live-dot.connecting{background:var(--amber);animation:livePulse 0.5s ease-in-out infinite}

/* ═══════════════════════════════════════════════════════════════════════════════
   PHASE 2-4: ADVANCED ANALYSIS STYLES
   ═══════════════════════════════════════════════════════════════════════════════ */

/* ADVANCED ANALYSIS BAR */
.signal-advanced{display:flex;gap:4px;margin-top:4px;flex-wrap:wrap;padding:4px 6px;background:var(--bg4);border-radius:4px}
.signal-advanced .adv-tag{font-size:8px;padding:2px 5px;border-radius:3px;display:flex;align-items:center;gap:2px}
.signal-advanced .adv-tag .icon{font-size:10px}

/* Volume Profile Tags */
.signal-advanced .vp-tag{background:rgba(59,130,246,0.15);color:var(--blue);border:1px solid var(--blue)}
.signal-advanced .vp-tag.at-poc{background:rgba(255,215,0,0.2);color:var(--gold);border:1px solid var(--gold)}
.signal-advanced .vp-tag.at-vah{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.signal-advanced .vp-tag.at-val{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}

/* Order Flow Tags */
.signal-advanced .of-tag{background:rgba(168,85,247,0.15);color:var(--purple);border:1px solid var(--purple)}
.signal-advanced .of-tag.buy-aggro{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}
.signal-advanced .of-tag.sell-aggro{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.signal-advanced .of-tag.absorption{background:rgba(6,182,212,0.15);color:var(--cyan);border:1px solid var(--cyan)}

/* ML Prediction Tags */
.signal-advanced .ml-tag{background:rgba(245,158,11,0.15);color:var(--amber);border:1px solid var(--amber)}
.signal-advanced .ml-tag.favorable{background:var(--long-dim);color:var(--long);border:1px solid var(--long);animation:mlGlow 2s ease-in-out infinite}
.signal-advanced .ml-tag.unfavorable{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
@keyframes mlGlow{0%,100%{box-shadow:0 0 3px var(--long)}50%{box-shadow:0 0 8px var(--long)}}

/* Confidence Badge */
.signal-advanced .conf-badge{font-size:7px;padding:1px 4px;border-radius:2px;font-weight:700}
.signal-advanced .conf-badge.high{background:var(--long);color:var(--bg)}
.signal-advanced .conf-badge.medium{background:var(--amber);color:var(--bg)}
.signal-advanced .conf-badge.low{background:var(--bg3);color:var(--text3)}

/* Combined Score Ring */
.adv-score-ring{width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:9px;font-weight:700;position:relative;margin-left:auto}
.adv-score-ring::before{content:'';position:absolute;inset:-2px;border-radius:50%;border:2px solid var(--border);border-top-color:var(--long)}
.adv-score-ring.high{color:var(--long)}
.adv-score-ring.high::before{border-color:var(--long)}
.adv-score-ring.medium{color:var(--amber)}
.adv-score-ring.medium::before{border-color:var(--amber)}
.adv-score-ring.low{color:var(--text3)}

/* FILTERED SIGNALS SECTION */
.filtered-section{padding:8px 10px;background:var(--bg3);border-top:1px solid var(--border);cursor:pointer}
.filtered-section:hover{background:var(--bg4)}
.filtered-header{display:flex;align-items:center;justify-content:space-between;font-size:11px;color:var(--text3)}
.filtered-count{color:var(--short);font-weight:700}
.filtered-list{display:none;margin-top:8px;padding-top:8px;border-top:1px solid var(--border)}
.filtered-list.show{display:block}
.filtered-item{font-size:10px;padding:4px 6px;background:var(--short-dim);border-radius:4px;margin-bottom:4px;color:var(--short)}

/* ENV PANEL SECTION */
.env-panel{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px}
.env-panel-title{font-size:12px;font-weight:700;color:var(--cyan);margin-bottom:10px;padding-bottom:6px;border-bottom:1px solid var(--border)}
.env-row{display:flex;justify-content:space-between;align-items:center;padding:4px 0;font-size:11px}
.env-row .label{color:var(--text3)}

/* BACKTEST PANEL - COLLAPSIBLE */
/* COMBINED PANELS ROW - SIDE BY SIDE 50/50 */
.panels-row{display:flex;flex-direction:row;gap:4px;padding:4px;background:var(--bg2);border-bottom:1px solid var(--border);flex-wrap:nowrap}
.panels-row .panel-half{flex:1 1 50%;min-width:0;max-width:50%;background:var(--bg3);border-radius:6px;border:1px solid var(--border);overflow:hidden}
.panel-half .panel-header{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;cursor:pointer;user-select:none;background:var(--bg3)}
.panel-half .panel-header:active{background:var(--bg4)}
.panel-half .panel-title{display:flex;align-items:center;gap:4px;font-size:11px;font-weight:700}
.panel-half .panel-title.flow-color{color:var(--amber)}
.panel-half .panel-title.backtest-color{color:var(--cyan)}
.panel-half .panel-toggle{font-size:14px;color:var(--text3);transition:transform 0.3s}
.panel-half .panel-toggle.expanded{transform:rotate(180deg)}
.panel-half .panel-content{max-height:0;overflow:hidden;transition:max-height 0.3s ease-out}
.panel-half .panel-content.expanded{max-height:400px;overflow-y:auto}

/* FLOW PANEL - COMPACT */
.flow-grid-compact{display:grid;grid-template-columns:1fr 1fr;gap:3px;padding:6px}
.flow-item-compact{text-align:center;padding:5px 3px;background:var(--bg4);border-radius:4px}
.flow-item-compact .flow-label{font-size:7px;color:var(--text3);margin-bottom:1px;text-transform:uppercase;white-space:nowrap}
.flow-item-compact .flow-value{font-size:10px;font-weight:700;color:var(--text);white-space:nowrap}
.flow-item-compact .flow-change{font-size:8px;margin-top:1px;white-space:nowrap}
.flow-item-compact .flow-change.up{color:var(--long)}
.flow-item-compact .flow-change.down{color:var(--short)}
.flow-verdict-compact{display:flex;align-items:center;justify-content:center;gap:4px;padding:5px;background:var(--bg4);border-top:1px solid var(--border)}
.flow-verdict-compact .label{font-size:8px;color:var(--text3)}
.flow-verdict-compact .value{font-size:9px;font-weight:700;padding:2px 6px;border-radius:3px}
.flow-verdict-compact .value.bullish{background:var(--long-dim);color:var(--long)}
.flow-verdict-compact .value.bearish{background:var(--short-dim);color:var(--short)}
.flow-verdict-compact .value.squeeze{background:var(--amber-dim);color:var(--amber)}
.flow-verdict-compact .value.neutral{background:var(--bg3);color:var(--text2)}

/* BACKTEST PANEL - COMPACT */
.backtest-controls-compact{display:flex;flex-direction:column;gap:3px;padding:5px}
.backtest-controls-row{display:flex;gap:3px}
.backtest-select-compact{flex:1;background:var(--bg4);border:1px solid var(--border);color:var(--text);padding:4px 4px;border-radius:3px;font-size:9px;min-width:0}
.backtest-run-compact{background:var(--cyan);color:var(--bg);border:none;padding:4px 8px;border-radius:3px;font-size:9px;font-weight:700;cursor:pointer;white-space:nowrap}
.backtest-run-compact:hover{background:var(--long)}
.backtest-run-compact:disabled{background:var(--bg4);color:var(--text3);cursor:not-allowed}
.backtest-results-compact{padding:5px;font-size:9px}
.backtest-results-compact .backtest-summary{display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-bottom:5px}
.backtest-results-compact .backtest-stat{background:var(--bg4);padding:5px;border-radius:4px}
.backtest-results-compact .backtest-stat-label{font-size:7px;color:var(--text3);margin-bottom:1px}
.backtest-results-compact .backtest-stat-value{font-size:11px;font-weight:700}
.backtest-results-compact .backtest-stat-value.positive{color:var(--long)}
.backtest-results-compact .backtest-stat-value.negative{color:var(--short)}
.backtest-results-compact .backtest-grade-row{display:flex;align-items:center;justify-content:space-between;padding:3px 5px;background:var(--bg4);border-radius:3px;margin-bottom:2px;font-size:8px}
.backtest-results-compact .grade-name{font-weight:700}
.backtest-results-compact .win-rate{color:var(--long);font-weight:600}
.backtest-results-compact .pnl.positive{color:var(--long)}
.backtest-results-compact .pnl.negative{color:var(--short)}
.backtest-empty{text-align:center;padding:10px;color:var(--text3);font-size:8px}
.backtest-empty .icon{font-size:14px;margin-bottom:3px}

/* Hide old panels - kept for backwards compatibility */
.backtest-panel{display:none}
.flow-panel{display:none}

/* Legacy support classes */
.backtest-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;cursor:pointer;user-select:none}
.backtest-header:hover{background:var(--bg3)}
.backtest-title{display:flex;align-items:center;gap:8px;font-size:12px;font-weight:700;color:var(--cyan)}
.backtest-toggle{font-size:14px;color:var(--text3);transition:transform 0.3s}
.backtest-toggle.expanded{transform:rotate(180deg)}
.backtest-content{max-height:0;overflow:hidden;transition:max-height 0.3s ease-out}
.backtest-content.expanded{max-height:600px;overflow-y:auto}
.backtest-controls{display:flex;flex-wrap:wrap;gap:8px;padding:10px 12px;background:var(--bg3);border-top:1px solid var(--border)}
.backtest-select{background:var(--bg4);border:1px solid var(--border);color:var(--text);padding:6px 10px;border-radius:4px;font-size:11px}
.backtest-run{background:var(--cyan);color:var(--bg);border:none;padding:6px 16px;border-radius:4px;font-size:11px;font-weight:700;cursor:pointer}
.backtest-run:hover{background:var(--long)}
.backtest-run:disabled{background:var(--bg4);color:var(--text3);cursor:not-allowed}
.backtest-results{padding:10px 12px}
.backtest-summary{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px}
.backtest-stat{background:var(--bg3);padding:10px;border-radius:6px;border:1px solid var(--border)}
.backtest-stat-label{font-size:10px;color:var(--text3);margin-bottom:4px}
.backtest-stat-value{font-size:16px;font-weight:700}
.backtest-stat-value.positive{color:var(--long)}
.backtest-stat-value.negative{color:var(--short)}
.backtest-stat-value.neutral{color:var(--text)}
.backtest-grades{margin-bottom:12px}
.backtest-grade-row{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:var(--bg3);border-radius:4px;margin-bottom:6px;font-size:11px}
.backtest-grade-row .grade-name{font-weight:700}
.backtest-grade-row .grade-stats{display:flex;gap:12px;color:var(--text2)}
.backtest-grade-row .win-rate{color:var(--long);font-weight:700}
.backtest-grade-row .pnl.positive{color:var(--long)}
.backtest-grade-row .pnl.negative{color:var(--short)}
.backtest-insights{background:var(--bg3);padding:10px;border-radius:6px;border:1px solid var(--border)}
.backtest-insight{display:flex;align-items:center;gap:8px;font-size:11px;padding:4px 0;color:var(--text2)}
.backtest-insight .icon{font-size:14px}
.backtest-insight .highlight{color:var(--long);font-weight:700}
.backtest-insight .lowlight{color:var(--short);font-weight:700}
.backtest-loading{text-align:center;padding:30px;color:var(--text3)}
.backtest-loading .spinner{font-size:24px;animation:spin 1s linear infinite}
@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}

/* Legacy flow panel CSS - hidden but kept for compatibility */
.flow-panel{display:none;background:var(--bg2);border-bottom:1px solid var(--border)}
.flow-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;cursor:pointer;user-select:none}
.flow-header:hover{background:var(--bg3)}
.flow-title{display:flex;align-items:center;gap:8px;font-size:12px;font-weight:700;color:var(--amber)}
.flow-status{font-size:10px;font-weight:400;padding:2px 6px;border-radius:3px;margin-left:8px}
.flow-status.bullish{background:var(--long-dim);color:var(--long)}
.flow-status.bearish{background:var(--short-dim);color:var(--short)}
.flow-status.neutral{background:var(--amber-dim);color:var(--amber)}
.flow-toggle{font-size:14px;color:var(--text3);transition:transform 0.3s}
.flow-toggle.expanded{transform:rotate(180deg)}
.flow-content{max-height:0;overflow:hidden;transition:max-height 0.3s ease-out}
.flow-content.expanded{max-height:200px}
.flow-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;padding:10px 12px;background:var(--bg3)}
.flow-item{text-align:center;padding:8px 4px;background:var(--bg4);border-radius:6px;border:1px solid var(--border)}
.flow-label{font-size:9px;color:var(--text3);margin-bottom:4px;text-transform:uppercase}
.flow-value{font-size:13px;font-weight:700;color:var(--text)}
.flow-change{font-size:10px;margin-top:2px}
.flow-change.up{color:var(--long)}
.flow-change.down{color:var(--short)}
.flow-change.neutral{color:var(--text3)}
.flow-verdict{display:flex;align-items:center;justify-content:center;gap:8px;padding:8px 12px;background:var(--bg4);border-top:1px solid var(--border)}
.flow-verdict-label{font-size:10px;color:var(--text3);text-transform:uppercase}
.flow-verdict-value{font-size:12px;font-weight:700;padding:4px 12px;border-radius:4px}
.flow-verdict-value.bullish{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}
.flow-verdict-value.bearish{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.flow-verdict-value.squeeze{background:var(--amber-dim);color:var(--amber);border:1px solid var(--amber)}
.flow-verdict-value.neutral{background:var(--bg3);color:var(--text2);border:1px solid var(--border)}

.env-row .value{font-weight:600}
.env-row .value.ok{color:var(--long)}
.env-row .value.warn{color:var(--amber)}
.env-row .value.bad{color:var(--short)}
.env-row .points{font-size:10px;color:var(--text3);margin-left:6px}
.env-divider{height:1px;background:var(--border);margin:8px 0}
.env-total{display:flex;justify-content:space-between;align-items:center;padding:8px 0;font-size:13px;font-weight:700}
.env-total .score{font-size:16px}
.env-total .score.go{color:var(--long)}
.env-total .score.caution{color:var(--amber)}
.env-total .score.risky{color:#ff8c00}
.env-total .score.nogo{color:var(--short)}

/* AI ENV VERDICT */
.ai-env-verdict{padding:8px;background:var(--bg4);border-radius:6px;margin-top:8px;font-size:11px}
.ai-env-verdict.agree{border-left:3px solid var(--long)}
.ai-env-verdict.warn{border-left:3px solid var(--amber)}
.ai-env-verdict.disagree{border-left:3px solid var(--short)}

/* SCAN PROGRESS BAR - LONGER & GLOWING */
.scan-progress-bar{display:none;flex:1;align-items:center;gap:6px}
.scan-progress-bar.active{display:flex}
.scan-progress-track{flex:1;height:6px;background:var(--bg4);border-radius:3px;overflow:hidden;box-shadow:inset 0 0 3px rgba(0,0,0,0.3)}
.scan-progress-fill{height:100%;border-radius:3px;transition:width 0.3s;background:var(--amber)}
.scan-progress-fill.scanning{background:linear-gradient(90deg,rgba(255,100,100,0.9),rgba(255,180,100,0.9),rgba(255,255,100,0.9),rgba(100,255,100,0.9),rgba(100,255,255,0.9),rgba(100,180,255,0.9),rgba(180,100,255,0.9),rgba(255,100,255,0.9),rgba(255,100,180,0.9),rgba(255,100,100,0.9));background-size:200% 100%;animation:rainbowFlow 2s linear infinite;box-shadow:0 0 8px rgba(200,200,255,0.3),0 0 15px rgba(100,200,255,0.2)}
.scan-progress-fill.done{background:linear-gradient(90deg,var(--long),rgba(0,255,170,0.8),var(--cyan),rgba(0,255,170,0.8),var(--long));background-size:200% 100%;animation:completePulse 3s ease-in-out infinite;box-shadow:0 0 10px var(--long),0 0 20px rgba(0,255,170,0.3)}
.scan-progress-fill.error{background:linear-gradient(90deg,var(--short),rgba(255,107,107,0.8),rgba(255,71,87,0.8),rgba(255,107,107,0.8),var(--short));background-size:200% 100%;animation:errorPulse 1.5s ease-in-out infinite;box-shadow:0 0 10px var(--short),0 0 20px rgba(255,71,87,0.3)}
@keyframes errorPulse{0%,100%{background-position:0% 50%;box-shadow:0 0 8px var(--short)}50%{background-position:100% 50%;box-shadow:0 0 15px var(--short)}}
.scan-progress-text.error{color:var(--short)}
.scan-progress-pct.error{color:var(--short)}
@keyframes rainbowFlow{0%{background-position:0% 50%}100%{background-position:200% 50%}}
@keyframes completePulse{0%,100%{background-position:0% 50%;box-shadow:0 0 10px var(--long)}50%{background-position:100% 50%;box-shadow:0 0 20px var(--long),0 0 30px var(--cyan)}}
.scan-progress-text{font-size:10px;color:var(--amber);white-space:nowrap}
.scan-progress-text.done{color:var(--long)}
@keyframes scanGlow{0%,100%{box-shadow:0 0 5px var(--amber),0 0 10px rgba(247,166,0,0.4)}50%{box-shadow:0 0 8px var(--amber),0 0 15px rgba(247,166,0,0.5)}}

/* GLOW RADAR ICON */
.glow-radar{color:var(--gold);text-shadow:0 0 10px var(--gold),0 0 20px var(--gold),0 0 30px rgba(255,215,0,0.5);animation:radarPulse 2s ease-in-out infinite}
@keyframes radarPulse{0%,100%{transform:scale(1);opacity:1}50%{transform:scale(1.1);opacity:0.8}}

/* RAINBOW CIRCLE SPINNER WITH TEXT INSIDE */
.rainbow-circle-container{
    width:120px;
    height:120px;
    position:relative;
    margin:0 auto 10px;
}
.rainbow-circle-ring{
    position:absolute;
    top:0;left:0;right:0;bottom:0;
    border-radius:50%;
    border:4px solid transparent;
    background:linear-gradient(var(--bg2),var(--bg2)) padding-box,
               conic-gradient(from 0deg,
                   rgba(255,100,100,0.8),
                   rgba(255,180,100,0.8),
                   rgba(255,255,100,0.8),
                   rgba(100,255,100,0.8),
                   rgba(100,255,255,0.8),
                   rgba(100,180,255,0.8),
                   rgba(180,100,255,0.8),
                   rgba(255,100,255,0.8),
                   rgba(255,100,180,0.8),
                   rgba(255,100,100,0.8)
               ) border-box;
    animation:rainbowSpin 2s linear infinite, gentleFlash 1s ease-in-out infinite;
    box-shadow:0 0 15px rgba(100,200,255,0.3),0 0 30px rgba(255,100,200,0.2);
}
.rainbow-circle-inner{
    position:absolute;
    top:8px;left:8px;right:8px;bottom:8px;
    border-radius:50%;
    background:var(--bg2);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    padding:8px;
}
.rainbow-circle-coin{
    font-size:14px;
    font-weight:700;
    color:var(--cyan);
    text-shadow:0 0 5px rgba(0,200,255,0.5);
}
.rainbow-circle-tf{
    font-size:11px;
    font-weight:600;
    color:var(--amber);
}
.rainbow-circle-count{
    font-size:10px;
    color:var(--text2);
    margin-top:2px;
}
.rainbow-circle-pct{
    font-size:16px;
    font-weight:700;
    color:var(--gold);
    text-shadow:0 0 5px rgba(255,200,0,0.4);
}
@keyframes rainbowSpin{
    0%{transform:rotate(0deg)}
    100%{transform:rotate(360deg)}
}
@keyframes gentleFlash{
    0%,100%{opacity:1}
    50%{opacity:0.7}
}

/* SIMPLE SCANNING TEXT */
.scan-text-glow{
    color:var(--cyan);
    text-shadow:0 0 5px rgba(0,200,255,0.5);
    font-weight:600;
}
.scan-text-amber{
    color:var(--amber);
    text-shadow:0 0 5px rgba(255,180,0,0.4);
    font-weight:600;
}

/* CONTENT LAYOUT */
.content{display:flex;flex-direction:column;flex:1}
@media(min-width:900px){.content{flex-direction:row}.sidebar{width:380px;border-right:1px solid var(--border)}.main{flex:1}}
.sidebar{background:var(--bg2);display:flex;flex-direction:column;max-height:55vh}
@media(min-width:900px){.sidebar{max-height:none;height:calc(100vh - 52px)}}

/* SIDEBAR TOP */
.sidebar-top{padding:10px;border-bottom:1px solid var(--border)}
.mode-row{display:flex;gap:4px;margin-bottom:8px}
.mode-btn{flex:1;padding:8px 4px;border:1px solid var(--border);border-radius:5px;background:transparent;color:var(--text2);font-size:11px;font-weight:600;cursor:pointer;transition:all 0.2s}
.mode-btn.active{background:var(--purple);border-color:var(--purple);color:white}
.mode-btn:hover:not(.active){background:var(--bg4)}
.filter-row{display:flex;gap:4px}
.filter-btn{flex:1;padding:6px 4px;border:1px solid var(--border);border-radius:4px;background:transparent;color:var(--text3);font-size:12px;cursor:pointer;transition:all 0.2s}
.filter-btn.active{background:var(--bg4);color:var(--text);border-color:var(--text3)}
.filter-btn .count{margin-left:3px;color:var(--cyan)}

/* SIGNAL LIST */
.signal-list{flex:1;overflow-y:auto;padding:8px}
.signal-card{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:8px;cursor:pointer;transition:all 0.3s}
.signal-card:hover{transform:translateX(2px)}
.signal-card.active{border-color:var(--gold);background:var(--gold-dim)}

/* GLOWING EFFECTS - LONG/SHORT */
.signal-card.long{border-left:3px solid var(--long);box-shadow:0 0 12px rgba(0,217,160,0.2),inset 0 0 20px rgba(0,217,160,0.05)}
.signal-card.long:hover{box-shadow:0 0 20px rgba(0,217,160,0.4),inset 0 0 30px rgba(0,217,160,0.1)}
.signal-card.short{border-left:3px solid var(--short);box-shadow:0 0 12px rgba(255,71,87,0.2),inset 0 0 20px rgba(255,71,87,0.05)}
.signal-card.short:hover{box-shadow:0 0 20px rgba(255,71,87,0.4),inset 0 0 30px rgba(255,71,87,0.1)}

/* GLOWING GRADE BADGES */
.signal-card.long.grade-perfect{box-shadow:0 0 15px rgba(0,217,160,0.3),0 0 25px rgba(255,215,0,0.3)}
.signal-card.short.grade-perfect{box-shadow:0 0 15px rgba(255,71,87,0.3),0 0 25px rgba(255,215,0,0.3)}
.signal-card.long.grade-strong{box-shadow:0 0 15px rgba(0,217,160,0.35)}
.signal-card.short.grade-strong{box-shadow:0 0 15px rgba(255,71,87,0.35)}
.signal-card.long.grade-valid{box-shadow:0 0 12px rgba(0,217,160,0.25),0 0 20px rgba(59,130,246,0.2)}
.signal-card.short.grade-valid{box-shadow:0 0 12px rgba(255,71,87,0.25),0 0 20px rgba(59,130,246,0.2)}
.signal-card.long.grade-heating{box-shadow:0 0 10px rgba(0,217,160,0.2),0 0 15px rgba(245,158,11,0.2)}
.signal-card.short.grade-heating{box-shadow:0 0 10px rgba(255,71,87,0.2),0 0 15px rgba(245,158,11,0.2)}
.signal-card.grade-brewing{box-shadow:0 0 8px rgba(168,85,247,0.15)}

/* 3/3 AGREEMENT EXTRA GLOW */
.signal-card.full-agree{animation:pulseGlow 2s ease-in-out infinite}
@keyframes pulseGlow{0%,100%{filter:brightness(1)}50%{filter:brightness(1.1)}}

.signal-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.signal-pair{font-weight:700;font-size:14px;display:flex;align-items:center;gap:5px}
.dir-tag{font-size:12px;font-weight:700;padding:2px 6px;border-radius:3px}
.dir-tag.long{background:var(--long-dim);color:var(--long);box-shadow:0 0 8px rgba(0,217,160,0.3)}
.dir-tag.short{background:var(--short-dim);color:var(--short);box-shadow:0 0 8px rgba(255,71,87,0.3)}
.tf-tag{font-size:12px;padding:2px 6px;border-radius:3px;background:var(--bg4);border:1px solid var(--cyan);color:var(--cyan)}

/* GLOWING GRADE BADGES */
.grade{font-size:12px;font-weight:700;padding:4px 8px;border-radius:4px}
.grade.perfect{background:linear-gradient(135deg,var(--gold),#ffaa00);color:#000;box-shadow:0 0 15px rgba(255,215,0,0.5);animation:goldPulse 1.5s ease-in-out infinite}
@keyframes goldPulse{0%,100%{box-shadow:0 0 15px rgba(255,215,0,0.5)}50%{box-shadow:0 0 25px rgba(255,215,0,0.8)}}
.grade.strong{background:var(--long);color:#000;box-shadow:0 0 12px rgba(0,217,160,0.4)}
.grade.valid{background:var(--blue);color:white;box-shadow:0 0 10px rgba(59,130,246,0.4)}
.grade.heating{background:var(--amber);color:#000;box-shadow:0 0 10px rgba(245,158,11,0.4)}
.grade.brewing{background:var(--purple-dim);color:var(--purple);border:1px solid var(--purple);box-shadow:0 0 8px rgba(168,85,247,0.3)}
.signal-meta{display:flex;gap:6px;font-size:12px;color:var(--text2);margin-bottom:5px}
.signal-scores{display:flex;gap:3px;flex-wrap:wrap}
.score-tag{font-size:12px;padding:2px 5px;border-radius:3px;background:var(--bg4);color:var(--text2);font-family:monospace}
.score-tag.good{color:var(--long);text-shadow:0 0 5px rgba(0,217,160,0.5)}
.score-tag.mid{color:var(--amber);text-shadow:0 0 5px rgba(245,158,11,0.5)}
.score-tag.low{color:var(--short);text-shadow:0 0 5px rgba(255,71,87,0.5)}

/* STATUS BADGES */
.status-badge{font-size:11px;font-weight:700;padding:2px 5px;border-radius:3px;margin-left:4px}
.status-badge.new{background:var(--cyan-dim);color:var(--cyan);box-shadow:0 0 8px rgba(6,182,212,0.4)}
.status-badge.up{background:var(--long-dim);color:var(--long)}
.status-badge.down{background:var(--short-dim);color:var(--short)}
.status-badge.gone{background:var(--bg4);color:var(--text3);text-decoration:line-through}

/* MAIN PANEL */
.main{padding:12px;overflow-y:auto;background:var(--bg1)}
@media(min-width:900px){.main{height:calc(100vh - 52px)}}
.detail-box{background:var(--bg2);border:1px solid var(--border);border-radius:10px;padding:14px}
.detail-header{display:flex;justify-content:space-between;align-items:center;padding-bottom:12px;border-bottom:1px solid var(--border);margin-bottom:12px;flex-wrap:wrap;gap:8px}
.detail-title{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.detail-pair{font-size:22px;font-weight:700}
.detail-price{text-align:right}
.detail-price-label{font-size:12px;color:var(--text2)}
.detail-price-value{font-size:18px;font-weight:700;font-family:monospace}

/* HTF BOX */
.htf-box{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:12px}
.htf-title{font-size:11px;color:var(--text2);margin-bottom:8px;display:flex;align-items:center;gap:6px}
.htf-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:6px}
.htf-item{text-align:center;padding:6px 4px;background:var(--bg4);border-radius:5px}
.htf-label{font-size:12px;color:var(--text3)}
.htf-value{font-size:11px;font-weight:700}
.htf-value.bull{color:var(--long)}
.htf-value.bear{color:var(--short)}
.htf-value.neutral{color:var(--text3)}

/* AI SECTION */
.ai-section{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:14px;margin-bottom:12px}
.ai-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
.ai-title{font-size:13px;font-weight:700;display:flex;align-items:center;gap:6px}
.ai-verdict{font-size:11px;font-weight:700;padding:4px 12px;border-radius:4px}
.ai-verdict.take{background:var(--long-dim);color:var(--long)}
.ai-verdict.skip{background:var(--short-dim);color:var(--short)}
.ai-verdict.wait{background:var(--amber-dim);color:var(--amber)}
.ai-bar{height:8px;background:var(--bg2);border-radius:4px;overflow:hidden;margin-bottom:8px}
.ai-fill{height:100%;border-radius:4px;transition:width 0.3s}
.ai-text{font-size:11px;color:var(--text2);line-height:1.5;margin-bottom:8px}
.ai-risks{font-size:12px;color:var(--amber);margin-bottom:8px}
.ai-btn{width:100%;padding:10px;background:linear-gradient(135deg,#f55036,#ff6b4a);border:none;color:white;border-radius:6px;font-size:12px;font-weight:700;cursor:pointer}
.ai-btn:hover{opacity:0.9}

/* ANALYSIS GRID */
.analysis-grid{display:grid;grid-template-columns:1fr;gap:10px;margin-bottom:12px}
@media(min-width:600px){.analysis-grid{grid-template-columns:repeat(3,1fr)}}
.analysis-card{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px}
.analysis-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.analysis-title{font-size:11px;color:var(--text2)}
.analysis-score{font-family:monospace;font-weight:700;padding:3px 8px;border-radius:4px;font-size:12px}
.analysis-row{display:flex;justify-content:space-between;font-size:12px;padding:3px 0;border-bottom:1px solid var(--border)}
.analysis-row:last-child{border-bottom:none}
.analysis-label{color:var(--text2)}
.analysis-value{font-family:monospace;font-weight:600}
.factor-list{display:flex;flex-wrap:wrap;gap:3px;margin-top:8px}
.factor{font-size:12px;padding:2px 5px;border-radius:3px;background:var(--bg4);color:var(--text2)}
.factor.bull{background:var(--long-dim);color:var(--long)}
.factor.bear{background:var(--short-dim);color:var(--short)}
.factor.warn{background:var(--amber-dim);color:var(--amber)}

/* TRADE SECTION */
.trade-section{margin-bottom:12px}
.trade-title{font-size:12px;font-weight:600;margin-bottom:10px;color:var(--text2)}
.trade-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:6px}
@media(max-width:600px){.trade-grid{grid-template-columns:repeat(3,1fr)}}
@media(max-width:400px){.trade-grid{grid-template-columns:repeat(2,1fr)}}
.trade-box{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:8px 4px;text-align:center}
.trade-box-label{font-size:12px;color:var(--text3);margin-bottom:2px}
.trade-box-value{font-family:monospace;font-size:12px;font-weight:600;word-break:break-all}
.trade-box.entry{border-color:var(--cyan)}.trade-box.entry .trade-box-value{color:var(--cyan)}
.trade-box.limit{border-color:var(--purple);background:var(--purple-dim)}.trade-box.limit .trade-box-value{color:var(--purple)}
.trade-box.limit .limit-type{font-size:9px;color:var(--purple);font-weight:700;margin-top:2px}
.trade-box.sl{border-color:var(--short)}.trade-box.sl .trade-box-value{color:var(--short)}
.trade-box.tp{border-color:var(--long)}.trade-box.tp .trade-box-value{color:var(--long)}
.trade-meta{display:flex;justify-content:space-between;align-items:center;margin-top:10px}
.rr-tag{background:var(--purple-dim);color:var(--purple);padding:5px 12px;border-radius:5px;font-size:11px;font-weight:600}
.track-btn{padding:10px 20px;background:var(--amber-dim);border:1px solid var(--amber);color:var(--amber);border-radius:6px;font-size:12px;font-weight:600;cursor:pointer}
.track-btn:hover{background:var(--amber);color:#000}

/* ACTIVE TRADES */
.active-section{border-top:1px solid var(--border);padding:10px;background:var(--bg1)}
.active-title{font-size:11px;font-weight:700;margin-bottom:8px;display:flex;align-items:center;gap:6px}
.active-count{background:var(--purple);color:white;font-size:12px;padding:2px 6px;border-radius:8px}
.active-list{max-height:150px;overflow-y:auto}
.active-card{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:6px}
.active-card.long{border-left:3px solid var(--long)}
.active-card.short{border-left:3px solid var(--short)}
.active-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
.active-pair{font-weight:700;font-size:12px;display:flex;align-items:center;gap:5px}
.active-pnl{font-family:monospace;font-size:11px;font-weight:700;padding:2px 6px;border-radius:4px}
.active-pnl.profit{background:var(--long-dim);color:var(--long)}
.active-pnl.loss{background:var(--short-dim);color:var(--short)}
.active-levels{display:grid;grid-template-columns:repeat(5,1fr);gap:3px;margin-bottom:4px}
.active-level{text-align:center;padding:3px;background:var(--bg4);border-radius:3px}
.active-level-label{font-size:11px;color:var(--text3)}
.active-level-value{font-family:monospace;font-size:12px}
.active-level.hit{background:var(--long-dim);border:1px solid var(--long)}
.active-level.stopped{background:var(--short-dim);border:1px solid var(--short)}
.active-meta{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--text3)}
.close-btn{padding:3px 8px;background:var(--bg4);border:1px solid var(--border);color:var(--text2);border-radius:3px;font-size:12px;cursor:pointer}
.close-btn:hover{background:var(--short-dim);border-color:var(--short);color:var(--short)}
.btn-history{padding:2px 6px;background:var(--purple-dim);border:1px solid var(--purple);color:var(--purple);border-radius:3px;font-size:10px;cursor:pointer;margin-left:auto}
.btn-history:hover{background:var(--purple);color:#fff}

/* SAVED TRADES */
.saved-section{border-top:1px solid var(--border);padding:10px;background:linear-gradient(135deg, var(--bg1) 0%, rgba(0,200,255,0.05) 100%)}
.saved-title{font-size:11px;font-weight:700;display:flex;justify-content:space-between;align-items:center;cursor:pointer;padding:4px 0;color:var(--cyan)}
.saved-title:hover{color:var(--gold)}
.saved-count{background:var(--cyan);color:var(--bg1);font-size:10px;padding:2px 6px;border-radius:8px;font-weight:700}
.saved-toggle{font-size:10px;transition:transform 0.2s}
.saved-toggle.open{transform:rotate(180deg)}
.saved-list{max-height:200px;overflow-y:auto;margin-top:8px}
.saved-card{background:var(--bg3);border:1px solid var(--cyan);border-radius:6px;padding:10px;margin-bottom:8px;position:relative}
.saved-card.long{border-left:3px solid var(--long)}
.saved-card.short{border-left:3px solid var(--short)}
.saved-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.saved-pair{font-weight:700;font-size:13px;color:var(--text)}
.saved-dir{font-size:10px;padding:2px 6px;border-radius:3px;font-weight:700}
.saved-dir.long{background:var(--long);color:#000}
.saved-dir.short{background:var(--short);color:#fff}
.saved-grade{font-size:10px;padding:2px 6px;border-radius:3px;font-weight:700;background:var(--gold);color:#000}
.saved-info{display:grid;grid-template-columns:repeat(4,1fr);gap:4px;margin-bottom:8px}
.saved-info-item{text-align:center;background:var(--bg4);border-radius:4px;padding:4px}
.saved-info-label{font-size:9px;color:var(--text3)}
.saved-info-value{font-size:11px;font-weight:600;font-family:monospace}
.saved-meta{display:flex;justify-content:space-between;align-items:center;font-size:10px;color:var(--text3)}
.saved-time{font-style:italic}
.saved-actions{display:flex;gap:6px}
.saved-btn{padding:4px 10px;border-radius:4px;font-size:10px;font-weight:600;cursor:pointer;border:1px solid}
.saved-btn.view{background:var(--cyan-dim);border-color:var(--cyan);color:var(--cyan)}
.saved-btn.view:hover{background:var(--cyan);color:#000}
.saved-btn.delete{background:var(--short-dim);border-color:var(--short);color:var(--short)}
.saved-btn.delete:hover{background:var(--short);color:#fff}
.save-btn{padding:10px 20px;background:var(--cyan-dim);border:1px solid var(--cyan);color:var(--cyan);border-radius:6px;font-size:12px;font-weight:600;cursor:pointer;margin-left:8px}
.save-btn:hover{background:var(--cyan);color:#000}
.tv-btn{padding:10px 20px;background:rgba(33,150,243,0.15);border:1px solid #2196F3;color:#2196F3;border-radius:6px;font-size:12px;font-weight:600;cursor:pointer;margin-left:8px;transition:all 0.2s}
.tv-btn:hover{background:#2196F3;color:#fff}


/* ═══════════════════════════════════════════════════════════════════════════════
   ENHANCED SAVED TRADES STYLES v2.0
   ═══════════════════════════════════════════════════════════════════════════════ */

/* Saved Trade Card - Enhanced */
.saved-card-enhanced {
    background: var(--bg3);
    border: 1px solid var(--border);
    border-radius: 8px;
    margin-bottom: 10px;
    overflow: hidden;
    transition: all 0.3s ease;
}
.saved-card-enhanced.long { border-left: 4px solid var(--long); }
.saved-card-enhanced.short { border-left: 4px solid var(--short); }
.saved-card-enhanced:hover { border-color: var(--cyan); }

/* Card Header */
.saved-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 12px;
    background: var(--bg4);
    border-bottom: 1px solid var(--border);
}
.saved-card-pair {
    font-weight: 700;
    font-size: 14px;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 8px;
}
.saved-card-dir {
    font-size: 10px;
    padding: 3px 8px;
    border-radius: 4px;
    font-weight: 700;
}
.saved-card-dir.long { background: var(--long); color: #000; }
.saved-card-dir.short { background: var(--short); color: #fff; }

/* Status Badge */
.saved-status-badge {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: 700;
}
.saved-status-badge.strong-profit { background: var(--long-dim); color: var(--long); }
.saved-status-badge.in-profit { background: var(--long-dim); color: var(--long); }
.saved-status-badge.tp-hit { background: var(--gold-dim); color: var(--gold); animation: pulse 1s infinite; }
.saved-status-badge.near-entry { background: var(--amber-dim); color: var(--amber); }
.saved-status-badge.small-loss { background: var(--amber-dim); color: var(--amber); }
.saved-status-badge.at-risk { background: var(--short-dim); color: var(--short); animation: pulse 0.5s infinite; }
.saved-status-badge.stopped-out { background: var(--short); color: #fff; }
.saved-status-badge.loading { background: var(--bg4); color: var(--text3); }

/* Row Container */
.saved-row {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
}
.saved-row:last-child { border-bottom: none; }

/* Row Label */
.saved-row-label {
    font-size: 10px;
    font-weight: 700;
    color: var(--text3);
    margin-bottom: 6px;
    display: flex;
    align-items: center;
    gap: 6px;
}
.saved-row-label .emoji { font-size: 12px; }

/* ROW 1: Original Data */
.saved-row.original {
    background: linear-gradient(90deg, rgba(59,130,246,0.05) 0%, transparent 100%);
}
.saved-original-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
}
.saved-original-item {
    background: var(--bg4);
    border-radius: 4px;
    padding: 6px;
    text-align: center;
}
.saved-original-item .label {
    font-size: 9px;
    color: var(--text3);
    margin-bottom: 2px;
}
.saved-original-item .value {
    font-size: 11px;
    font-weight: 600;
    font-family: 'Courier New', monospace;
}
.saved-original-item .value.entry { color: var(--cyan); }
.saved-original-item .value.sl { color: var(--short); }
.saved-original-item .value.tp { color: var(--long); }
.saved-original-item .value.rr { color: var(--purple); }

/* ROW 2: Live Progress */
.saved-row.live {
    background: linear-gradient(90deg, rgba(0,217,160,0.05) 0%, transparent 100%);
}
.saved-live-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}
.saved-live-price {
    font-size: 16px;
    font-weight: 700;
    font-family: 'Courier New', monospace;
}
.saved-live-pnl {
    font-size: 14px;
    font-weight: 700;
    padding: 4px 10px;
    border-radius: 4px;
}
.saved-live-pnl.profit { background: var(--long-dim); color: var(--long); }
.saved-live-pnl.loss { background: var(--short-dim); color: var(--short); }

/* Progress Bar */
.saved-progress-container {
    margin-top: 8px;
}
.saved-progress-bar {
    position: relative;
    height: 24px;
    background: var(--bg4);
    border-radius: 12px;
    overflow: visible;
    margin-bottom: 4px;
}
.saved-progress-fill {
    height: 100%;
    border-radius: 12px;
    transition: width 0.5s ease;
}
.saved-progress-fill.profit {
    background: linear-gradient(90deg, var(--long-dim), var(--long));
}
.saved-progress-fill.loss {
    background: linear-gradient(90deg, var(--short), var(--short-dim));
}
.saved-progress-fill.neutral {
    background: linear-gradient(90deg, var(--amber-dim), var(--amber));
}

/* Progress Markers */
.saved-progress-marker {
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 10px;
    font-weight: 700;
    padding: 2px 4px;
    border-radius: 3px;
    white-space: nowrap;
    z-index: 2;
}
.saved-progress-marker.current {
    background: transparent;
    color: var(--cyan);
    font-size: 14px;
    padding: 0;
    box-shadow: none;
    z-index: 3;
}

/* Progress Labels */
.saved-progress-labels {
    display: flex;
    justify-content: space-between;
    font-size: 9px;
    color: var(--text3);
    padding: 0 4px;
}

/* ROW 3: AI Interpretation */
.saved-row.ai {
    background: linear-gradient(90deg, rgba(168,85,247,0.05) 0%, transparent 100%);
}
.saved-ai-commentary {
    font-size: 12px;
    color: var(--text);
    line-height: 1.5;
    padding: 8px 10px;
    background: var(--bg4);
    border-radius: 6px;
    border-left: 3px solid var(--purple);
}
.saved-ai-suggestion {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-top: 8px;
    padding: 6px 10px;
    background: var(--long-dim);
    border: 1px solid var(--long);
    border-radius: 4px;
    font-size: 11px;
    color: var(--long);
}
.saved-ai-warning {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-top: 8px;
    padding: 6px 10px;
    background: var(--amber-dim);
    border: 1px solid var(--amber);
    border-radius: 4px;
    font-size: 11px;
    color: var(--amber);
}
.saved-ai-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px;
    color: var(--text3);
    font-size: 11px;
}
.saved-ai-btn {
    padding: 6px 12px;
    background: var(--purple-dim);
    border: 1px solid var(--purple);
    color: var(--purple);
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}
.saved-ai-btn:hover {
    background: var(--purple);
    color: #fff;
}

/* Card Actions */
.saved-card-actions {
    display: flex;
    gap: 6px;
    padding: 10px 12px;
    background: var(--bg4);
    border-top: 1px solid var(--border);
}
.saved-action-btn {
    flex: 1;
    padding: 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    border: 1px solid;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
}
.saved-action-btn.refresh {
    background: var(--cyan-dim);
    border-color: var(--cyan);
    color: var(--cyan);
}
.saved-action-btn.refresh:hover {
    background: var(--cyan);
    color: #000;
}
.saved-action-btn.details {
    background: var(--purple-dim);
    border-color: var(--purple);
    color: var(--purple);
}
.saved-action-btn.details:hover {
    background: var(--purple);
    color: #fff;
}
.saved-action-btn.delete {
    background: var(--short-dim);
    border-color: var(--short);
    color: var(--short);
    flex: 0.5;
}
.saved-action-btn.delete:hover {
    background: var(--short);
    color: #fff;
}

/* Last Updated */
.saved-last-updated {
    font-size: 9px;
    color: var(--text3);
    text-align: right;
    padding: 4px 12px;
    background: var(--bg4);
}

/* Enhanced saved list */
.saved-list-enhanced {
    max-height: 400px;
    overflow-y: auto;
    padding: 8px;
}

/* Empty state */
.saved-empty {
    text-align: center;
    padding: 20px;
    color: var(--text3);
}
.saved-empty-icon {
    font-size: 32px;
    margin-bottom: 8px;
}
.saved-empty-text {
    font-size: 12px;
}

/* Refresh All Button */
.saved-refresh-all {
    width: 100%;
    padding: 8px;
    background: var(--bg4);
    border: 1px dashed var(--border);
    border-radius: 6px;
    color: var(--text3);
    font-size: 11px;
    cursor: pointer;
    margin-bottom: 10px;
    transition: all 0.2s;
}
.saved-refresh-all:hover {
    background: var(--cyan-dim);
    border-color: var(--cyan);
    color: var(--cyan);
}
/* EMPTY & LOADING */
.empty{text-align:center;padding:40px 20px;color:var(--text2)}
.empty-icon{font-size:36px;margin-bottom:10px}
.spinner{width:24px;height:24px;border:3px solid var(--bg4);border-top-color:var(--gold);border-radius:50%;animation:spin 0.8s linear infinite;margin:0 auto 10px}
@keyframes spin{to{transform:rotate(360deg)}}
.scan-status{font-size:12px;color:var(--text3);margin-top:6px}

/* MODAL */
.modal-bg{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;z-index:1000;padding:10px}
.modal-bg.show{display:flex}
.modal{background:var(--bg2);border:1px solid var(--border);border-radius:12px;width:100%;max-width:500px;max-height:90vh;overflow:hidden}
.modal-head{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border-bottom:1px solid var(--border)}
.modal-title{font-size:14px;font-weight:700}
.modal-close{background:none;border:none;color:var(--text2);font-size:22px;cursor:pointer}
.modal-body{padding:14px;overflow-y:auto;max-height:60vh}
.form-group{margin-bottom:12px}
.form-label{font-size:12px;color:var(--text2);margin-bottom:4px;display:block}
.form-input,.form-select{width:100%;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px}
.form-row{display:flex;gap:8px;margin-top:6px}
.form-row .btn{flex:1}
.key-status{font-size:12px;padding:6px 10px;border-radius:5px;margin-bottom:12px}
.key-status.valid{background:var(--long-dim);color:var(--long)}
.key-status.invalid{background:var(--short-dim);color:var(--short)}

/* Key Status Grid */
.key-grid{display:grid;grid-template-columns:repeat(11,1fr);gap:4px;margin:10px 0;padding:8px;background:var(--bg4);border-radius:6px}
.key-slot{display:flex;flex-direction:column;align-items:center;padding:4px 2px;border-radius:4px;font-size:9px;background:var(--bg3)}
.key-slot.active{background:var(--long-dim);border:1px solid var(--long)}
.key-slot.error{background:var(--short-dim);border:1px solid var(--short)}
.key-slot.off{background:var(--bg4);opacity:0.4}
.key-slot.empty{background:var(--bg3);border:1px dashed var(--border)}
.key-slot-icon{font-size:12px}
.key-slot-label{color:var(--text3);font-size:8px}

/* Key Row with Toggle */
.key-row{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.key-row .form-input{flex:1}

/* Toggle Switch */
.toggle-switch{position:relative;width:32px;height:18px;flex-shrink:0}
.toggle-switch input{opacity:0;width:0;height:0}
.toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:var(--bg4);border-radius:18px;transition:0.3s}
.toggle-slider:before{position:absolute;content:"";height:12px;width:12px;left:3px;bottom:3px;background:var(--text3);border-radius:50%;transition:0.3s}
.toggle-switch input:checked+.toggle-slider{background:var(--long)}
.toggle-switch input:checked+.toggle-slider:before{transform:translateX(14px)}

/* Key Status Indicator */
.key-indicator{font-size:14px;width:20px;text-align:center;flex-shrink:0}

.modal-foot{padding:12px 14px;border-top:1px solid var(--border);display:flex;justify-content:flex-end;gap:8px}
.groq-info{background:var(--cyan-dim);border:1px solid var(--cyan);border-radius:6px;padding:10px;font-size:11px;color:var(--cyan);margin-bottom:12px}
.groq-info a{color:var(--cyan)}

/* TIMEFRAME & ALERT TOGGLES */
.tf-toggle{display:flex;align-items:center;justify-content:center;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;cursor:pointer;transition:all 0.2s}
.tf-toggle:has(input:checked){background:var(--long-dim);border-color:var(--long)}
.tf-toggle input{display:none}
.tf-toggle-label{font-size:13px;font-weight:700;color:var(--text)}
.tf-toggle:has(input:checked) .tf-toggle-label{color:var(--long)}
.alert-toggle{display:flex;align-items:center;gap:10px;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;cursor:pointer;margin-bottom:8px}
.alert-toggle:has(input:checked){background:var(--amber-dim);border-color:var(--amber)}
.alert-toggle input{width:18px;height:18px;accent-color:var(--amber)}
.alert-toggle-label{font-size:12px;color:var(--text)}

/* TOAST */
.toast-box{position:fixed;bottom:12px;right:12px;z-index:1100}
.toast{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:10px 14px;margin-top:6px;font-size:12px;animation:slideIn 0.3s}
.toast.success{border-color:var(--long);background:var(--long-dim)}
.toast.error{border-color:var(--short);background:var(--short-dim)}
.toast.warning{border-color:var(--amber);background:var(--amber-dim)}
@keyframes slideIn{from{opacity:0;transform:translateX(30px)}to{opacity:1;transform:translateX(0)}}

/* DASHBOARD STATS BAR */
.stats-bar{display:grid;grid-template-columns:repeat(6,1fr);gap:4px;padding:8px 6px;background:var(--bg2);border-bottom:1px solid var(--border)}
.stat-box{text-align:center;padding:6px 3px;background:var(--bg3);border-radius:6px;border:1px solid var(--border);transition:all 0.2s}
.stat-box:hover{background:var(--bg4);transform:scale(1.02)}
.stat-box:active{transform:scale(0.98)}
.stat-value{font-size:15px;font-weight:700;font-family:monospace}
.stat-value.long{color:var(--long);text-shadow:0 0 8px rgba(0,217,160,0.4)}
.stat-value.short{color:var(--short);text-shadow:0 0 8px rgba(255,71,87,0.4)}
.stat-value.gold{color:var(--gold);text-shadow:0 0 8px rgba(255,215,0,0.4)}
.stat-label{font-size:9px;color:var(--text3);margin-top:2px;font-weight:600;letter-spacing:0.5px}
/* Individual stat box styles */
.stat-box:nth-child(1){border-color:var(--cyan);border-width:1px 1px 2px 1px}
.stat-box:nth-child(1) .stat-value{color:var(--cyan)}
.stat-box:nth-child(2){border-color:#00ffcc;border-width:1px 1px 2px 1px;background:linear-gradient(180deg,var(--bg3) 0%,rgba(0,255,204,0.1) 100%)}
.stat-box:nth-child(2) .stat-label{color:#00ffcc}
.stat-box:nth-child(3){border-color:var(--gold);border-width:1px 1px 2px 1px;background:linear-gradient(180deg,var(--bg3) 0%,rgba(255,215,0,0.1) 100%)}
.stat-box:nth-child(3) .stat-label{color:var(--gold)}
.stat-box:nth-child(4){border-color:var(--long);border-width:1px 1px 2px 1px}
.stat-box:nth-child(4) .stat-label{color:var(--long)}
.stat-box:nth-child(5){border-color:var(--short);border-width:1px 1px 2px 1px}
.stat-box:nth-child(5) .stat-label{color:var(--short)}
.stat-box:nth-child(6){border-color:var(--amber);border-width:1px 1px 2px 1px}
.stat-box:nth-child(6) .stat-value{color:var(--amber)}
.stat-box:nth-child(6) .stat-label{color:var(--amber)}

/* COIN MANAGER */
.coin-manager{max-height:200px;overflow-y:auto;border:1px solid var(--border);border-radius:6px;padding:8px;background:var(--bg4)}
.coin-grid{display:flex;flex-wrap:wrap;gap:4px}
.coin-chip{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg3);border:1px solid var(--border);border-radius:4px;font-size:11px;font-weight:600}
.coin-chip .remove-coin{cursor:pointer;color:var(--short);font-weight:700}
.coin-chip .remove-coin:hover{color:#ff0000}
.add-coin-row{display:flex;gap:6px;margin-bottom:8px}
.add-coin-row input{flex:1;padding:8px;background:var(--bg4);border:1px solid var(--border);border-radius:4px;color:var(--text);font-size:12px;text-transform:uppercase}

/* HEAT MAP */
.heat-map-container{padding:8px;overflow-x:auto}
.heat-map-table{width:100%;border-collapse:collapse;font-size:11px}
.heat-map-table th{padding:6px 4px;background:var(--bg3);color:var(--text2);font-weight:600;border:1px solid var(--border);position:sticky;top:0}
.heat-map-table td{padding:4px;text-align:center;border:1px solid var(--border);cursor:pointer;transition:all 0.2s}
.heat-map-table td:hover{transform:scale(1.1);z-index:10}
.heat-map-table .coin-name{text-align:left;font-weight:600;background:var(--bg3);position:sticky;left:0}
.heat-cell{border-radius:4px;padding:4px 2px;font-weight:700;font-size:10px}
.heat-cell.long{background:var(--long-dim);color:var(--long);box-shadow:inset 0 0 10px rgba(0,217,160,0.3)}
.heat-cell.short{background:var(--short-dim);color:var(--short);box-shadow:inset 0 0 10px rgba(255,71,87,0.3)}
.heat-cell.none{background:var(--bg4);color:var(--text3)}
.heat-cell.perfect{box-shadow:0 0 8px rgba(255,215,0,0.5)}

/* RISK CALCULATOR */
.risk-calc{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px}
.risk-row{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
.risk-input{padding:8px;background:var(--bg4);border:1px solid var(--border);border-radius:4px;color:var(--text);font-size:12px;width:100%}
.risk-result{background:var(--long-dim);border:1px solid var(--long);border-radius:6px;padding:10px;text-align:center}
.risk-result-value{font-size:18px;font-weight:700;color:var(--long)}
.risk-result-label{font-size:11px;color:var(--text2)}

/* SIGNAL HISTORY */
.history-list{max-height:200px;overflow-y:auto}
.history-item{display:flex;justify-content:space-between;align-items:center;padding:8px;background:var(--bg3);border-radius:6px;margin-bottom:6px;border-left:3px solid var(--border)}
.history-item.win{border-left-color:var(--long);background:var(--long-dim)}
.history-item.loss{border-left-color:var(--short);background:var(--short-dim)}
.history-item.pending{border-left-color:var(--amber)}
.history-pnl{font-weight:700;font-family:monospace}
.history-pnl.profit{color:var(--long)}
.history-pnl.loss{color:var(--short)}

/* WEIGHT SLIDERS */
.weight-slider{margin-bottom:12px}
.weight-slider-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
.weight-slider-label{font-size:12px;color:var(--text2);flex:1}
.weight-slider-value{font-size:12px;font-weight:700;color:var(--cyan)}
.weight-slider input[type="range"]{width:100%;height:6px;background:var(--bg4);border-radius:3px;outline:none;-webkit-appearance:none}
.weight-slider input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;background:var(--cyan);border-radius:50%;cursor:pointer;box-shadow:0 0 8px rgba(6,182,212,0.5)}
.weight-slider input[type="range"]:disabled{opacity:0.5;cursor:not-allowed}
.weight-slider.locked{opacity:0.7;background:var(--bg4);border-radius:6px;padding:4px}

/* LOCK BUTTONS */
.lock-btn{background:transparent;border:1px solid var(--border);border-radius:4px;padding:2px 6px;font-size:12px;cursor:pointer;margin:0 8px;transition:all 0.2s}
.lock-btn:hover{background:var(--bg4)}
.lock-btn.locked{background:var(--amber-dim);border-color:var(--amber);color:var(--amber)}

/* VIEW TOGGLE */
.view-toggle{display:flex;gap:4px;margin-bottom:8px}
.view-btn{flex:1;padding:8px;border:1px solid var(--border);border-radius:4px;background:var(--bg4);color:var(--text3);font-size:12px;cursor:pointer;transition:all 0.2s}
.view-btn.active{background:var(--cyan-dim);border-color:var(--cyan);color:var(--cyan)}

/* OLED THEME */
body.oled{--bg1:#000000;--bg2:#050505;--bg3:#0a0a0a;--bg4:#111111;--border:#1a1a1a}
</style>
</head>
<body>
<div class="app">
<header class="header">
<!-- ROW 1: Market Info (Scrollable, matching ENV bar style) -->
<div class="header-row1">
<div class="info-badge" id="badgeBTC" title="BTC Price"><span class="icon">₿</span><span class="label">BTC:</span><span class="value" id="badgeBTCVal">---</span></div>
<div class="info-badge" id="badgeFG" title="Fear & Greed"><span class="icon">😱</span><span class="label">F&G:</span><span class="value" id="badgeFGVal">--</span></div>
<div class="info-badge" id="badgeDom" title="BTC Dominance"><span class="icon">📊</span><span class="label">DOM:</span><span class="value" id="badgeDomVal">--</span></div>
<div class="info-badge" id="badgeSeason" title="Alt/BTC Season"><span class="icon">🌙</span><span class="label">SZN:</span><span class="value" id="badgeSeasonVal">--</span></div>
<div class="info-badge" id="badgeSession" title="Trading Session"><span class="icon">🌍</span><span class="label">SESSION:</span><span class="value" id="badgeSessionVal">---</span></div>
<div class="info-badge" id="badgeAlts" title="Alts Condition"><span class="icon">🪙</span><span class="label">ALTS:</span><span class="value" id="badgeAltsVal">--</span></div>
</div>
<!-- ROW 2: Scan Progress Bar + Buttons -->
<div class="header-row2">
<div class="scan-progress-bar active" id="scanProgressBar">
    <span class="scan-progress-text" id="scanProgressText">Ready</span>
    <div class="scan-progress-track"><div class="scan-progress-fill" id="scanProgressFill" style="width:0%"></div></div>
    <span class="scan-progress-text" id="scanProgressPct">0%</span>
</div>
<div class="header-btns">
<button class="btn active" id="scanBtn" onclick="toggleScan()"><span id="scanIcon">●</span> Scan</button>
<button class="btn" onclick="showSettings()">⚙</button>
</div>
</div>
</header>

<!-- ENVIRONMENT BAR -->
<div class="env-bar" id="envBar">
<div class="env-status" id="envBTC" title="BTC Trend"><span class="icon">₿</span><span class="label">BTC:</span><span class="value" id="envBTCVal">--</span></div>
<div class="env-status" id="envBTCD" title="BTC Dominance Trend"><span class="icon">📊</span><span class="label">BTC.D:</span><span class="value" id="envBTCDVal">--</span></div>
<div class="env-status" id="envDXY" title="DXY Trend"><span class="icon">💵</span><span class="label">DXY:</span><span class="value" id="envDXYVal">--</span></div>
<div class="env-status" id="envStruct" title="BTC Structure"><span class="icon">🏗️</span><span class="label">STRUCT:</span><span class="value" id="envStructVal">--</span></div>
<div class="env-status" id="envRSI" title="BTC RSI"><span class="icon">📈</span><span class="label">RSI:</span><span class="value" id="envRSIVal">--</span></div>
<div class="env-status" id="envFund" title="Funding Rate"><span class="icon">💰</span><span class="label">FUND:</span><span class="value" id="envFundVal">--</span></div>
<div class="env-status" id="envOI" title="BTC Open Interest"><span class="icon">📊</span><span class="label">OI:</span><span class="value" id="envOIVal">--</span></div>
<div class="env-verdict" id="envVerdict"><span class="env-score" id="envScore">--</span><span id="envVerdictText">LOADING</span></div>
</div>

<!-- V10.3 STRUCTURE BAR -->
<div class="structure-bar" id="structureBar">
<div class="str-status" id="strChannel" title="Liquidity Channel"><span class="icon">📊</span><span class="label">CH:</span><span class="value" id="strChannelVal">--</span></div>
<div class="str-status" id="strTrendline" title="Trendlines"><span class="icon">📐</span><span class="label">TL:</span><span class="value" id="strTrendlineVal">--</span></div>
<div class="str-status" id="strCompression" title="Compression"><span class="icon">🔄</span><span class="label">COMP:</span><span class="value" id="strCompressionVal">--</span></div>
<div class="str-status" id="strBias" title="Channel Bias"><span class="icon">🎯</span><span class="label">BIAS:</span><span class="value" id="strBiasVal">--</span></div>
<div class="str-verdict" id="strVerdict"><span class="str-score" id="strScore">--</span><span id="strVerdictText">STRUCTURE</span></div>
</div>

<!-- 🔥 PHASE 1: LIVE DATA BAR -->
<div class="live-data-bar" id="liveDataBar">
    <div class="live-dot connecting"></div>
    <div class="live-badge liq-badge neutral">
        <span class="icon">💀</span>
        <span class="label">LIQS</span>
        <span class="value">Loading...</span>
    </div>
    <div class="live-badge oi-badge neutral">
        <span class="icon">📊</span>
        <span class="label">OI</span>
        <span class="value">--</span>
    </div>
    <div class="live-badge whale-badge neutral">
        <span class="icon">🐋</span>
        <span class="label">WHALE</span>
        <span class="value">--</span>
    </div>
    <div class="live-badge funding-badge neutral">
        <span class="icon">💰</span>
        <span class="label">FUND</span>
        <span class="value">--</span>
    </div>
</div>

<!-- DASHBOARD STATS BAR -->
<div class="stats-bar">
    <div class="stat-box" onclick="filterByStats('all')" style="cursor:pointer"><div class="stat-value" id="statTotal">0</div><div class="stat-label">ALL</div></div>
    <div class="stat-box" onclick="filterByStats('cream')" style="cursor:pointer"><div class="stat-value" id="statCream" style="color:#00ffcc;text-shadow:0 0 8px #00ffcc">0</div><div class="stat-label">💎</div></div>
    <div class="stat-box" onclick="filterByStats('perfect')" style="cursor:pointer"><div class="stat-value gold" id="statPerfect">0</div><div class="stat-label">🥇</div></div>
    <div class="stat-box" onclick="filterByStats('long')" style="cursor:pointer"><div class="stat-value long" id="statLong">0</div><div class="stat-label">LONG</div></div>
    <div class="stat-box" onclick="filterByStats('short')" style="cursor:pointer"><div class="stat-value short" id="statShort">0</div><div class="stat-label">SHORT</div></div>
    <div class="stat-box" onclick="filterByStats('agree3')" style="cursor:pointer"><div class="stat-value" id="statFullAgree">0</div><div class="stat-label">3/3</div></div>
</div>

<div class="content">
<aside class="sidebar">
<div class="sidebar-top">
<!-- VIEW TOGGLE -->
<div class="view-toggle">
    <button class="view-btn active" id="viewList" onclick="setView('list')">📋 List</button>
    <button class="view-btn" id="viewHeatmap" onclick="setView('heatmap')">🌡️ Heat Map</button>
</div>
<div class="mode-row">
<button class="mode-btn active" id="modeAll" onclick="setMode('ALL')">ALL</button>
<button class="mode-btn" id="modeScalp" onclick="setMode('SCALP')">SCALP</button>
<button class="mode-btn" id="modeSwing" onclick="setMode('SWING')">SWING</button>
</div>
<div class="filter-row">
<button class="filter-btn active" id="filterAll" onclick="setFilter('all')">All<span class="count" id="cAll">0</span></button>
<button class="filter-btn" id="filterPerfect" onclick="setFilter('perfect')">🔥<span class="count" id="cPerfect">0</span></button>
<button class="filter-btn" id="filterReady" onclick="setFilter('ready')">Ready<span class="count" id="cReady">0</span></button>
<button class="filter-btn" id="filterEarly" onclick="setFilter('early')">Early<span class="count" id="cEarly">0</span></button>
</div>
</div>
<div class="signal-list" id="signalList"><div class="empty"><div class="rainbow-circle-container"><div class="rainbow-circle-ring"></div><div class="rainbow-circle-inner"><div class="rainbow-circle-coin">Ready</div><div class="rainbow-circle-tf">to scan</div><div class="rainbow-circle-pct">0%</div><div class="rainbow-circle-count">0/0</div></div></div></div></div>


<!-- HIDDEN LEGACY ELEMENTS (for backward compatibility) -->
<div id="activeList" style="display:none"></div>
<div id="activeCount" style="display:none">0</div>
<div id="aiDot" class="ai-dot" style="display:none"></div>
<div id="aiStatus" style="display:none"></div>

<!-- SAVED TRADES SECTION -->
<div class="saved-section" id="savedSection">
<div class="saved-title" onclick="toggleSavedTrades()">
    <span>💾 Saved Trades <span class="saved-count" id="savedCount">0</span></span>
    <span class="saved-toggle" id="savedToggle">▼</span>
</div>
<div class="saved-list" id="savedList" style="display:none">
    <div style="text-align:center;color:var(--text3);font-size:12px;padding:8px">No saved trades</div>
</div>
</div>

</aside>
<main class="main" id="mainPanel"><div class="empty"><div class="empty-icon" style="font-size:48px;color:var(--cyan);text-shadow:0 0 15px rgba(0,200,255,0.5)">📊</div>Select a signal to view details</div></main>
</div>
</div>

<!-- SETTINGS MODAL -->
<div class="modal-bg" id="settingsModal">
<div class="modal" style="max-height:90vh;overflow-y:auto">
<div class="modal-head"><span class="modal-title">⚙️ Settings</span><button class="modal-close" onclick="hideSettings()">×</button></div>
<div class="modal-body">

<!-- AI SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin-bottom:10px;border-bottom:1px solid var(--border);padding-bottom:6px">🤖 AI Configuration (v13 Multi-AI - 11 Keys)</div>
<div id="keyStatus" class="key-status valid">✅ Multi-AI System Ready</div>
<div class="groq-info">🧠 v13 uses 3 AI providers with auto-failover & key rotation: Groq → DeepSeek → Gemini</div>

<!-- Key Status Grid -->
<div class="key-grid" id="keyStatusGrid">
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G1</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G2</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G3</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G4</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G5</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">DS</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm1</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm2</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm3</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm4</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm5</span></div>
</div>

<!-- Groq Keys (5 slots) -->
<div style="font-size:12px;font-weight:600;color:var(--long);margin:12px 0 8px 0">🟢 Groq API Keys (5 slots - FREE)</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey1On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey1" placeholder="Groq Key 1: gsk_...">
    <span class="key-indicator" id="groqKey1Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey2On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey2" placeholder="Groq Key 2: gsk_...">
    <span class="key-indicator" id="groqKey2Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey3On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey3" placeholder="Groq Key 3: gsk_...">
    <span class="key-indicator" id="groqKey3Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey4On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey4" placeholder="Groq Key 4: gsk_...">
    <span class="key-indicator" id="groqKey4Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey5On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey5" placeholder="Groq Key 5: gsk_...">
    <span class="key-indicator" id="groqKey5Status">⚪</span>
</div>
<div style="font-size:10px;color:var(--text3);margin-bottom:12px">Get free keys: <a href="https://console.groq.com/keys" target="_blank" style="color:var(--cyan)">console.groq.com/keys</a></div>

<!-- DeepSeek Key (1 slot) -->
<div style="font-size:12px;font-weight:600;color:var(--blue);margin:12px 0 8px 0">🔵 DeepSeek API Key (1 slot - Paid)</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="deepseekKey1On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="deepseekKey1" placeholder="DeepSeek Key: sk-...">
    <span class="key-indicator" id="deepseekKey1Status">⚪</span>
</div>
<div style="font-size:10px;color:var(--text3);margin-bottom:12px">Best value: <a href="https://platform.deepseek.com" target="_blank" style="color:var(--cyan)">platform.deepseek.com</a> (~$0.14/1M tokens)</div>

<!-- Gemini Keys (5 slots) -->
<div style="font-size:12px;font-weight:600;color:var(--purple);margin:12px 0 8px 0">🟣 Gemini API Keys (5 slots - FREE)</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey1On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey1" placeholder="Gemini Key 1: AIza...">
    <span class="key-indicator" id="geminiKey1Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey2On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey2" placeholder="Gemini Key 2: AIza...">
    <span class="key-indicator" id="geminiKey2Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey3On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey3" placeholder="Gemini Key 3: AIza...">
    <span class="key-indicator" id="geminiKey3Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey4On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey4" placeholder="Gemini Key 4: AIza...">
    <span class="key-indicator" id="geminiKey4Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey5On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey5" placeholder="Gemini Key 5: AIza...">
    <span class="key-indicator" id="geminiKey5Status">⚪</span>
</div>
<div style="font-size:10px;color:var(--text3);margin-bottom:12px">Free backup: <a href="https://aistudio.google.com/apikey" target="_blank" style="color:var(--cyan)">aistudio.google.com/apikey</a></div>

<div class="form-row">
<button class="btn" onclick="toggleKeyVis()">👁️ Show</button>
<button class="btn" onclick="clearKey()">🗑️ Clear All</button>
<button class="btn primary" onclick="testAllKeys()">🔌 Test All Keys</button>
</div>

<div class="form-group">
<label class="form-label">AI Model (Groq)</label>
<select class="form-select" id="aiModelSelect">
<option value="llama-3.3-70b-versatile">Llama 3.3 70B (Best)</option>
<option value="llama-3.1-8b-instant">Llama 3.1 8B (Fast)</option>
<option value="mixtral-8x7b-32768">Mixtral 8x7B</option>
<option value="gemma2-9b-it">Gemma 2 9B</option>
</select>
</div>

<!-- AI DISPLAY MODE SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--purple);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🤖 AI Display Mode</div>
<div style="display:flex;gap:8px;margin-bottom:10px">
<button class="btn" id="aiModeDetailed" onclick="setAIDisplayMode('detailed')" style="flex:1">📊 Detailed (13)</button>
<button class="btn" id="aiModeCompact" onclick="setAIDisplayMode('compact')" style="flex:1">📱 Compact (6)</button>
</div>
<div style="font-size:11px;color:var(--text3);margin-bottom:10px">
<b>Detailed:</b> All 13 sections expanded separately<br>
<b>Compact:</b> 6 grouped sections for mobile/quick view
</div>

<!-- COIN SELECTION SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🪙 Coin Selection</div>
<div style="display:flex;gap:6px;margin-bottom:10px">
<button class="btn" onclick="setCoinCount(50)">Top 50</button>
<button class="btn" onclick="setCoinCount(100)">Top 100</button>
<button class="btn" onclick="setCoinCount(150)">Top 150</button>
<button class="btn" onclick="setCoinCount(200)">Top 200</button>
</div>
<div class="add-coin-row">
<input type="text" id="addCoinInput" placeholder="Add coin (e.g. TRUMP)" maxlength="15">
<button class="btn" onclick="addCoin()">➕ Add</button>
</div>
<div style="font-size:11px;color:var(--text3);margin-bottom:6px">Selected: <span id="coinCountDisplay">50</span> coins (Click × to remove)</div>
<div class="coin-manager" id="coinManager"></div>

<!-- WEIGHT SLIDERS SECTION WITH LOCK -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">⚖️ Engine Weights <button class="btn" onclick="lockAllEngines()" style="font-size:10px;padding:2px 6px;margin-left:10px">🔒 Lock All</button> <button class="btn" onclick="unlockAllEngines()" style="font-size:10px;padding:2px 6px">🔓 Unlock All</button></div>
<div class="weight-slider" id="sliderZone">
<div class="weight-slider-header"><span class="weight-slider-label">🎯 Zone Analysis</span><button class="lock-btn" id="lockZone" onclick="toggleEngineLock('zone')">🔓</button><span class="weight-slider-value" id="weightZoneVal">35%</span></div>
<input type="range" min="10" max="60" value="35" id="weightZone" oninput="updateWeightDisplay()">
</div>
<div class="weight-slider" id="sliderSMC">
<div class="weight-slider-header"><span class="weight-slider-label">📐 SMC Analysis</span><button class="lock-btn" id="lockSMC" onclick="toggleEngineLock('smc')">🔓</button><span class="weight-slider-value" id="weightSMCVal">35%</span></div>
<input type="range" min="10" max="60" value="35" id="weightSMC" oninput="updateWeightDisplay()">
</div>
<div class="weight-slider" id="sliderMomentum">
<div class="weight-slider-header"><span class="weight-slider-label">📊 Momentum Analysis</span><button class="lock-btn" id="lockMomentum" onclick="toggleEngineLock('momentum')">🔓</button><span class="weight-slider-value" id="weightMomentumVal">30%</span></div>
<input type="range" min="10" max="60" value="30" id="weightMomentum" oninput="updateWeightDisplay()">
</div>
<div style="font-size:10px;color:var(--amber);text-align:center;margin-top:4px">🔒 = Locked (won't change when scrolling)</div>
<div style="font-size:11px;color:var(--text3);text-align:center;margin-top:4px">Total: <span id="weightTotal">100%</span></div>

<!-- RISK CALCULATOR SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">💰 Risk Management</div>
<div class="risk-row">
<div class="form-group" style="margin:0">
<label class="form-label">Account Size ($)</label>
<input type="number" class="risk-input" id="riskAccount" value="1000" placeholder="1000">
</div>
<div class="form-group" style="margin:0">
<label class="form-label">Risk Per Trade (%)</label>
<input type="number" class="risk-input" id="riskPercent" value="2" min="0.5" max="10" step="0.5" placeholder="2">
</div>
</div>
<div class="risk-row">
<div class="form-group" style="margin:0">
<label class="form-label">Default Leverage</label>
<select class="form-select" id="riskLeverage">
<option value="3">3x</option>
<option value="5">5x</option>
<option value="10" selected>10x</option>
<option value="20">20x</option>
</select>
</div>
<div class="form-group" style="margin:0">
<label class="form-label">Max Position ($)</label>
<input type="number" class="risk-input" id="riskMaxPosition" value="500" placeholder="500">
</div>
</div>

<!-- TIMEFRAME SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">⏱️ Timeframes to Scan</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<label class="tf-toggle"><input type="checkbox" id="tf5m" checked><span class="tf-toggle-label">5m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf15m" checked><span class="tf-toggle-label">15m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf30m" checked><span class="tf-toggle-label">30m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf1h" checked><span class="tf-toggle-label">1H</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf4h" checked><span class="tf-toggle-label">4H</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf1d" checked><span class="tf-toggle-label">1D</span></label>
</div>

<!-- AUTO-SCAN INTERVAL -->
<div class="form-group">
<label class="form-label">🔄 Auto-Scan Interval</label>
<select class="form-select" id="scanInterval">
<option value="60000">1 Minute</option>
<option value="180000">3 Minutes</option>
<option value="300000" selected>5 Minutes</option>
<option value="600000">10 Minutes</option>
</select>
</div>

<!-- ALERTS SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🔔 Alert Settings</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="alertSound" checked><span class="alert-toggle-label">🔊 Sound Alert on New Signal</span></label>
</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="alertVibrate"><span class="alert-toggle-label">📳 Vibrate on New Signal</span></label>
</div>
<div class="form-group">
<label class="form-label">Alert for Grade</label>
<select class="form-select" id="alertGrade">
<option value="PERFECT">PERFECT only</option>
<option value="STRONG">STRONG and above</option>
<option value="VALID">VALID and above</option>
<option value="HEATING">HEATING and above</option>
<option value="BREWING" selected>All signals (BREWING+)</option>
</select>
</div>
<button class="btn" onclick="testAlert()" style="width:100%;margin-top:8px">🔔 Test Alert</button>

<!-- TELEGRAM SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">📱 Telegram Alerts</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="telegramEnabled"><span class="alert-toggle-label">Enable Telegram Alerts</span></label>
</div>
<div class="form-group">
<label class="form-label">Bot Token</label>
<input type="text" class="form-input" id="telegramToken" placeholder="123456789:ABCdefGHI...">
</div>
<div class="form-group">
<label class="form-label">Chat ID</label>
<input type="text" class="form-input" id="telegramChatId" placeholder="Your chat ID">
</div>
<button class="btn" onclick="testTelegram()" style="width:100%;margin-top:8px">📱 Test Telegram</button>

<!-- THEME SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🎨 Theme</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="oledTheme"><span class="alert-toggle-label">🌙 OLED Black Theme (Battery Saver)</span></label>
</div>

<!-- TIMEZONE SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🕐 Timezone & Session</div>
<div class="form-group">
<label class="form-label">Your City</label>
<select class="form-select" id="userTimezone">
<option value="auto">🌐 Auto-Detect</option>
<option value="Australia/Melbourne">🇦🇺 Melbourne (UTC+11)</option>
<option value="Australia/Sydney">🇦🇺 Sydney (UTC+11)</option>
<option value="Australia/Perth">🇦🇺 Perth (UTC+8)</option>
<option value="Asia/Singapore">🇸🇬 Singapore (UTC+8)</option>
<option value="Asia/Hong_Kong">🇭🇰 Hong Kong (UTC+8)</option>
<option value="Asia/Tokyo">🇯🇵 Tokyo (UTC+9)</option>
<option value="Asia/Dubai">🇦🇪 Dubai (UTC+4)</option>
<option value="Europe/London">🇬🇧 London (UTC+0)</option>
<option value="Europe/Paris">🇫🇷 Paris (UTC+1)</option>
<option value="America/New_York">🇺🇸 New York (UTC-5)</option>
<option value="America/Chicago">🇺🇸 Chicago (UTC-6)</option>
<option value="America/Los_Angeles">🇺🇸 Los Angeles (UTC-8)</option>
</select>
</div>
<div id="timezonePreview" style="font-size:11px;color:var(--text3);padding:8px;background:var(--bg4);border-radius:4px;margin-top:8px">
🕐 Current: -- | Session: --
</div>

</div>
<div class="modal-foot">
<button class="btn" onclick="hideSettings()">Cancel</button>
<button class="btn active" onclick="saveSettings()">Save</button>
</div>
</div>
</div>
<div class="toast-box" id="toastBox"></div>

<script>
// ═══════════════════════════════════════════════════════════════════════════════
// GLOBAL ERROR HANDLERS - CRASH PREVENTION
// ═══════════════════════════════════════════════════════════════════════════════

// Catch all uncaught errors
window.onerror = function(msg, url, line, col, error) {
    // Ignore network/browser-specific noise
    const msgStr = String(msg || '');
    if (msgStr.includes('AbortSignal') || 
        msgStr.includes('postMessage') || 
        msgStr.includes('Failed to fetch') ||
        msgStr.includes('NetworkError') ||
        msgStr.includes('Timeout') ||
        msgStr.includes('cloned')) {
        return true;
    }
    console.error('🛑 Global Error:', msg, 'at line', line);
    // Show user-friendly toast if available
    if (typeof toast === 'function') {
        toast('An error occurred - check console', 'error');
    }
    return true;  // Prevents default error handling (crash)
};

// Catch unhandled promise rejections
window.onunhandledrejection = function(event) {
    // Ignore network/browser noise
    const reason = event.reason ? String(event.reason) : '';
    if (reason.includes('AbortSignal') || 
        reason.includes('postMessage') || 
        reason.includes('abort') || 
        reason.includes('Failed to fetch') ||
        reason.includes('Timeout') ||
        reason.includes('cloned') ||
        reason.includes('NetworkError')) {
        event.preventDefault();
        return;
    }
    console.error('🛑 Unhandled Promise Rejection:', event.reason);
    if (typeof toast === 'function') {
        toast('Network/API error - retrying...', 'warning');
    }
    event.preventDefault();  // Prevents crash
};

// ═══════════════════════════════════════════════════════════════════════════════
// 🛡️ CRASH-PROOF WRAPPER SYSTEM - SOLID PROTECTION
// ═══════════════════════════════════════════════════════════════════════════════

// Safe wrapper for synchronous functions
function safeCall(fn, fallback, context = 'Unknown') {
    try {
        const result = fn();
        return result;
    } catch (e) {
        console.error(`🛡️ SafeCall Error [${context}]:`, e.message);
        return fallback;
    }
}

// Safe wrapper for async functions
async function safeAsync(fn, fallback, context = 'Unknown') {
    try {
        const result = await fn();
        return result;
    } catch (e) {
        console.error(`🛡️ SafeAsync Error [${context}]:`, e.message);
        return fallback;
    }
}

// Safe property access - prevents "Cannot read property of undefined"
function safeGet(obj, path, fallback = null) {
    try {
        const keys = path.split('.');
        let result = obj;
        for (const key of keys) {
            if (result === null || result === undefined) return fallback;
            result = result[key];
        }
        return result !== undefined ? result : fallback;
    } catch (e) {
        return fallback;
    }
}

// Safe number - ensures value is a valid number
function safeNum(val, fallback = 0) {
    const num = Number(val);
    return isNaN(num) || !isFinite(num) ? fallback : num;
}

// Safe array - ensures value is an array
function safeArr(val) {
    return Array.isArray(val) ? val : [];
}

// Safe object - ensures value is an object
function safeObj(val) {
    return val && typeof val === 'object' && !Array.isArray(val) ? val : {};
}

// Safe division - prevents divide by zero
function safeDiv(a, b, fallback = 0) {
    if (b === 0 || isNaN(b) || !isFinite(b)) return fallback;
    const result = a / b;
    return isNaN(result) || !isFinite(result) ? fallback : result;
}

// Safe percentage calculation
function safePct(value, total, decimals = 2) {
    if (!total || total === 0) return 0;
    const pct = (value / total) * 100;
    return isNaN(pct) || !isFinite(pct) ? 0 : Number(pct.toFixed(decimals));
}

// Safe array reduce
function safeReduce(arr, fn, initial) {
    if (!Array.isArray(arr) || arr.length === 0) return initial;
    try {
        return arr.reduce(fn, initial);
    } catch (e) {
        return initial;
    }
}

// Safe array map
function safeMap(arr, fn) {
    if (!Array.isArray(arr)) return [];
    try {
        return arr.map(fn).filter(x => x !== undefined && x !== null);
    } catch (e) {
        return [];
    }
}

// Safe array filter
function safeFilter(arr, fn) {
    if (!Array.isArray(arr)) return [];
    try {
        return arr.filter(fn);
    } catch (e) {
        return [];
    }
}

// Safe JSON parse
function safeJSON(str, fallback = null) {
    try {
        return JSON.parse(str);
    } catch (e) {
        return fallback;
    }
}

// Safe toFixed
function safeFixed(num, decimals = 2) {
    const n = safeNum(num, 0);
    try {
        return n.toFixed(decimals);
    } catch (e) {
        return '0';
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// END CRASH-PROOF WRAPPER SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Console log limiter
let consoleLogCount = 0;
const originalConsoleLog = console.log;
console.log = function(...args) {
    consoleLogCount++;
    if (consoleLogCount > 1000) {
        if (consoleLogCount === 1001) {
            originalConsoleLog('⚠️ Console log limit reached - throttling');
        }
        if (consoleLogCount % 100 === 0) {
            originalConsoleLog(...args);  // Log every 100th
        }
        return;
    }
    originalConsoleLog(...args);
};

// ═══════════════════════════════════════════════════════════════════════════════
// Bybit Scanner - CONFIGURATION
// ═══════════════════════════════════════════════════════════════════════════════

const CONFIG = {
    // ═══════════════════════════════════════════════════════════════════════════
    // V10.3 STRUCTURE ENGINE CONFIG (FROM QUANTUM CHART)
    // ═══════════════════════════════════════════════════════════════════════════
    STRUCTURE: {
        enabled: true,
        
        // Channel validation
        channel: {
            enabled: true,
            minWidth: 0.02,         // 2% minimum channel width
            maxWidth: 0.08,         // 8% maximum channel width
            boundaryTypes: ['ob', 'zone', 'swing'],  // Priority order
            boundaryScores: { ob: 25, zone: 15, swing: 5 }
        },
        
        // Trendline validation
        trendlines: {
            enabled: true,
            swingPeriods: [3, 5, 8],     // Multi-TF swing detection
            minTouches: 2,
            maxLines: 3
        },
        
        // Compression detection
        compression: {
            enabled: true,
            atrPeriod: 14,
            compressionThreshold: 0.8,    // ATR < 80% of average = compressed
            expansionThreshold: 1.2       // ATR > 120% = expansion
        },
        
        // Bias calculation
        bias: {
            premiumZone: 0.75,            // Top 25% of channel
            discountZone: 0.25,           // Bottom 25% of channel
            equilibriumTolerance: 0.1     // 10% around midline
        },
        
        // Gate requirements
        gate: {
            enabled: true,
            requireChannel: true,
            requireTrendlineOrZone: true,
            requireBiasAlignment: true,
            blockOnFail: false            // Set to true to hard-block signals
        }
    },
    
    // FULL 200 COINS LIST - Bybit USDT perpetuals (OPTIMIZED - No Meme Coins)
    ALL_COINS: [
        // Tier 1: Blue Chips (1-20) - Highest Liquidity
        'BTCUSDT','ETHUSDT','BNBUSDT','SOLUSDT','XRPUSDT','ADAUSDT','AVAXUSDT','DOGEUSDT',
        'DOTUSDT','LINKUSDT','MATICUSDT','LTCUSDT','BCHUSDT','ATOMUSDT','ETCUSDT','XLMUSDT',
        'NEARUSDT','ICPUSDT','APTUSDT','FILUSDT',
        // Tier 2: Large Caps (21-50) - Strong Volume
        'UNIUSDT','AAVEUSDT','LDOUSDT','ARBUSDT','OPUSDT','INJUSDT','SUIUSDT','SEIUSDT',
        'TIAUSDT','STXUSDT','IMXUSDT','RUNEUSDT','MKRUSDT','GRTUSDT','FETUSDT','RNDRUSDT',
        'THETAUSDT','HBARUSDT','ALGOUSDT','VETUSDT','FTMUSDT','EGLDUSDT','FLOWUSDT','SANDUSDT',
        'AXSUSDT','MANAUSDT','ENJUSDT','CHZUSDT','GALAUSDT','QNTUSDT',
        // Tier 3: Mid Caps DeFi (51-80) - Solid Projects
        'SNXUSDT','COMPUSDT','CRVUSDT','SUSHIUSDT','1INCHUSDT','DYDXUSDT','GMXUSDT','PERPUSDT',
        'ZRXUSDT','LRCUSDT','BALUSDT','YFIUSDT','PENDLEUSDT','ENAUSDT','JUPUSDT','PYTHUSDT',
        'WLDUSDT','TAOUSDT','AGIXUSDT','OCEANUSDT','MINAUSDT','KAVAUSDT','ROSAUSDT','NEOUSDT',
        'XTZUSDT','EOSUSDT','IOTAUSDT','DASHUSDT','ZECUSDT','XMRUSDT',
        // Tier 4: Infrastructure & L2 (81-110) - Tech Focused
        'STRKUSDT','MANTAUSDT','ZKUSDT','SCROLLUSDT','ZETAUSDT','CELOUSDT','KSMUSDT','ARUSDT',
        'STORJUSDT','ANKRUSDT','SKLUSDT','CTSIUSDT','BANDUSDT','API3USDT','LPTUSDT','RENDERUSDT',
        'ILVUSDT','CFXUSDT','KASUSDT','EIGENUSDT','RONINUSDT','OMUSDT','DYMUSDT','MOVRUSDT',
        'GLMRUSDT','RADUSDT','LQTYUSDT','TRUUSDT','POLYXUSDT','SYNUSDT',
        // Tier 5: Gaming & NFT (111-140) - Growing Sectors  
        'GMTUSDT','APEUSDT','MAGICUSDT','YGGUSDT','PORTALUSDT','PIXELUSDT','XAIUSDT','ACEUSDT',
        'ALTUSDT','BEAMUSDT','PRIMESDT','GABORUSDT','MBOXUSDT','RAREUSDT','AUDIOUSDT','HIGHUSDT',
        'BICOUSDT','BLURUSDT','MASKUSDT','RDNTUSDT','HOOKUSDT','IDUSDT','EDUUSDT','MAVUSDT',
        'CYBERUSDT','ARKMUSDT','FRONTUSDT','AGLDUSDT','SUPERUSDT','SAFEUSDT',
        // Tier 6: Established Alts (141-170) - Proven Track Record
        'WAVESUSDT','RENUSDT','ONTUSDT','ZENUSDT','DCRUSDT','RLCUSDT','NMRUSDT','LSKUSDT',
        'XVSUSDT','ALPACAUSDT','DARUSDT','JTOUSDT','SAGAUSDT','TNSRUSDT','AEVOUSDT','REZUSDT',
        'IOUSDT','LISTAUSDT','DRIFTUSDT','MORPHOUSDT','GRASSUSDT','MOVEUSDT','VANAUSDT',
        'SCRUSDT','ATHUSDT','MEUSDT','BBUSDT','LEVERUSDT','MDTUSDT','AMBUSDT',
        // Tier 7: Additional Quality (171-200) - Diversification
        'COTIUSDT','OGNUSDT','REQUSDT','PUNDIXUSDT','PHAUSDT','FORTHUSDT','BONDUSDT','MLNUSDT',
        'BADGERUSDT','RARIUSDT','ALCXUSDT','FXSUSDT','CVXUSDT','SDUSDT','PRIMEUSDT','XVGUSDT',
        'STEEMUSDT','SNTUSDT','FUNUSDT','NKNUSDT','POWRUSDT','CVCUSDT','DATAUSDT','GTCUSDT',
        'TORNUSDT','PEOPLEUSDT','ELFUSDT','ACHUSDT','CTKUSDT','WINGUSDT'
    ],
    
    // Active coins list (can be modified by user)
    COINS: [],
    
    // Timeframes for scanning - V5.3 UPDATED
    TF_SCALP: ['15','30'],                 // V9.1: Only 15m and 30m (best performers)
    TF_SWING: ['60'],                       // V9.1: 1H as swing (not 4H)
    TF_ALL: ['5','15','30','240'],         // All: No 1H (confirmation only), No 1D (poor performance)
    TF_LABELS: {'5':'5m','15':'15m','30':'30m','60':'1H','240':'4H','D':'1D','W':'1W'},
    
    // HTF mapping for each entry TF - V5.3: 1H is confirmation TF
    HTF_MAP: {
        '5': ['15','60'],              // 5m entry → check 15m, 1H
        '15': ['60','240'],            // 15m entry → check 1H, 4H
        '30': ['60','240'],            // 30m entry → check 1H, 4H
        '240': ['D'],                  // 4H entry → check 1D
        'D': ['W']                     // 1D entry → check 1W (not used)
    },
    
    // V5.3 MODE-SPECIFIC SETTINGS
    MODE_SETTINGS: {
        SCALP: {
            tfs: ['5','15','30'],
            boss: 'MOMENTUM',          // RSI/Volume is king for scalp
            slMultiplier: 1.0,         // Tight SL
            tpMultiplier: 1.5,         // Quick TP (1:1.5)
            rsiOversold: 35,
            rsiOverbought: 65,
            volumeThreshold: 1.3,      // 1.3x average volume
            useHTF: true,              // Use 1H as confirmation
            confirmTF: '60'            // 1H confirms scalp direction
        },
        SWING: {
            tfs: ['240'],
            boss: 'HTF',               // HTF trend is king for swing
            slMultiplier: 1.5,         // Normal SL
            tpMultiplier: 2.5,         // Standard TP (1:1.67)
            useHTF: true,
            confirmTF: 'D'             // 1D confirms swing direction
        }
    },
    
    // Zone Analysis TFs for multi-TF confluence
    ZONE_TFS: ['15','30','60','240'],
    
    // Scoring weights (can be modified by user)
    WEIGHTS: { zone: 0.35, smc: 0.35, momentum: 0.30 },
    
    // Grade thresholds (V1 ULTIMATE - Updated)
    GRADES: {
        PERFECT: 90,
        STRONG: 75,
        VALID: 60,
        HEATING: 45
    },
    
    // Conflict penalties
    PENALTIES: {
        ZONE_SMC_CONFLICT: -20,
        HTF_CONFLICT: -10,
        EXHAUSTION: -10,
        DIVERGENCE_AGAINST: -15
    },
    
    // V5.1 SELF-LEARNING CONFIG
    LEARNING: {
        ENABLED: true,
        HISTORY_DAYS: 180,          // 6 months backtest
        MIN_PATTERNS: 15,           // Min patterns before adjusting
        CONFIDENCE_BOOST: 10,       // Points added for high confidence
        CONFIDENCE_PENALTY: 15,     // Points subtracted for low confidence
        HIGH_WIN_RATE: 0.65,        // 65%+ = high confidence
        LOW_WIN_RATE: 0.45,         // Below 45% = low confidence
        OPTIMAL_SETTINGS: {
            '5':   { zone: 60, smc: 30, momentum: 40, sl: 1.5, tp: 2.0 },
            '15':  { zone: 65, smc: 35, momentum: 45, sl: 2.0, tp: 2.5 },
            '30':  { zone: 70, smc: 40, momentum: 50, sl: 2.0, tp: 2.5 },
            '60':  { zone: 75, smc: 45, momentum: 55, sl: 2.5, tp: 3.0 },
            '240': { zone: 80, smc: 50, momentum: 55, sl: 2.5, tp: 3.5 },
            'D':   { zone: 80, smc: 50, momentum: 55, sl: 3.0, tp: 4.0 }
        }
    },
    
    // API
    BYBIT_BASE: 'https://api.bybit.com',
    BYBIT_V5: 'https://api.bybit.com/v5',
    GROQ_URL: 'https://api.groq.com/openai/v1/chat/completions',
    DEEPSEEK_URL: 'https://api.deepseek.com/v1/chat/completions',
    GEMINI_URL: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent',
    
    // Scan intervals
    SCAN_DELAY: 150,        // ms between API calls (SAFETY: prevent rate limit)
    AUTO_SCAN_INTERVAL: 60000  // 1 minute
};

// ═══════════════════════════════════════════════════════════════════════════════
// 🎭 COIN PERSONALITY SYSTEM - V10 (STANDALONE - NOT INSIDE CONFIG!)
// Each coin behaves differently. BTC is not DOGE is not SOL.
// ═══════════════════════════════════════════════════════════════════════════════
const COIN_PERSONALITY = {
    // ─────────────────────────────────────────────────────────────────────────────
    // TIER 1: KING (BTC) - Most stable, respects levels, institutional trading
    // ─────────────────────────────────────────────────────────────────────────────
    KING: {
        coins: ['BTCUSDT'],
        name: 'KING',
        volatilityMult: 0.8,        // Tighter zones (less volatile)
        zoneThreshold: 0.012,       // 1.2% zone distance (stricter)
        minRejectionMult: 1.8,      // Need stronger rejection wick
        volumeRequired: 0.6,        // Lower volume OK (always has liquidity)
        positionFilterLong: 45,     // Can LONG up to 45% of range
        positionFilterShort: 55,    // Can SHORT down to 55% of range
        trendStrict: true,          // Strictly follow trend
        htfReliable: true,          // HTF very reliable
        requireSweep: false,        // Sweep not required
        slMultiplier: 1.0,          // Standard SL
        tpMultiplier: 1.0,          // Standard TP
        description: 'Institutional favorite, respects S/R, predictable'
    },
    
    // ─────────────────────────────────────────────────────────────────────────────
    // TIER 2: BLUE CHIPS - Large caps, follow BTC, moderate volatility
    // ─────────────────────────────────────────────────────────────────────────────
    BLUECHIP: {
        coins: ['ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'ADAUSDT', 'LTCUSDT', 'BCHUSDT', 'XLMUSDT'],
        name: 'BLUECHIP',
        volatilityMult: 1.0,        // Standard zones
        zoneThreshold: 0.015,       // 1.5% zone distance
        minRejectionMult: 1.5,      // Standard rejection
        volumeRequired: 0.8,        // Standard volume needed
        positionFilterLong: 55,     // Can LONG up to 55%
        positionFilterShort: 45,    // Can SHORT down to 45%
        trendStrict: true,          // Follow trend
        htfReliable: true,          // HTF reliable
        requireSweep: false,        // Sweep not required
        slMultiplier: 1.0,          // Standard SL
        tpMultiplier: 1.0,          // Standard TP
        description: 'Stable large caps, follow BTC trend'
    },
    
    // ─────────────────────────────────────────────────────────────────────────────
    // TIER 3: RUNNERS - High beta, can move fast, need momentum
    // ─────────────────────────────────────────────────────────────────────────────
    RUNNER: {
        coins: ['SOLUSDT', 'AVAXUSDT', 'NEARUSDT', 'APTUSDT', 'SUIUSDT', 'SEIUSDT', 'INJUSDT', 
                'ARBUSDT', 'OPUSDT', 'TIAUSDT', 'STXUSDT', 'RUNEUSDT'],
        name: 'RUNNER',
        volatilityMult: 1.2,        // Wider zones (more volatile)
        zoneThreshold: 0.018,       // 1.8% zone distance
        minRejectionMult: 1.3,      // Slightly easier rejection
        volumeRequired: 1.0,        // Need volume confirmation
        positionFilterLong: 50,     // Tighter: LONG only below 50%
        positionFilterShort: 50,    // Tighter: SHORT only above 50%
        trendStrict: true,          // Must follow trend (they run hard)
        htfReliable: true,          // HTF reliable
        requireSweep: false,        // Sweep preferred but not required
        slMultiplier: 1.2,          // Wider SL (more volatile)
        tpMultiplier: 1.3,          // Bigger TP potential
        description: 'High beta, can pump/dump 10%+ fast'
    },
    
    // ─────────────────────────────────────────────────────────────────────────────
    // TIER 4: MID CAPS - Solid projects, moderate risk
    // ─────────────────────────────────────────────────────────────────────────────
    MIDCAP: {
        coins: ['DOTUSDT', 'LINKUSDT', 'MATICUSDT', 'ATOMUSDT', 'ETCUSDT', 'ICPUSDT', 'FILUSDT',
                'UNIUSDT', 'AAVEUSDT', 'LDOUSDT', 'MKRUSDT', 'GRTUSDT', 'FETUSDT', 'RNDRUSDT',
                'THETAUSDT', 'HBARUSDT', 'ALGOUSDT', 'VETUSDT', 'FTMUSDT', 'EGLDUSDT', 'QNTUSDT',
                'SNXUSDT', 'COMPUSDT', 'CRVUSDT', 'DYDXUSDT', 'GMXUSDT', 'PENDLEUSDT', 'JUPUSDT'],
        name: 'MIDCAP',
        volatilityMult: 1.3,        // Wider zones
        zoneThreshold: 0.018,       // 1.8% zone distance
        minRejectionMult: 1.2,      // Standard rejection
        volumeRequired: 1.0,        // Need volume
        positionFilterLong: 50,     // LONG below 50%
        positionFilterShort: 50,    // SHORT above 50%
        trendStrict: false,         // Can counter-trend at extremes
        htfReliable: true,          // HTF mostly reliable
        requireSweep: false,        // Not required
        slMultiplier: 1.2,          // Slightly wider SL
        tpMultiplier: 1.2,          // Good TP potential
        description: 'Solid projects, good trading range'
    },
    
    // ─────────────────────────────────────────────────────────────────────────────
    // TIER 5: VOLATILE - High volatility, needs extra care
    // ─────────────────────────────────────────────────────────────────────────────
    VOLATILE: {
        coins: ['IMXUSDT', 'FLOWUSDT', 'SANDUSDT', 'AXSUSDT', 'MANAUSDT', 'ENJUSDT', 'GALAUSDT',
                'WLDUSDT', 'TAOUSDT', 'AGIXUSDT', 'OCEANUSDT', 'APEUSDT', 'MAGICUSDT', 'BLURUSDT',
                'GMTUSDT', 'YGGUSDT', 'PORTALUSDT', 'PIXELUSDT', 'XAIUSDT', 'ACEUSDT', 'ALTUSDT'],
        name: 'VOLATILE',
        volatilityMult: 1.5,        // Much wider zones
        zoneThreshold: 0.022,       // 2.2% zone distance
        minRejectionMult: 1.5,      // Need clear rejection
        volumeRequired: 1.2,        // Higher volume needed
        positionFilterLong: 40,     // Only LONG in bottom 40%
        positionFilterShort: 60,    // Only SHORT in top 40%
        trendStrict: true,          // Must follow trend
        htfReliable: false,         // HTF less reliable (too choppy)
        requireSweep: false,        // Preferred
        slMultiplier: 1.5,          // Wide SL
        tpMultiplier: 1.5,          // Big TP potential
        description: 'Gaming/NFT tokens, can move 20%+ easily'
    },
    
    // ─────────────────────────────────────────────────────────────────────────────
    // TIER 6: MEME/DEGEN - Extreme volatility, manipulation, strict filters
    // ─────────────────────────────────────────────────────────────────────────────
    MEME: {
        coins: ['DOGEUSDT', 'SHIBUSDT', 'PEPEUSDT', 'WIFUSDT', 'FLOKIUSDT', 'BONKUSDT', 
                'PEOPLEUSDT', 'LEVERUSDT', 'ACHUSDT'],
        name: 'MEME',
        volatilityMult: 2.0,        // Very wide zones
        zoneThreshold: 0.025,       // 2.5% zone distance
        minRejectionMult: 2.0,      // Strong rejection required
        volumeRequired: 1.5,        // High volume required
        positionFilterLong: 30,     // Only LONG in bottom 30%
        positionFilterShort: 70,    // Only SHORT in top 30%
        trendStrict: true,          // MUST follow trend (don't fade memes)
        htfReliable: false,         // HTF unreliable
        requireSweep: true,         // MUST have liquidity sweep
        slMultiplier: 2.0,          // Very wide SL
        tpMultiplier: 2.0,          // Huge TP potential
        description: 'Meme coins - trade only at EXTREMES with SWEEP'
    },
    
    // ─────────────────────────────────────────────────────────────────────────────
    // TIER 7: LOWCAP/UNKNOWN - Small caps, be careful
    // ─────────────────────────────────────────────────────────────────────────────
    LOWCAP: {
        coins: [], // Everything else falls here
        name: 'LOWCAP',
        volatilityMult: 1.5,        // Wider zones
        zoneThreshold: 0.020,       // 2% zone distance
        minRejectionMult: 1.5,      // Clear rejection needed
        volumeRequired: 1.2,        // Need volume
        positionFilterLong: 40,     // LONG below 40%
        positionFilterShort: 60,    // SHORT above 60%
        trendStrict: true,          // Follow trend
        htfReliable: false,         // HTF less reliable
        requireSweep: false,        // Preferred
        slMultiplier: 1.5,          // Wider SL
        tpMultiplier: 1.5,          // Good TP
        description: 'Small caps - extra caution'
    }
};

// Helper function to get coin personality
function getCoinPersonality(symbol) {
    const sym = symbol.toUpperCase();
    
    for (const tier of Object.values(COIN_PERSONALITY)) {
        if (tier.coins && tier.coins.includes(sym)) {
            return tier;
        }
    }
    
    // Default to LOWCAP for unknown coins
    return COIN_PERSONALITY.LOWCAP;
}

// ═══════════════════════════════════════════════════════════════════════════════
// EXTENDED CONFIG - SAFETY LIMITS & BRAIN SYSTEMS
// ═══════════════════════════════════════════════════════════════════════════════
const CONFIG_EXTENDED = {
    // ═══════════════════════════════════════════════════════════════════════════════
    // SAFETY LIMITS - CRASH PREVENTION
    // ═══════════════════════════════════════════════════════════════════════════════
    SAFETY: {
        // Array limits
        MAX_SIGNALS: 500,
        MAX_SAVED_TRADES: 50,
        MAX_HISTORY: 100,
        MAX_CONSOLE_LOGS: 1000,
        
        // API limits
        API_TIMEOUT_MS: 10000,      // 10 second timeout
        MAX_RETRIES: 3,             // Max retry attempts
        SCAN_DELAY_MS: 150,         // Delay between API calls
        AI_DELAY_MS: 500,           // Delay between AI calls
        
        // Interval limits
        MIN_SCAN_INTERVAL_MS: 30000, // Min 30 seconds
        PRICE_REFRESH_MS: 5000,      // 5 second price refresh
        
        // Storage limits
        MAX_STORAGE_MB: 2,           // Max localStorage usage
        MAX_STORAGE_ITEMS: 50,       // Max items per storage key
        
        // Loop limits
        MAX_ITERATIONS: 10000,       // Max loop iterations
        MAX_RECURSION: 100,          // Max recursion depth
        MAX_COINS_PER_SCAN: 300,     // Max coins per scan (increased from 100)
        
        // Concurrent limits
        MAX_CONCURRENT_SCANS: 1,     // Only 1 scan at a time
        MAX_CONCURRENT_AI: 1         // Only 1 AI call at a time
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 1: AUTO POSITION SIZING BY VOLATILITY
    // ═══════════════════════════════════════════════════════════════════════════════
    VOLATILITY_SIZING: {
        baseRiskPercent: 1.0,           // Base risk 1% of account
        maxRiskPercent: 2.0,            // Maximum risk per trade
        minRiskPercent: 0.25,           // Minimum risk per trade
        
        // ATR thresholds (as % of price)
        atrLow: 0.5,                    // Below 0.5% = low volatility
        atrNormal: 1.5,                 // 0.5% - 1.5% = normal
        atrHigh: 3.0,                   // 1.5% - 3% = high volatility
        atrExtreme: 5.0,                // Above 3% = extreme
        
        // Size multipliers by volatility
        multipliers: {
            LOW: 1.5,                   // Calm market - can size up
            NORMAL: 1.0,                // Normal size
            HIGH: 0.6,                  // Volatile - reduce size
            EXTREME: 0.3                // Extreme - minimal size
        },
        
        // Grade multipliers
        gradeMultipliers: {
            PERFECT: 1.25,
            STRONG: 1.0,
            VALID: 0.75,
            HEATING: 0.5,
            BREWING: 0.25
        },
        
        // Intent multipliers (from J's Bot)
        intentMultipliers: {
            STOP_HUNT: 1.0,             // Normal size for stop hunts
            BREAKOUT: 0.8,              // Slightly smaller for breakouts (can add)
            ABSORPTION: 0.0             // No trade for absorption
        }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 2: CORRELATION FILTER (OVEREXPOSURE PROTECTION)
    // ═══════════════════════════════════════════════════════════════════════════════
    CORRELATION: {
        enabled: true,
        maxSimilarSignals: 3,           // Max signals from same group
        
        // Correlation groups (coins that move together)
        groups: {
            BTC_CORRELATED: ['BTCUSDT'],
            ETH_ECOSYSTEM: ['ETHUSDT', 'OPUSDT', 'ARBUSDT', 'MATICUSDT', 'STXUSDT', 'LDOUSDT'],
            SOL_ECOSYSTEM: ['SOLUSDT', 'JUPUSDT', 'BONKUSDT', 'WIFUSDT', 'RNDRUSDT', 'PYTHUSDT'],
            LAYER1: ['AVAXUSDT', 'DOTUSDT', 'ATOMUSDT', 'NEARUSDT', 'APTUSDT', 'SUIUSDT', 'SEIUSDT', 'INJUSDT'],
            DEFI: ['UNIUSDT', 'AAVEUSDT', 'MKRUSDT', 'SNXUSDT', 'COMPUSDT', 'CRVUSDT', 'SUSHIUSDT', 'DYDXUSDT'],
            AI_TOKENS: ['FETUSDT', 'AGIXUSDT', 'RNDRUSDT', 'WLDUSDT', 'TAOUSDT'],
            MEME: ['DOGEUSDT', 'SHIBUSDT', 'PEPEUSDT', 'BONKUSDT', 'FLOKIUSDT', 'WIFUSDT', 'MEWUSDT', 'BOMEUSDT'],
            GAMING: ['AXSUSDT', 'SANDUSDT', 'MANAUSDT', 'GALAUSDT', 'ENJUSDT', 'ILVUSDT', 'IMXUSDT'],
            OLD_ALTS: ['LTCUSDT', 'BCHUSDT', 'ETCUSDT', 'XLMUSDT', 'XRPUSDT', 'ADAUSDT', 'TRXUSDT'],
            STORAGE: ['FILUSDT', 'ARUSDT', 'STORJUSDT'],
            ORACLES: ['LINKUSDT', 'BANDUSDT', 'API3USDT']
        },
        
        // Alert thresholds
        warningThreshold: 2,            // Warn at 2 similar signals
        blockThreshold: 4               // Block at 4 similar signals
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 3: DRAWDOWN PROTECTION (LOSS STREAK MANAGEMENT)
    // ═══════════════════════════════════════════════════════════════════════════════
    DRAWDOWN: {
        enabled: true,
        
        // Loss streak thresholds
        warningStreak: 2,               // Warn after 2 consecutive losses
        reduceStreak: 3,                // Reduce size after 3 losses
        pauseStreak: 5,                 // Pause trading after 5 losses
        
        // Size reduction multipliers
        reductions: {
            streak3: 0.5,               // 50% size after 3 losses
            streak4: 0.25,              // 25% size after 4 losses
            streak5: 0.0                // Pause (0%) after 5 losses
        },
        
        // Recovery
        recoveryWins: 2,                // Wins needed to reset
        
        // Daily limits
        maxDailyLosses: 5,              // Max losses per day
        maxDailyLossPercent: 5.0,       // Max 5% account loss per day
        
        // Cooldown
        cooldownMinutes: 30,            // Cooldown after hitting limits
        
        // Grade restrictions during drawdown
        minGradeDuringDrawdown: 'STRONG' // Only STRONG+ during drawdown
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 4: INTENT CLASSIFICATION (FROM J's BOT)
    // ═══════════════════════════════════════════════════════════════════════════════
    INTENT: {
        enabled: true,
        
        // SL multipliers by intent
        slMultipliers: {
            STOP_HUNT: 2.2,             // Wider SL - expects wick
            BREAKOUT: 1.8,              // Tighter SL - momentum
            ABSORPTION: null            // No trade
        },
        
        // TP multipliers by intent
        tpMultipliers: {
            STOP_HUNT: 3.5,             // Fade back target
            BREAKOUT: 4.0,              // Ride trend target
            ABSORPTION: null            // No trade
        },
        
        // TP modes
        tpModes: {
            STOP_HUNT: 'LIQUIDITY_TARGET',  // Target opposite liquidity
            BREAKOUT: 'TRAILING',            // Trail with trend
            ABSORPTION: 'NONE'               // No trade
        },
        
        // Entry modes
        entryModes: {
            STOP_HUNT: 'CONFIRMATION',      // Wait for confirmation
            BREAKOUT: 'MOMENTUM',           // Enter on momentum
            ABSORPTION: 'NONE'              // No trade
        }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 5: PATTERN MEMORY (FROM J's BOT)
    // ═══════════════════════════════════════════════════════════════════════════════
    PATTERN_MEMORY: {
        enabled: true,
        minOccurrences: 5,              // Min patterns before using
        minConfidence: 0.6,             // Min 60% success rate to boost
        maxConfidence: 0.9,             // Max 90% confidence boost
        decayDays: 30,                  // Patterns decay after 30 days
        
        // Confidence adjustments
        boostMultiplier: 1.15,          // +15% confidence for good patterns
        penaltyMultiplier: 0.85         // -15% confidence for bad patterns
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 6: COIN PERSONALITY - Each coin behaves differently!
    // ═══════════════════════════════════════════════════════════════════════════════
    COIN_PERSONALITY: {
        enabled: true,
        
        // Pre-defined coin personalities based on historical behavior
        profiles: {
            // === KING - BTC ===
            BTCUSDT: {
                type: 'KING',
                volatility: 'MEDIUM',
                respects_zones: 0.85,       // How well it respects S/R (0-1)
                trend_strength: 0.80,       // How strongly it trends
                fake_breakouts: 0.30,       // How often it fakes breakouts
                best_tf: ['15', '60', '240'], // Best timeframes
                avoid_tf: ['1', '5'],        // Timeframes to avoid
                sl_multiplier: 1.0,         // SL adjustment
                tp_multiplier: 1.0,         // TP adjustment
                min_score: 70,              // Minimum score to trade
                notes: 'Leader - moves first, others follow'
            },
            
            // === MAJORS - High liquidity, predictable ===
            ETHUSDT: {
                type: 'MAJOR',
                volatility: 'MEDIUM',
                respects_zones: 0.80,
                trend_strength: 0.75,
                fake_breakouts: 0.35,
                best_tf: ['15', '60', '240'],
                avoid_tf: ['1', '5'],
                sl_multiplier: 1.0,
                tp_multiplier: 1.0,
                min_score: 70,
                notes: 'Second leader - follows BTC closely'
            },
            BNBUSDT: {
                type: 'MAJOR',
                volatility: 'MEDIUM',
                respects_zones: 0.75,
                trend_strength: 0.70,
                fake_breakouts: 0.40,
                best_tf: ['15', '30', '60'],
                avoid_tf: ['1', '5'],
                sl_multiplier: 1.1,
                tp_multiplier: 1.0,
                min_score: 72,
                notes: 'Exchange coin - manipulated during Binance news'
            },
            SOLUSDT: {
                type: 'MAJOR',
                volatility: 'HIGH',
                respects_zones: 0.65,
                trend_strength: 0.85,
                fake_breakouts: 0.50,
                best_tf: ['15', '30'],
                avoid_tf: ['1', '5', '240'],
                sl_multiplier: 1.3,
                tp_multiplier: 1.2,
                min_score: 75,
                notes: 'High volatility - trends hard, wicks hard'
            },
            XRPUSDT: {
                type: 'MAJOR',
                volatility: 'MEDIUM',
                respects_zones: 0.70,
                trend_strength: 0.60,
                fake_breakouts: 0.45,
                best_tf: ['15', '60'],
                avoid_tf: ['1', '5'],
                sl_multiplier: 1.1,
                tp_multiplier: 1.0,
                min_score: 72,
                notes: 'News driven - SEC lawsuit sensitive'
            },
            
            // === VOLATILE - Higher risk, needs wider SL ===
            DOGEUSDT: {
                type: 'MEME',
                volatility: 'VERY_HIGH',
                respects_zones: 0.50,
                trend_strength: 0.70,
                fake_breakouts: 0.60,
                best_tf: ['15', '30'],
                avoid_tf: ['1', '5', '240', '1D'],
                sl_multiplier: 1.5,
                tp_multiplier: 1.3,
                min_score: 80,
                notes: 'Meme coin - Elon tweets move it, wicks are brutal'
            },
            SHIBUSDT: {
                type: 'MEME',
                volatility: 'VERY_HIGH',
                respects_zones: 0.45,
                trend_strength: 0.65,
                fake_breakouts: 0.65,
                best_tf: ['15', '30'],
                avoid_tf: ['1', '5', '240', '1D'],
                sl_multiplier: 1.6,
                tp_multiplier: 1.4,
                min_score: 82,
                notes: 'Meme coin - follows DOGE, very unpredictable'
            },
            PEPEUSDT: {
                type: 'MEME',
                volatility: 'EXTREME',
                respects_zones: 0.40,
                trend_strength: 0.60,
                fake_breakouts: 0.70,
                best_tf: ['15'],
                avoid_tf: ['1', '5', '60', '240', '1D'],
                sl_multiplier: 1.8,
                tp_multiplier: 1.5,
                min_score: 85,
                notes: 'Extreme meme - only trade with strong confluence'
            },
            
            // === LAYER 1s - Moderate volatility ===
            AVAXUSDT: {
                type: 'LAYER1',
                volatility: 'HIGH',
                respects_zones: 0.65,
                trend_strength: 0.75,
                fake_breakouts: 0.45,
                best_tf: ['15', '30', '60'],
                avoid_tf: ['1', '5'],
                sl_multiplier: 1.2,
                tp_multiplier: 1.1,
                min_score: 73,
                notes: 'Solid L1 - good trends but volatile'
            },
            DOTUSDT: {
                type: 'LAYER1',
                volatility: 'HIGH',
                respects_zones: 0.60,
                trend_strength: 0.70,
                fake_breakouts: 0.50,
                best_tf: ['15', '30', '60'],
                avoid_tf: ['1', '5'],
                sl_multiplier: 1.3,
                tp_multiplier: 1.1,
                min_score: 74,
                notes: 'Parachain ecosystem - news sensitive'
            },
            ADAUSDT: {
                type: 'LAYER1',
                volatility: 'MEDIUM',
                respects_zones: 0.70,
                trend_strength: 0.55,
                fake_breakouts: 0.40,
                best_tf: ['30', '60', '240'],
                avoid_tf: ['1', '5', '15'],
                sl_multiplier: 1.1,
                tp_multiplier: 0.9,
                min_score: 72,
                notes: 'Slow mover - good for swing trades'
            },
            ATOMUSDT: {
                type: 'LAYER1',
                volatility: 'MEDIUM',
                respects_zones: 0.65,
                trend_strength: 0.70,
                fake_breakouts: 0.45,
                best_tf: ['15', '30', '60'],
                avoid_tf: ['1', '5'],
                sl_multiplier: 1.2,
                tp_multiplier: 1.0,
                min_score: 73,
                notes: 'Cosmos ecosystem - moderate behavior'
            },
            NEARUSDT: {
                type: 'LAYER1',
                volatility: 'HIGH',
                respects_zones: 0.60,
                trend_strength: 0.75,
                fake_breakouts: 0.50,
                best_tf: ['15', '30'],
                avoid_tf: ['1', '5'],
                sl_multiplier: 1.3,
                tp_multiplier: 1.2,
                min_score: 75,
                notes: 'AI narrative coin - volatile'
            },
            APTUSDT: {
                type: 'LAYER1',
                volatility: 'HIGH',
                respects_zones: 0.55,
                trend_strength: 0.80,
                fake_breakouts: 0.55,
                best_tf: ['15', '30'],
                avoid_tf: ['1', '5', '240'],
                sl_multiplier: 1.4,
                tp_multiplier: 1.2,
                min_score: 76,
                notes: 'New L1 - trends hard, fake breakouts common'
            },
            SUIUSDT: {
                type: 'LAYER1',
                volatility: 'VERY_HIGH',
                respects_zones: 0.50,
                trend_strength: 0.80,
                fake_breakouts: 0.60,
                best_tf: ['15', '30'],
                avoid_tf: ['1', '5', '240'],
                sl_multiplier: 1.5,
                tp_multiplier: 1.3,
                min_score: 78,
                notes: 'Very new - high volatility, be careful'
            },
            
            // === DEFI - Moderate ===
            LINKUSDT: {
                type: 'DEFI',
                volatility: 'MEDIUM',
                respects_zones: 0.75,
                trend_strength: 0.70,
                fake_breakouts: 0.35,
                best_tf: ['15', '30', '60'],
                avoid_tf: ['1', '5'],
                sl_multiplier: 1.1,
                tp_multiplier: 1.0,
                min_score: 70,
                notes: 'Oracle leader - respects zones well'
            },
            UNIUSDT: {
                type: 'DEFI',
                volatility: 'MEDIUM',
                respects_zones: 0.70,
                trend_strength: 0.65,
                fake_breakouts: 0.40,
                best_tf: ['15', '30', '60'],
                avoid_tf: ['1', '5'],
                sl_multiplier: 1.1,
                tp_multiplier: 1.0,
                min_score: 72,
                notes: 'DEX leader - follows ETH ecosystem'
            },
            AAVEUSDT: {
                type: 'DEFI',
                volatility: 'MEDIUM',
                respects_zones: 0.70,
                trend_strength: 0.65,
                fake_breakouts: 0.40,
                best_tf: ['30', '60'],
                avoid_tf: ['1', '5', '15'],
                sl_multiplier: 1.1,
                tp_multiplier: 1.0,
                min_score: 72,
                notes: 'Lending leader - moderate behavior'
            },
            
            // === STORAGE - AR is here! ===
            ARUSDT: {
                type: 'STORAGE',
                volatility: 'HIGH',
                respects_zones: 0.55,
                trend_strength: 0.70,
                fake_breakouts: 0.55,
                best_tf: ['30', '60'],
                avoid_tf: ['1', '5', '15'],
                sl_multiplier: 1.4,
                tp_multiplier: 1.2,
                min_score: 78,
                notes: 'Storage coin - trends but WICKS HARD, avoid 15m!'
            },
            FILUSDT: {
                type: 'STORAGE',
                volatility: 'HIGH',
                respects_zones: 0.55,
                trend_strength: 0.65,
                fake_breakouts: 0.50,
                best_tf: ['30', '60'],
                avoid_tf: ['1', '5', '15'],
                sl_multiplier: 1.3,
                tp_multiplier: 1.1,
                min_score: 75,
                notes: 'Storage coin - similar to AR'
            },
            
            // === OLD ALTS - More predictable ===
            LTCUSDT: {
                type: 'OLD_ALT',
                volatility: 'LOW',
                respects_zones: 0.80,
                trend_strength: 0.55,
                fake_breakouts: 0.30,
                best_tf: ['60', '240'],
                avoid_tf: ['1', '5', '15'],
                sl_multiplier: 1.0,
                tp_multiplier: 0.9,
                min_score: 68,
                notes: 'Digital silver - slow, predictable'
            },
            ETCUSDT: {
                type: 'OLD_ALT',
                volatility: 'MEDIUM',
                respects_zones: 0.70,
                trend_strength: 0.60,
                fake_breakouts: 0.40,
                best_tf: ['30', '60', '240'],
                avoid_tf: ['1', '5'],
                sl_multiplier: 1.1,
                tp_multiplier: 1.0,
                min_score: 70,
                notes: 'ETH classic - follows ETH with lag'
            },
            XLMUSDT: {
                type: 'OLD_ALT',
                volatility: 'LOW',
                respects_zones: 0.75,
                trend_strength: 0.50,
                fake_breakouts: 0.35,
                best_tf: ['60', '240'],
                avoid_tf: ['1', '5', '15'],
                sl_multiplier: 1.0,
                tp_multiplier: 0.9,
                min_score: 68,
                notes: 'Very slow mover - good for swing only'
            }
        },
        
        // Default profile for unknown coins
        default: {
            type: 'UNKNOWN',
            volatility: 'MEDIUM',
            respects_zones: 0.60,
            trend_strength: 0.65,
            fake_breakouts: 0.50,
            best_tf: ['15', '30', '60'],
            avoid_tf: ['1', '5'],
            sl_multiplier: 1.2,
            tp_multiplier: 1.0,
            min_score: 75,
            notes: 'Unknown coin - use default settings with caution'
        }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 7: ADAPTIVE LEARNING - Learn from your actual trades!
    // ═══════════════════════════════════════════════════════════════════════════════
    ADAPTIVE_LEARNING: {
        enabled: true,
        
        // How many trades before we start adjusting
        minTrades: 10,
        
        // Learning rate (how fast to adjust)
        learningRate: 0.1,
        
        // What we learn per coin
        trackPerCoin: true,
        
        // What we learn per timeframe
        trackPerTF: true,
        
        // What we learn per direction
        trackPerDirection: true,
        
        // Decay old data (days)
        decayDays: 60,
        
        // Auto-adjust thresholds
        autoAdjust: {
            // If win rate < 40% for coin/tf combo, increase min_score
            lowWinRateThreshold: 0.40,
            lowWinRatePenalty: 5,           // Add +5 to min score
            
            // If win rate > 70% for coin/tf combo, decrease min_score
            highWinRateThreshold: 0.70,
            highWinRateBonus: -3,            // Reduce min score by 3
            
            // If avg loss > avg win, widen SL
            lossRatioThreshold: 1.2,
            slAdjustment: 0.1               // Add 10% to SL multiplier
        }
    }
};

// MERGE CONFIG_EXTENDED into CONFIG for backwards compatibility
Object.assign(CONFIG, CONFIG_EXTENDED);

// ═══════════════════════════════════════════════════════════════════════════════
// 🧠 INTELLIGENT BRAIN STATE
// ═══════════════════════════════════════════════════════════════════════════════

const BRAIN_STATE = {
    // Drawdown tracking
    drawdown: {
        consecutiveLosses: 0,
        consecutiveWins: 0,
        dailyLosses: 0,
        dailyLossPercent: 0,
        lastLossTime: null,
        isPaused: false,
        pausedUntil: null,
        lastResetDate: null
    },
    
    // Pattern memory database
    patternDB: [],
    
    // Correlation tracking
    activeSignals: [],
    groupCounts: {},
    
    // Trade history for learning
    tradeHistory: []
};

// ═══════════════════════════════════════════════════════════════════════════════
// V5.1 SELF-LEARNING ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

const LEARNING_STATE = {
    patternMemory: {},      // Pattern key -> {wins, losses, total}
    optimalSettings: null,  // Optimized settings per TF
    lastOptimized: null,    // Timestamp
    backtestResults: {}     // Cache
};

const SelfLearning = {
    // Initialize from localStorage
    init() {
        try {
            const saved = localStorage.getItem('bsv5_learning');
            if (saved) {
                const data = JSON.parse(saved);
                LEARNING_STATE.patternMemory = data.patternMemory || {};
                LEARNING_STATE.optimalSettings = data.optimalSettings || null;
                LEARNING_STATE.lastOptimized = data.lastOptimized || null;
            }
            console.log('🧠 Self-Learning initialized:', Object.keys(LEARNING_STATE.patternMemory).length, 'patterns');
        } catch (e) {
            // Silent: Learning init
        }
    },
    
    // Save to localStorage
    save() {
        try {
            localStorage.setItem('bsv5_learning', JSON.stringify(LEARNING_STATE));
        } catch (e) { /* Silent */ }
    },
    
    // Create pattern key from signal
    createPatternKey(signal) {
        const tf = signal.tfRaw || signal.tf;
        const dir = signal.direction;
        const zBucket = Math.floor((signal.scores?.zone || 0) / 20) * 20;
        const sBucket = Math.floor((signal.scores?.smc || 0) / 20) * 20;
        return `${tf}_${dir}_Z${zBucket}_S${sBucket}`;
    },
    
    // Get adjustment for signal BEFORE firing
    getAdjustment(signal) {
        if (!CONFIG.LEARNING.ENABLED) return { adj: 0, confidence: 'N/A', winRate: 0, total: 0 };
        
        const key = this.createPatternKey(signal);
        const pattern = LEARNING_STATE.patternMemory[key];
        
        if (!pattern || pattern.total < CONFIG.LEARNING.MIN_PATTERNS) {
            return { adj: 0, confidence: 'LOW', winRate: 0, total: pattern?.total || 0 };
        }
        
        const winRate = pattern.wins / pattern.total;
        let adj = 0, confidence = 'MEDIUM';
        
        if (winRate >= CONFIG.LEARNING.HIGH_WIN_RATE && pattern.total >= 25) {
            adj = CONFIG.LEARNING.CONFIDENCE_BOOST;
            confidence = 'HIGH';
        } else if (winRate >= 0.55) {
            adj = 5;
            confidence = 'MEDIUM';
        } else if (winRate < CONFIG.LEARNING.LOW_WIN_RATE) {
            adj = -CONFIG.LEARNING.CONFIDENCE_PENALTY;
            confidence = 'LOW';
        }
        
        return { 
            adj, 
            confidence, 
            winRate: Math.round(winRate * 100), 
            total: pattern.total,
            key
        };
    },
    
    // Record trade outcome
    recordOutcome(signal, isWin) {
        const key = this.createPatternKey(signal);
        if (!LEARNING_STATE.patternMemory[key]) {
            LEARNING_STATE.patternMemory[key] = { wins: 0, losses: 0, total: 0 };
        }
        
        LEARNING_STATE.patternMemory[key].total++;
        if (isWin) LEARNING_STATE.patternMemory[key].wins++;
        else LEARNING_STATE.patternMemory[key].losses++;
        
        this.save();
        console.log(`🧠 Pattern recorded: ${key} = ${isWin ? 'WIN' : 'LOSS'}`);
    },
    
    // Get stats for display
    getStats() {
        const patterns = Object.keys(LEARNING_STATE.patternMemory).length;
        const totalTrades = Object.values(LEARNING_STATE.patternMemory)
            .reduce((sum, p) => sum + p.total, 0);
        const totalWins = Object.values(LEARNING_STATE.patternMemory)
            .reduce((sum, p) => sum + p.wins, 0);
        const avgWinRate = totalTrades > 0 ? Math.round((totalWins / totalTrades) * 100) : 0;
        
        return { patterns, totalTrades, totalWins, avgWinRate };
    },
    
    // Apply learning adjustment to score
    applyToScore(signal) {
        if (!CONFIG.LEARNING.ENABLED) return signal.score;
        
        const learning = this.getAdjustment(signal);
        signal.learning = learning;
        
        let adjustedScore = signal.score + learning.adj;
        adjustedScore = Math.max(0, Math.min(100, adjustedScore));
        
        return adjustedScore;
    }
};

// Initialize learning on load
setTimeout(() => SelfLearning.init(), 100);

// ═══════════════════════════════════════════════════════════════════════════════
// STATE MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════════
// MULTI-AI PROVIDER SYSTEM (v13 UPGRADE)
// ═══════════════════════════════════════════════════════════════════════════════

// Groq API Keys (5 keys for rotation) - Add your keys in Settings
const GROQ_KEYS = [
    '', // Add your Groq key in Settings
    '',
    '',
    '',
    ''
];

// DeepSeek API Keys (paid - best value)
const DEEPSEEK_KEYS = [
    '', // Add your DeepSeek key in Settings
];

// Gemini API Keys (free backup)
const GEMINI_KEYS = [
    '', // Add your Gemini key in Settings
    '',
    '',
    '',
    ''
];

// KEY ENABLED STATE (ON/OFF toggles)
const KEY_ENABLED = {
    groq: [true, true, true, true, true],
    deepseek: [true],
    gemini: [true, true, true, true, true]
};

// KEY STATUS (null=untested, true=working, false=failed)
const KEY_STATUS = {
    groq: [null, null, null, null, null],
    deepseek: [null],
    gemini: [null, null, null, null, null]
};

let currentGroqKeyIndex = 0;
let currentDeepSeekKeyIndex = 0;
let currentGeminiKeyIndex = 0;

// Get next API key with rotation (respects ON/OFF toggles)
function getNextGroqKey() {
    const validKeys = GROQ_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.groq[item.index]);
    if (validKeys.length === 0) return null;
    const item = validKeys[currentGroqKeyIndex % validKeys.length];
    console.log(`🔑 Using Groq Key #${item.index + 1} (${currentGroqKeyIndex % validKeys.length + 1}/${validKeys.length})`);
    currentGroqKeyIndex++;
    return item.key;
}

function getNextDeepSeekKey() {
    const validKeys = DEEPSEEK_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.deepseek[item.index]);
    if (validKeys.length === 0) return null;
    const item = validKeys[currentDeepSeekKeyIndex % validKeys.length];
    console.log(`🔑 Using DeepSeek Key #${item.index + 1}`);
    currentDeepSeekKeyIndex++;
    return item.key;
}

function getNextGeminiKey() {
    const validKeys = GEMINI_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.gemini[item.index]);
    if (validKeys.length === 0) return null;
    const item = validKeys[currentGeminiKeyIndex % validKeys.length];
    console.log(`🔑 Using Gemini Key #${item.index + 1} (${currentGeminiKeyIndex % validKeys.length + 1}/${validKeys.length})`);
    currentGeminiKeyIndex++;
    return item.key;
}

// Legacy support
const API_KEYS = GROQ_KEYS;
let currentKeyIndex = 0;

// Get next API key (round-robin rotation) - Legacy support
function getNextAPIKey() {
    return getNextGroqKey() || API_KEYS[0];
}

const DEFAULT_KEY = '';

const STATE = {
    mode: 'ALL',
    filter: 'all',
    statsFilter: 'all',  // Stats bar filter: 'all', 'perfect', 'long', 'short', 'agree3'
    view: 'list',  // 'list' or 'heatmap'
    scanning: false,
    scanInProgress: false,  // SAFETY: Lock to prevent concurrent scans
    aiCallInProgress: false,  // SAFETY: Lock to prevent concurrent AI calls
    signals: [],
    previousSignals: [],  // For tracking changes (⬆️⬇️🆕💀)
    selected: null,
    current: null,
    aiResult: null,
    trades: [],
    savedTrades: [],  // 💾 Saved trades for later reference
    signalHistory: [],  // Track TP/SL hits
    btc: { price: 0, change: 0 },
    // Market data for badges
    fearGreed: null,
    dxy: null,
    funding: null,
    btcDominance: null,
    btcDomTrend: 'flat',
    altSeasonScore: 50,
    aiKey: DEFAULT_KEY,
    aiModel: 'llama-3.3-70b-versatile',
    // v13 Multi-AI Keys
    deepseekKey: '',
    geminiKey: '',
    scanProgress: { current: 0, total: 0, coin: '', tf: '' },
    // Timeframe toggles
    tfEnabled: {
        '5': true,
        '15': true,
        '30': true,
        '60': true,
        '240': true,
        'D': true
    },
    // Alert settings
    alertSound: true,
    alertVibrate: false,
    alertGrade: 'BREWING',
    // Telegram settings
    telegramEnabled: false,
    telegramToken: '',
    telegramChatId: '',
    // Scan interval (ms)
    scanInterval: 300000,  // 5 minutes default
    // AI expanded state
    aiExpanded: false,
    // AI Display Mode: 'detailed' (13 sections) or 'compact' (6 sections)
    aiDisplayMode: 'detailed',
    // Risk management
    riskAccount: 1000,
    riskPercent: 2,
    riskLeverage: 10,
    riskMaxPosition: 500,
    // Theme
    oledTheme: false,
    // Custom coins (if modified)
    customCoins: null,
    coinCount: 50,
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🛡️ PROFESSIONAL HARDENING - 5 Critical Fixes
    // ═══════════════════════════════════════════════════════════════════════════════
    hardening: {
        // FIX 1: LIVE SIGNAL LOGGING - Track every signal outcome
        signalLog: [],                    // Array of { signal, outcome, timestamp }
        signalLogMax: 500,                // Keep last 500 signals
        
        // FIX 2: REGIME COOLDOWN - Prevent whipsaw
        regime: {
            current: 'UNKNOWN',           // TRENDING, RANGING, VOLATILE, UNKNOWN
            lastChange: 0,                // Timestamp of last regime change
            cooldownCandles: 5,           // Don't flip for N candles
            candlesSinceChange: 0,        // Counter
            locked: false                 // True if in cooldown
        },
        
        // FIX 3: MEMORY CLEANUP - Prevent memory bloat
        cleanup: {
            lastCleanup: Date.now(),
            cleanupInterval: 300000,      // Clean every 5 minutes
            maxSignals: 200,              // Max signals in memory
            maxTrades: 100                // Max trades in memory
        },
        
        // FIX 4: ERROR RETRY LIMIT - Pause on repeated failures
        errors: {
            consecutive: 0,               // Consecutive API failures
            maxConsecutive: 5,            // Pause after 5 failures
            paused: false,                // True if scanning paused
            pausedAt: 0,                  // When paused
            pauseDuration: 60000,         // Pause for 1 minute
            totalErrors: 0,               // Total errors this session
            lastError: null               // Last error message
        },
        
        // FIX 5: ASYNC MUTEX - Proper scan locking
        mutex: {
            scanLock: false,              // Hard lock for scanning
            scanLockTime: 0,              // When lock was acquired
            scanLockTimeout: 120000,      // Force unlock after 2 minutes
            queuedScans: 0,               // Scans waiting
            lastScanComplete: 0           // When last scan finished
        }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // ENVIRONMENT SYSTEM STATE
    // ═══════════════════════════════════════════════════════════════════════════════
    environment: {
        // Layer 1: Macro
        dxy: { value: 0, trend: 'FLAT', favorable: null },       // null = unknown
        btcTrend: { direction: 'FLAT', strength: 0 },
        btcDominance: { value: 0, trend: 'FLAT' },
        
        // Layer 2: BTC Health
        btcStructure: { status: 'UNKNOWN', score: 0 },          // INTACT, BROKEN, UNKNOWN
        btcRSI: { value: 50, status: 'HEALTHY' },               // HEALTHY, OVERBOUGHT, OVERSOLD
        
        // Layer 3: Leverage
        funding: { rate: 0, status: 'NORMAL' },                 // NORMAL, ELEVATED, EXTREME
        
        // Layer 4: Verdict
        score: 50,
        verdict: 'UNKNOWN',                                      // GO, CAUTION, RISKY, NO-GO
        favoredDirection: null,                                  // LONG, SHORT, or null
        
        // Timestamps
        lastUpdate: null,
        isStale: false
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🔥 PHASE 1: TOP TIER LIVE DATA STATE
    // ═══════════════════════════════════════════════════════════════════════════════
    liveData: {
        // WebSocket connection status
        wsConnected: false,
        wsReconnectAttempts: 0,
        wsLastHeartbeat: null,
        
        // Liquidation tracking
        liquidations: {
            recent: [],              // Last 100 liquidations
            longTotal5m: 0,          // Long liqs in last 5 min
            shortTotal5m: 0,         // Short liqs in last 5 min
            longTotal15m: 0,         // Long liqs in last 15 min
            shortTotal15m: 0,        // Short liqs in last 15 min
            bias: 'NEUTRAL',         // BULLISH (shorts rekt), BEARISH (longs rekt), NEUTRAL
            biasStrength: 0,         // 0-100
            cascadeDetected: false,  // True if big cascade happening
            lastBigLiq: null,        // Last liquidation > $500K
            byCoin: {}               // Per-coin liquidation data
        },
        
        // Open Interest tracking
        openInterest: {
            btc: { current: 0, change5m: 0, change1h: 0, trend: 'FLAT' },
            eth: { current: 0, change5m: 0, change1h: 0, trend: 'FLAT' },
            total: { current: 0, change5m: 0, change1h: 0, trend: 'FLAT' },
            byCoin: {},
            lastUpdate: null
        },
        
        // Whale/Large trade tracking
        whales: {
            recent: [],              // Last 50 whale trades
            buyVolume5m: 0,          // Buy volume in last 5 min
            sellVolume5m: 0,         // Sell volume in last 5 min
            bias: 'NEUTRAL',         // BUYING, SELLING, NEUTRAL
            lastWhale: null,         // Last whale trade
            alertQueue: [],          // Pending whale alerts
            threshold: 100000        // $100K minimum for whale
        },
        
        // Funding rate tracking
        funding: {
            btc: { rate: 0, predicted: 0, countdown: '', nextTime: null },
            eth: { rate: 0, predicted: 0, countdown: '', nextTime: null },
            average: 0,              // Average funding across top coins
            extremeCoins: [],        // Coins with extreme funding
            byCoin: {},
            lastUpdate: null
        }
    },
    
    // Filtered signals count
    filteredSignals: [],
    filteredCount: 0,
    showFiltered: false,
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 INTELLIGENT BRAIN STATE (v3 - 100% Intelligence)
    // ═══════════════════════════════════════════════════════════════════════════════
    brain: {
        // Drawdown tracking
        consecutiveLosses: 0,
        consecutiveWins: 0,
        dailyLosses: 0,
        dailyLossPercent: 0,
        lastLossTime: null,
        isPaused: false,
        pausedUntil: null,
        lastResetDate: new Date().toDateString(),
        
        // Active correlation tracking
        activeSignalGroups: {},
        
        // Pattern memory (persisted to localStorage)
        patternDB: [],
        
        // Trade history for learning
        tradeResults: []
    },
    
    // Trade history for P&L tracking
    tradeHistory: []
};

// ═══════════════════════════════════════════════════════════════════════════════
// UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

// BUG FIX #1: Safe DOM element text setter - prevents crash if element doesn't exist
function safeSetText(id, text) {
    const el = document.getElementById(id);
    if (el) el.textContent = text;
}

// BUG FIX #1: Safe DOM element HTML setter
function safeSetHTML(id, html) {
    const el = document.getElementById(id);
    if (el) el.innerHTML = html;
}

// BUG FIX #1: Safe DOM class operations
function safeAddClass(id, className) {
    const el = document.getElementById(id);
    if (el) el.classList.add(className);
}

function safeRemoveClass(id, className) {
    const el = document.getElementById(id);
    if (el) el.classList.remove(className);
}

function safeSetStyle(id, prop, value) {
    const el = document.getElementById(id);
    if (el) el.style[prop] = value;
}

// BUG FIX #2: Safe localStorage operations - prevents crash in private mode or when full
function safeStorageSet(key, value) {
    try {
        localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));
        return true;
    } catch (e) {
        console.warn('⚠️ localStorage.setItem failed:', key, e.message);
        return false;
    }
}

function safeStorageGet(key, defaultValue = null) {
    try {
        const item = localStorage.getItem(key);
        if (item === null) return defaultValue;
        try {
            return JSON.parse(item);
        } catch {
            return item; // Return as string if not JSON
        }
    } catch (e) {
        console.warn('⚠️ localStorage.getItem failed:', key, e.message);
        return defaultValue;
    }
}

function safeStorageRemove(key) {
    try {
        localStorage.removeItem(key);
        return true;
    } catch (e) {
        console.warn('⚠️ localStorage.removeItem failed:', key, e.message);
        return false;
    }
}

function toast(msg, type = '') {
    const box = document.getElementById('toastBox');
    if (!box) return; // BUG FIX #1: Null check
    const t = document.createElement('div');
    t.className = 'toast ' + type;
    t.textContent = msg;
    box.appendChild(t);
    setTimeout(() => t.remove(), 3500);
}

function fmtPrice(p) {
    if (!p || isNaN(p)) return '0';
    if (p >= 1000) return p.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    if (p >= 1) return p.toFixed(4);
    if (p >= 0.001) return p.toFixed(6);
    return p.toFixed(8);
}

function fmtPct(p) {
    // FIX: Add null/undefined check
    if (p === null || p === undefined || isNaN(p)) return '+0.00%';
    return (p >= 0 ? '+' : '') + p.toFixed(2) + '%';
}

function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

function scoreColor(s) {
    if (s >= 70) return 'var(--long)';
    if (s >= 50) return 'var(--amber)';
    return 'var(--short)';
}

function scoreClass(s) {
    if (s >= 70) return 'good';
    if (s >= 50) return 'mid';
    return 'low';
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🛡️ PROFESSIONAL HARDENING MODULE - 5 Critical Production Fixes
// ═══════════════════════════════════════════════════════════════════════════════

const Hardening = {
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX 1: LIVE SIGNAL LOGGING - Track every signal outcome for forward testing
    // ═══════════════════════════════════════════════════════════════════════════
    logSignal(signal, coin, tf) {
        if (!signal || !STATE.hardening) return;
        
        const logEntry = {
            id: `${coin}_${tf}_${Date.now()}`,
            timestamp: Date.now(),
            coin,
            tf,
            direction: signal.direction,
            score: signal.score,
            entry: signal.entry,
            sl: signal.levels?.sl,
            tp: signal.levels?.tp,
            grade: signal.grade,
            regime: STATE.hardening.regime.current,
            // Outcome tracking (filled later)
            outcome: null,           // 'TP_HIT', 'SL_HIT', 'TIMEOUT', 'CANCELLED'
            outcomeTime: null,
            actualPnl: null,
            mae: null,               // Maximum Adverse Excursion
            mfe: null                // Maximum Favorable Excursion
        };
        
        STATE.hardening.signalLog.unshift(logEntry);
        
        // Keep only last N signals
        if (STATE.hardening.signalLog.length > STATE.hardening.signalLogMax) {
            STATE.hardening.signalLog = STATE.hardening.signalLog.slice(0, STATE.hardening.signalLogMax);
        }
        
        // Save to localStorage
        this.saveSignalLog();
        
        return logEntry.id;
    },
    
    updateSignalOutcome(signalId, outcome, pnl, mae = null, mfe = null) {
        if (!STATE.hardening) return;
        
        const signal = STATE.hardening.signalLog.find(s => s.id === signalId);
        if (signal) {
            signal.outcome = outcome;
            signal.outcomeTime = Date.now();
            signal.actualPnl = pnl;
            signal.mae = mae;
            signal.mfe = mfe;
            this.saveSignalLog();
        }
    },
    
    getSignalStats() {
        if (!STATE.hardening?.signalLog) return null;
        
        const completed = STATE.hardening.signalLog.filter(s => s.outcome);
        if (completed.length === 0) return { total: 0, message: 'No completed signals yet' };
        
        const wins = completed.filter(s => s.outcome === 'TP_HIT').length;
        const losses = completed.filter(s => s.outcome === 'SL_HIT').length;
        const winRate = ((wins / completed.length) * 100).toFixed(1);
        const totalPnl = completed.reduce((sum, s) => sum + (s.actualPnl || 0), 0);
        
        // By regime
        const byRegime = {};
        for (const s of completed) {
            if (!byRegime[s.regime]) byRegime[s.regime] = { wins: 0, total: 0 };
            byRegime[s.regime].total++;
            if (s.outcome === 'TP_HIT') byRegime[s.regime].wins++;
        }
        
        return {
            total: STATE.hardening.signalLog.length,
            completed: completed.length,
            wins,
            losses,
            winRate,
            totalPnl: totalPnl.toFixed(2),
            byRegime
        };
    },
    
    saveSignalLog() {
        try {
            const toSave = STATE.hardening.signalLog.slice(0, 200); // Save last 200
            localStorage.setItem('hardeningSignalLog', JSON.stringify(toSave));
        } catch (e) { /* Storage full, ignore */ }
    },
    
    loadSignalLog() {
        try {
            const saved = localStorage.getItem('hardeningSignalLog');
            if (saved && STATE.hardening) {
                STATE.hardening.signalLog = JSON.parse(saved);
            }
        } catch (e) { /* Ignore */ }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX 2: REGIME COOLDOWN - Prevent whipsaw on regime changes
    // ═══════════════════════════════════════════════════════════════════════════
    updateRegime(newRegime) {
        if (!STATE.hardening?.regime) return;
        
        const regime = STATE.hardening.regime;
        
        // If same regime, just increment counter
        if (newRegime === regime.current) {
            regime.candlesSinceChange++;
            regime.locked = false;
            return true;
        }
        
        // If trying to change during cooldown, block it
        if (regime.locked && regime.candlesSinceChange < regime.cooldownCandles) {
            regime.candlesSinceChange++;
            console.log(`🛡️ Regime change blocked: ${regime.current} → ${newRegime} (cooldown ${regime.candlesSinceChange}/${regime.cooldownCandles})`);
            return false;
        }
        
        // Allow regime change
        console.log(`🔄 Regime change: ${regime.current} → ${newRegime}`);
        regime.current = newRegime;
        regime.lastChange = Date.now();
        regime.candlesSinceChange = 0;
        regime.locked = true;
        
        return true;
    },
    
    getRegime() {
        return STATE.hardening?.regime?.current || 'UNKNOWN';
    },
    
    isRegimeLocked() {
        if (!STATE.hardening?.regime) return false;
        const r = STATE.hardening.regime;
        return r.locked && r.candlesSinceChange < r.cooldownCandles;
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX 3: MEMORY CLEANUP - Prevent memory bloat on long sessions
    // ═══════════════════════════════════════════════════════════════════════════
    cleanup() {
        if (!STATE.hardening?.cleanup) return;
        
        const cfg = STATE.hardening.cleanup;
        const now = Date.now();
        
        // Only cleanup every N ms
        if (now - cfg.lastCleanup < cfg.cleanupInterval) return;
        
        console.log('🧹 Running memory cleanup...');
        cfg.lastCleanup = now;
        
        // Trim signals array
        if (STATE.signals && STATE.signals.length > cfg.maxSignals) {
            STATE.signals = STATE.signals.slice(0, cfg.maxSignals);
        }
        
        // Trim trades array
        if (STATE.trades && STATE.trades.length > cfg.maxTrades) {
            STATE.trades = STATE.trades.slice(0, cfg.maxTrades);
        }
        
        // Trim previous signals
        if (STATE.previousSignals && STATE.previousSignals.length > cfg.maxSignals) {
            STATE.previousSignals = STATE.previousSignals.slice(0, cfg.maxSignals);
        }
        
        // Trim signal log
        if (STATE.hardening.signalLog && STATE.hardening.signalLog.length > STATE.hardening.signalLogMax) {
            STATE.hardening.signalLog = STATE.hardening.signalLog.slice(0, STATE.hardening.signalLogMax);
        }
        
        // Force garbage collection hint
        if (window.gc) window.gc();
        
        console.log('🧹 Cleanup complete');
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX 4: ERROR RETRY LIMIT - Pause scanning on repeated API failures
    // ═══════════════════════════════════════════════════════════════════════════
    recordError(errorMsg) {
        if (!STATE.hardening?.errors) return false;
        
        const err = STATE.hardening.errors;
        err.consecutive++;
        err.totalErrors++;
        err.lastError = errorMsg;
        
        console.warn(`⚠️ API Error (${err.consecutive}/${err.maxConsecutive}): ${errorMsg}`);
        
        // Pause if too many consecutive errors
        if (err.consecutive >= err.maxConsecutive && !err.paused) {
            err.paused = true;
            err.pausedAt = Date.now();
            console.error(`🛑 SCANNING PAUSED: ${err.consecutive} consecutive errors. Will resume in ${err.pauseDuration/1000}s`);
            toast(`Scanning paused: API errors`, 'error');
            return true; // Indicates pause was triggered
        }
        
        return false;
    },
    
    recordSuccess() {
        if (!STATE.hardening?.errors) return;
        STATE.hardening.errors.consecutive = 0; // Reset on success
    },
    
    canScan() {
        if (!STATE.hardening?.errors) return true;
        
        const err = STATE.hardening.errors;
        
        // If not paused, can scan
        if (!err.paused) return true;
        
        // Check if pause duration has passed
        const elapsed = Date.now() - err.pausedAt;
        if (elapsed >= err.pauseDuration) {
            err.paused = false;
            err.consecutive = 0;
            console.log('✅ Scanning resumed after pause');
            return true;
        }
        
        return false;
    },
    
    getErrorStats() {
        if (!STATE.hardening?.errors) return null;
        const e = STATE.hardening.errors;
        return {
            consecutive: e.consecutive,
            total: e.totalErrors,
            paused: e.paused,
            lastError: e.lastError,
            resumeIn: e.paused ? Math.max(0, e.pauseDuration - (Date.now() - e.pausedAt)) : 0
        };
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX 5: ASYNC MUTEX - Proper scan locking to prevent race conditions
    // ═══════════════════════════════════════════════════════════════════════════
    async acquireScanLock(timeout = 5000) {
        if (!STATE.hardening?.mutex) return true; // No hardening, allow
        
        const mutex = STATE.hardening.mutex;
        const startWait = Date.now();
        
        // Wait for lock to be released
        while (mutex.scanLock) {
            // Check for stale lock (force release after timeout)
            if (Date.now() - mutex.scanLockTime > mutex.scanLockTimeout) {
                console.warn('🔓 Force releasing stale scan lock');
                mutex.scanLock = false;
                break;
            }
            
            // Check if we've waited too long
            if (Date.now() - startWait > timeout) {
                console.warn('⏰ Scan lock timeout - scan queued');
                mutex.queuedScans++;
                return false;
            }
            
            // Wait a bit before retry
            await new Promise(r => setTimeout(r, 100));
        }
        
        // Acquire lock
        mutex.scanLock = true;
        mutex.scanLockTime = Date.now();
        return true;
    },
    
    releaseScanLock() {
        if (!STATE.hardening?.mutex) return;
        
        const mutex = STATE.hardening.mutex;
        mutex.scanLock = false;
        mutex.lastScanComplete = Date.now();
        
        // Process queued scans
        if (mutex.queuedScans > 0) {
            mutex.queuedScans--;
        }
    },
    
    isScanLocked() {
        return STATE.hardening?.mutex?.scanLock || false;
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // MASTER INIT - Call on app start
    // ═══════════════════════════════════════════════════════════════════════════
    init() {
        console.log('🛡️ Professional Hardening module initialized');
        this.loadSignalLog();
        
        // Run cleanup every minute
        setInterval(() => this.cleanup(), 60000);
    }
};

// Initialize hardening on load
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => Hardening.init(), 2000);
});

// ═══════════════════════════════════════════════════════════════════════════════
// API FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

async function fetchJSON(url, retries = 0) {
    const timeout = CONFIG.SAFETY?.API_TIMEOUT_MS || 10000;
    const maxRetries = CONFIG.SAFETY?.MAX_RETRIES || 3;
    
    try {
        // Use Promise.race for timeout (avoids AbortSignal cloning issues)
        const fetchPromise = fetch(url);
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), timeout)
        );
        
        const r = await Promise.race([fetchPromise, timeoutPromise]);
        
        // BUG FIX #7: Handle Bybit rate limiting (429)
        if (r.status === 429) {
            if (retries < maxRetries) {
                // Longer backoff for rate limits
                await sleep(2000 * (retries + 1));
                return fetchJSON(url, retries + 1);
            }
            return null;
        }
        
        // BUG FIX #7: Handle other API errors
        if (r.status === 403 || r.status === 401) {
            return null;
        }
        
        if (r.ok) return await r.json();
    } catch (e) {
        // Silent timeout handling
    }
    
    // Retry logic
    if (retries < maxRetries) {
        await sleep(500 * (retries + 1));  // Exponential backoff
        return fetchJSON(url, retries + 1);
    }
    
    // Fallback to proxy (last resort)
    try {
        const fetchPromise = fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(url));
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), timeout)
        );
        
        const r2 = await Promise.race([fetchPromise, timeoutPromise]);
        
        if (r2.ok) return await r2.json();
    } catch (e2) { 
        // Silently ignore CORS proxy errors
    }
    
    return null;
}

// ═══════════════════════════════════════════════════════════════════════════════
// BINANCE FUTURES API - 1500 CANDLES + PAGINATION FOR MORE HISTORY
// ═══════════════════════════════════════════════════════════════════════════════

// TF mapping: Internal -> Binance
const BYBIT_TF = {
    '5': '5',
    '15': '15',
    '30': '30',
    '60': '60',
    '240': '240',
    'D': 'D'
};

// Fetch klines with pagination support - BYBIT V5 API
async function fetchKlines(symbol, tf, limit = 200) {
    try {
        const bybitTf = BYBIT_TF[tf] || '15';
        
        // If requesting more than 1000, use pagination (Bybit limit is 1000)
        if (limit > 1000) {
            return await fetchKlinesPaginated(symbol, bybitTf, limit);
        }
        
        // Single call for smaller requests
        limit = Math.min(limit, 1000);
        const url = `${CONFIG.BYBIT_V5}/market/kline?category=linear&symbol=${symbol}&interval=${bybitTf}&limit=${limit}`;
        
        // Simple fetch with Promise.race for timeout (avoids AbortSignal cloning issues)
        const fetchPromise = fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });
        
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 10000)
        );
        
        const response = await Promise.race([fetchPromise, timeoutPromise]);
        
        if (!response.ok) {
            return await fetchKlinesSecondary(symbol, tf, Math.min(limit, 1000));
        }
        
        const data = await response.json();
        
        if (data && data.retCode === 0 && data.result && data.result.list && data.result.list.length > 0) {
            // Bybit V5 format: [startTime, open, high, low, close, volume, turnover]
            // Note: Bybit returns newest first, so we need to reverse
            const klines = data.result.list.map(k => ({
                time: parseInt(k[0]),
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
            })).reverse(); // Reverse to get oldest first
            
            return klines;
        }
        
        return await fetchKlinesSecondary(symbol, tf, Math.min(limit, 1000));
        
    } catch (e) {
        // Silent fail - avoid console spam
        return await fetchKlinesSecondary(symbol, tf, Math.min(limit, 1000));
    }
}

// Paginated fetch for extended history (up to 6000 candles = 6 calls for Bybit)
async function fetchKlinesPaginated(symbol, bybitTf, totalLimit) {
    try {
        const maxPerCall = 1000; // Bybit limit is 1000 per call
        const numCalls = Math.min(Math.ceil(totalLimit / maxPerCall), 6); // Max 6 calls for 6000 candles
        
        let allKlines = [];
        let endTime = Date.now();
        
        for (let i = 0; i < numCalls; i++) {
            const url = `${CONFIG.BYBIT_V5}/market/kline?category=linear&symbol=${symbol}&interval=${bybitTf}&limit=${maxPerCall}&end=${endTime}`;
            
            const response = await fetch(url);
            if (!response.ok) break;
            
            const data = await response.json();
            if (!data || data.retCode !== 0 || !data.result || !data.result.list || data.result.list.length === 0) break;
            
            // Bybit V5 format: [startTime, open, high, low, close, volume, turnover]
            const klines = data.result.list.map(k => ({
                time: parseInt(k[0]),
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
            }));
            
            // Bybit returns newest first, so we reverse and prepend
            allKlines = [...klines.reverse(), ...allKlines];
            
            // Set endTime to oldest candle for next batch (Bybit uses 'end' parameter)
            endTime = parseInt(data.result.list[data.result.list.length - 1][0]) - 1;
            
            // Small delay to avoid rate limits
            await new Promise(r => setTimeout(r, 150));
        }
        
        // Sort by time and remove duplicates
        allKlines.sort((a, b) => a.time - b.time);
        
        // Remove duplicates based on time
        const seen = new Set();
        allKlines = allKlines.filter(k => {
            if (seen.has(k.time)) return false;
            seen.add(k.time);
            return true;
        });
        
        console.log(`Bybit paginated: ${symbol} ${bybitTf} = ${allKlines.length} candles`);
        
        return allKlines.length > 0 ? allKlines : null;
        
    } catch (e) {
        // Silent fail
        return null;
    }
}

// Secondary fetch function - backup using same Bybit API
async function fetchKlinesSecondary(symbol, tf, limit = 200) {
    // This is a backup in case main fetch fails
    try {
        const bybitTf = BYBIT_TF[tf] || '15';
        limit = Math.min(limit, 1000);
        const url = `${CONFIG.BYBIT_V5}/market/kline?category=linear&symbol=${symbol}&interval=${bybitTf}&limit=${limit}`;
        
        // Simple fetch with Promise.race for timeout
        const fetchPromise = fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });
        
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 8000)
        );
        
        const response = await Promise.race([fetchPromise, timeoutPromise]);
        
        if (!response.ok) return null;
        const data = await response.json();
        if (data && data.retCode === 0 && data.result && data.result.list && data.result.list.length > 0) {
            return data.result.list.map(k => ({
                time: parseInt(k[0]),
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
            })).reverse();
        }
        return null;
    } catch (e) {
        // Silently fail - don't spam console
        return null;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🧠🧠🧠 INTELLIGENT BRAIN MODULE v1.0 - 100% INTELLIGENCE 🧠🧠🧠
// ═══════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 BRAIN 1: AUTO POSITION SIZING BY VOLATILITY
// ─────────────────────────────────────────────────────────────────────────────────

function getVolatilityCategory(atr, currentPrice) {
    if (!atr || !currentPrice || currentPrice === 0) {
        return { category: 'NORMAL', multiplier: 1.0, atrPercent: 0, description: 'Unknown', icon: '❓' };
    }
    
    const atrPercent = (atr / currentPrice) * 100;
    const cfg = CONFIG.VOLATILITY_SIZING;
    
    if (atrPercent <= cfg.atrLow) {
        return {
            category: 'LOW',
            multiplier: cfg.multipliers.LOW,
            atrPercent: atrPercent.toFixed(2),
            description: 'Calm market - can size up',
            icon: '😴'
        };
    } else if (atrPercent <= cfg.atrNormal) {
        return {
            category: 'NORMAL',
            multiplier: cfg.multipliers.NORMAL,
            atrPercent: atrPercent.toFixed(2),
            description: 'Normal conditions',
            icon: '✅'
        };
    } else if (atrPercent <= cfg.atrHigh) {
        return {
            category: 'HIGH',
            multiplier: cfg.multipliers.HIGH,
            atrPercent: atrPercent.toFixed(2),
            description: 'Volatile - reduce size',
            icon: '⚠️'
        };
    } else {
        return {
            category: 'EXTREME',
            multiplier: cfg.multipliers.EXTREME,
            atrPercent: atrPercent.toFixed(2),
            description: 'Extreme volatility - minimal size',
            icon: '🔥'
        };
    }
}

function calculateSmartPositionSize(params) {
    const {
        accountBalance = STATE.riskAccount || 1000,
        currentPrice,
        atr,
        slPrice,
        grade = 'VALID',
        confidence = 70,
        intent = 'STOP_HUNT',
        drawdownMultiplier = 1.0
    } = params;
    
    const cfg = CONFIG.VOLATILITY_SIZING;
    
    // 1. Get base risk amount
    let riskPercent = cfg.baseRiskPercent;
    
    // 2. Adjust by volatility
    const volatility = getVolatilityCategory(atr, currentPrice);
    riskPercent *= volatility.multiplier;
    
    // 3. Adjust by grade
    const gradeMultiplier = cfg.gradeMultipliers[grade] || 1.0;
    riskPercent *= gradeMultiplier;
    
    // 4. Adjust by intent
    const intentMultiplier = cfg.intentMultipliers[intent] || 1.0;
    if (intentMultiplier === 0) {
        return {
            positionSize: 0,
            riskAmount: 0,
            riskPercent: 0,
            leverage: 0,
            blocked: true,
            reason: 'ABSORPTION - No trade',
            breakdown: { volatility, grade, intent, drawdown: drawdownMultiplier }
        };
    }
    riskPercent *= intentMultiplier;
    
    // 5. Adjust by confidence
    const confidenceMultiplier = Math.max(0.5, Math.min(1.25, confidence / 80));
    riskPercent *= confidenceMultiplier;
    
    // 6. Apply drawdown protection
    riskPercent *= drawdownMultiplier;
    
    // 7. Clamp to min/max
    riskPercent = Math.max(cfg.minRiskPercent, Math.min(cfg.maxRiskPercent, riskPercent));
    
    // 8. Calculate actual position
    const riskAmount = accountBalance * (riskPercent / 100);
    const slDistance = Math.abs(currentPrice - slPrice);
    const slPercent = (slDistance / currentPrice) * 100;
    
    // Position size based on risk and SL distance
    let positionSize = 0;
    let leverage = STATE.riskLeverage || 10;
    
    if (slPercent > 0) {
        positionSize = riskAmount / (slPercent / 100);
        positionSize = Math.min(positionSize, STATE.riskMaxPosition || 500);
        leverage = Math.min(Math.ceil(positionSize / (accountBalance * 0.1)), 20);
    }
    
    return {
        positionSize: Math.round(positionSize * 100) / 100,
        riskAmount: Math.round(riskAmount * 100) / 100,
        riskPercent: Math.round(riskPercent * 100) / 100,
        leverage: leverage,
        blocked: false,
        reason: null,
        breakdown: {
            volatility: volatility,
            gradeMultiplier: gradeMultiplier,
            intentMultiplier: intentMultiplier,
            confidenceMultiplier: Math.round(confidenceMultiplier * 100) / 100,
            drawdownMultiplier: drawdownMultiplier
        }
    };
}

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 BRAIN 2: CORRELATION FILTER (OVEREXPOSURE PROTECTION)
// ─────────────────────────────────────────────────────────────────────────────────

function getCorrelationGroup(symbol) {
    const groups = CONFIG.CORRELATION.groups;
    for (const [groupName, coins] of Object.entries(groups)) {
        if (coins.includes(symbol)) {
            return groupName;
        }
    }
    return 'UNCORRELATED';
}

function checkCorrelationFilter(symbol, direction, currentSignals) {
    if (!CONFIG.CORRELATION.enabled) {
        return { allowed: true, warning: null, groupCount: 0 };
    }
    
    const group = getCorrelationGroup(symbol);
    const cfg = CONFIG.CORRELATION;
    
    // Count existing signals in same group with same direction
    const groupSignals = currentSignals.filter(sig => 
        getCorrelationGroup(sig.symbol) === group && 
        sig.direction === direction &&
        sig.symbol !== symbol
    );
    
    const groupCount = groupSignals.length;
    
    // Check thresholds
    if (groupCount >= cfg.blockThreshold) {
        return {
            allowed: false,
            warning: `🚫 BLOCKED: ${groupCount} ${direction} signals in ${group} group (max ${cfg.blockThreshold})`,
            groupCount: groupCount,
            group: group,
            relatedSignals: groupSignals.map(s => s.symbol)
        };
    }
    
    if (groupCount >= cfg.warningThreshold) {
        return {
            allowed: true,
            warning: `⚠️ WARNING: ${groupCount} ${direction} signals in ${group} group`,
            groupCount: groupCount,
            group: group,
            relatedSignals: groupSignals.map(s => s.symbol)
        };
    }
    
    return {
        allowed: true,
        warning: null,
        groupCount: groupCount,
        group: group
    };
}

function getActiveSignalsByGroup(signals) {
    const groupCounts = {};
    
    signals.forEach(sig => {
        const group = getCorrelationGroup(sig.symbol);
        const key = `${group}_${sig.direction}`;
        if (!groupCounts[key]) {
            groupCounts[key] = { count: 0, symbols: [], group: group, direction: sig.direction };
        }
        groupCounts[key].count++;
        groupCounts[key].symbols.push(sig.symbol);
    });
    
    return groupCounts;
}

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 BRAIN 3: DRAWDOWN PROTECTION (LOSS STREAK MANAGEMENT)
// ─────────────────────────────────────────────────────────────────────────────────

function initDrawdownTracking() {
    // Load from localStorage
    const saved = safeStorageGet('brainDrawdown', null);
    if (saved) {
        STATE.brain.consecutiveLosses = saved.consecutiveLosses || 0;
        STATE.brain.consecutiveWins = saved.consecutiveWins || 0;
        STATE.brain.dailyLosses = saved.dailyLosses || 0;
        STATE.brain.dailyLossPercent = saved.dailyLossPercent || 0;
        STATE.brain.isPaused = saved.isPaused || false;
        STATE.brain.pausedUntil = saved.pausedUntil ? new Date(saved.pausedUntil) : null;
        STATE.brain.lastResetDate = saved.lastResetDate || new Date().toDateString();
    }
    
    // Reset daily counters if new day
    const today = new Date().toDateString();
    if (STATE.brain.lastResetDate !== today) {
        STATE.brain.dailyLosses = 0;
        STATE.brain.dailyLossPercent = 0;
        STATE.brain.lastResetDate = today;
        STATE.brain.isPaused = false;
        STATE.brain.pausedUntil = null;
        saveDrawdownState();
    }
    
    // Check if pause has expired
    if (STATE.brain.isPaused && STATE.brain.pausedUntil) {
        if (new Date() > new Date(STATE.brain.pausedUntil)) {
            STATE.brain.isPaused = false;
            STATE.brain.pausedUntil = null;
            saveDrawdownState();
            console.log('🧠 Drawdown pause expired - trading resumed');
        }
    }
}

function saveDrawdownState() {
    safeStorageSet('brainDrawdown', {
        consecutiveLosses: STATE.brain.consecutiveLosses,
        consecutiveWins: STATE.brain.consecutiveWins,
        dailyLosses: STATE.brain.dailyLosses,
        dailyLossPercent: STATE.brain.dailyLossPercent,
        isPaused: STATE.brain.isPaused,
        pausedUntil: STATE.brain.pausedUntil,
        lastResetDate: STATE.brain.lastResetDate
    });
}

function recordTradeResult(isWin, pnlPercent = 0) {
    const cfg = CONFIG.DRAWDOWN;
    
    if (isWin) {
        STATE.brain.consecutiveWins++;
        STATE.brain.consecutiveLosses = 0;
        
        // Check recovery
        if (STATE.brain.consecutiveWins >= cfg.recoveryWins) {
            STATE.brain.isPaused = false;
            STATE.brain.pausedUntil = null;
            console.log('🧠 Recovery achieved! Trading at full capacity');
            toast('🧠 Recovery! Full trading resumed', 'success');
        }
    } else {
        STATE.brain.consecutiveLosses++;
        STATE.brain.consecutiveWins = 0;
        STATE.brain.dailyLosses++;
        STATE.brain.dailyLossPercent += Math.abs(pnlPercent);
        
        // Check if we need to pause
        if (STATE.brain.consecutiveLosses >= cfg.pauseStreak) {
            STATE.brain.isPaused = true;
            STATE.brain.pausedUntil = new Date(Date.now() + cfg.cooldownMinutes * 60 * 1000);
            console.log(`🧠 Trading PAUSED after ${STATE.brain.consecutiveLosses} consecutive losses`);
            toast(`🛑 Trading paused for ${cfg.cooldownMinutes}min (${STATE.brain.consecutiveLosses} losses)`, 'error');
        } else if (STATE.brain.dailyLosses >= cfg.maxDailyLosses) {
            STATE.brain.isPaused = true;
            STATE.brain.pausedUntil = new Date(Date.now() + cfg.cooldownMinutes * 60 * 1000);
            console.log(`🧠 Trading PAUSED after ${STATE.brain.dailyLosses} daily losses`);
            toast(`🛑 Daily loss limit reached (${STATE.brain.dailyLosses} losses)`, 'error');
        } else if (STATE.brain.dailyLossPercent >= cfg.maxDailyLossPercent) {
            STATE.brain.isPaused = true;
            STATE.brain.pausedUntil = new Date(Date.now() + cfg.cooldownMinutes * 60 * 1000);
            console.log(`🧠 Trading PAUSED - daily loss ${STATE.brain.dailyLossPercent.toFixed(1)}%`);
            toast(`🛑 Daily loss limit ${STATE.brain.dailyLossPercent.toFixed(1)}% reached`, 'error');
        }
    }
    
    saveDrawdownState();
}

function getDrawdownMultiplier() {
    const cfg = CONFIG.DRAWDOWN;
    
    // If paused, return 0
    if (STATE.brain.isPaused) {
        return { multiplier: 0, status: 'PAUSED', reason: 'Trading paused due to drawdown' };
    }
    
    // Apply reductions based on loss streak
    const losses = STATE.brain.consecutiveLosses;
    
    if (losses >= 5) {
        return { multiplier: cfg.reductions.streak5, status: 'PAUSED', reason: `${losses} consecutive losses - paused` };
    } else if (losses >= 4) {
        return { multiplier: cfg.reductions.streak4, status: 'MINIMAL', reason: `${losses} consecutive losses - 25% size` };
    } else if (losses >= 3) {
        return { multiplier: cfg.reductions.streak3, status: 'REDUCED', reason: `${losses} consecutive losses - 50% size` };
    } else if (losses >= 2) {
        return { multiplier: 0.75, status: 'WARNING', reason: `${losses} consecutive losses - 75% size` };
    }
    
    return { multiplier: 1.0, status: 'NORMAL', reason: null };
}

function checkDrawdownGradeFilter(grade) {
    const cfg = CONFIG.DRAWDOWN;
    
    if (!STATE.brain.isPaused && STATE.brain.consecutiveLosses < cfg.reduceStreak) {
        return { allowed: true, reason: null };
    }
    
    // During drawdown, only allow STRONG+ grades
    const gradeRank = { PERFECT: 5, STRONG: 4, VALID: 3, HEATING: 2, BREWING: 1 };
    const minRank = gradeRank[cfg.minGradeDuringDrawdown] || 4;
    const currentRank = gradeRank[grade] || 0;
    
    if (currentRank < minRank) {
        return {
            allowed: false,
            reason: `During drawdown: Only ${cfg.minGradeDuringDrawdown}+ signals allowed (got ${grade})`
        };
    }
    
    return { allowed: true, reason: null };
}

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 BRAIN 4: INTENT CLASSIFICATION (FROM J's BOT)
// ─────────────────────────────────────────────────────────────────────────────────

function detectLiquidityPools(klines, tolerance = 0.005) {
    if (!klines || klines.length < 20) return [];
    
    const swings = [];
    const len = klines.length;
    
    // Find swing highs and lows
    for (let i = 2; i < len - 2; i++) {
        const isHigh = klines[i].high > klines[i-1].high && 
                       klines[i].high > klines[i-2].high &&
                       klines[i].high > klines[i+1].high && 
                       klines[i].high > klines[i+2].high;
        
        const isLow = klines[i].low < klines[i-1].low && 
                      klines[i].low < klines[i-2].low &&
                      klines[i].low < klines[i+1].low && 
                      klines[i].low < klines[i+2].low;
        
        if (isHigh) swings.push({ price: klines[i].high, type: 'HIGH', index: i });
        if (isLow) swings.push({ price: klines[i].low, type: 'LOW', index: i });
    }
    
    // Cluster into pools
    const pools = [];
    const currentPrice = klines[len - 1].close;
    
    swings.forEach(swing => {
        const existingPool = pools.find(p => 
            p.type === swing.type && 
            Math.abs(p.price - swing.price) / swing.price <= tolerance
        );
        
        if (existingPool) {
            existingPool.strength++;
            existingPool.price = (existingPool.price + swing.price) / 2;
        } else {
            pools.push({
                price: swing.price,
                type: swing.type,
                strength: 1,
                distance: Math.abs(currentPrice - swing.price) / currentPrice * 100
            });
        }
    });
    
    return pools.filter(p => p.strength >= 2).sort((a, b) => a.distance - b.distance);
}

function isLiquiditySweep(candle, pool, avgVolume) {
    const wickSize = Math.abs(candle.high - candle.low);
    const bodySize = Math.abs(candle.close - candle.open);
    const wickRatio = wickSize > 0 ? (wickSize - bodySize) / wickSize : 0;
    
    const pierced = pool.type === 'HIGH' 
        ? candle.high > pool.price 
        : candle.low < pool.price;
    
    const closedBack = pool.type === 'HIGH'
        ? candle.close < pool.price
        : candle.close > pool.price;
    
    return pierced && closedBack && wickRatio > 0.55 && candle.volume > avgVolume * 1.4;
}

function classifyIntent(klines, pool, atr) {
    if (!klines || klines.length < 3) return 'ABSORPTION';
    
    const last = klines[klines.length - 1];
    const prev = klines[klines.length - 2];
    
    // Re-accepted (stop hunt)
    const reAccepted = pool.type === 'HIGH'
        ? last.close < pool.price && prev.close < pool.price
        : last.close > pool.price && prev.close > pool.price;
    
    // Breakout accepted
    const breakoutAccepted = pool.type === 'HIGH'
        ? last.close > pool.price + atr * 0.2
        : last.close < pool.price - atr * 0.2;
    
    if (reAccepted) return 'STOP_HUNT';
    if (breakoutAccepted) return 'BREAKOUT';
    return 'ABSORPTION';
}

function detectMarketIntent(klines, atr) {
    if (!klines || klines.length < 50) {
        return { intent: 'ABSORPTION', confidence: 0, pool: null };
    }
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    const tolerance = (atr / currentPrice) * 0.15;
    
    // Find liquidity pools
    const pools = detectLiquidityPools(klines, tolerance);
    
    if (pools.length === 0) {
        return { intent: 'ABSORPTION', confidence: 0, pool: null, reason: 'No liquidity pools found' };
    }
    
    // Get nearest pool
    const nearestPool = pools[0];
    
    // Check if recently swept
    const recentCandles = klines.slice(-5);
    const avgVolume = klines.slice(-20).reduce((sum, k) => sum + k.volume, 0) / 20;
    
    let swept = false;
    recentCandles.forEach(candle => {
        if (isLiquiditySweep(candle, nearestPool, avgVolume)) {
            swept = true;
        }
    });
    
    if (swept) {
        const intent = classifyIntent(recentCandles, nearestPool, atr);
        const confidence = nearestPool.strength * 20 + (swept ? 30 : 0);
        
        return {
            intent: intent,
            confidence: Math.min(100, confidence),
            pool: nearestPool,
            swept: swept,
            reason: `Liquidity sweep detected at ${nearestPool.type} pool`
        };
    }
    
    // No sweep - check for buildup
    if (nearestPool.distance < 1.0) {
        return {
            intent: 'ABSORPTION',
            confidence: 30,
            pool: nearestPool,
            swept: false,
            reason: 'Price consolidating near liquidity'
        };
    }
    
    return {
        intent: 'ABSORPTION',
        confidence: 0,
        pool: null,
        reason: 'No clear intent detected'
    };
}

function getIntentBasedLevels(intent, currentPrice, atr, direction) {
    const cfg = CONFIG.INTENT;
    
    if (!cfg.enabled || intent === 'ABSORPTION') {
        return null;
    }
    
    const slMult = cfg.slMultipliers[intent] || 2.0;
    const tpMult = cfg.tpMultipliers[intent] || 3.0;
    
    let sl, tp1, tp2, tp3;
    
    if (direction === 'LONG') {
        sl = currentPrice - (atr * slMult);
        tp1 = currentPrice + (atr * tpMult * 0.5);
        tp2 = currentPrice + (atr * tpMult);
        tp3 = currentPrice + (atr * tpMult * 1.5);
    } else {
        sl = currentPrice + (atr * slMult);
        tp1 = currentPrice - (atr * tpMult * 0.5);
        tp2 = currentPrice - (atr * tpMult);
        tp3 = currentPrice - (atr * tpMult * 1.5);
    }
    
    return {
        sl: sl,
        tp1: tp1,
        tp2: tp2,
        tp3: tp3,
        slMultiplier: slMult,
        tpMultiplier: tpMult,
        tpMode: cfg.tpModes[intent],
        entryMode: cfg.entryModes[intent],
        intent: intent
    };
}

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 BRAIN 5: PATTERN MEMORY (FROM J's BOT)
// ─────────────────────────────────────────────────────────────────────────────────

function initPatternMemory() {
    const saved = safeStorageGet('brainPatternDB', []);
    STATE.brain.patternDB = saved || [];
    console.log(`🧠 Loaded ${STATE.brain.patternDB.length} patterns from memory`);
}

function savePatternMemory() {
    // Limit to 500 patterns
    if (STATE.brain.patternDB.length > 500) {
        STATE.brain.patternDB = STATE.brain.patternDB.slice(-500);
    }
    safeStorageSet('brainPatternDB', STATE.brain.patternDB);
}

function createPatternSignature(signal) {
    // Create a unique signature for pattern matching
    return {
        symbol: signal.symbol,
        tf: signal.tf,
        direction: signal.direction,
        grade: signal.grade,
        intent: signal.intent || 'UNKNOWN',
        zoneScore: Math.round((signal.scores?.zone || 0) / 10) * 10,  // Round to nearest 10
        smcScore: Math.round((signal.scores?.smc || 0) / 10) * 10,
        momentumScore: Math.round((signal.scores?.momentum || 0) / 10) * 10,
        envVerdict: STATE.environment?.verdict || 'UNKNOWN',
        hour: new Date().getHours()  // Time of day
    };
}

function findMatchingPatterns(signature) {
    const cfg = CONFIG.PATTERN_MEMORY;
    if (!cfg.enabled || STATE.brain.patternDB.length < cfg.minOccurrences) {
        return { matches: [], successRate: 0.5, confidence: 0 };
    }
    
    const matches = STATE.brain.patternDB.filter(p => {
        // Match on key attributes (allow some flexibility)
        const symbolMatch = p.symbol === signature.symbol;
        const tfMatch = p.tf === signature.tf;
        const directionMatch = p.direction === signature.direction;
        const gradeMatch = p.grade === signature.grade;
        const intentMatch = p.intent === signature.intent;
        
        // Score similarity
        const zoneClose = Math.abs(p.zoneScore - signature.zoneScore) <= 20;
        const smcClose = Math.abs(p.smcScore - signature.smcScore) <= 20;
        
        // Must match: direction, grade
        // Should match: symbol OR tf, intent
        return directionMatch && gradeMatch && 
               (symbolMatch || tfMatch) && 
               (intentMatch || zoneClose || smcClose);
    });
    
    if (matches.length < cfg.minOccurrences) {
        return { matches: [], successRate: 0.5, confidence: 0 };
    }
    
    const wins = matches.filter(m => m.result === 'WIN').length;
    const successRate = wins / matches.length;
    
    return {
        matches: matches,
        successRate: successRate,
        confidence: matches.length >= 10 ? 'HIGH' : matches.length >= 5 ? 'MEDIUM' : 'LOW',
        totalMatches: matches.length,
        wins: wins,
        losses: matches.length - wins
    };
}

function getPatternConfidenceMultiplier(signal) {
    const cfg = CONFIG.PATTERN_MEMORY;
    if (!cfg.enabled) return { multiplier: 1.0, reason: null };
    
    const signature = createPatternSignature(signal);
    const patternData = findMatchingPatterns(signature);
    
    if (patternData.matches.length === 0) {
        return { multiplier: 1.0, reason: 'No pattern history', patternData: null };
    }
    
    const successRate = patternData.successRate;
    
    if (successRate >= cfg.minConfidence) {
        // Boost confidence for good patterns
        const boost = Math.min(cfg.boostMultiplier, 1 + (successRate - 0.5) * 0.3);
        return {
            multiplier: boost,
            reason: `Pattern ${(successRate * 100).toFixed(0)}% success (${patternData.totalMatches} trades)`,
            patternData: patternData
        };
    } else if (successRate < 0.4) {
        // Penalize bad patterns
        return {
            multiplier: cfg.penaltyMultiplier,
            reason: `⚠️ Pattern ${(successRate * 100).toFixed(0)}% success - CAUTION`,
            patternData: patternData
        };
    }
    
    return {
        multiplier: 1.0,
        reason: `Pattern ${(successRate * 100).toFixed(0)}% success`,
        patternData: patternData
    };
}

function recordPatternResult(signal, result) {
    const signature = createPatternSignature(signal);
    
    STATE.brain.patternDB.push({
        ...signature,
        result: result,  // 'WIN' or 'LOSS'
        timestamp: Date.now(),
        pnl: signal.pnl || 0
    });
    
    // Decay old patterns
    const cfg = CONFIG.PATTERN_MEMORY;
    const cutoff = Date.now() - (cfg.decayDays * 24 * 60 * 60 * 1000);
    STATE.brain.patternDB = STATE.brain.patternDB.filter(p => p.timestamp > cutoff);
    
    savePatternMemory();
    console.log(`🧠 Pattern recorded: ${result} for ${signal.symbol} ${signal.tf}`);
}

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 MASTER BRAIN: COMBINE ALL INTELLIGENCES
// ─────────────────────────────────────────────────────────────────────────────────

function applyIntelligentBrain(signal, currentSignals = []) {
    const result = {
        originalSignal: signal,
        allowed: true,
        blocked: false,
        blockReason: null,
        warnings: [],
        
        // Brain outputs
        intent: null,
        positionSize: null,
        correlation: null,
        drawdown: null,
        pattern: null,
        
        // Modified levels (if intent changes them)
        modifiedLevels: null,
        
        // Final confidence
        adjustedConfidence: signal.score || 70
    };
    
    // 1. Check if trading is paused (Brain 3)
    initDrawdownTracking();
    const drawdown = getDrawdownMultiplier();
    result.drawdown = drawdown;
    
    if (drawdown.multiplier === 0) {
        result.blocked = true;
        result.allowed = false;
        result.blockReason = drawdown.reason;
        return result;
    }
    
    // 2. Check grade during drawdown
    const gradeCheck = checkDrawdownGradeFilter(signal.grade);
    if (!gradeCheck.allowed) {
        result.blocked = true;
        result.allowed = false;
        result.blockReason = gradeCheck.reason;
        return result;
    }
    
    // 3. Detect intent (Brain 4)
    if (signal.atr && signal.price) {
        // Use existing klines if available, otherwise use signal data
        const intentData = detectMarketIntent(
            signal.klines || null, 
            signal.atr
        );
        result.intent = intentData;
        
        if (intentData.intent === 'ABSORPTION') {
            result.warnings.push('⚠️ ABSORPTION detected - weak setup');
        }
        
        // Get intent-based levels
        if (intentData.intent !== 'ABSORPTION') {
            result.modifiedLevels = getIntentBasedLevels(
                intentData.intent,
                signal.price,
                signal.atr,
                signal.direction
            );
        }
    }
    
    // 4. Check correlation (Brain 2)
    const correlation = checkCorrelationFilter(
        signal.symbol,
        signal.direction,
        currentSignals
    );
    result.correlation = correlation;
    
    if (!correlation.allowed) {
        result.blocked = true;
        result.allowed = false;
        result.blockReason = correlation.warning;
        return result;
    }
    
    if (correlation.warning) {
        result.warnings.push(correlation.warning);
    }
    
    // 5. Get pattern confidence (Brain 5)
    initPatternMemory();
    const pattern = getPatternConfidenceMultiplier(signal);
    result.pattern = pattern;
    
    if (pattern.reason) {
        if (pattern.multiplier < 1) {
            result.warnings.push(pattern.reason);
        }
    }
    
    // 6. Calculate position size (Brain 1)
    const positionSize = calculateSmartPositionSize({
        accountBalance: STATE.riskAccount || 1000,
        currentPrice: signal.price,
        atr: signal.atr,
        slPrice: signal.levels?.sl || signal.price * 0.98,
        grade: signal.grade,
        confidence: signal.score || 70,
        intent: result.intent?.intent || 'STOP_HUNT',
        drawdownMultiplier: drawdown.multiplier
    });
    result.positionSize = positionSize;
    
    if (positionSize.blocked) {
        result.blocked = true;
        result.allowed = false;
        result.blockReason = positionSize.reason;
        return result;
    }
    
    // 7. Adjust confidence
    let adjustedConfidence = signal.score || 70;
    adjustedConfidence *= pattern.multiplier;
    adjustedConfidence *= (result.intent?.intent === 'STOP_HUNT' ? 1.1 : 
                          result.intent?.intent === 'BREAKOUT' ? 1.0 : 0.8);
    result.adjustedConfidence = Math.round(Math.min(100, Math.max(0, adjustedConfidence)));
    
    return result;
}

// Initialize brains on load
function initIntelligentBrains() {
    console.log('🧠 Initializing Intelligent Brain Module v1.0...');
    initDrawdownTracking();
    initPatternMemory();
    console.log('🧠 All 5 brains activated - 100% Intelligence achieved!');
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF INTELLIGENT BRAIN MODULE
// ═══════════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════════
// 🏦 INSTITUTIONAL DATA FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

// Fetch Funding Rate for a symbol - BYBIT V5 API
async function fetchFundingRate(symbol) {
    try {
        const url = `${CONFIG.BYBIT_V5}/market/funding/history?category=linear&symbol=${symbol}&limit=1`;
        const d = await fetchJSON(url);
        if (d && d.retCode === 0 && d.result && d.result.list && d.result.list.length > 0) {
            const rate = parseFloat(d.result.list[0].fundingRate) || 0;
            const time = parseInt(d.result.list[0].fundingRateTimestamp) || 0;
            return {
                rate: rate,
                ratePercent: (rate * 100).toFixed(4),
                timestamp: time,
                // Interpretation
                sentiment: rate > 0.0003 ? 'OVERLEVERAGED_LONG' : 
                          rate < -0.0003 ? 'OVERLEVERAGED_SHORT' : 
                          rate > 0 ? 'SLIGHTLY_LONG' : 
                          rate < 0 ? 'SLIGHTLY_SHORT' : 'NEUTRAL',
                // Trading signal
                signal: rate > 0.001 ? 'SHORT_SQUEEZE_RISK' :
                       rate < -0.001 ? 'LONG_SQUEEZE_RISK' :
                       rate > 0.0005 ? 'LONGS_PAYING' :
                       rate < -0.0005 ? 'SHORTS_PAYING' : 'BALANCED'
            };
        }
    } catch(e) { 
        // Silent fail for funding rate
    }
    return null;
}

// Fetch Open Interest - BYBIT V5 API
async function fetchOpenInterest(symbol = 'BTCUSDT') {
    try {
        const url = `${CONFIG.BYBIT_V5}/market/open-interest?category=linear&symbol=${symbol}&intervalTime=5min&limit=48`;
        const d = await fetchJSON(url);
        if (d && d.retCode === 0 && d.result && d.result.list && d.result.list.length > 0) {
            const list = d.result.list;
            const currentOI = parseFloat(list[0].openInterest) || 0;
            
            let change = 0;
            let changePct = 0;
            let rising = 0, falling = 0;
            
            if (list.length > 1) {
                const oldest = parseFloat(list[list.length - 1].openInterest) || 1;
                const latest = parseFloat(list[0].openInterest) || currentOI;
                change = latest - oldest;
                changePct = oldest > 0 ? ((latest - oldest) / oldest) * 100 : 0;
                
                for (let i = 0; i < list.length - 1; i++) {
                    const curr = parseFloat(list[i].openInterest);
                    const prev = parseFloat(list[i+1].openInterest);
                    if (curr > prev) rising++;
                    else if (curr < prev) falling++;
                }
            }
            
            return {
                current: currentOI,
                change: change,
                changePct: changePct,
                change4h: changePct.toFixed(2),
                trend: rising > falling * 1.5 ? 'RISING' : 
                      falling > rising * 1.5 ? 'FALLING' : 'STABLE',
                risingCount: rising,
                fallingCount: falling,
                timestamp: Date.now(),
                // Trading interpretation
                signal: changePct > 5 ? 'NEW_POSITIONS_OPENING' :
                       changePct < -5 ? 'POSITIONS_CLOSING' :
                       changePct > 2 ? 'SLIGHT_BUILDUP' :
                       changePct < -2 ? 'SLIGHT_UNWIND' : 'STABLE'
            };
        }
    } catch(e) { 
        // Silent fail for OI fetch
    }
    return null;
}

// Fetch Long/Short Ratio - BYBIT V5 API (using tickers as proxy since L/S ratio isn't public)
async function fetchLongShortRatio(symbol) {
    try {
        // Bybit doesn't have public global L/S ratio API
        // We estimate from funding rate direction as a proxy
        const fundingData = await fetchFundingRate(symbol);
        
        if (fundingData) {
            // Positive funding = more longs, Negative = more shorts
            const rate = fundingData.rate;
            const longBias = rate > 0 ? 0.5 + Math.min(rate * 100, 0.15) : 0.5 - Math.min(Math.abs(rate) * 100, 0.15);
            const shortBias = 1 - longBias;
            
            return {
                buyRatio: (longBias * 100).toFixed(1),
                sellRatio: (shortBias * 100).toFixed(1),
                ratio: shortBias > 0 ? (longBias / shortBias).toFixed(2) : '1.00',
                dominance: longBias > 0.55 ? 'LONG_DOMINANT' :
                          shortBias > 0.55 ? 'SHORT_DOMINANT' : 'BALANCED',
                trend: rate > 0.0001 ? 'LONGS_INCREASING' :
                      rate < -0.0001 ? 'SHORTS_INCREASING' : 'STABLE',
                // Contrarian signal
                contrarianSignal: longBias > 0.65 ? 'BEARISH' :
                                 shortBias > 0.65 ? 'BULLISH' :
                                 longBias > 0.55 ? 'SLIGHTLY_BEARISH' :
                                 shortBias > 0.55 ? 'SLIGHTLY_BULLISH' : 'NEUTRAL',
                estimated: true // Flag that this is estimated from funding rate
            };
        }
    } catch(e) { 
        // Silent fail for L/S ratio 
    }
    return null;
}

// Calculate Liquidation Levels based on current price
function calculateLiquidationLevels(currentPrice, direction) {
    // SAFETY: Validate currentPrice
    if (!currentPrice || currentPrice <= 0 || isNaN(currentPrice)) {
        return { levels: [], longCluster: [], shortCluster: [], analysis: 'No price data' };
    }
    
    // Common leverage levels used by traders
    const leverages = [3, 5, 10, 20, 25, 50, 75, 100];
    const levels = [];
    
    leverages.forEach(lev => {
        // Approximate liquidation prices (simplified, doesn't account for fees/maintenance margin)
        // Long liquidation: entry * (1 - 1/leverage)
        // Short liquidation: entry * (1 + 1/leverage)
        
        const longLiqPrice = currentPrice * (1 - (0.9 / lev)); // 90% of margin used
        const shortLiqPrice = currentPrice * (1 + (0.9 / lev));
        
        // SAFETY: Safe division
        const longDist = currentPrice > 0 ? ((currentPrice - longLiqPrice) / currentPrice * 100).toFixed(2) : '0.00';
        const shortDist = currentPrice > 0 ? ((shortLiqPrice - currentPrice) / currentPrice * 100).toFixed(2) : '0.00';
        
        levels.push({
            leverage: lev,
            longLiqPrice: longLiqPrice,
            shortLiqPrice: shortLiqPrice,
            longDistPct: longDist,
            shortDistPct: shortDist
        });
    });
    
    // Find key liquidation clusters (where most retail traders would be liquidated)
    const retailLeverages = [10, 20, 25]; // Most common retail leverage
    const longCluster = levels.filter(l => retailLeverages.includes(l.leverage))
                              .map(l => l.longLiqPrice);
    const shortCluster = levels.filter(l => retailLeverages.includes(l.leverage))
                               .map(l => l.shortLiqPrice);
    
    return {
        levels: levels,
        longCluster: {
            low: longCluster.length > 0 ? Math.min(...longCluster) : 0,
            high: longCluster.length > 0 ? Math.max(...longCluster) : 0,
            mid: longCluster.length > 0 ? longCluster.reduce((a, b) => a + b, 0) / longCluster.length : 0
        },
        shortCluster: {
            low: shortCluster.length > 0 ? Math.min(...shortCluster) : 0,
            high: shortCluster.length > 0 ? Math.max(...shortCluster) : 0,
            mid: shortCluster.length > 0 ? shortCluster.reduce((a, b) => a + b, 0) / shortCluster.length : 0
        },
        // Key magnet levels (where price is attracted to grab liquidity)
        magnetLong: levels.find(l => l.leverage === 20)?.longLiqPrice || 0,
        magnetShort: levels.find(l => l.leverage === 20)?.shortLiqPrice || 0
    };
}

// Master function: Fetch all institutional data for a symbol
async function fetchInstitutionalData(symbol, currentPrice) {
    const [funding, oi, lsRatio] = await Promise.all([
        fetchFundingRate(symbol),
        fetchOpenInterest(symbol),
        fetchLongShortRatio(symbol)
    ]);
    
    const liqLevels = calculateLiquidationLevels(currentPrice, null);
    
    // Calculate institutional bias
    let bullScore = 0, bearScore = 0;
    
    // Funding Rate Analysis
    if (funding) {
        if (funding.rate > 0.0005) bearScore += 20; // Longs overleveraged
        else if (funding.rate < -0.0005) bullScore += 20; // Shorts overleveraged
        else if (funding.rate > 0.0001) bearScore += 10;
        else if (funding.rate < -0.0001) bullScore += 10;
    }
    
    // OI Analysis
    if (oi) {
        // Rising OI with price direction = trend continuation
        // Rising OI against price = reversal brewing
        if (parseFloat(oi.change4h) > 5) {
            // New positions opening - need to combine with price action
            bullScore += 5;
            bearScore += 5;
        } else if (parseFloat(oi.change4h) < -5) {
            // Positions closing - trend exhaustion
            bullScore += 0;
            bearScore += 0;
        }
    }
    
    // Long/Short Ratio (Contrarian)
    if (lsRatio) {
        if (parseFloat(lsRatio.buyRatio) > 60) bearScore += 25; // Too many longs
        else if (parseFloat(lsRatio.sellRatio) > 60) bullScore += 25; // Too many shorts
        else if (parseFloat(lsRatio.buyRatio) > 55) bearScore += 15;
        else if (parseFloat(lsRatio.sellRatio) > 55) bullScore += 15;
    }
    
    // Determine overall institutional bias
    let institutionalBias = 'NEUTRAL';
    let biasStrength = 0;
    
    if (bullScore > bearScore + 20) {
        institutionalBias = 'BULLISH';
        biasStrength = bullScore - bearScore;
    } else if (bearScore > bullScore + 20) {
        institutionalBias = 'BEARISH';
        biasStrength = bearScore - bullScore;
    } else if (bullScore > bearScore + 10) {
        institutionalBias = 'SLIGHTLY_BULLISH';
        biasStrength = bullScore - bearScore;
    } else if (bearScore > bullScore + 10) {
        institutionalBias = 'SLIGHTLY_BEARISH';
        biasStrength = bearScore - bullScore;
    }
    
    // Squeeze detection
    let squeezeRisk = null;
    if (funding && lsRatio) {
        if (funding.rate > 0.0008 && parseFloat(lsRatio.buyRatio) > 60) {
            squeezeRisk = {
                type: 'LONG_SQUEEZE',
                probability: 'HIGH',
                trigger: liqLevels.magnetLong,
                reason: 'High funding + crowded longs'
            };
        } else if (funding.rate < -0.0008 && parseFloat(lsRatio.sellRatio) > 60) {
            squeezeRisk = {
                type: 'SHORT_SQUEEZE',
                probability: 'HIGH',
                trigger: liqLevels.magnetShort,
                reason: 'Negative funding + crowded shorts'
            };
        } else if (funding.rate > 0.0005 && parseFloat(lsRatio.buyRatio) > 55) {
            squeezeRisk = {
                type: 'LONG_SQUEEZE',
                probability: 'MEDIUM',
                trigger: liqLevels.magnetLong,
                reason: 'Elevated funding + long bias'
            };
        } else if (funding.rate < -0.0005 && parseFloat(lsRatio.sellRatio) > 55) {
            squeezeRisk = {
                type: 'SHORT_SQUEEZE',
                probability: 'MEDIUM',
                trigger: liqLevels.magnetShort,
                reason: 'Negative funding + short bias'
            };
        }
    }
    
    return {
        funding: funding,
        openInterest: oi,
        longShortRatio: lsRatio,
        liquidationLevels: liqLevels,
        institutionalBias: institutionalBias,
        biasStrength: biasStrength,
        bullScore: bullScore,
        bearScore: bearScore,
        squeezeRisk: squeezeRisk,
        timestamp: Date.now()
    };
}

// Analyze institutional data for trade decision
function analyzeInstitutionalData(instData, direction) {
    if (!instData) return { score: 0, factors: [], warnings: [] };
    
    const result = {
        score: 0,
        factors: [],
        warnings: [],
        recommendation: 'NEUTRAL'
    };
    
    // Check if institutional bias aligns with trade direction
    if (direction === 'LONG') {
        if (instData.institutionalBias === 'BULLISH') {
            result.score += 25;
            result.factors.push('Institutional bias: BULLISH');
        } else if (instData.institutionalBias === 'SLIGHTLY_BULLISH') {
            result.score += 15;
            result.factors.push('Institutional bias: Slightly bullish');
        } else if (instData.institutionalBias === 'BEARISH') {
            result.score -= 20;
            result.warnings.push('⚠️ Institutional bias AGAINST long');
        } else if (instData.institutionalBias === 'SLIGHTLY_BEARISH') {
            result.score -= 10;
            result.warnings.push('Institutional bias slightly against');
        }
        
        // Squeeze risk check
        if (instData.squeezeRisk) {
            if (instData.squeezeRisk.type === 'LONG_SQUEEZE') {
                result.score -= 30;
                result.warnings.push(`🚨 ${instData.squeezeRisk.probability} LONG SQUEEZE risk`);
            } else if (instData.squeezeRisk.type === 'SHORT_SQUEEZE') {
                result.score += 20;
                result.factors.push('🚀 Short squeeze potential');
            }
        }
        
    } else { // SHORT
        if (instData.institutionalBias === 'BEARISH') {
            result.score += 25;
            result.factors.push('Institutional bias: BEARISH');
        } else if (instData.institutionalBias === 'SLIGHTLY_BEARISH') {
            result.score += 15;
            result.factors.push('Institutional bias: Slightly bearish');
        } else if (instData.institutionalBias === 'BULLISH') {
            result.score -= 20;
            result.warnings.push('⚠️ Institutional bias AGAINST short');
        } else if (instData.institutionalBias === 'SLIGHTLY_BULLISH') {
            result.score -= 10;
            result.warnings.push('Institutional bias slightly against');
        }
        
        // Squeeze risk check
        if (instData.squeezeRisk) {
            if (instData.squeezeRisk.type === 'SHORT_SQUEEZE') {
                result.score -= 30;
                result.warnings.push(`🚨 ${instData.squeezeRisk.probability} SHORT SQUEEZE risk`);
            } else if (instData.squeezeRisk.type === 'LONG_SQUEEZE') {
                result.score += 20;
                result.factors.push('🚀 Long squeeze potential');
            }
        }
    }
    
    // Funding rate bonus/penalty
    if (instData.funding) {
        if (direction === 'LONG' && instData.funding.rate < -0.0003) {
            result.score += 10;
            result.factors.push(`Negative funding (${instData.funding.ratePercent}%) - shorts paying`);
        } else if (direction === 'SHORT' && instData.funding.rate > 0.0003) {
            result.score += 10;
            result.factors.push(`Positive funding (${instData.funding.ratePercent}%) - longs paying`);
        } else if (direction === 'LONG' && instData.funding.rate > 0.0005) {
            result.score -= 10;
            result.warnings.push(`High funding (${instData.funding.ratePercent}%) - expensive longs`);
        } else if (direction === 'SHORT' && instData.funding.rate < -0.0005) {
            result.score -= 10;
            result.warnings.push(`Negative funding (${instData.funding.ratePercent}%) - expensive shorts`);
        }
    }
    
    // OI trend
    if (instData.openInterest) {
        if (instData.openInterest.trend === 'RISING') {
            result.factors.push(`OI rising +${instData.openInterest.change4h}% (new positions)`);
        } else if (instData.openInterest.trend === 'FALLING') {
            result.warnings.push(`OI falling ${instData.openInterest.change4h}% (positions closing)`);
        }
    }
    
    // Overall recommendation
    if (result.score >= 30) {
        result.recommendation = 'STRONG_CONFIRM';
    } else if (result.score >= 15) {
        result.recommendation = 'CONFIRM';
    } else if (result.score <= -20) {
        result.recommendation = 'AVOID';
    } else if (result.score <= -10) {
        result.recommendation = 'CAUTION';
    } else {
        result.recommendation = 'NEUTRAL';
    }
    
    return result;
}


async function fetchBTC() {
    try {
        const d = await fetchJSON(`${CONFIG.BYBIT_V5}/market/tickers?category=linear&symbol=BTCUSDT`);
        if (d && d.retCode === 0 && d.result && d.result.list && d.result.list.length > 0) {
            const ticker = d.result.list[0];
            STATE.btc.price = parseFloat(ticker.lastPrice);
            STATE.btc.change = parseFloat(ticker.price24hPcnt) * 100 || 0;
            // Update BTC badge
            const btcBadge = document.getElementById('badgeBTC');
            const btcVal = document.getElementById('badgeBTCVal');
            if (btcVal) {
                const priceK = '$' + (STATE.btc.price / 1000).toFixed(1) + 'K';
                const arrow = STATE.btc.change >= 0 ? '▲' : '▼';
                btcVal.textContent = priceK + arrow;
                btcBadge.className = 'info-badge ' + (STATE.btc.change >= 0 ? 'go' : 'nogo');
            }
        }
    } catch(e) {
        // Silent fail for BTC
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENVIRONMENT ANALYSIS SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Fetch BTC klines for structure and RSI analysis
async function fetchBTCAnalysis() {
    try {
        // Fetch BTC 1H and 4H klines
        const btc1H = await fetchKlines('BTCUSDT', '60', 100);
        const btc4H = await fetchKlines('BTCUSDT', '240', 100);
        
        if (!btc1H || !btc4H || btc1H.length < 50 || btc4H.length < 50) {
            return null;
        }
        
        // Calculate BTC RSI (14 period on 4H)
        const rsi = calcRSI(btc4H);
        STATE.environment.btcRSI = {
            value: Math.round(rsi.value),
            status: rsi.value > 70 ? 'OVERBOUGHT' : rsi.value < 30 ? 'OVERSOLD' : 'HEALTHY'
        };
        
        // Determine BTC Trend from 4H
        const ema20 = calcEMA(btc4H.map(k => k.close), 20);
        const ema50 = calcEMA(btc4H.map(k => k.close), 50);
        const currentPrice = btc4H[btc4H.length - 1].close;
        const ema20Val = ema20[ema20.length - 1];
        const ema50Val = ema50[ema50.length - 1];
        
        let btcTrend = 'FLAT';
        let strength = 50;
        
        if (currentPrice > ema20Val && ema20Val > ema50Val) {
            btcTrend = 'BULLISH';
            strength = 70 + Math.min(30, ((currentPrice - ema50Val) / ema50Val) * 100);
        } else if (currentPrice < ema20Val && ema20Val < ema50Val) {
            btcTrend = 'BEARISH';
            strength = 70 + Math.min(30, ((ema50Val - currentPrice) / ema50Val) * 100);
        } else if (currentPrice > ema20Val) {
            btcTrend = 'BULLISH';
            strength = 55;
        } else if (currentPrice < ema20Val) {
            btcTrend = 'BEARISH';
            strength = 55;
        }
        
        STATE.environment.btcTrend = { direction: btcTrend, strength: Math.min(100, strength) };
        
        // Check BTC Structure (look for recent BOS)
        const swings = findSwingPoints(btc4H, 5, 5);
        let structureStatus = 'INTACT';
        
        // Check if recent swing low was broken (bearish structure break)
        if (swings.lows.length >= 2) {
            const recentLow = swings.lows[swings.lows.length - 1];
            const prevLow = swings.lows[swings.lows.length - 2];
            if (currentPrice < prevLow.price && recentLow.price < prevLow.price) {
                structureStatus = 'BROKEN_DOWN';
            }
        }
        
        // Check if recent swing high was broken (bullish structure break)
        if (swings.highs.length >= 2) {
            const recentHigh = swings.highs[swings.highs.length - 1];
            const prevHigh = swings.highs[swings.highs.length - 2];
            if (currentPrice > prevHigh.price && recentHigh.price > prevHigh.price) {
                structureStatus = 'BROKEN_UP';
            }
        }
        
        STATE.environment.btcStructure = {
            status: structureStatus,
            score: structureStatus === 'INTACT' ? 100 : 
                   structureStatus === 'BROKEN_UP' ? 80 : 
                   structureStatus === 'BROKEN_DOWN' ? 20 : 50
        };
        
        return true;
    } catch (e) {
        console.error('BTC Analysis error:', e);
        return null;
    }
}

// Calculate Environment Score (FULL 100 points with null safety)
function calculateEnvironmentScore(signalDirection, signal = null) {
    let score = 0;
    let details = [];
    const dir = signalDirection || 'LONG';
    const env = STATE.environment || {};
    
    // SAFETY: Default values if environment not loaded
    const dxy = env.dxy || { trend: 'FLAT', value: 0 };
    const btcTrend = env.btcTrend || { direction: 'FLAT', strength: 50 };
    const btcD = env.btcDominance || { trend: 'FLAT', value: 0 };
    const struct = env.btcStructure || { status: 'UNKNOWN', score: 50 };
    const rsi = env.btcRSI || { value: 50, status: 'HEALTHY' };
    const funding = env.funding || { rate: 0, status: 'NORMAL' };
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 1: MACRO (40 points)
    // ═══════════════════════════════════════════════════════════════════
    
    // DXY (10 points)
    if (dxy.trend === 'FALLING') {
        score += 10;
        details.push({ label: 'DXY', value: '▼ DOWN', status: 'ok', points: '+10' });
    } else if (dxy.trend === 'RISING') {
        score += 2;
        details.push({ label: 'DXY', value: '▲ UP', status: 'bad', points: '+2' });
    } else {
        score += 5;
        details.push({ label: 'DXY', value: '─ FLAT', status: 'warn', points: '+5' });
    }
    
    // BTC Trend (15 points)
    if ((dir === 'LONG' && btcTrend.direction === 'BULLISH') ||
        (dir === 'SHORT' && btcTrend.direction === 'BEARISH')) {
        score += 15;
        details.push({ label: 'BTC Trend', value: btcTrend.direction, status: 'ok', points: '+15' });
    } else if (btcTrend.direction === 'FLAT') {
        score += 7;
        details.push({ label: 'BTC Trend', value: 'FLAT', status: 'warn', points: '+7' });
    } else {
        score += 0;
        details.push({ label: 'BTC Trend', value: (btcTrend.direction || 'N/A') + ' ❌', status: 'bad', points: '+0' });
    }
    
    // BTC.D (15 points)
    if ((dir === 'LONG' && btcD.trend === 'FALLING') ||
        (dir === 'SHORT' && btcD.trend === 'RISING')) {
        score += 15;
        details.push({ label: 'BTC.D', value: btcD.trend === 'FALLING' ? '▼ ALTS' : '▲ BTC', status: 'ok', points: '+15' });
    } else if (btcD.trend === 'FLAT') {
        score += 7;
        details.push({ label: 'BTC.D', value: '─ FLAT', status: 'warn', points: '+7' });
    } else {
        score += 0;
        details.push({ label: 'BTC.D', value: btcD.trend === 'RISING' ? '▲ BTC SZN' : '▼ ALT SZN', status: 'bad', points: '+0' });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 2: BTC HEALTH (25 points)
    // ═══════════════════════════════════════════════════════════════════
    
    // BTC Structure (15 points)
    if (struct.status === 'INTACT') {
        score += 15;
        details.push({ label: 'Structure', value: 'INTACT', status: 'ok', points: '+15' });
    } else if ((dir === 'LONG' && struct.status === 'BROKEN_UP') ||
               (dir === 'SHORT' && struct.status === 'BROKEN_DOWN')) {
        score += 12;
        details.push({ label: 'Structure', value: struct.status, status: 'ok', points: '+12' });
    } else if (struct.status === 'UNKNOWN') {
        score += 7;
        details.push({ label: 'Structure', value: 'UNKNOWN', status: 'warn', points: '+7' });
    } else {
        score += 0;
        details.push({ label: 'Structure', value: (struct.status || 'N/A') + ' ❌', status: 'bad', points: '+0' });
    }
    
    // BTC RSI (10 points)
    if (rsi.status === 'HEALTHY') {
        score += 10;
        details.push({ label: 'BTC RSI', value: rsi.value + ' OK', status: 'ok', points: '+10' });
    } else if ((dir === 'LONG' && rsi.status === 'OVERSOLD') ||
               (dir === 'SHORT' && rsi.status === 'OVERBOUGHT')) {
        score += 10;
        details.push({ label: 'BTC RSI', value: rsi.value + ' ' + rsi.status, status: 'ok', points: '+10' });
    } else {
        score += 3;
        details.push({ label: 'BTC RSI', value: rsi.value + ' ⚠️', status: 'warn', points: '+3' });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 3: LEVERAGE (10 points)
    // ═══════════════════════════════════════════════════════════════════
    
    // Funding Rate (10 points)
    const fundingPct = ((funding.rate || 0) * 100).toFixed(3);
    if (funding.status === 'NORMAL') {
        score += 10;
        details.push({ label: 'Funding', value: fundingPct + '%', status: 'ok', points: '+10' });
    } else if (funding.status === 'ELEVATED') {
        if ((dir === 'LONG' && funding.rate < 0) || (dir === 'SHORT' && funding.rate > 0)) {
            score += 10;
            details.push({ label: 'Funding', value: fundingPct + '%', status: 'ok', points: '+10' });
        } else {
            score += 5;
            details.push({ label: 'Funding', value: fundingPct + '% ⚠️', status: 'warn', points: '+5' });
        }
    } else { // EXTREME
        if ((dir === 'LONG' && funding.rate > 0) || (dir === 'SHORT' && funding.rate < 0)) {
            score += 0;
            details.push({ label: 'Funding', value: fundingPct + '% ❌', status: 'bad', points: '+0' });
        } else {
            score += 10;
            details.push({ label: 'Funding', value: fundingPct + '%', status: 'ok', points: '+10' });
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 4: MARKET FLOW (10 points) - OI Analysis
    // ═══════════════════════════════════════════════════════════════════
    
    // Open Interest Analysis (10 points)
    const oiAnalysis = analyzeOIForSignal(dir, signal?.coinOI);
    score += oiAnalysis.score;
    
    if (oiAnalysis.status === 'CONFIRMED') {
        details.push({ label: 'OI Flow', value: '✅ CONFIRMED', status: 'ok', points: `+${oiAnalysis.score}` });
    } else if (oiAnalysis.status === 'SQUEEZE') {
        details.push({ label: 'OI Flow', value: '⚠️ SQUEEZE', status: 'warn', points: `+${oiAnalysis.score}` });
    } else if (oiAnalysis.status === 'DANGER') {
        details.push({ label: 'OI Flow', value: '❌ LIQUIDATIONS', status: 'bad', points: `+${oiAnalysis.score}` });
    } else {
        details.push({ label: 'OI Flow', value: '─ NEUTRAL', status: 'warn', points: `+${oiAnalysis.score}` });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 5: COIN SPECIFIC (15 points) - RS + HTF (reduced from 25)
    // ═══════════════════════════════════════════════════════════════════
    
    // Coin Relative Strength (8 points - reduced from 15)
    if (signal && signal.coinRS !== undefined) {
        const rs = signal.coinRS;
        if (rs >= 1.2) {
            score += 8;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x STRONG', status: 'ok', points: '+8' });
        } else if (rs >= 1.0) {
            score += 6;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x OK', status: 'ok', points: '+6' });
        } else if (rs >= 0.8) {
            score += 3;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x ⚠️', status: 'warn', points: '+3' });
        } else {
            score += 0;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x WEAK ❌', status: 'bad', points: '+0' });
        }
    } else {
        score += 4;
        details.push({ label: 'Coin RS', value: 'N/A', status: 'warn', points: '+4' });
    }
    
    // HTF Alignment (7 points - reduced from 10)
    if (signal && signal.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 0;
        if (htfPct >= 75) {
            score += 7;
            details.push({ label: 'HTF Align', value: Math.round(htfPct) + '% ✓', status: 'ok', points: '+7' });
        } else if (htfPct >= 50) {
            score += 4;
            details.push({ label: 'HTF Align', value: Math.round(htfPct) + '%', status: 'warn', points: '+4' });
        } else {
            score += 0;
            details.push({ label: 'HTF Align', value: Math.round(htfPct) + '% ❌', status: 'bad', points: '+0' });
        }
    } else {
        score += 3;
        details.push({ label: 'HTF Align', value: 'N/A', status: 'warn', points: '+3' });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // FINAL SCORE (100 points max)
    // DXY: 10 + BTC Trend: 15 + BTC.D: 15 + Structure: 15 + RSI: 10 + 
    // Funding: 10 + OI: 10 + RS: 8 + HTF: 7 = 100
    // ═══════════════════════════════════════════════════════════════════
    
    // Determine verdict based on 100-point scale
    let verdict = 'NO-GO';
    if (score >= 80) verdict = 'GO';
    else if (score >= 60) verdict = 'CAUTION';
    else if (score >= 40) verdict = 'RISKY';
    
    // Add OI warning if squeeze detected
    const oiWarning = oiAnalysis.warning;
    
    return { score, verdict, details, oiWarning };
}

// Update Environment Display
function updateEnvironmentDisplay() {
    const env = STATE.environment || {};
    
    // SAFETY: Default values
    const btcTrend = env.btcTrend || { direction: 'FLAT' };
    const btcDom = env.btcDominance || { trend: 'FLAT' };
    const dxy = env.dxy || { value: 0, trend: 'FLAT' };
    const struct = env.btcStructure || { status: 'UNKNOWN' };
    const rsi = env.btcRSI || { value: 50, status: 'HEALTHY' };
    const funding = env.funding || { rate: 0, status: 'NORMAL' };
    
    // BTC Trend
    const btcEl = document.getElementById('envBTC');
    const btcVal = document.getElementById('envBTCVal');
    if (btcVal && btcEl) {
        const trend = btcTrend.direction || 'FLAT';
        btcVal.textContent = trend === 'BULLISH' ? '🟢 BULL' : trend === 'BEARISH' ? '🔴 BEAR' : '🟡 FLAT';
        btcEl.className = 'env-status ' + (trend === 'BULLISH' ? 'go' : trend === 'BEARISH' ? 'nogo' : 'caution');
    }
    
    // BTC.D Trend
    const btcdEl = document.getElementById('envBTCD');
    const btcdVal = document.getElementById('envBTCDVal');
    if (btcdVal && btcdEl) {
        const trend = btcDom.trend || 'FLAT';
        btcdVal.textContent = trend === 'FALLING' ? '▼ ALTS' : trend === 'RISING' ? '▲ BTC' : '─ FLAT';
        btcdEl.className = 'env-status ' + (trend === 'FALLING' ? 'go' : trend === 'RISING' ? 'nogo' : 'caution');
    }
    
    // DXY Trend
    const dxyEl = document.getElementById('envDXY');
    const dxyVal = document.getElementById('envDXYVal');
    if (dxyVal && dxyEl) {
        const trend = dxy.trend || 'FLAT';
        const value = dxy.value || 0;
        dxyVal.textContent = value ? value.toFixed(1) + (trend === 'FALLING' ? '▼' : trend === 'RISING' ? '▲' : '') : '--';
        dxyEl.className = 'env-status ' + (trend === 'FALLING' ? 'go' : trend === 'RISING' ? 'nogo' : 'caution');
    }
    
    // Structure
    const structEl = document.getElementById('envStruct');
    const structVal = document.getElementById('envStructVal');
    if (structVal && structEl) {
        const status = struct.status || 'UNKNOWN';
        structVal.textContent = status === 'INTACT' ? '✅ OK' : status === 'BROKEN_UP' ? '⬆️ BRK' : status === 'BROKEN_DOWN' ? '⬇️ BRK' : '❓';
        structEl.className = 'env-status ' + (status === 'INTACT' ? 'go' : status === 'UNKNOWN' ? 'caution' : status === 'BROKEN_UP' ? 'caution' : 'nogo');
    }
    
    // RSI
    const rsiEl = document.getElementById('envRSI');
    const rsiVal = document.getElementById('envRSIVal');
    if (rsiVal && rsiEl) {
        const rsiStatus = rsi.status || 'HEALTHY';
        const rsiValue = rsi.value || 50;
        rsiVal.textContent = rsiValue + (rsiStatus === 'HEALTHY' ? '' : rsiStatus === 'OVERBOUGHT' ? '🔥' : '❄️');
        rsiEl.className = 'env-status ' + (rsiStatus === 'HEALTHY' ? 'go' : 'caution');
    }
    
    // Funding
    const fundEl = document.getElementById('envFund');
    const fundVal = document.getElementById('envFundVal');
    if (fundVal && fundEl) {
        const rate = funding.rate || 0;
        const status = funding.status || 'NORMAL';
        fundVal.textContent = (rate * 100).toFixed(2) + '%';
        fundEl.className = 'env-status ' + (status === 'NORMAL' ? 'go' : status === 'ELEVATED' ? 'caution' : 'nogo');
    }
    
    // Calculate overall score for favored direction
    const longEnv = calculateEnvironmentScore('LONG');
    const shortEnv = calculateEnvironmentScore('SHORT');
    
    let favoredDir = null;
    let bestScore = 0;
    let bestVerdict = 'NO-GO';
    
    if (longEnv.score > shortEnv.score) {
        favoredDir = 'LONG';
        bestScore = longEnv.score;
        bestVerdict = longEnv.verdict;
    } else if (shortEnv.score > longEnv.score) {
        favoredDir = 'SHORT';
        bestScore = shortEnv.score;
        bestVerdict = shortEnv.verdict;
    } else {
        bestScore = longEnv.score;
        bestVerdict = longEnv.verdict;
    }
    
    STATE.environment.score = bestScore;
    STATE.environment.verdict = bestVerdict;
    STATE.environment.favoredDirection = favoredDir;
    STATE.environment.lastUpdate = Date.now();
    
    // Update verdict display
    const verdictEl = document.getElementById('envVerdict');
    const scoreEl = document.getElementById('envScore');
    const verdictText = document.getElementById('envVerdictText');
    
    if (verdictEl && scoreEl && verdictText) {
        scoreEl.textContent = bestScore + '/100';
        const dirText = favoredDir ? (favoredDir === 'LONG' ? '📈' : '📉') : '';
        verdictText.textContent = dirText + ' ' + bestVerdict;
        
        const verdictClass = bestVerdict === 'GO' ? 'go' : 
                            bestVerdict === 'CAUTION' ? 'caution' : 
                            bestVerdict === 'RISKY' ? 'risky' : 'nogo';
        verdictEl.className = 'env-verdict ' + verdictClass;
    }
}

// V10.3 Structure Bar Update - Updates based on active signal or BTC structure
function updateStructureBar(structureData = null) {
    try {
        // Use provided structure data or try to get from current/selected signal
        const str = structureData || 
                   (STATE.current?.structure) || 
                   (STATE.selected?.structure) || 
                   (STATE.signals[0]?.structure) || 
                   null;
        
        // Channel
        const chEl = document.getElementById('strChannel');
        const chVal = document.getElementById('strChannelVal');
        if (chVal && chEl) {
            if (str?.channel?.isValid) {
                chVal.textContent = (str.channel.widthPct * 100).toFixed(1) + '%';
                chEl.className = 'str-status valid';
            } else {
                chVal.textContent = 'NO';
                chEl.className = 'str-status invalid';
            }
        }
        
        // Trendlines
        const tlEl = document.getElementById('strTrendline');
        const tlVal = document.getElementById('strTrendlineVal');
        if (tlVal && tlEl) {
            const bullCount = str?.trendlines?.bull?.length || 0;
            const bearCount = str?.trendlines?.bear?.length || 0;
            const totalTL = bullCount + bearCount;
            if (totalTL > 0) {
                tlVal.textContent = `↑${bullCount} ↓${bearCount}`;
                tlEl.className = 'str-status valid';
            } else {
                tlVal.textContent = 'NONE';
                tlEl.className = 'str-status neutral';
            }
        }
        
        // Compression
        const compEl = document.getElementById('strCompression');
        const compVal = document.getElementById('strCompressionVal');
        if (compVal && compEl) {
            if (str?.compression?.isCompressed) {
                compVal.textContent = '🔄 YES';
                compEl.className = 'str-status valid';
            } else if (str?.compression?.isExpanding) {
                compVal.textContent = '💥 EXP';
                compEl.className = 'str-status neutral';
            } else {
                compVal.textContent = 'NO';
                compEl.className = 'str-status';
            }
        }
        
        // Bias
        const biasEl = document.getElementById('strBias');
        const biasVal = document.getElementById('strBiasVal');
        if (biasVal && biasEl) {
            const bias = str?.bias || 'NEUTRAL';
            if (bias === 'DISCOUNT') {
                biasVal.textContent = '🟢 DISC';
                biasEl.className = 'str-status valid';
            } else if (bias === 'PREMIUM') {
                biasVal.textContent = '🔴 PREM';
                biasEl.className = 'str-status invalid';
            } else {
                biasVal.textContent = '⚖️ EQ';
                biasEl.className = 'str-status neutral';
            }
        }
        
        // Verdict
        const verdictEl = document.getElementById('strVerdict');
        const scoreEl = document.getElementById('strScore');
        const verdictText = document.getElementById('strVerdictText');
        if (verdictEl && scoreEl && verdictText) {
            const score = str?.score || 0;
            const gatePass = str?.gatePass !== false;
            
            scoreEl.textContent = score;
            verdictText.textContent = gatePass ? 'VALID' : 'WEAK';
            verdictEl.className = 'str-verdict ' + (gatePass && score >= 30 ? 'valid' : score >= 15 ? 'neutral' : 'invalid');
        }
        
    } catch (e) {
        // Silent: Structure bar
    }
}

// Full Environment Update
async function updateEnvironment() {
    try {
        // Fetch BTC analysis
        await fetchBTCAnalysis();
        
        // Update DXY trend from existing state
        if (STATE.dxy && STATE.dxy.price) {
            STATE.environment.dxy = {
                value: STATE.dxy.price,
                trend: STATE.dxy.price > STATE.dxy.prevPrice ? 'RISING' : 
                       STATE.dxy.price < STATE.dxy.prevPrice ? 'FALLING' : 'FLAT',
                favorable: STATE.dxy.price < STATE.dxy.prevPrice
            };
        }
        
        // Update BTC.D trend from existing state
        STATE.environment.btcDominance = {
            value: STATE.btcDominance || 0,
            trend: STATE.btcDomTrend === 'rising' ? 'RISING' : 
                   STATE.btcDomTrend === 'falling' ? 'FALLING' : 'FLAT'
        };
        
        // Update Funding from existing state
        if (STATE.funding !== null) {
            const rate = STATE.funding;
            STATE.environment.funding = {
                rate: rate,
                status: Math.abs(rate) > 0.001 ? 'EXTREME' : 
                        Math.abs(rate) > 0.0005 ? 'ELEVATED' : 'NORMAL'
            };
        }
        
        // Update display
        updateEnvironmentDisplay();
        
        // Update ALTS badge based on new environment
        updateAltsBadge();
        
    } catch (e) {
        console.error('Environment update error:', e);
    }
}

// Check if signal should be filtered based on environment
function shouldFilterSignal(signal) {
    const env = STATE.environment || {};
    const dir = signal?.direction || 'LONG';
    
    // SAFETY: Default values
    const structStatus = env.btcStructure?.status || 'UNKNOWN';
    const fundStatus = env.funding?.status || 'NORMAL';
    const fundRate = env.funding?.rate || 0;
    
    // HARD BLOCK 1: BTC Structure broken against signal
    if (dir === 'LONG' && structStatus === 'BROKEN_DOWN') {
        return { filter: true, reason: 'BTC Structure broken down - no longs' };
    }
    if (dir === 'SHORT' && structStatus === 'BROKEN_UP') {
        return { filter: true, reason: 'BTC Structure broken up - no shorts' };
    }
    
    // HARD BLOCK 2: Extreme funding against signal
    if (fundStatus === 'EXTREME') {
        if (dir === 'LONG' && fundRate > 0.001) {
            return { filter: true, reason: 'Extreme positive funding (longs crowded)' };
        }
        if (dir === 'SHORT' && fundRate < -0.001) {
            return { filter: true, reason: 'Extreme negative funding (shorts crowded)' };
        }
    }
    
    // HARD BLOCK 3: HTF severely misaligned (<25%)
    if (signal?.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 50;
        if (htfPct < 25) {
            return { filter: true, reason: 'HTF severely misaligned (' + Math.round(htfPct) + '%)' };
        }
    }
    
    // HARD BLOCK 4: Environment score too low (using signal for RS/HTF)
    const envScore = calculateEnvironmentScore(dir, signal);
    if (envScore.score < 30) {
        return { filter: true, reason: 'Environment score too low (' + envScore.score + '/100)' };
    }
    
    return { filter: false, reason: null };
}

// Get environment icons for signal card
function getEnvIcons(signal) {
    const env = STATE.environment || {};
    const dir = signal?.direction || 'LONG';
    const icons = [];
    
    // SAFETY: Default values
    const btcTrend = env.btcTrend?.direction || 'FLAT';
    const btcDomTrend = env.btcDominance?.trend || 'FLAT';
    const dxyTrend = env.dxy?.trend || 'FLAT';
    const structStatus = env.btcStructure?.status || 'UNKNOWN';
    const rsiStatus = env.btcRSI?.status || 'HEALTHY';
    const fundStatus = env.funding?.status || 'NORMAL';
    const fundRate = env.funding?.rate || 0;
    
    // BTC Trend
    const btcOk = (dir === 'LONG' && btcTrend === 'BULLISH') ||
                  (dir === 'SHORT' && btcTrend === 'BEARISH') ||
                  btcTrend === 'FLAT';
    icons.push({ label: 'BTC', ok: btcOk, warn: btcTrend === 'FLAT' });
    
    // BTC.D
    const btcdOk = (dir === 'LONG' && btcDomTrend === 'FALLING') ||
                   (dir === 'SHORT' && btcDomTrend === 'RISING') ||
                   btcDomTrend === 'FLAT';
    icons.push({ label: 'D', ok: btcdOk, warn: btcDomTrend === 'FLAT' });
    
    // DXY
    const dxyOk = dxyTrend === 'FALLING' || dxyTrend === 'FLAT';
    icons.push({ label: 'DXY', ok: dxyOk, warn: dxyTrend === 'FLAT' });
    
    // Structure
    const structOk = structStatus === 'INTACT' ||
                     (dir === 'LONG' && structStatus === 'BROKEN_UP') ||
                     (dir === 'SHORT' && structStatus === 'BROKEN_DOWN');
    icons.push({ label: 'STR', ok: structOk, warn: structStatus === 'UNKNOWN' });
    
    // RSI
    const rsiOk = rsiStatus === 'HEALTHY' ||
                  (dir === 'LONG' && rsiStatus === 'OVERSOLD') ||
                  (dir === 'SHORT' && rsiStatus === 'OVERBOUGHT');
    icons.push({ label: 'RSI', ok: rsiOk, warn: !rsiOk });
    
    // Funding
    const fundOk = fundStatus === 'NORMAL' ||
                   (dir === 'LONG' && fundRate < 0) ||
                   (dir === 'SHORT' && fundRate > 0);
    icons.push({ label: 'FND', ok: fundOk, warn: fundStatus === 'ELEVATED' });
    
    // HTF (from signal)
    if (signal?.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 0;
        const htfOk = htfPct >= 50;
        icons.push({ label: 'HTF', ok: htfOk, warn: htfPct >= 33 && htfPct < 50 });
    }
    
    return icons;
}

// Generate Environment HTML for signal card
function generateEnvIconsHtml(signal) {
    const icons = getEnvIcons(signal);
    const envScore = calculateEnvironmentScore(signal?.direction, signal);
    
    let html = '<div class="signal-env">';
    icons.forEach(icon => {
        const statusClass = icon.ok ? 'ok' : icon.warn ? 'warn' : 'bad';
        const symbol = icon.ok ? '✓' : icon.warn ? '!' : '✗';
        html += `<span class="env-icon ${statusClass}" title="${icon.label}">${icon.label}${symbol}</span>`;
    });
    html += `<span class="env-icon ${envScore.verdict === 'GO' ? 'ok' : envScore.verdict === 'CAUTION' ? 'warn' : 'bad'}">${envScore.score}</span>`;
    html += '</div>';
    
    return html;
}

// Generate Environment Panel HTML for main panel
function generateEnvPanelHtml(signal) {
    const envScore = calculateEnvironmentScore(signal?.direction, signal);
    const verdictClass = envScore.verdict === 'GO' ? 'go' : 
                        envScore.verdict === 'CAUTION' ? 'caution' : 
                        envScore.verdict === 'RISKY' ? 'risky' : 'nogo';
    
    let html = `
    <div class="env-panel">
        <div class="env-panel-title">📊 ENVIRONMENT ANALYSIS</div>`;
    
    envScore.details.forEach(d => {
        html += `
        <div class="env-row">
            <span class="label">${d.label}</span>
            <span class="value ${d.status}">${d.value}<span class="points">${d.points}</span></span>
        </div>`;
    });
    
    html += `
        <div class="env-divider"></div>
        <div class="env-total">
            <span>ENVIRONMENT SCORE:</span>
            <span class="score ${verdictClass}">${envScore.score}/100 ${envScore.verdict}</span>
        </div>
    </div>`;
    
    return html;
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARKET BADGES DATA FETCHING
// ═══════════════════════════════════════════════════════════════════════════════

// Fetch Fear & Greed Index
async function fetchFearGreed() {
    try {
        const d = await fetchJSON('https://api.alternative.me/fng/?limit=1');
        if (d && d.data && d.data[0]) {
            const value = parseInt(d.data[0].value);
            STATE.fearGreed = value;
            const badge = document.getElementById('badgeFG');
            const val = document.getElementById('badgeFGVal');
            if (val) {
                val.textContent = value;
                // Green for fear (<=40 = buying opportunity), Red for greed (>=60 = caution)
                if (value <= 40) {
                    badge.className = 'info-badge go';
                } else if (value >= 60) {
                    badge.className = 'info-badge nogo';
                } else {
                    badge.className = 'info-badge caution';
                }
            }
        }
    } catch(e) { /* Silent fail */ }
}

// Fetch DXY Index
async function fetchDXY() {
    try {
        // V5.1 FIX: DXY estimation from BTC inverse correlation
        // When BTC rises, DXY typically falls (80%+ correlation)
        // This is MORE RELIABLE than proxy-dependent Yahoo fetch
        
        const btcKlines = await fetchKlines('BTCUSDT', '60', 24);
        if (btcKlines && btcKlines.length >= 24) {
            const btcNow = btcKlines[btcKlines.length - 1].close;
            const btc24hAgo = btcKlines[0].close;
            const btcChange = (btcNow - btc24hAgo) / btc24hAgo;
            
            // Inverse correlation: BTC up = DXY down
            const estimatedDXYChange = -btcChange * 0.5; // DXY moves ~50% of inverse BTC
            const baseDXY = 104; // Typical DXY range
            const estimatedDXY = baseDXY * (1 + estimatedDXYChange);
            
            STATE.dxy = { 
                price: estimatedDXY, 
                prevPrice: baseDXY,
                estimated: true,
                btcBased: true
            };
            
            // Also update environment
            if (!STATE.environment) STATE.environment = {};
            if (btcChange > 0.005) {
                STATE.environment.dxy = { trend: 'FALLING', value: estimatedDXY };
            } else if (btcChange < -0.005) {
                STATE.environment.dxy = { trend: 'RISING', value: estimatedDXY };
            } else {
                STATE.environment.dxy = { trend: 'FLAT', value: estimatedDXY };
            }
        }
    } catch(e) { 
        // Silent fail
        // Fallback to FLAT
        STATE.environment = STATE.environment || {};
        STATE.environment.dxy = { trend: 'FLAT', value: 104 };
    }
}

// Fetch Funding Rate - BINANCE API
async function fetchFunding() {
    try {
        const d = await fetchJSON(`${CONFIG.BYBIT_V5}/market/tickers?category=linear&symbol=BTCUSDT`);
        if (d && d.lastFundingRate) {
            const rate = parseFloat(d.lastFundingRate);
            STATE.funding = rate; // Store as decimal (e.g., 0.0001 = 0.01%)
            // Funding display now handled by Environment Bar
        }
    } catch(e) { /* Silent fail */ }
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🕐 SESSION & TIMEZONE AWARENESS SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Initialize awareness state
if (!STATE.awareness) {
    STATE.awareness = {
        timezone: 'auto',
        currentSession: null,
        nextSession: null,
        news: [],
        lastNewsUpdate: 0
    };
}

// Trading sessions in UTC
const TRADING_SESSIONS = {
    ASIA: { start: 0, end: 8, name: 'ASIA', emoji: '🌏', volatility: 'LOW', color: 'var(--cyan)' },
    LONDON: { start: 8, end: 16, name: 'LONDON', emoji: '🇬🇧', volatility: 'HIGH', color: 'var(--amber)' },
    NEW_YORK: { start: 13, end: 21, name: 'NEW YORK', emoji: '🇺🇸', volatility: 'HIGH', color: 'var(--amber)' },
    OVERLAP: { start: 13, end: 16, name: 'LONDON/NY OVERLAP', emoji: '🔥', volatility: 'EXTREME', color: 'var(--short)' },
    OFF_HOURS: { start: 21, end: 24, name: 'OFF HOURS', emoji: '😴', volatility: 'LOW', color: 'var(--text3)' }
};

// Get user's local time based on selected timezone
function getUserTime() {
    const tz = STATE.awareness.timezone || 'auto';
    const options = { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: true,
        timeZone: tz === 'auto' ? undefined : tz
    };
    return new Date().toLocaleTimeString('en-US', options);
}

// Get user's timezone name
function getUserTimezoneName() {
    const tz = STATE.awareness.timezone || 'auto';
    if (tz === 'auto') {
        return Intl.DateTimeFormat().resolvedOptions().timeZone.split('/').pop().replace('_', ' ');
    }
    return tz.split('/').pop().replace('_', ' ');
}

// Get current UTC hour
function getUTCHour() {
    return new Date().getUTCHours();
}

// Determine current trading session
function getCurrentSession() {
    const utcHour = getUTCHour();
    
    // Check for overlap first (highest priority)
    if (utcHour >= 13 && utcHour < 16) {
        return TRADING_SESSIONS.OVERLAP;
    }
    // London session
    if (utcHour >= 8 && utcHour < 16) {
        return TRADING_SESSIONS.LONDON;
    }
    // New York session
    if (utcHour >= 13 && utcHour < 21) {
        return TRADING_SESSIONS.NEW_YORK;
    }
    // Asia session
    if (utcHour >= 0 && utcHour < 8) {
        return TRADING_SESSIONS.ASIA;
    }
    // Off hours
    return TRADING_SESSIONS.OFF_HOURS;
}

// Get next session and time until it starts
function getNextSession() {
    const utcHour = getUTCHour();
    const utcMinute = new Date().getUTCMinutes();
    
    let nextSession, hoursUntil;
    
    if (utcHour < 8) {
        nextSession = TRADING_SESSIONS.LONDON;
        hoursUntil = 8 - utcHour;
    } else if (utcHour < 13) {
        nextSession = TRADING_SESSIONS.OVERLAP;
        hoursUntil = 13 - utcHour;
    } else if (utcHour < 16) {
        nextSession = TRADING_SESSIONS.NEW_YORK;
        hoursUntil = 16 - utcHour;
    } else if (utcHour < 21) {
        nextSession = TRADING_SESSIONS.OFF_HOURS;
        hoursUntil = 21 - utcHour;
    } else {
        nextSession = TRADING_SESSIONS.ASIA;
        hoursUntil = (24 - utcHour) + 0;
    }
    
    const minutesUntil = 60 - utcMinute;
    const totalMinutes = (hoursUntil - 1) * 60 + minutesUntil;
    
    return {
        session: nextSession,
        hours: Math.floor(totalMinutes / 60),
        minutes: totalMinutes % 60
    };
}

// Fetch crypto news/events
async function fetchCryptoNews() {
    try {
        // Using CoinGecko's free events API
        const events = [];
        
        // Check for known major events (hardcoded for reliability)
        const now = new Date();
        const today = now.toISOString().split('T')[0];
        
        // Major recurring events to watch
        const majorEvents = [
            { day: 'Wednesday', time: '18:00', name: 'FOMC Minutes', impact: 'HIGH' },
            { day: 'Friday', time: '12:30', name: 'US Jobs Report', impact: 'HIGH' },
            { day: 'Thursday', time: '12:30', name: 'US CPI Data', impact: 'HIGH' },
        ];
        
        const dayOfWeek = now.toLocaleDateString('en-US', { weekday: 'long' });
        
        majorEvents.forEach(event => {
            if (event.day === dayOfWeek) {
                events.push({
                    name: event.name,
                    time: event.time + ' UTC',
                    impact: event.impact,
                    emoji: event.impact === 'HIGH' ? '⚠️' : '📰'
                });
            }
        });
        
        // Try to fetch live news from alternative API
        try {
            const newsUrl = 'https://api.coingecko.com/api/v3/events';
            const d = await fetchJSON(newsUrl);
            if (d && d.data && Array.isArray(d.data)) {
                const todayEvents = d.data.filter(e => e.start_date && e.start_date.startsWith(today)).slice(0, 3);
                todayEvents.forEach(e => {
                    events.push({
                        name: e.title || 'Crypto Event',
                        time: e.start_date,
                        impact: 'MEDIUM',
                        emoji: '📅'
                    });
                });
            }
        } catch (e) {
            // Ignore if news fetch fails - use static events only
        }
        
        STATE.awareness.news = events;
        STATE.awareness.lastNewsUpdate = Date.now();
        
    } catch(e) { 
        // Silent fail
        STATE.awareness.news = [];
    }
}

// Generate awareness check HTML for main panel
function generateAwarenessHtml() {
    const session = getCurrentSession();
    const nextSess = getNextSession();
    const userTime = getUserTime();
    const cityName = getUserTimezoneName();
    const news = STATE.awareness.news || [];
    
    const volColor = session.volatility === 'EXTREME' ? 'var(--short)' : 
                     session.volatility === 'HIGH' ? 'var(--amber)' : 'var(--long)';
    const volBg = session.volatility === 'EXTREME' ? 'var(--short-dim)' : 
                  session.volatility === 'HIGH' ? 'var(--amber-dim)' : 'var(--long-dim)';
    
    let newsHtml = '';
    if (news.length > 0) {
        newsHtml = news.map(n => `
            <div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0">
                <span style="font-size:11px">${n.emoji} ${n.name}</span>
                <span style="font-size:10px;color:${n.impact === 'HIGH' ? 'var(--short)' : 'var(--amber)'}">${n.time}</span>
            </div>
        `).join('');
    } else {
        newsHtml = '<div style="font-size:11px;color:var(--text3)">✅ No major news today</div>';
    }
    
    // Generate tips based on session
    let tips = [];
    if (session.volatility === 'EXTREME') {
        tips = ['⚠️ Widen SL by 20% during overlap', '⚠️ Reduce position size', '⚠️ Expect fast moves'];
    } else if (session.volatility === 'HIGH') {
        tips = ['📈 Good for breakout trades', '💡 Watch for fake-outs at open', '⏰ First 30min = volatile'];
    } else if (session.name === 'ASIA') {
        tips = ['📊 Range-bound trading likely', '💡 Good for scalping S/R', '😴 Lower volume expected'];
    } else {
        tips = ['😴 Low liquidity period', '⚠️ Spreads may widen', '💤 Consider waiting'];
    }
    
    return `
        <div style="background:var(--bg4);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px">
            <div style="font-size:12px;font-weight:700;color:var(--purple);margin-bottom:10px;display:flex;justify-content:space-between;align-items:center">
                <span>⚠️ AWARENESS CHECK</span>
                <span style="font-size:10px;color:var(--text3)">${userTime}</span>
            </div>
            
            <!-- Session Info -->
            <div style="background:${volBg};border:1px solid ${volColor};border-radius:6px;padding:10px;margin-bottom:10px">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                    <span style="font-size:13px;font-weight:700;color:${volColor}">${session.emoji} ${session.name}</span>
                    <span style="font-size:10px;padding:2px 8px;border-radius:3px;background:${volColor};color:var(--bg1);font-weight:600">${session.volatility} VOL</span>
                </div>
                <div style="font-size:10px;color:var(--text2)">
                    🕐 Your time: ${userTime} (${cityName})
                </div>
                <div style="font-size:10px;color:var(--text3);margin-top:4px">
                    ⏭️ Next: ${nextSess.session.emoji} ${nextSess.session.name} in ${nextSess.hours}h ${nextSess.minutes}m
                </div>
            </div>
            
            <!-- News -->
            <div style="background:var(--bg3);border-radius:6px;padding:8px;margin-bottom:10px">
                <div style="font-size:11px;font-weight:600;color:var(--amber);margin-bottom:6px">📰 TODAY'S NEWS</div>
                ${newsHtml}
            </div>
            
            <!-- Tips -->
            <div style="background:var(--bg3);border-radius:6px;padding:8px">
                <div style="font-size:11px;font-weight:600;color:var(--cyan);margin-bottom:6px">💡 SESSION TIPS</div>
                ${tips.map(t => `<div style="font-size:10px;color:var(--text2);padding:2px 0">${t}</div>`).join('')}
            </div>
        </div>
    `;
}

// Update timezone preview in settings
function updateTimezonePreview() {
    const preview = document.getElementById('timezonePreview');
    if (preview) {
        const session = getCurrentSession();
        const userTime = getUserTime();
        const cityName = getUserTimezoneName();
        preview.innerHTML = `🕐 ${userTime} (${cityName}) | ${session.emoji} ${session.name} | ${session.volatility} Vol`;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// OPEN INTEREST & LIQUIDATION TRACKING
// ═══════════════════════════════════════════════════════════════════════════════

// Initialize OI state
if (!STATE.openInterest) {
    STATE.openInterest = {
        btc: { current: 0, previous: 0, change1h: 0, change24h: 0 },
        history: [],
        lastUpdate: 0
    };
}

if (!STATE.liquidations) {
    STATE.liquidations = {
        longs1h: 0,
        shorts1h: 0,
        totalLongs24h: 0,
        totalShorts24h: 0,
        lastUpdate: 0
    };
}

// Fetch BTC Open Interest - BINANCE API
async function fetchBTCOpenInterest() {
    try {
        // Get current OI
        const currentData = await fetchJSON(`${CONFIG.BYBIT_V5}/market/open-interest?category=linear&symbol=BTCUSDT`);
        
        // Get historical OI
        const histData = await fetchJSON(`${CONFIG.BYBIT_V5}/market/open-interest?category=linear&intervalTime=1h&limit=25&symbol=BTCUSDT&period=1h&limit=25`);
        
        if (currentData && currentData.openInterest) {
            const currentOI = parseFloat(currentData.openInterest);
            const previousOI = STATE.openInterest.btc.current || currentOI;
            
            // Store OI history for trend analysis
            if (histData && Array.isArray(histData)) {
                STATE.openInterest.history = histData.map(item => ({
                    oi: parseFloat(item.sumOpenInterest),
                    time: parseInt(item.timestamp)
                }));
            }
            
            // Calculate changes
            let oi1hAgo = currentOI;
            let oi24hAgo = currentOI;
            
            if (histData && Array.isArray(histData) && histData.length > 1) {
                oi1hAgo = parseFloat(histData[histData.length - 2]?.sumOpenInterest) || currentOI;
                oi24hAgo = histData.length > 23 ? parseFloat(histData[histData.length - 24]?.sumOpenInterest) || currentOI : currentOI;
            }
            
            const change1h = oi1hAgo > 0 ? ((currentOI - oi1hAgo) / oi1hAgo) * 100 : 0;
            const change24h = oi24hAgo > 0 ? ((currentOI - oi24hAgo) / oi24hAgo) * 100 : 0;
            
            STATE.openInterest.btc = {
                current: currentOI,
                previous: previousOI,
                change1h: change1h,
                change24h: change24h,
                trend: change1h > 0.5 ? 'RISING' : change1h < -0.5 ? 'FALLING' : 'FLAT'
            };
            
            STATE.openInterest.lastUpdate = Date.now();
            
            // Update ENV bar OI display
            updateOIDisplay();
            
            // Update Market Flow panel
            updateMarketFlowPanel();
            
            console.log(`📊 BTC OI: ${(currentOI / 1e9).toFixed(2)}B (${change1h >= 0 ? '+' : ''}${change1h.toFixed(2)}% 1H)`);
        }
    } catch (e) {
        // Silent fail
    }
}

// Fetch coin-specific OI - BINANCE API
async function fetchCoinOI(symbol) {
    try {
        // Current OI
        const currentData = await fetchJSON(`${CONFIG.BYBIT_V5}/market/open-interest?category=linear&symbol=${symbol}`);
        
        if (currentData && currentData.openInterest) {
            const currentOI = parseFloat(currentData.openInterest);
            
            // Get 1h historical for change calculation
            const histData = await fetchJSON(`${CONFIG.BYBIT_V5}/market/open-interest?category=linear&intervalTime=1h&limit=25&symbol=${symbol}&period=1h&limit=2`);
            
            let prevOI = currentOI;
            if (histData && Array.isArray(histData) && histData.length > 1) {
                prevOI = parseFloat(histData[histData.length - 2]?.sumOpenInterest) || currentOI;
            }
            
            const change = prevOI > 0 ? ((currentOI - prevOI) / prevOI) * 100 : 0;
            
            return {
                current: currentOI,
                change1h: change,
                trend: change > 0.5 ? 'RISING' : change < -0.5 ? 'FALLING' : 'FLAT'
            };
        }
    } catch (e) {
        // Silent fail
    }
    return null;
}

// Fetch recent liquidations (estimated from funding + OI changes)
async function fetchLiquidations() {
    try {
        // Binance doesn't have direct liquidation API for free
        // We estimate based on OI drops during price moves
        
        const btcOI = STATE.openInterest.btc;
        const btcChange = STATE.btc.change || 0;
        
        // Estimate liquidations based on OI change vs price change
        let longsLiq = 0;
        let shortsLiq = 0;
        
        if (btcOI.change1h < -1 && btcChange < -1) {
            // OI down + Price down = Long liquidations
            longsLiq = Math.abs(btcOI.change1h) * 5; // Rough estimate in $M
        } else if (btcOI.change1h < -1 && btcChange > 1) {
            // OI down + Price up = Short liquidations
            shortsLiq = Math.abs(btcOI.change1h) * 5;
        }
        
        STATE.liquidations = {
            longs1h: longsLiq,
            shorts1h: shortsLiq,
            bias: longsLiq > shortsLiq ? 'LONGS_LIQUIDATED' : 
                  shortsLiq > longsLiq ? 'SHORTS_LIQUIDATED' : 'BALANCED',
            lastUpdate: Date.now()
        };
        
        updateMarketFlowPanel();
        
    } catch (e) {
        // Silent fail
    }
}

// Update OI display in ENV bar
function updateOIDisplay() {
    const oiEl = document.getElementById('envOI');
    const oiVal = document.getElementById('envOIVal');
    
    if (oiVal && oiEl) {
        const btcOI = STATE.openInterest.btc;
        const change = btcOI.change1h || 0;
        const arrow = change > 0.5 ? '▲' : change < -0.5 ? '▼' : '';
        const sign = change >= 0 ? '+' : '';
        
        oiVal.textContent = `${sign}${change.toFixed(1)}%${arrow}`;
        
        // Color based on OI trend
        if (change > 1) {
            oiEl.className = 'env-status go';
        } else if (change < -1) {
            oiEl.className = 'env-status nogo';
        } else {
            oiEl.className = 'env-status caution';
        }
    }
}

// Toggle Market Flow panel
function toggleFlow() {
    const content = document.getElementById('flowContent');
    const toggle = document.getElementById('flowToggle');
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    safeStorageSet('flowExpanded', !isExpanded);
}

// Restore Flow panel state
function restoreFlowState() {
    const expandedVal = safeStorageGet('flowExpanded', false);
    const expanded = expandedVal === true || expandedVal === 'true';
    if (expanded) {
        document.getElementById('flowContent')?.classList.add('expanded');
        document.getElementById('flowToggle')?.classList.add('expanded');
        // Also expand new panel
        document.getElementById('flowContentNew')?.classList.add('expanded');
        document.getElementById('flowToggleNew')?.classList.add('expanded');
    }
}

// Toggle NEW compact Flow panel
function toggleFlowNew() {
    const content = document.getElementById('flowContentNew');
    const toggle = document.getElementById('flowToggleNew');
    if (!content || !toggle) return;
    
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    safeStorageSet('flowExpanded', !isExpanded);
}

// Toggle NEW compact Backtest panel
function toggleBacktestNew() {
    const content = document.getElementById('backtestContentNew');
    const toggle = document.getElementById('backtestToggleNew');
    if (!content || !toggle) return;
    
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    safeStorageSet('backtestExpanded', !isExpanded);
}

// Quick select timeframes for backtest
function btSelectTF(mode) {
    const tf5m = document.getElementById('btTF5m');
    const tf15m = document.getElementById('btTF15m');
    const tf30m = document.getElementById('btTF30m');
    const tf1h = document.getElementById('btTF1h');
    const tf4h = document.getElementById('btTF4h');
    const tf1d = document.getElementById('btTF1d');
    
    // Uncheck all first
    if (tf5m) tf5m.checked = false;
    if (tf15m) tf15m.checked = false;
    if (tf30m) tf30m.checked = false;
    if (tf1h) tf1h.checked = false;
    if (tf4h) tf4h.checked = false;
    if (tf1d) tf1d.checked = false;
    
    // Set based on mode
    switch(mode) {
        case '15m':
            if (tf15m) tf15m.checked = true;
            break;
        case '30m':
            if (tf30m) tf30m.checked = true;
            break;
        case '1h':
            if (tf1h) tf1h.checked = true;
            break;
        case '4h':
            if (tf4h) tf4h.checked = true;
            break;
        case 'all':
            if (tf15m) tf15m.checked = true;
            if (tf30m) tf30m.checked = true;
            if (tf1h) tf1h.checked = true;
            if (tf4h) tf4h.checked = true;
            break;
    }
}

// Restore NEW panels state
function restoreNewPanelsState() {
    // Flow panel
    const flowExpanded = safeStorageGet('flowExpanded', false);
    if (flowExpanded === true || flowExpanded === 'true') {
        document.getElementById('flowContentNew')?.classList.add('expanded');
        document.getElementById('flowToggleNew')?.classList.add('expanded');
    }
    // Backtest panel
    const btExpanded = safeStorageGet('backtestExpanded', false);
    if (btExpanded === true || btExpanded === 'true') {
        document.getElementById('backtestContentNew')?.classList.add('expanded');
        document.getElementById('backtestToggleNew')?.classList.add('expanded');
    }
}

// Update Market Flow panel (both old and new compact)
function updateMarketFlowPanel() {
    const btcOI = STATE.openInterest.btc;
    const btcPrice = STATE.btc || {};
    const liq = STATE.liquidations || {};
    
    // Calculate values once
    const oiInB = (btcOI.current / 1e9).toFixed(2);
    const change = btcOI.change1h || 0;
    const changeText = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
    const changeClass = `flow-change ${change > 0 ? 'up' : change < 0 ? 'down' : 'neutral'}`;
    
    // BTC OI Value - OLD panel
    const flowBtcOI = document.getElementById('flowBtcOI');
    const flowBtcOIChange = document.getElementById('flowBtcOIChange');
    if (flowBtcOI) {
        flowBtcOI.textContent = `$${oiInB}B`;
        flowBtcOIChange.textContent = `${changeText} 1H`;
        flowBtcOIChange.className = changeClass;
    }
    
    // BTC OI Value - NEW compact panel
    const flowBtcOINew = document.getElementById('flowBtcOINew');
    const flowBtcOIChangeNew = document.getElementById('flowBtcOIChangeNew');
    if (flowBtcOINew) {
        flowBtcOINew.textContent = `$${oiInB}B`;
        flowBtcOIChangeNew.textContent = changeText;
        flowBtcOIChangeNew.className = changeClass;
    }
    
    // OI vs Price interpretation
    const oiChange = btcOI.change1h || 0;
    const priceChange = btcPrice.change || 0;
    
    let interpretation = 'NEUTRAL';
    let status = 'neutral';
    
    if (priceChange > 0.5 && oiChange > 0.5) {
        interpretation = '✅ REAL BUY';
        status = 'up';
    } else if (priceChange > 0.5 && oiChange < -0.5) {
        interpretation = '⚠️ SQUEEZE';
        status = 'down';
    } else if (priceChange < -0.5 && oiChange > 0.5) {
        interpretation = '✅ REAL SELL';
        status = 'up';
    } else if (priceChange < -0.5 && oiChange < -0.5) {
        interpretation = '⚠️ LONG LIQ';
        status = 'down';
    }
    
    const priceStatusText = `P:${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(1)}%`;
    
    // OLD panel
    const flowOIPrice = document.getElementById('flowOIPrice');
    const flowOIPriceStatus = document.getElementById('flowOIPriceStatus');
    if (flowOIPrice) {
        flowOIPrice.textContent = interpretation;
        flowOIPriceStatus.textContent = priceStatusText;
        flowOIPriceStatus.className = `flow-change ${status}`;
    }
    
    // NEW compact panel
    const flowOIPriceNew = document.getElementById('flowOIPriceNew');
    const flowOIPriceStatusNew = document.getElementById('flowOIPriceStatusNew');
    if (flowOIPriceNew) {
        flowOIPriceNew.textContent = interpretation.replace('✅ ', '').replace('⚠️ ', '');
        flowOIPriceStatusNew.textContent = priceStatusText;
        flowOIPriceStatusNew.className = `flow-change ${status}`;
    }
    
    // Store interpretation for signal filtering
    STATE.openInterest.interpretation = interpretation.includes('REAL') ? 'REAL' : 
                                        interpretation.includes('SQUEEZE') ? 'SQUEEZE' : 
                                        interpretation.includes('LIQ') ? 'LIQUIDATION' : 'NEUTRAL';
    
    // Liquidations - OLD panel
    const flowLongsLiq = document.getElementById('flowLongsLiq');
    const flowShortsLiq = document.getElementById('flowShortsLiq');
    if (flowLongsLiq && flowShortsLiq) {
        flowLongsLiq.textContent = `$${(liq.longs1h || 0).toFixed(1)}M`;
        flowShortsLiq.textContent = `$${(liq.shorts1h || 0).toFixed(1)}M`;
        
        document.getElementById('flowLongsLiqPct').textContent = liq.longs1h > 5 ? '🔥 HIGH' : 'Normal';
        document.getElementById('flowLongsLiqPct').className = `flow-change ${liq.longs1h > 5 ? 'down' : 'neutral'}`;
        
        document.getElementById('flowShortsLiqPct').textContent = liq.shorts1h > 5 ? '🔥 HIGH' : 'Normal';
        document.getElementById('flowShortsLiqPct').className = `flow-change ${liq.shorts1h > 5 ? 'down' : 'neutral'}`;
    }
    
    // Liquidations - NEW compact panel
    const flowLongsLiqNew = document.getElementById('flowLongsLiqNew');
    const flowShortsLiqNew = document.getElementById('flowShortsLiqNew');
    if (flowLongsLiqNew && flowShortsLiqNew) {
        flowLongsLiqNew.textContent = `$${(liq.longs1h || 0).toFixed(1)}M`;
        flowShortsLiqNew.textContent = `$${(liq.shorts1h || 0).toFixed(1)}M`;
        
        const flowLongsLiqPctNew = document.getElementById('flowLongsLiqPctNew');
        const flowShortsLiqPctNew = document.getElementById('flowShortsLiqPctNew');
        if (flowLongsLiqPctNew) {
            flowLongsLiqPctNew.textContent = liq.longs1h > 5 ? '🔥' : 'OK';
            flowLongsLiqPctNew.className = `flow-change ${liq.longs1h > 5 ? 'down' : 'neutral'}`;
        }
        if (flowShortsLiqPctNew) {
            flowShortsLiqPctNew.textContent = liq.shorts1h > 5 ? '🔥' : 'OK';
            flowShortsLiqPctNew.className = `flow-change ${liq.shorts1h > 5 ? 'down' : 'neutral'}`;
        }
    }
    
    // Market Bias calculation
    const interp = STATE.openInterest.interpretation || 'NEUTRAL';
    let bias = 'NEUTRAL';
    let biasClass = 'neutral';
    
    if (interp === 'REAL' && priceChange > 0) {
        bias = '🟢 BULLISH';
        biasClass = 'bullish';
    } else if (interp === 'REAL' && priceChange < 0) {
        bias = '🔴 BEARISH';
        biasClass = 'bearish';
    } else if (interp === 'SQUEEZE') {
        bias = '⚠️ SQUEEZE';
        biasClass = 'squeeze';
    } else if (interp === 'LIQUIDATION') {
        bias = '💀 LIQUIDATIONS';
        biasClass = 'squeeze';
    }
    
    // OLD panel bias
    const flowBias = document.getElementById('flowBias');
    const flowStatus = document.getElementById('flowStatus');
    if (flowBias) {
        flowBias.textContent = bias;
        flowBias.className = `flow-verdict-value ${biasClass}`;
        
        if (flowStatus) {
            flowStatus.textContent = bias.replace(/[🟢🔴⚠️💀]/g, '').trim();
            flowStatus.className = `flow-status ${biasClass}`;
        }
    }
    
    // NEW compact panel bias
    const flowBiasNew = document.getElementById('flowBiasNew');
    if (flowBiasNew) {
        flowBiasNew.textContent = bias;
        flowBiasNew.className = `value ${biasClass}`;
    }
}

// Analyze OI for signal validation
function analyzeOIForSignal(direction, coinOI = null) {
    const btcOI = STATE.openInterest.btc;
    const btcPrice = STATE.btc || {};
    const interp = STATE.openInterest.interpretation || 'NEUTRAL';
    
    let score = 5; // Base score
    let status = 'NEUTRAL';
    let warning = null;
    
    // Check if OI confirms direction
    if (direction === 'LONG') {
        if (interp === 'REAL' && btcPrice.change > 0) {
            // Real buying - great for longs
            score = 10;
            status = 'CONFIRMED';
        } else if (interp === 'SQUEEZE') {
            // Short squeeze - risky for new longs
            score = 3;
            status = 'SQUEEZE';
            warning = 'Short squeeze detected - risky entry';
        } else if (interp === 'LIQUIDATION') {
            // Long liquidations - terrible for longs
            score = 0;
            status = 'DANGER';
            warning = 'Long liquidations in progress';
        }
    } else { // SHORT
        if (interp === 'REAL' && btcPrice.change < 0) {
            // Real selling - great for shorts
            score = 10;
            status = 'CONFIRMED';
        } else if (interp === 'SQUEEZE' || interp === 'LIQUIDATION') {
            // Squeeze happening - risky for shorts
            score = 3;
            status = 'SQUEEZE';
            warning = 'Potential squeeze - risky entry';
        }
    }
    
    // Coin-specific OI boost
    if (coinOI && coinOI.trend === 'RISING') {
        score += 2;
    }
    
    return { score: Math.min(10, score), status, warning };
}

// Fetch BTC Dominance
async function fetchBTCDominance() {
    try {
        const d = await fetchJSON('https://api.coingecko.com/api/v3/global');
        if (d && d.data && d.data.market_cap_percentage) {
            const dom = d.data.market_cap_percentage.btc;
            const prevDom = STATE.btcDominance || dom;
            STATE.btcDominance = dom;
            STATE.btcDomTrend = dom > prevDom ? 'rising' : dom < prevDom ? 'falling' : 'flat';
            
            const badge = document.getElementById('badgeDom');
            const val = document.getElementById('badgeDomVal');
            if (val) {
                const arrow = STATE.btcDomTrend === 'rising' ? '▲' : STATE.btcDomTrend === 'falling' ? '▼' : '';
                val.textContent = dom.toFixed(1) + '%' + arrow;
                
                // Green if falling (good for alts), Red if rising
                badge.className = 'info-badge ' + (STATE.btcDomTrend === 'falling' ? 'go' : STATE.btcDomTrend === 'rising' ? 'nogo' : 'caution');
            }
            
            // Update Season badge based on dominance
            updateSeasonBadge(dom, STATE.btcDomTrend);
            
            // Update ALTS condition badge
            updateAltsBadge();
        }
    } catch(e) { /* Silent fail */ }
}

// Update ALTS GOOD/BAD badge
function updateAltsBadge() {
    const badge = document.getElementById('badgeAlts');
    const val = document.getElementById('badgeAltsVal');
    if (!badge || !val) return;
    
    const env = STATE.environment || {};
    const btcDomTrend = STATE.btcDomTrend || 'flat';
    const btcStructure = env.btcStructure?.status || 'UNKNOWN';
    
    // ALTS GOOD: BTC.D falling + BTC structure intact
    // ALTS BAD: BTC.D rising OR BTC structure broken down
    // ALTS FLAT: BTC.D flat
    
    if (btcDomTrend === 'falling' && btcStructure === 'INTACT') {
        val.textContent = '🟢 GOOD';
        badge.className = 'info-badge go';
    } else if (btcDomTrend === 'rising' || btcStructure === 'BROKEN_DOWN') {
        val.textContent = '🔴 BAD';
        badge.className = 'info-badge nogo';
    } else {
        val.textContent = '🟡 FLAT';
        badge.className = 'info-badge caution';
    }
}

// Update Alt/BTC Season badge
function updateSeasonBadge(dom, trend) {
    const badge = document.getElementById('badgeSeason');
    const val = document.getElementById('badgeSeasonVal');
    if (!badge || !val) return;
    
    // Calculate alt season score (0-100, higher = more alt season)
    let altScore = 100 - dom; // Base: inverse of dominance
    if (trend === 'falling') altScore += 10;
    if (trend === 'rising') altScore -= 10;
    altScore = Math.max(0, Math.min(100, altScore));
    
    STATE.altSeasonScore = altScore;
    
    if (altScore >= 60) {
        // Alt Season
        val.textContent = '🌙 ALT';
        badge.className = 'info-badge go';
    } else if (altScore <= 40) {
        // BTC Season
        val.textContent = '₿ BTC';
        badge.className = 'info-badge nogo';
    } else {
        // Neutral
        val.textContent = '⚖️ MIX';
        badge.className = 'info-badge caution';
    }
}

// Update Trading Session Badge
function updateSessionBadge() {
    const badge = document.getElementById('badgeSession');
    const val = document.getElementById('badgeSessionVal');
    if (!badge || !val) return;
    
    const now = new Date();
    const utcHour = now.getUTCHours();
    
    let session = '---';
    let isActive = false;
    
    // Session times (UTC)
    if (utcHour >= 0 && utcHour < 8) {
        session = '🌏 ASIA';
        isActive = true;
    } else if (utcHour >= 8 && utcHour < 12) {
        session = '🌍 LDN';
        isActive = true;
    } else if (utcHour >= 12 && utcHour < 21) {
        session = '🌎 NY';
        isActive = true;
    } else {
        session = '🌑 OFF';
        isActive = false;
    }
    
    val.textContent = session;
    badge.className = isActive ? 'info-badge go' : 'info-badge caution';
}

// Fetch all market data
async function fetchAllMarketData() {
    await Promise.all([
        fetchFearGreed(),
        fetchDXY(),
        fetchFunding(),
        fetchBTCDominance()
    ]);
    updateSessionBadge();
}

// Update scan progress bar when complete
function setScanComplete() {
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    const btn = document.getElementById('scanBtn');
    
    if (fill) {
        fill.style.width = '100%';
        fill.classList.remove('scanning');
        fill.classList.add('done');
    }
    if (text) {
        text.textContent = '✅ Complete';
        text.classList.add('done');
    }
    if (pct) {
        pct.textContent = '100%';
        pct.classList.add('done');
    }
    if (btn) {
        btn.classList.remove('scanning');
        btn.classList.add('scan-done');
    }
}

// Reset scan progress bar
function resetScanProgress() {
    const bar = document.getElementById('scanProgressBar');
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    const btn = document.getElementById('scanBtn');
    
    if (bar) {
        bar.classList.add('active');
    }
    if (fill) {
        fill.style.width = '5%'; // Start with visible bar
        fill.classList.remove('done', 'error');
        fill.classList.add('scanning');
    }
    if (text) {
        text.textContent = '🔄 Starting...';
        text.classList.remove('done', 'error');
    }
    if (pct) {
        pct.textContent = '0%';
        pct.classList.remove('done', 'error');
    }
    if (btn) {
        btn.classList.remove('scan-done');
        btn.classList.add('scanning');
    }
}

// Set scan error state (red)
function setScanError(message) {
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    
    if (fill) {
        fill.classList.remove('scanning', 'done');
        fill.classList.add('error');
    }
    if (text) {
        text.textContent = '❌ ' + (message || 'Error');
        text.classList.add('error');
    }
    if (pct) {
        pct.classList.add('error');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// STATS BAR FILTER FUNCTION
// ═══════════════════════════════════════════════════════════════════════════════

function filterByStats(type) {
    STATE.statsFilter = type;
    updateSignalList();
    
    // Highlight active stat box
    document.querySelectorAll('.stat-box').forEach(box => {
        box.style.borderColor = 'var(--border)';
    });
    
    const activeBox = event.currentTarget;
    if (type !== 'all') {
        activeBox.style.borderColor = 'var(--gold)';
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// BACKTEST ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

// Toggle backtest panel expand/collapse
function toggleBacktest() {
    const content = document.getElementById('backtestContent');
    const toggle = document.getElementById('backtestToggle');
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    // Save state
    safeStorageSet('backtestExpanded', !isExpanded);
}

// Restore backtest panel state on load
function restoreBacktestState() {
    const expandedVal = safeStorageGet('backtestExpanded', false);
    const expanded = expandedVal === true || expandedVal === 'true';
    if (expanded) {
        document.getElementById('backtestContent')?.classList.add('expanded');
        document.getElementById('backtestToggle')?.classList.add('expanded');
        // Also expand new panel
        document.getElementById('backtestContentNew')?.classList.add('expanded');
        document.getElementById('backtestToggleNew')?.classList.add('expanded');
    }
}

// Run backtest from NEW compact panel
async function runBacktestNew() {
    console.log('🧪 BACKTEST: Starting...');
    const btn = document.getElementById('btRunBtnNew');
    const results = document.getElementById('backtestResultsNew');
    const coinSelect = document.getElementById('btCoinNew');
    const gradeFilter = document.getElementById('btGradeNew')?.value || 'all';
    console.log('🧪 BACKTEST: Elements found:', { btn: !!btn, results: !!results, coinSelect: !!coinSelect, gradeFilter });
    
    const selectedCoin = coinSelect?.value || 'BTCUSDT';
    
    // Get enabled timeframes from checkboxes
    const enabledTFs = [];
    if (document.getElementById('btTF5m')?.checked) enabledTFs.push('5');
    if (document.getElementById('btTF15m')?.checked) enabledTFs.push('15');
    if (document.getElementById('btTF30m')?.checked) enabledTFs.push('30');
    if (document.getElementById('btTF1h')?.checked) enabledTFs.push('60');
    if (document.getElementById('btTF4h')?.checked) enabledTFs.push('240');
    if (document.getElementById('btTF1d')?.checked) enabledTFs.push('D');
    
    // If no TFs selected, default to 15m and 30m
    if (enabledTFs.length === 0) {
        enabledTFs.push('15', '30');
    }
    
    // Disable button
    if (btn) {
        btn.disabled = true;
        btn.textContent = '⏳...';
    }
    
    // ALL old coins list
    const ALL_OLD_COINS = [
        'BTCUSDT', 'ETHUSDT', 'XRPUSDT', 'SOLUSDT', 'LTCUSDT',
        'BNBUSDT', 'ADAUSDT', 'DOGEUSDT', 'LINKUSDT', 'DOTUSDT',
        'ETCUSDT', 'XLMUSDT', 'TRXUSDT', 'UNIUSDT', 'EOSUSDT'
    ];
    
    // Get coins to test - SINGLE or ALL
    const coinsToTest = selectedCoin === 'ALL' ? ALL_OLD_COINS : [selectedCoin];
    
    // Use enabled timeframes from checkboxes
    const timeframes = enabledTFs;
    
    // Initialize results
    const allResults = {
        totalTrades: 0,
        wins: 0,
        losses: 0,
        totalPnL: 0,
        fees: 0,
        netPnL: 0,
        byGrade: {
            cream: { trades: 0, wins: 0, pnl: 0 },
            perfect: { trades: 0, wins: 0, pnl: 0 },
            strong: { trades: 0, wins: 0, pnl: 0 },
            valid: { trades: 0, wins: 0, pnl: 0 }
        },
        byTF: {},
        byCoin: {},
        dataInfo: {}
    };
    
    const FEE_RATE = 0.04; // 0.04% round trip
    
    try {
        // Process each coin ONE BY ONE
        for (let coinIdx = 0; coinIdx < coinsToTest.length; coinIdx++) {
            const coin = coinsToTest[coinIdx];
            
            // Update progress
            if (results) {
                results.innerHTML = `
                    <div class="backtest-empty">
                        <div class="icon">⏳</div>
                        <div style="font-size:12px;color:var(--accent);font-weight:700">${coin.replace('USDT','')}</div>
                        <div style="font-size:9px;color:var(--text3)">${coinIdx+1}/${coinsToTest.length} coins</div>
                        <div style="font-size:8px;color:var(--text2);margin-top:4px">Fetching 6000 candles from Bybit...</div>
                    </div>
                `;
            }
            
            // Process each timeframe
            for (const tf of timeframes) {
                try {
                    // V9.2: GET 6000 CANDLES FROM BINANCE (4 API calls)!
                    const klines = await fetchKlines(coin, tf, 6000);
                    if (!klines || klines.length < 100) continue;
                    
                    // Track data info
                    const tfLabel = CONFIG.TF_LABELS[tf] || tf;
                    if (!allResults.dataInfo[tfLabel]) {
                        allResults.dataInfo[tfLabel] = { candles: 0, days: 0, coins: 0 };
                    }
                    allResults.dataInfo[tfLabel].coins++;
                    
                    // Calculate actual days
                    const firstTime = klines[0].time;
                    const lastTime = klines[klines.length - 1].time;
                    const actualDays = Math.round((lastTime - firstTime) / (1000 * 60 * 60 * 24));
                    allResults.dataInfo[tfLabel].days = Math.max(allResults.dataInfo[tfLabel].days, actualDays);
                    allResults.dataInfo[tfLabel].candles = Math.max(allResults.dataInfo[tfLabel].candles, klines.length);
                    
                    // Skip if not enough data
                    if (actualDays < 5) continue;
                    
                    // Initialize TF tracking
                    if (!allResults.byTF[tfLabel]) {
                        allResults.byTF[tfLabel] = { trades: 0, wins: 0, pnl: 0 };
                    }
                    
                    // Initialize coin tracking
                    if (!allResults.byCoin[coin]) {
                        allResults.byCoin[coin] = { trades: 0, wins: 0 };
                    }
                    
                    // Step through candles
                    const stepSize = tf === '5' ? 12 : tf === '15' ? 8 : tf === '30' ? 6 : tf === '60' ? 4 : 2;
                    let signalCount = 0;
                    
                    for (let i = 100; i < klines.length - 20; i += stepSize) {
                        const historicalKlines = klines.slice(Math.max(0, i - 100), i);
                        if (historicalKlines.length < 50) continue;
                        
                        // Check for signal
                        try {
                            const signal = quickSignalCheck(historicalKlines, coin, tf);
                            if (!signal) continue;
                            signalCount++;
                            
                            // Apply grade filter
                            if (gradeFilter === 'cream' && !signal.isCream) continue;
                            if (gradeFilter === 'perfect' && signal.grade !== 'PERFECT' && !signal.isCream) continue;
                            if (gradeFilter === 'strong' && !['PERFECT', 'STRONG'].includes(signal.grade) && !signal.isCream) continue;
                            
                            // Get future candles for outcome
                            const futureKlines = klines.slice(i + 1, i + 21);
                            if (futureKlines.length < 5) continue;
                            
                            // Simulate outcome
                            const outcome = simulateTradeOutcome(signal, futureKlines);
                            
                            // Apply fees
                            const netPnl = outcome.pnl - FEE_RATE;
                            
                            // Record results
                            allResults.totalTrades++;
                            if (outcome.won) allResults.wins++;
                            else allResults.losses++;
                            allResults.totalPnL += outcome.pnl;
                            allResults.fees += FEE_RATE;
                            allResults.netPnL += netPnl;
                            
                            // By grade
                            const gradeKey = signal.isCream ? 'cream' : signal.grade.toLowerCase();
                        if (allResults.byGrade[gradeKey]) {
                            allResults.byGrade[gradeKey].trades++;
                            if (outcome.won) allResults.byGrade[gradeKey].wins++;
                            allResults.byGrade[gradeKey].pnl += netPnl;
                        }
                        
                        // By TF
                        allResults.byTF[tfLabel].trades++;
                        if (outcome.won) allResults.byTF[tfLabel].wins++;
                        allResults.byTF[tfLabel].pnl += netPnl;
                        
                        // By coin
                        allResults.byCoin[coin].trades++;
                        if (outcome.won) allResults.byCoin[coin].wins++;
                        } catch (sigErr) {
                            console.warn(`Signal error at ${coin} ${tf} i=${i}:`, sigErr.message);
                        }
                    }
                    
                    console.log(`🧪 BACKTEST: ${coin} ${tf} = ${signalCount} signals found`);
                    
                    // Small delay between TFs
                    await sleep(50);
                    
                } catch (e) {
                    console.warn(`Error ${coin} ${tf}:`, e);
                }
            }
            
            // Delay between coins
            await sleep(100);
        }
        
        // Display results
        displayBacktestResultsCompact(allResults, 0);
        
    } catch (error) {
        console.error('Backtest error:', error);
        if (results) {
            results.innerHTML = `
                <div class="backtest-empty">
                    <div class="icon">❌</div>
                    <div>Failed: ${error.message}</div>
                </div>
            `;
        }
    }
    
    if (btn) {
        btn.disabled = false;
        btn.textContent = '▶ RUN';
    }
}

// Display backtest results - V5.5 HONEST VERSION
function displayBacktestResultsCompact(results, days) {
    const container = document.getElementById('backtestResultsNew');
    if (!container) return;
    
    const winRate = results.totalTrades > 0 ? ((results.wins / results.totalTrades) * 100).toFixed(0) : 0;
    const grossPnL = results.totalPnL || 0;
    const fees = results.fees || 0;
    const netPnL = results.netPnL || (grossPnL - fees);
    
    // Calculate actual max days from data
    const maxDays = Object.values(results.dataInfo || {}).reduce((max, info) => Math.max(max, info.days || 0), 0);
    
    container.innerHTML = `
        <div class="backtest-summary">
            <div class="backtest-stat">
                <div class="backtest-stat-label">Win/Loss</div>
                <div class="backtest-stat-value">
                    <span class="positive">${results.wins}W</span> / <span class="negative">${results.losses}L</span>
                </div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Win Rate</div>
                <div class="backtest-stat-value ${results.wins > results.losses ? 'positive' : 'negative'}">${winRate}%</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Net PnL</div>
                <div class="backtest-stat-value ${netPnL >= 0 ? 'positive' : 'negative'}">${netPnL >= 0 ? '+' : ''}${netPnL.toFixed(1)}%</div>
            </div>
        </div>
        <div style="font-size:8px;color:var(--text3);text-align:center;margin-bottom:4px">
            Fees: -${fees.toFixed(1)}% | Real Data: ${maxDays} days max
        </div>
        <div style="font-size:9px;margin:4px 0;padding:4px 0;border-top:1px solid var(--border);border-bottom:1px solid var(--border)">
            <div style="display:flex;justify-content:space-between;margin-bottom:2px">
                <span>💎 Cream</span>
                <span>${results.byGrade.cream.trades}t | ${results.byGrade.cream.trades > 0 ? ((results.byGrade.cream.wins / results.byGrade.cream.trades) * 100).toFixed(0) : 0}% | <span class="${results.byGrade.cream.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.cream.pnl >= 0 ? '+' : ''}${results.byGrade.cream.pnl.toFixed(1)}%</span></span>
            </div>
            <div style="display:flex;justify-content:space-between;margin-bottom:2px">
                <span>🥇 Perfect</span>
                <span>${results.byGrade.perfect.trades}t | ${results.byGrade.perfect.trades > 0 ? ((results.byGrade.perfect.wins / results.byGrade.perfect.trades) * 100).toFixed(0) : 0}% | <span class="${results.byGrade.perfect.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.perfect.pnl >= 0 ? '+' : ''}${results.byGrade.perfect.pnl.toFixed(1)}%</span></span>
            </div>
            <div style="display:flex;justify-content:space-between;margin-bottom:2px">
                <span>🥈 Strong</span>
                <span>${results.byGrade.strong.trades}t | ${results.byGrade.strong.trades > 0 ? ((results.byGrade.strong.wins / results.byGrade.strong.trades) * 100).toFixed(0) : 0}% | <span class="${results.byGrade.strong.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.strong.pnl >= 0 ? '+' : ''}${results.byGrade.strong.pnl.toFixed(1)}%</span></span>
            </div>
            <div style="display:flex;justify-content:space-between">
                <span>✅ Valid</span>
                <span>${results.byGrade.valid.trades}t | ${results.byGrade.valid.trades > 0 ? ((results.byGrade.valid.wins / results.byGrade.valid.trades) * 100).toFixed(0) : 0}% | <span class="${results.byGrade.valid.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.valid.pnl >= 0 ? '+' : ''}${results.byGrade.valid.pnl.toFixed(1)}%</span></span>
            </div>
        </div>
        <div style="font-size:8px">
            <div style="color:var(--amber);margin-bottom:2px">⚠️ REAL DATA PER TF:</div>
            <div style="display:flex;flex-wrap:wrap;gap:4px">
            ${Object.entries(results.dataInfo || {}).map(([tf, info]) => {
                const wr = results.byTF[tf]?.trades > 0 ? Math.round((results.byTF[tf].wins / results.byTF[tf].trades) * 100) : 0;
                const trades = results.byTF[tf]?.trades || 0;
                const color = info.days >= 60 ? 'var(--long)' : info.days >= 14 ? 'var(--amber)' : 'var(--short)';
                const status = info.days < 14 ? '❌' : info.days >= 60 ? '✅' : '⚠️';
                return `<span style="color:${color}">${status}${tf}:${info.days}d(${trades}t,${wr}%)</span>`;
            }).join(' ')}
            </div>
        </div>
        <div style="font-size:7px;color:var(--text3);margin-top:6px;padding-top:4px;border-top:1px solid var(--border)">
            <div style="color:var(--amber)">📊 BYBIT API LIMITS:</div>
            <div>5m=5d | 15m=15d | 30m=31d | 1H=62d | 4H=250d | 1D=4yr</div>
        </div>
        <div style="text-align:center;font-size:7px;color:var(--text3);margin-top:4px">
            ${results.totalTrades} trades from real Bybit data
        </div>
    `;
}

// Run backtest
async function runBacktest() {
    const btn = document.getElementById('btRunBtn');
    const results = document.getElementById('backtestResults');
    const status = document.getElementById('backtestStatus');
    
    const range = parseInt(document.getElementById('btRange').value);
    const gradeFilter = document.getElementById('btGrade').value;
    const tfFilter = document.getElementById('btTF').value;
    
    // Disable button and show loading
    btn.disabled = true;
    btn.textContent = '⏳ Running...';
    status.textContent = '(Running...)';
    
    results.innerHTML = `
        <div class="backtest-loading">
            <div class="spinner">⏳</div>
            <div style="margin-top:10px">Fetching historical data...</div>
            <div style="font-size:10px;color:var(--text3);margin-top:4px">This may take 30-60 seconds</div>
        </div>
    `;
    
    try {
        // Get coins to backtest (use current selection or top coins)
        const coins = STATE.coins?.length > 0 ? STATE.coins.slice(0, 20) : [
            'BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'BNBUSDT', 'XRPUSDT',
            'DOGEUSDT', 'ADAUSDT', 'AVAXUSDT', 'DOTUSDT', 'MATICUSDT'
        ];
        
        // Get timeframes based on filter
        let timeframes = ['60', '240', 'D'];  // 1H, 4H, 1D
        if (tfFilter === 'scalp') {
            timeframes = ['5', '15', '60'];  // 5m, 15m, 1H
        } else if (tfFilter === 'swing') {
            timeframes = ['240', 'D'];  // 4H, 1D
        }
        
        // Calculate how many candles we need
        const candlesNeeded = range * 24;  // Approximate candles per day for 1H
        
        // Run backtest simulation
        const backtestResults = await simulateBacktest(coins, timeframes, candlesNeeded, gradeFilter);
        
        // Display results
        displayBacktestResults(backtestResults, range);
        
        status.textContent = `(${backtestResults.totalTrades} trades analyzed)`;
        
    } catch (error) {
        console.error('Backtest error:', error);
        results.innerHTML = `
            <div style="text-align:center;padding:20px;color:var(--short)">
                <div style="font-size:24px;margin-bottom:8px">❌</div>
                <div>Backtest failed: ${error.message}</div>
            </div>
        `;
        status.textContent = '(Error)';
    }
    
    btn.disabled = false;
    btn.textContent = '▶ RUN';
}

// Simulate backtest using historical data - V5.5 HONEST VERSION
async function simulateBacktest(coins, timeframes, candlesNeeded, gradeFilter) {
    const results = {
        totalTrades: 0,
        wins: 0,
        losses: 0,
        totalPnL: 0,
        fees: 0,
        netPnL: 0,
        byGrade: {
            cream: { trades: 0, wins: 0, pnl: 0, avgRR: 0 },
            perfect: { trades: 0, wins: 0, pnl: 0, avgRR: 0 },
            strong: { trades: 0, wins: 0, pnl: 0, avgRR: 0 },
            valid: { trades: 0, wins: 0, pnl: 0, avgRR: 0 }
        },
        byTF: {},
        byCoin: {},
        trades: [],
        dataInfo: {} // Track actual data available per TF
    };
    
    const FEE_RATE = 0.001; // 0.1% per trade (0.2% round trip)
    
    // Process each coin/TF combination
    for (const coin of coins) {
        for (const tf of timeframes) {
            try {
                // Fetch historical klines - GET WHAT BINANCE GIVES US
                const klines = await fetchKlines(coin, tf, 1500);
                if (!klines || klines.length < 100) continue;
                
                // Track actual data received
                const tfLabel = CONFIG.TF_LABELS[tf] || tf;
                if (!results.dataInfo[tfLabel]) {
                    results.dataInfo[tfLabel] = {
                        candles: klines.length,
                        days: 0,
                        coins: 0
                    };
                }
                results.dataInfo[tfLabel].coins++;
                
                // Calculate actual days of data
                const firstTime = klines[0].time;
                const lastTime = klines[klines.length - 1].time;
                const actualDays = Math.round((lastTime - firstTime) / (1000 * 60 * 60 * 24));
                results.dataInfo[tfLabel].days = Math.max(results.dataInfo[tfLabel].days, actualDays);
                
                // HONEST: Only backtest if we have enough data
                // Skip if less than 14 days of data
                if (actualDays < 14) {
                    console.warn(`${coin} ${tfLabel}: Only ${actualDays} days of data - SKIPPING`);
                    continue;
                }
                
                // Slide through history - step based on TF to avoid oversampling
                const stepSize = tf === '5' ? 12 : tf === '15' ? 8 : tf === '30' ? 6 : tf === '60' ? 4 : 2;
                
                for (let i = 100; i < klines.length - 20; i += stepSize) {
                    // Create subset of candles up to this point
                    const historicalKlines = klines.slice(Math.max(0, i - 100), i);
                    
                    if (historicalKlines.length < 50) continue;
                    
                    // Quick signal check
                    const signalResult = quickSignalCheck(historicalKlines, coin, tf);
                    
                    if (!signalResult) continue;
                    
                    // Apply grade filter
                    if (gradeFilter === 'cream' && !signalResult.isCream) continue;
                    if (gradeFilter === 'perfect' && signalResult.grade !== 'PERFECT') continue;
                    if (gradeFilter === 'strong' && !['PERFECT', 'STRONG'].includes(signalResult.grade)) continue;
                    
                    // Simulate trade outcome
                    const futureKlines = klines.slice(i + 1, i + 21);
                    if (futureKlines.length < 5) continue;
                    
                    const outcome = simulateTradeOutcome(signalResult, futureKlines);
                    
                    // Calculate fees (0.1% entry + 0.1% exit = 0.2% total)
                    const tradeFee = 0.2; // 0.2% round trip
                    const netPnl = outcome.pnl - tradeFee;
                    
                    // Record results
                    results.totalTrades++;
                    if (outcome.won) results.wins++;
                    else results.losses++;
                    results.totalPnL += outcome.pnl;
                    results.fees += tradeFee;
                    results.netPnL += netPnl;
                    
                    // By grade
                    const gradeKey = signalResult.isCream ? 'cream' : signalResult.grade.toLowerCase();
                    if (results.byGrade[gradeKey]) {
                        results.byGrade[gradeKey].trades++;
                        if (outcome.won) results.byGrade[gradeKey].wins++;
                        results.byGrade[gradeKey].pnl += netPnl; // Net after fees
                        results.byGrade[gradeKey].avgRR += outcome.rr;
                    }
                    
                    // By TF
                    if (!results.byTF[tfLabel]) results.byTF[tfLabel] = { trades: 0, wins: 0, pnl: 0 };
                    results.byTF[tfLabel].trades++;
                    if (outcome.won) results.byTF[tfLabel].wins++;
                    results.byTF[tfLabel].pnl += netPnl;
                    
                    // By Coin
                    if (!results.byCoin[coin]) results.byCoin[coin] = { trades: 0, wins: 0 };
                    results.byCoin[coin].trades++;
                    if (outcome.won) results.byCoin[coin].wins++;
                    
                    // Store trade
                    results.trades.push({
                        coin,
                        tf: tfLabel,
                        grade: signalResult.grade,
                        direction: signalResult.direction,
                        entry: signalResult.entry,
                        outcome: outcome.won ? 'WIN' : 'LOSS',
                        pnl: netPnl,
                        rr: outcome.rr,
                        time: new Date(historicalKlines[historicalKlines.length - 1].time).toLocaleDateString()
                    });
                }
                
                // Small delay to prevent rate limiting
                await sleep(50);
                
            } catch (e) {
                console.warn(`Backtest error for ${coin} ${tf}:`, e);
            }
        }
    }
    
    // Calculate averages
    Object.keys(results.byGrade).forEach(grade => {
        const g = results.byGrade[grade];
        if (g.trades > 0) {
            g.avgRR = (g.avgRR / g.trades).toFixed(1);
        }
    });
    
    return results;
}

// V5.1 BACKTEST ZONE DETECTION - Simple and fast
function detectZones(klines, lookback = 50) {
    const zones = [];
    if (!klines || klines.length < lookback) return zones;
    
    const recentKlines = klines.slice(-lookback);
    
    // Find swing highs and lows
    for (let i = 2; i < recentKlines.length - 2; i++) {
        const candle = recentKlines[i];
        const prev2 = recentKlines[i - 2];
        const prev1 = recentKlines[i - 1];
        const next1 = recentKlines[i + 1];
        const next2 = recentKlines[i + 2];
        
        // Swing High (resistance)
        if (candle.high > prev1.high && candle.high > prev2.high &&
            candle.high > next1.high && candle.high > next2.high) {
            
            // Check if similar zone exists
            const existing = zones.find(z => 
                z.type === 'resistance' && 
                Math.abs(z.high - candle.high) / candle.high < 0.005
            );
            
            if (existing) {
                existing.touches++;
                existing.strength += 10;
            } else {
                zones.push({
                    type: 'resistance',
                    high: candle.high,
                    low: candle.high * 0.998,
                    touches: 1,
                    strength: 60
                });
            }
        }
        
        // Swing Low (support)
        if (candle.low < prev1.low && candle.low < prev2.low &&
            candle.low < next1.low && candle.low < next2.low) {
            
            const existing = zones.find(z => 
                z.type === 'support' && 
                Math.abs(z.low - candle.low) / candle.low < 0.005
            );
            
            if (existing) {
                existing.touches++;
                existing.strength += 10;
            } else {
                zones.push({
                    type: 'support',
                    high: candle.low * 1.002,
                    low: candle.low,
                    touches: 1,
                    strength: 60
                });
            }
        }
    }
    
    return zones;
}

// Quick signal check - V5.3 DUAL MODE: SCALP vs SWING
function quickSignalCheck(klines, symbol, tf) {
    if (klines.length < 100) return null;
    
    const len = klines.length;
    const c0 = klines[len - 1]; // Current candle
    const c1 = klines[len - 2]; // Previous candle
    const c2 = klines[len - 3]; // 2 candles ago
    const currentPrice = c0.close;
    const atr = calcATR(klines);
    const closes = klines.map(k => k.close);
    
    // ═══════════════════════════════════════════════════════════════════════════
    // STEP 1: ZONE DETECTION - Find Support/Resistance
    // ═══════════════════════════════════════════════════════════════════════════
    
    const swingLookback = 60;
    const swingLows = [];
    const swingHighs = [];
    
    // Find swing points
    for (let i = 5; i < Math.min(len - 5, swingLookback); i++) {
        const c = klines[i];
        let isHigh = true, isLow = true;
        
        for (let j = 1; j <= 4; j++) {
            if (klines[i-j]?.high >= c.high || klines[i+j]?.high >= c.high) isHigh = false;
            if (klines[i-j]?.low <= c.low || klines[i+j]?.low <= c.low) isLow = false;
        }
        
        if (isHigh) swingHighs.push({ price: c.high, index: i, volume: c.volume });
        if (isLow) swingLows.push({ price: c.low, index: i, volume: c.volume });
    }
    
    // Cluster zones (group nearby levels)
    function clusterLevels(levels, threshold) {
        if (levels.length === 0) return [];
        
        const sorted = [...levels].sort((a, b) => a.price - b.price);
        const clusters = [];
        let cluster = [sorted[0]];
        
        for (let i = 1; i < sorted.length; i++) {
            if ((sorted[i].price - cluster[0].price) / cluster[0].price < threshold) {
                cluster.push(sorted[i]);
            } else {
                clusters.push({
                    price: cluster.reduce((s, l) => s + l.price, 0) / cluster.length,
                    touches: cluster.length,
                    strength: cluster.length * 10 + (cluster.reduce((s, l) => s + l.volume, 0) > 0 ? 10 : 0)
                });
                cluster = [sorted[i]];
            }
        }
        clusters.push({
            price: cluster.reduce((s, l) => s + l.price, 0) / cluster.length,
            touches: cluster.length,
            strength: cluster.length * 10
        });
        
        return clusters;
    }
    
    const supportZones = clusterLevels(swingLows, 0.015);
    const resistanceZones = clusterLevels(swingHighs, 0.015);
    
    // Find nearest zone
    let nearestSupport = null;
    let nearestResistance = null;
    let supportDist = Infinity;
    let resistDist = Infinity;
    
    for (const zone of supportZones) {
        if (zone.price < currentPrice) {
            const dist = (currentPrice - zone.price) / currentPrice;
            if (dist < supportDist) {
                supportDist = dist;
                nearestSupport = zone;
            }
        }
    }
    
    for (const zone of resistanceZones) {
        if (zone.price > currentPrice) {
            const dist = (zone.price - currentPrice) / currentPrice;
            if (dist < resistDist) {
                resistDist = dist;
                nearestResistance = zone;
            }
        }
    }
    
    // Also check if AT zone (within 1.5% or 1 ATR)
    const zoneThreshold = Math.max(0.015, atr / currentPrice);
    
    let atSupport = nearestSupport && supportDist < zoneThreshold;
    let atResistance = nearestResistance && resistDist < zoneThreshold;
    
    // Also check if price recently touched zone (within last 3 candles)
    if (!atSupport && nearestSupport) {
        for (let i = 1; i <= 3; i++) {
            const candle = klines[len - i];
            if (candle && Math.abs(candle.low - nearestSupport.price) / nearestSupport.price < 0.008) {
                atSupport = true;
                break;
            }
        }
    }
    
    if (!atResistance && nearestResistance) {
        for (let i = 1; i <= 3; i++) {
            const candle = klines[len - i];
            if (candle && Math.abs(candle.high - nearestResistance.price) / nearestResistance.price < 0.008) {
                atResistance = true;
                break;
            }
        }
    }
    
    // NO ZONE = NO TRADE
    if (!atSupport && !atResistance) return null;
    
    // Determine direction from zone
    let direction = null;
    let zoneStrength = 0;
    
    if (atSupport && !atResistance) {
        direction = 'LONG';
        zoneStrength = nearestSupport.touches * 15;
    } else if (atResistance && !atSupport) {
        direction = 'SHORT';
        zoneStrength = nearestResistance.touches * 15;
    } else if (atSupport && atResistance) {
        // At both - pick stronger zone
        if (nearestSupport.touches >= nearestResistance.touches) {
            direction = 'LONG';
            zoneStrength = nearestSupport.touches * 15;
        } else {
            direction = 'SHORT';
            zoneStrength = nearestResistance.touches * 15;
        }
    }
    
    if (!direction) return null;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 🧠 SMART BRAIN V2.0 - INSTITUTIONAL INTELLIGENCE LAYER
    // Based on: Quant strategies, SMC, ICT concepts, Prop firm filters
    // Prevents: Bad entries, wrong direction, fading breakouts, no confirmation
    // ═══════════════════════════════════════════════════════════════════════════
    
    // 🎭 GET COIN PERSONALITY - Adjust filters based on coin behavior
    const personality = getCoinPersonality(symbol);
    const pName = personality.name;
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 1: PRICE POSITION IN RANGE (Where are we?) - PERSONALITY ADJUSTED
    // ─────────────────────────────────────────────────────────────────────────────
    const rangeLookback = 50;
    const rangeCandles = klines.slice(-rangeLookback);
    const rangeHigh = Math.max(...rangeCandles.map(c => c.high));
    const rangeLow = Math.min(...rangeCandles.map(c => c.low));
    const totalRange = rangeHigh - rangeLow;
    const pricePositionPct = totalRange > 0 ? ((currentPrice - rangeLow) / totalRange) * 100 : 50;
    
    // PERSONALITY: Use coin-specific position filters
    const longMaxPosition = personality.positionFilterLong || 55;   // Can LONG up to this %
    const shortMinPosition = personality.positionFilterShort || 45; // Can SHORT down to this %
    
    // BLOCK: SHORT when price is below coin's short threshold
    if (direction === 'SHORT' && pricePositionPct < shortMinPosition) {
        return null; // ❌ Don't SHORT at bottom (threshold: ${shortMinPosition}% for ${pName})
    }
    
    // BLOCK: LONG when price is above coin's long threshold  
    if (direction === 'LONG' && pricePositionPct > longMaxPosition) {
        return null; // ❌ Don't LONG at top (threshold: ${longMaxPosition}% for ${pName})
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 2: MARKET STRUCTURE / TREND (What's the trend?)
    // ─────────────────────────────────────────────────────────────────────────────
    const structureLookback = 30;
    const recentSwingHighs = [];
    const recentSwingLows = [];
    
    for (let i = 5; i < Math.min(len - 5, structureLookback); i++) {
        const c = klines[len - 1 - i];
        let isHigh = true, isLow = true;
        
        for (let j = 1; j <= 3; j++) {
            const prev = klines[len - 1 - i - j];
            const next = klines[len - 1 - i + j];
            if (prev && next) {
                if (prev.high >= c.high || next.high >= c.high) isHigh = false;
                if (prev.low <= c.low || next.low <= c.low) isLow = false;
            }
        }
        
        if (isHigh) recentSwingHighs.push({ price: c.high, index: i });
        if (isLow) recentSwingLows.push({ price: c.low, index: i });
    }
    
    let marketTrend = 'NEUTRAL';
    
    if (recentSwingHighs.length >= 2 && recentSwingLows.length >= 2) {
        recentSwingHighs.sort((a, b) => a.index - b.index);
        recentSwingLows.sort((a, b) => a.index - b.index);
        
        const latestHigh = recentSwingHighs[0]?.price || 0;
        const prevHigh = recentSwingHighs[1]?.price || 0;
        const latestLow = recentSwingLows[0]?.price || 0;
        const prevLow = recentSwingLows[1]?.price || 0;
        
        // Higher Highs + Higher Lows = UPTREND
        if (latestHigh > prevHigh && latestLow > prevLow) {
            marketTrend = 'UPTREND';
        }
        // Lower Highs + Lower Lows = DOWNTREND
        else if (latestHigh < prevHigh && latestLow < prevLow) {
            marketTrend = 'DOWNTREND';
        }
    }
    
    // BLOCK: SHORT in UPTREND (unless at extreme top >75%)
    if (direction === 'SHORT' && marketTrend === 'UPTREND' && pricePositionPct < 75) {
        return null; // ❌ Don't SHORT against uptrend
    }
    
    // BLOCK: LONG in DOWNTREND (unless at extreme bottom <25%)
    if (direction === 'LONG' && marketTrend === 'DOWNTREND' && pricePositionPct > 25) {
        return null; // ❌ Don't LONG against downtrend
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 3: STRICT ZONE PROXIMITY (Are we ACTUALLY at the zone?) - PERSONALITY ADJUSTED
    // ─────────────────────────────────────────────────────────────────────────────
    const strictZoneThreshold = personality.zoneThreshold || 0.015; // Personality-based distance
    
    if (direction === 'LONG' && nearestSupport) {
        const actualDistToSupport = (currentPrice - nearestSupport.price) / currentPrice;
        if (actualDistToSupport > strictZoneThreshold) {
            return null; // ❌ Not actually AT support
        }
    }
    
    if (direction === 'SHORT' && nearestResistance) {
        const actualDistToResistance = (nearestResistance.price - currentPrice) / currentPrice;
        if (actualDistToResistance > strictZoneThreshold) {
            return null; // ❌ Not actually AT resistance
        }
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 4: ZONE STRENGTH (Is the zone strong enough?)
    // ─────────────────────────────────────────────────────────────────────────────
    if (direction === 'LONG' && nearestSupport && nearestSupport.touches < 2) {
        return null; // ❌ Weak support
    }
    if (direction === 'SHORT' && nearestResistance && nearestResistance.touches < 2) {
        return null; // ❌ Weak resistance
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 5: REJECTION CANDLE REQUIRED (Is there actual rejection?) - PERSONALITY ADJUSTED
    // Based on: ICT/SMC "displacement" concept - need actual rejection, not just "near zone"
    // ─────────────────────────────────────────────────────────────────────────────
    const body0 = Math.abs(c0.close - c0.open);
    const upperWick0 = c0.high - Math.max(c0.open, c0.close);
    const lowerWick0 = Math.min(c0.open, c0.close) - c0.low;
    const totalRange0 = c0.high - c0.low;
    
    // PERSONALITY: Minimum rejection multiplier
    const minRejMult = personality.minRejectionMult || 1.5;
    
    let hasRejection = false;
    let rejectionType = '';
    
    // For LONG: Need bullish rejection (long lower wick OR bullish engulfing OR hammer)
    if (direction === 'LONG') {
        // Hammer/Pin bar (lower wick > minRejMult x body) - PERSONALITY ADJUSTED
        if (lowerWick0 > body0 * minRejMult && lowerWick0 > totalRange0 * 0.5) {
            hasRejection = true;
            rejectionType = 'HAMMER';
        }
        // Bullish engulfing
        else if (c0.close > c0.open && c0.close > c1.high && body0 > Math.abs(c1.close - c1.open)) {
            hasRejection = true;
            rejectionType = 'ENGULFING';
        }
        // Bullish candle with lower wick showing rejection - PERSONALITY ADJUSTED
        else if (c0.close > c0.open && lowerWick0 > body0 * (minRejMult * 0.7)) {
            hasRejection = true;
            rejectionType = 'WICK_REJECT';
        }
        // Morning star pattern check (3 candles)
        else if (len >= 3) {
            const c2Body = Math.abs(c2.close - c2.open);
            const c1Body = Math.abs(c1.close - c1.open);
            if (c2.close < c2.open && c1Body < c2Body * 0.3 && c0.close > c0.open && c0.close > c2.open) {
                hasRejection = true;
                rejectionType = 'MORNING_STAR';
            }
        }
    }
    
    // For SHORT: Need bearish rejection (long upper wick OR bearish engulfing OR shooting star)
    if (direction === 'SHORT') {
        // Shooting star (upper wick > minRejMult x body) - PERSONALITY ADJUSTED
        if (upperWick0 > body0 * minRejMult && upperWick0 > totalRange0 * 0.5) {
            hasRejection = true;
            rejectionType = 'SHOOTING_STAR';
        }
        // Bearish engulfing
        else if (c0.close < c0.open && c0.close < c1.low && body0 > Math.abs(c1.close - c1.open)) {
            hasRejection = true;
            rejectionType = 'ENGULFING';
        }
        // Bearish candle with upper wick showing rejection
        else if (c0.close < c0.open && upperWick0 > body0 * 1.2) {
            hasRejection = true;
            rejectionType = 'WICK_REJECT';
        }
        // Evening star pattern check
        else if (len >= 3) {
            const c2Body = Math.abs(c2.close - c2.open);
            const c1Body = Math.abs(c1.close - c1.open);
            if (c2.close > c2.open && c1Body < c2Body * 0.3 && c0.close < c0.open && c0.close < c2.open) {
                hasRejection = true;
                rejectionType = 'EVENING_STAR';
            }
        }
    }
    
    // BLOCK: No rejection candle = no trade
    if (!hasRejection) {
        return null; // ❌ No rejection confirmation
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 6: VOLUME CONFIRMATION (Is there conviction behind the move?) - PERSONALITY ADJUSTED
    // Based on: Institutional trading requires volume to confirm moves
    // ─────────────────────────────────────────────────────────────────────────────
    const volLookback = 20;
    let avgVolume = 0;
    for (let i = 1; i <= volLookback; i++) {
        avgVolume += klines[len - 1 - i]?.volume || 0;
    }
    avgVolume /= volLookback;
    
    const currentVolume = c0.volume;
    const volRatio = avgVolume > 0 ? currentVolume / avgVolume : 1;
    
    // PERSONALITY: Minimum volume required
    const minVolRequired = personality.volumeRequired || 0.8;
    
    // Volume should be at least minVolRequired x average
    let volumeConfirm = volRatio >= minVolRequired;
    let volumeStrength = volRatio >= 1.5 ? 'HIGH' : volRatio >= 1.0 ? 'NORMAL' : 'LOW';
    
    // Bonus: High volume at rejection = very strong signal
    const volumeBonus = volRatio >= 1.5 ? 10 : volRatio >= 1.2 ? 5 : 0;
    
    // BLOCK: Volume below personality threshold - PERSONALITY ADJUSTED
    if (volRatio < minVolRequired * 0.6) {
        return null; // ❌ Volume too low for ${pName} (need ${minVolRequired}x)
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 7: BREAKOUT DETECTION (Don't fade breakouts!)
    // Based on: SMC concept - high volume at zone = breakout, not reversal
    // ─────────────────────────────────────────────────────────────────────────────
    let isBreakout = false;
    
    // Detect potential breakout: Strong candle WITH high volume moving THROUGH zone
    if (direction === 'LONG' && nearestResistance) {
        // If there's resistance above and price is pushing up with high volume
        const distToResist = (nearestResistance.price - currentPrice) / currentPrice;
        if (distToResist < 0.01 && volRatio > 1.5 && c0.close > c0.open && body0 > atr * 0.8) {
            isBreakout = true; // Looks like breakout, not reversal
        }
    }
    
    if (direction === 'SHORT' && nearestSupport) {
        // If there's support below and price is pushing down with high volume
        const distToSupport = (currentPrice - nearestSupport.price) / currentPrice;
        if (distToSupport < 0.01 && volRatio > 1.5 && c0.close < c0.open && body0 > atr * 0.8) {
            isBreakout = true; // Looks like breakdown, not reversal
        }
    }
    
    // Check for failed breakout (sweep + rejection = good reversal)
    let liquiditySweep = false;
    
    // For LONG: Check if price swept below support then came back (liquidity grab)
    if (direction === 'LONG' && nearestSupport) {
        for (let i = 0; i <= 3; i++) {
            const candle = klines[len - 1 - i];
            if (candle && candle.low < nearestSupport.price * 0.997 && candle.close > nearestSupport.price) {
                liquiditySweep = true;
                break;
            }
        }
    }
    
    // For SHORT: Check if price swept above resistance then came back
    if (direction === 'SHORT' && nearestResistance) {
        for (let i = 0; i <= 3; i++) {
            const candle = klines[len - 1 - i];
            if (candle && candle.high > nearestResistance.price * 1.003 && candle.close < nearestResistance.price) {
                liquiditySweep = true;
                break;
            }
        }
    }
    
    // BLOCK: Potential breakout without sweep = don't fade it
    if (isBreakout && !liquiditySweep) {
        return null; // ❌ Don't fade breakouts
    }
    
    // PERSONALITY: Meme coins REQUIRE liquidity sweep
    if (personality.requireSweep && !liquiditySweep) {
        return null; // ❌ ${pName} requires liquidity sweep - too risky without it
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 8: HIGHER TIMEFRAME ALIGNMENT (Does HTF agree?)
    // Based on: Multi-timeframe confluence - trade WITH the bigger picture
    // ─────────────────────────────────────────────────────────────────────────────
    // Calculate simple HTF bias using longer-term EMAs
    const ema50 = calcEMA(closes, 50);
    const ema200 = calcEMA(closes, 200);
    const ema50Val = ema50[ema50.length - 1];
    const ema200Val = ema200[ema200.length - 1];
    
    let htfBias = 'NEUTRAL';
    if (ema50Val && ema200Val) {
        if (ema50Val > ema200Val && currentPrice > ema50Val) {
            htfBias = 'BULLISH';
        } else if (ema50Val < ema200Val && currentPrice < ema50Val) {
            htfBias = 'BEARISH';
        }
    }
    
    // Strong warning: Trading against clear HTF bias
    let htfConflict = false;
    if (direction === 'SHORT' && htfBias === 'BULLISH') {
        htfConflict = true;
    }
    if (direction === 'LONG' && htfBias === 'BEARISH') {
        htfConflict = true;
    }
    
    // BLOCK: Strong HTF conflict without liquidity sweep = skip
    if (htfConflict && !liquiditySweep && pricePositionPct > 30 && pricePositionPct < 70) {
        return null; // ❌ Against HTF bias in middle of range
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 9: RSI EXTREME CHECK (Is momentum aligned?)
    // ─────────────────────────────────────────────────────────────────────────────
    const rsi = calcRSI(klines);
    let rsiAligned = true;
    
    // For LONG: RSI shouldn't be overbought (>75)
    if (direction === 'LONG' && rsi.value > 75) {
        rsiAligned = false;
    }
    // For SHORT: RSI shouldn't be oversold (<25)
    if (direction === 'SHORT' && rsi.value < 25) {
        rsiAligned = false;
    }
    
    // Bonus for extreme RSI in right direction
    const rsiBonus = (direction === 'LONG' && rsi.value < 35) ? 10 : 
                     (direction === 'SHORT' && rsi.value > 65) ? 10 : 0;
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 10: CANDLE COLOR CONFIRMATION (Final sanity check)
    // ─────────────────────────────────────────────────────────────────────────────
    const candleColor = c0.close > c0.open ? 'GREEN' : 'RED';
    let colorAligned = true;
    
    // Prefer candle color matching direction (not strict requirement due to rejection wicks)
    if (direction === 'LONG' && candleColor === 'RED' && rejectionType !== 'HAMMER') {
        colorAligned = false; // Warning but don't block if strong rejection
    }
    if (direction === 'SHORT' && candleColor === 'GREEN' && rejectionType !== 'SHOOTING_STAR') {
        colorAligned = false;
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 11: COIN PERSONALITY (Each coin behaves differently!)
    // Based on: Historical behavior patterns per coin
    // ─────────────────────────────────────────────────────────────────────────────
    const coinProfile = CONFIG.COIN_PERSONALITY?.profiles?.[symbol] || CONFIG.COIN_PERSONALITY?.default || {
        type: 'UNKNOWN', volatility: 'MEDIUM', respects_zones: 0.60, trend_strength: 0.65,
        fake_breakouts: 0.50, best_tf: ['15', '30', '60'], avoid_tf: ['1', '5'],
        sl_multiplier: 1.2, tp_multiplier: 1.0, min_score: 75
    };
    
    let coinPersonalityWarning = '';
    let coinAdjustment = 0;
    
    // Check if we're on an AVOID timeframe for this coin
    if (coinProfile.avoid_tf && coinProfile.avoid_tf.includes(tf)) {
        // Strong warning - this TF historically bad for this coin
        coinPersonalityWarning = `⚠️ ${symbol} bad on ${tf}m`;
        coinAdjustment -= 15; // Penalty
    }
    
    // Bonus if we're on a BEST timeframe for this coin
    if (coinProfile.best_tf && coinProfile.best_tf.includes(tf)) {
        coinAdjustment += 10; // Bonus for good TF
    }
    
    // Adjust for coin volatility
    if (coinProfile.volatility === 'EXTREME' || coinProfile.volatility === 'VERY_HIGH') {
        // Need higher score for volatile coins
        coinAdjustment -= 5;
    }
    
    // Meme coins need extra confirmation
    if (coinProfile.type === 'MEME') {
        if (!liquiditySweep) {
            coinAdjustment -= 10; // Memes need sweep confirmation
        }
        if (volRatio < 1.2) {
            coinAdjustment -= 5; // Memes need volume
        }
    }
    
    // High fake breakout coins - need sweep
    if (coinProfile.fake_breakouts > 0.5 && !liquiditySweep) {
        coinAdjustment -= 8; // High fake breakout coin without sweep
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // FILTER 12: ADAPTIVE LEARNING (Learn from past trades!)
    // Based on: Your actual trade history stored in localStorage
    // ─────────────────────────────────────────────────────────────────────────────
    let learningAdjustment = 0;
    let learningInfo = { winRate: null, trades: 0, adjusted: false };
    
    // Try to get learning data from localStorage
    try {
        const learningKey = `${symbol}_${tf}_${direction}`;
        const savedLearning = localStorage.getItem('bs_learning_v10');
        
        if (savedLearning && CONFIG.ADAPTIVE_LEARNING?.enabled) {
            const learningData = JSON.parse(savedLearning);
            const coinTFData = learningData[learningKey];
            
            if (coinTFData && coinTFData.trades >= (CONFIG.ADAPTIVE_LEARNING.minTrades || 10)) {
                const winRate = coinTFData.wins / coinTFData.trades;
                learningInfo.winRate = (winRate * 100).toFixed(0);
                learningInfo.trades = coinTFData.trades;
                learningInfo.adjusted = true;
                
                // Adjust based on historical win rate for this exact combo
                if (winRate < 0.40) {
                    // This combo loses money - strong penalty
                    learningAdjustment -= 15;
                    learningInfo.status = 'LOSING';
                } else if (winRate < 0.50) {
                    // Below breakeven - moderate penalty
                    learningAdjustment -= 8;
                    learningInfo.status = 'WEAK';
                } else if (winRate >= 0.65) {
                    // Good win rate - bonus!
                    learningAdjustment += 10;
                    learningInfo.status = 'STRONG';
                } else if (winRate >= 0.55) {
                    // Decent - small bonus
                    learningAdjustment += 5;
                    learningInfo.status = 'GOOD';
                }
            }
        }
    } catch (e) {
        // Learning data not available, continue without
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 🧠 SMART BRAIN SCORE CALCULATION
    // ═══════════════════════════════════════════════════════════════════════════
    let brainScore = 50; // Base score for passing all filters
    
    // Position bonus (closer to extreme = better)
    if (direction === 'LONG') {
        brainScore += Math.max(0, (40 - pricePositionPct) / 2); // Up to +20 for being at bottom
    } else {
        brainScore += Math.max(0, (pricePositionPct - 60) / 2); // Up to +20 for being at top
    }
    
    // Trend alignment bonus
    if ((direction === 'LONG' && marketTrend === 'UPTREND') || 
        (direction === 'SHORT' && marketTrend === 'DOWNTREND')) {
        brainScore += 15; // Trading WITH trend
    }
    
    // Liquidity sweep bonus (institutional entry)
    if (liquiditySweep) {
        brainScore += 20; // Strong institutional signal
    }
    
    // Volume and RSI bonuses
    brainScore += volumeBonus;
    brainScore += rsiBonus;
    
    // HTF alignment bonus
    if ((direction === 'LONG' && htfBias === 'BULLISH') || 
        (direction === 'SHORT' && htfBias === 'BEARISH')) {
        brainScore += 10;
    }
    
    // Candle color alignment
    if (colorAligned) {
        brainScore += 5;
    }
    
    // Zone strength bonus
    const zoneTouchBonus = direction === 'LONG' ? 
        Math.min((nearestSupport?.touches || 2) - 2, 3) * 5 :
        Math.min((nearestResistance?.touches || 2) - 2, 3) * 5;
    brainScore += zoneTouchBonus;
    
    // Coin personality adjustment
    brainScore += coinAdjustment;
    
    // Learning adjustment (from your trade history)
    brainScore += learningAdjustment;
    
    // Cap at 100, floor at 0
    brainScore = Math.max(0, Math.min(100, brainScore));
    
    // FINAL CHECK: If score too low after all adjustments, block
    const minRequiredScore = coinProfile.min_score || 70;
    if (brainScore < minRequiredScore - 10) {
        return null; // ❌ Score too low after all adjustments
    }
    
    // Store brain analysis for display
    const smartBrainData = {
        pricePosition: pricePositionPct.toFixed(0),
        marketTrend: marketTrend,
        rangeHigh: rangeHigh,
        rangeLow: rangeLow,
        hasRejection: hasRejection,
        rejectionType: rejectionType,
        volumeStrength: volumeStrength,
        volRatio: volRatio.toFixed(2),
        liquiditySweep: liquiditySweep,
        htfBias: htfBias,
        htfConflict: htfConflict,
        rsiValue: rsi.value.toFixed(0),
        rsiAligned: rsiAligned,
        brainScore: brainScore,
        // 🎭 Coin Personality info
        personality: pName,
        personalityDesc: personality.description || '',
        positionThresholds: `L<${longMaxPosition}% S>${shortMinPosition}%`,
        zoneThreshold: (strictZoneThreshold * 100).toFixed(1) + '%',
        passed: true
    };
    
    // 🧠 ALL FILTERS PASSED - Signal is SMART validated
    // ═══════════════════════════════════════════════════════════════════════════
    
    // ═══════════════════════════════════════════════════════════════════════════
    // STEP 2: REJECTION CONFIRMATIONS - Count all signs of reversal
    // ═══════════════════════════════════════════════════════════════════════════
    
    let confirmations = 0;
    let confirmList = [];
    
    // --- CANDLE REJECTION ---
    // (body0, upperWick0, lowerWick0, totalRange0 already declared above in FILTER 5)
    
    // Rejection wick (long wick in direction of zone)
    if (direction === 'LONG' && lowerWick0 > body0 * 1.5 && lowerWick0 > totalRange0 * 0.5) {
        confirmations++;
        confirmList.push('RejectionWick');
    }
    if (direction === 'SHORT' && upperWick0 > body0 * 1.5 && upperWick0 > totalRange0 * 0.5) {
        confirmations++;
        confirmList.push('RejectionWick');
    }
    
    // Engulfing candle
    const body1 = Math.abs(c1.close - c1.open);
    if (direction === 'LONG' && c0.close > c0.open && c0.close > c1.high && body0 > body1) {
        confirmations++;
        confirmList.push('BullEngulf');
    }
    if (direction === 'SHORT' && c0.close < c0.open && c0.close < c1.low && body0 > body1) {
        confirmations++;
        confirmList.push('BearEngulf');
    }
    
    // Candle color matches direction
    if (direction === 'LONG' && c0.close > c0.open) {
        confirmations++;
        confirmList.push('BullCandle');
    }
    if (direction === 'SHORT' && c0.close < c0.open) {
        confirmations++;
        confirmList.push('BearCandle');
    }
    
    // --- RSI CONFIRMATION ---
    // (rsi already declared in FILTER 9 above)
    
    if (direction === 'LONG' && rsi.value < 35) {
        confirmations++;
        confirmList.push('RSI_OS');
        if (rsi.value < 25) {
            confirmations++;
            confirmList.push('RSI_DeepOS');
        }
    }
    if (direction === 'SHORT' && rsi.value > 65) {
        confirmations++;
        confirmList.push('RSI_OB');
        if (rsi.value > 75) {
            confirmations++;
            confirmList.push('RSI_DeepOB');
        }
    }
    
    // --- RSI DIVERGENCE ---
    // Check if price made lower low but RSI made higher low (bullish div)
    // Or price made higher high but RSI made lower high (bearish div)
    const rsiValues = [];
    for (let i = 20; i >= 0; i--) {
        const slice = klines.slice(0, len - i);
        if (slice.length >= 14) {
            rsiValues.push(calcRSI(slice).value);
        }
    }
    
    if (rsiValues.length >= 10) {
        const recentLows = [];
        const recentHighs = [];
        
        for (let i = 5; i < Math.min(len - 5, 20); i++) {
            const c = klines[len - 1 - i];
            let isLow = true, isHigh = true;
            for (let j = 1; j <= 2; j++) {
                if (klines[len - 1 - i - j]?.low < c.low) isLow = false;
                if (klines[len - 1 - i + j]?.low < c.low) isLow = false;
                if (klines[len - 1 - i - j]?.high > c.high) isHigh = false;
                if (klines[len - 1 - i + j]?.high > c.high) isHigh = false;
            }
            if (isLow) recentLows.push({ price: c.low, idx: i, rsi: rsiValues[rsiValues.length - 1 - i] || 50 });
            if (isHigh) recentHighs.push({ price: c.high, idx: i, rsi: rsiValues[rsiValues.length - 1 - i] || 50 });
        }
        
        // Bullish divergence: lower price low, higher RSI low
        if (direction === 'LONG' && recentLows.length >= 2) {
            const [l1, l2] = recentLows.slice(0, 2);
            if (l1.price < l2.price && l1.rsi > l2.rsi) {
                confirmations += 2;
                confirmList.push('BullDiv');
            }
        }
        
        // Bearish divergence: higher price high, lower RSI high
        if (direction === 'SHORT' && recentHighs.length >= 2) {
            const [h1, h2] = recentHighs.slice(0, 2);
            if (h1.price > h2.price && h1.rsi < h2.rsi) {
                confirmations += 2;
                confirmList.push('BearDiv');
            }
        }
    }
    
    // --- VOLUME CONFIRMATION ---
    // (volRatio already declared in FILTER 6 above, reusing avgVol calculation)
    const avgVol = klines.slice(-20).reduce((s, k) => s + k.volume, 0) / 20;
    const volRatioConfirm = c0.volume / avgVol;
    
    if (volRatioConfirm > 1.5) {
        confirmations++;
        confirmList.push('VolSpike');
    }
    
    // --- EMA TREND (Bonus, not required) ---
    const ema9 = calcEMA(closes, 9);
    const ema21 = calcEMA(closes, 21);
    const ema9Val = ema9[ema9.length - 1];
    const ema21Val = ema21[ema21.length - 1];
    
    if (direction === 'LONG' && ema9Val > ema21Val) {
        confirmations++;
        confirmList.push('TrendAlign');
    }
    if (direction === 'SHORT' && ema9Val < ema21Val) {
        confirmations++;
        confirmList.push('TrendAlign');
    }
    
    // --- LIQUIDITY SWEEP (Price went beyond zone then came back) ---
    if (direction === 'LONG' && nearestSupport) {
        // Check if any of last 5 candles swept below support then closed above
        for (let i = 1; i <= 5; i++) {
            const candle = klines[len - i];
            if (candle.low < nearestSupport.price * 0.995 && candle.close > nearestSupport.price) {
                confirmations += 2;
                confirmList.push('LiqSweep');
                break;
            }
        }
    }
    if (direction === 'SHORT' && nearestResistance) {
        for (let i = 1; i <= 5; i++) {
            const candle = klines[len - i];
            if (candle.high > nearestResistance.price * 1.005 && candle.close < nearestResistance.price) {
                confirmations += 2;
                confirmList.push('LiqSweep');
                break;
            }
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // STEP 3: GRADE BY CONFIRMATIONS
    // ═══════════════════════════════════════════════════════════════════════════
    
    // V9.1: Minimum 3 confirmations required for higher quality
    if (confirmations < 3) return null;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // V9.6 SMART MATRIX - APPLY TO BACKTEST
    // ═══════════════════════════════════════════════════════════════════════════
    
    // Build quick zone/smc/momentum data for Smart Matrix
    const zoneTouches = direction === 'LONG' ? (nearestSupport?.touches || 0) : (nearestResistance?.touches || 0);
    const quickZone = { touches: zoneTouches, direction };
    const quickSMC = { 
        direction, 
        details: { 
            bos: { detected: confirmList.includes('BOS'), bodyClose: true },
            choch: { detected: confirmList.includes('CHOCH') },
            orderBlocks: { bullish: [], bearish: [] },
            fvg: { bullish: [], bearish: [] },
            liquiditySweep: { detected: confirmList.includes('LiqSweep') }
        }
    };
    const quickMomentum = {
        direction: rsi.value < 40 ? 'LONG' : rsi.value > 60 ? 'SHORT' : 'NEUTRAL',
        details: {
            rsi: { value: rsi.value },
            macd: { crossover: confirmList.includes('MACD'), histogram: 0 },
            adx: { adx: 25 },
            volume: { ratio: volRatio },
            divergence: { detected: confirmList.includes('BullDiv') || confirmList.includes('BearDiv') }
        }
    };
    
    // Calculate Smart Matrix weights
    let smartMatrix = null;
    try {
        smartMatrix = calculateSmartMatrix(
            { direction, details: { primaryZone: quickZone } },
            quickSMC,
            quickMomentum,
            klines
        );
    } catch (e) {
        smartMatrix = { weights: { zone: 33, smc: 33, momentum: 34 }, agreement: { bonus: 1.0 }, regime: { regime: 'UNKNOWN' } };
    }
    
    // Calculate base score
    let baseScore = 40 + zoneStrength + (confirmations * 8);
    
    // Apply Smart Matrix adjustments
    // Zone touch bonus (3=baseline, 4+=bonus)
    if (zoneTouches >= 3) {
        const touchBonus = zoneTouches === 3 ? 0 : (zoneTouches - 3) * 3; // +3 per touch above 3
        baseScore += Math.min(touchBonus, 15); // Cap at +15
    }
    
    // Agreement bonus
    baseScore *= smartMatrix.agreement?.bonus || 1.0;
    
    // Regime penalty for choppy
    if (smartMatrix.regime?.regime === 'CHOPPY') {
        baseScore *= 0.90;
    }
    
    let score = Math.min(100, Math.round(baseScore));
    
    // Grade - V17 AGREED THRESHOLDS
    let grade = 'HEATING';
    if (score >= 90) grade = 'PERFECT';
    else if (score >= 75) grade = 'STRONG';
    else if (score >= 60) grade = 'VALID';
    else if (score >= 45) grade = 'HEATING';
    else return null;
    
    const isCream = confirmations >= 6 && confirmList.includes('LiqSweep');
    
    // ═══════════════════════════════════════════════════════════════════════════
    // STEP 4: SET SL/TP
    // ═══════════════════════════════════════════════════════════════════════════
    
    let sl, tp;
    
    if (direction === 'LONG') {
        // SL below zone
        sl = nearestSupport ? nearestSupport.price * 0.995 : currentPrice - atr * 1.2;
        // TP at next resistance or 2R
        const risk = currentPrice - sl;
        tp = nearestResistance ? Math.min(nearestResistance.price * 0.995, currentPrice + risk * 2) : currentPrice + risk * 2;
    } else {
        // SL above zone
        sl = nearestResistance ? nearestResistance.price * 1.005 : currentPrice + atr * 1.2;
        // TP at next support or 2R
        const risk = sl - currentPrice;
        tp = nearestSupport ? Math.max(nearestSupport.price * 1.005, currentPrice - risk * 2) : currentPrice - risk * 2;
    }
    
    return {
        direction,
        grade,
        score,
        entry: currentPrice,
        atr,
        isCream,
        mode: ['5', '15', '30'].includes(tf) ? 'SCALP' : tf === '60' ? 'INTRADAY' : 'SWING',
        rsiValue: rsi.value,
        volSpike: volRatio > 1.5,
        confirmations,
        confirmList,
        zoneStrength,
        zoneTouches,
        smartMatrix, // Include Smart Matrix data
        smartBrain: smartBrainData, // 🧠 V10 Full Smart Brain analysis
        levels: { sl, tp }
    };
}

// Simulate trade outcome based on future candles
function simulateTradeOutcome(signal, futureKlines) {
    // ═══════════════════════════════════════════════════════════════════════════
    // PARANOID-SAFE TRADE SIMULATION - Fixes from ChatGPT audit
    // ═══════════════════════════════════════════════════════════════════════════
    
    if (!futureKlines || futureKlines.length === 0) {
        return { won: false, pnl: 0, rr: 0, reason: 'NO_DATA' };
    }
    
    if (!signal || !signal.levels) {
        console.warn('simulateTradeOutcome: Missing signal or levels');
        return { won: false, pnl: 0, rr: 0, reason: 'INVALID_SIGNAL' };
    }
    
    const signalEntry = signal.entry;
    const sl = signal.levels.sl;
    const tp = signal.levels.tp;
    const direction = signal.direction;
    
    if (!signalEntry || !sl || !tp || isNaN(signalEntry) || isNaN(sl) || isNaN(tp)) {
        console.warn('simulateTradeOutcome: Invalid entry/sl/tp values');
        return { won: false, pnl: 0, rr: 0, reason: 'INVALID_LEVELS' };
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX #1: ENTRY ON NEXT CANDLE OPEN + SLIPPAGE (not signal close)
    // ═══════════════════════════════════════════════════════════════════════════
    const nextOpen = futureKlines[0].open;
    const SLIPPAGE_PCT = 0.001; // 0.1% slippage
    const slippageAmount = nextOpen * SLIPPAGE_PCT;
    
    // Slippage works AGAINST you
    const entry = direction === 'LONG' 
        ? nextOpen + slippageAmount  // Buy higher
        : nextOpen - slippageAmount; // Sell lower
    
    const risk = Math.abs(entry - sl);
    const reward = Math.abs(tp - entry);
    const targetRR = risk > 0 ? reward / risk : 1.5;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX #2: Check if entry is already invalid (gapped through SL)
    // ═══════════════════════════════════════════════════════════════════════════
    if (direction === 'LONG' && entry >= sl && sl > signalEntry) {
        // Gap down through our SL
        return { won: false, pnl: -1.5, rr: -1.5, reason: 'GAP_THROUGH_SL' };
    }
    if (direction === 'SHORT' && entry <= sl && sl < signalEntry) {
        // Gap up through our SL
        return { won: false, pnl: -1.5, rr: -1.5, reason: 'GAP_THROUGH_SL' };
    }
    
    const BASE_RISK = 1.0;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX #3: PARANOID TP/SL LOGIC - Heuristic when both hit same candle
    // ═══════════════════════════════════════════════════════════════════════════
    for (let i = 0; i < futureKlines.length; i++) {
        const candle = futureKlines[i];
        const candleOpen = candle.open;
        const candleHigh = candle.high;
        const candleLow = candle.low;
        
        let slHit = false;
        let tpHit = false;
        
        if (direction === 'LONG') {
            slHit = candleLow <= sl;
            tpHit = candleHigh >= tp;
        } else {
            slHit = candleHigh >= sl;
            tpHit = candleLow <= tp;
        }
        
        // BOTH HIT SAME CANDLE - Use heuristic (most important fix!)
        if (slHit && tpHit) {
            // Heuristic: Check which is closer to candle open
            const distToSL = Math.abs(candleOpen - sl);
            const distToTP = Math.abs(candleOpen - tp);
            
            // If candle is bearish (close < open) and we're LONG, SL more likely
            // If candle is bullish (close > open) and we're SHORT, SL more likely
            const isBearish = candle.close < candle.open;
            const isBullish = candle.close > candle.open;
            
            let slFirst = false;
            
            if (direction === 'LONG') {
                // LONG trade: bearish candle = SL likely hit first
                if (isBearish) slFirst = true;
                else if (distToSL < distToTP) slFirst = true;
                else slFirst = Math.random() < 0.5; // True 50/50 if unclear
            } else {
                // SHORT trade: bullish candle = SL likely hit first
                if (isBullish) slFirst = true;
                else if (distToSL < distToTP) slFirst = true;
                else slFirst = Math.random() < 0.5;
            }
            
            if (slFirst) {
                return { won: false, pnl: -BASE_RISK, rr: -1, reason: 'SL_HIT_HEURISTIC', candle: i };
            } else {
                return { won: true, pnl: BASE_RISK * targetRR, rr: targetRR, reason: 'TP_HIT_HEURISTIC', candle: i };
            }
        }
        
        // Only SL hit
        if (slHit) {
            return { won: false, pnl: -BASE_RISK, rr: -1, reason: 'SL_HIT', candle: i };
        }
        
        // Only TP hit
        if (tpHit) {
            return { won: true, pnl: BASE_RISK * targetRR, rr: targetRR, reason: 'TP_HIT', candle: i };
        }
    }
    
    // Neither hit - calculate based on final position
    const lastPrice = futureKlines[futureKlines.length - 1].close;
    const move = direction === 'LONG' ? lastPrice - entry : entry - lastPrice;
    const rMult = risk > 0 ? move / risk : 0;
    
    return { won: rMult > 0, pnl: BASE_RISK * rMult, rr: rMult, reason: 'TIMEOUT' };
}

// ═══════════════════════════════════════════════════════════════════════════════
// CHOP FILTER - Detect sideways/low volatility conditions
// ═══════════════════════════════════════════════════════════════════════════════
function isChoppy(candles, lookback = 20) {
    if (!candles || candles.length < lookback) return false;
    
    const recent = candles.slice(-lookback);
    
    // Calculate ATR
    let atrSum = 0;
    for (let i = 1; i < recent.length; i++) {
        const tr = Math.max(
            recent[i].high - recent[i].low,
            Math.abs(recent[i].high - recent[i-1].close),
            Math.abs(recent[i].low - recent[i-1].close)
        );
        atrSum += tr;
    }
    const atr = atrSum / (recent.length - 1);
    const atrPct = (atr / recent[recent.length-1].close) * 100;
    
    // Calculate range compression
    const highest = Math.max(...recent.map(c => c.high));
    const lowest = Math.min(...recent.map(c => c.low));
    const rangePct = ((highest - lowest) / lowest) * 100;
    
    // CHOP conditions:
    // 1. ATR < 1% (low volatility)
    // 2. Range < 3% over 20 candles (compressed)
    const isLowVol = atrPct < 1.0;
    const isCompressed = rangePct < 3.0;
    
    return isLowVol || isCompressed;
}

// ═══════════════════════════════════════════════════════════════════════════════
// LOSING STREAK ANALYSIS - Capital death test
// ═══════════════════════════════════════════════════════════════════════════════
function analyzeLosingStreaks(trades) {
    if (!trades || trades.length === 0) return { maxStreak: 0, survives: true, worstSequence: 0 };
    
    let currentStreak = 0;
    let maxStreak = 0;
    let worstPnL = 0;
    let currentDrawdown = 0;
    
    for (const trade of trades) {
        const pnl = trade.netPnl !== undefined ? trade.netPnl : (trade.pnl - 0.2);
        
        if (pnl < 0) {
            currentStreak++;
            currentDrawdown += pnl;
            maxStreak = Math.max(maxStreak, currentStreak);
            worstPnL = Math.min(worstPnL, currentDrawdown);
        } else {
            currentStreak = 0;
            currentDrawdown = 0;
        }
    }
    
    // Survival test: Can we survive the worst 10-trade sequence?
    let worst10 = 0;
    for (let i = 0; i <= trades.length - 10; i++) {
        let sum = 0;
        for (let j = i; j < i + 10; j++) {
            const pnl = trades[j].netPnl !== undefined ? trades[j].netPnl : (trades[j].pnl - 0.2);
            sum += pnl;
        }
        worst10 = Math.min(worst10, sum);
    }
    
    // If worst 10-trade sequence loses more than 20% of capital, system is fragile
    const survives = worst10 > -20;
    
    return {
        maxStreak,
        worstDrawdown: worstPnL.toFixed(2),
        worst10Sequence: worst10.toFixed(2),
        survives,
        rating: maxStreak <= 5 ? 'EXCELLENT' : maxStreak <= 8 ? 'GOOD' : maxStreak <= 12 ? 'MODERATE' : 'POOR'
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// NO-TRADE SCORING - Reward silence, penalize overtrading
// ═══════════════════════════════════════════════════════════════════════════════
function calculateNoTradeScore(totalCandles, tradesCount, chopCandles = 0) {
    if (totalCandles === 0) return { score: 0, rating: 'N/A' };
    
    const tradeFrequency = tradesCount / totalCandles;
    const optimalFrequency = 0.02; // Ideal: 1 trade per 50 candles
    
    // Penalize if trading more than optimal
    let score = 100;
    if (tradeFrequency > optimalFrequency * 2) {
        score -= (tradeFrequency - optimalFrequency * 2) * 1000; // Heavy penalty
    }
    
    // Bonus for avoiding chop
    const chopAvoidance = chopCandles > 0 ? (1 - (tradesCount / chopCandles)) * 20 : 0;
    score += chopAvoidance;
    
    score = Math.max(0, Math.min(100, score));
    
    return {
        score: score.toFixed(0),
        frequency: (tradeFrequency * 100).toFixed(2) + '% of candles',
        rating: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : score >= 40 ? 'MODERATE' : 'OVERTRADING'
    };
}

// Display backtest results
function displayBacktestResults(results, days) {
    const container = document.getElementById('backtestResults');
    
    const winRate = results.totalTrades > 0 ? ((results.wins / results.totalTrades) * 100).toFixed(1) : 0;
    const pnlClass = results.totalPnL >= 0 ? 'positive' : 'negative';
    
    // Find best/worst
    let bestCoin = '-', bestCoinWin = 0;
    let worstCoin = '-', worstCoinWin = 100;
    Object.entries(results.byCoin).forEach(([coin, data]) => {
        if (data.trades >= 3) {
            const wr = (data.wins / data.trades) * 100;
            if (wr > bestCoinWin) { bestCoin = coin.replace('USDT', ''); bestCoinWin = wr; }
            if (wr < worstCoinWin) { worstCoin = coin.replace('USDT', ''); worstCoinWin = wr; }
        }
    });
    
    let bestTF = '-', bestTFWin = 0;
    Object.entries(results.byTF).forEach(([tf, data]) => {
        if (data.trades >= 3) {
            const wr = (data.wins / data.trades) * 100;
            if (wr > bestTFWin) { bestTF = tf; bestTFWin = wr; }
        }
    });
    
    container.innerHTML = `
        <div class="backtest-summary">
            <div class="backtest-stat">
                <div class="backtest-stat-label">Total Trades</div>
                <div class="backtest-stat-value neutral">${results.totalTrades}</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Win Rate</div>
                <div class="backtest-stat-value ${parseFloat(winRate) >= 50 ? 'positive' : 'negative'}">${winRate}%</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Total P&L</div>
                <div class="backtest-stat-value ${pnlClass}">${results.totalPnL >= 0 ? '+' : ''}${results.totalPnL.toFixed(0)}%</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Wins / Losses</div>
                <div class="backtest-stat-value neutral">${results.wins} / ${results.losses}</div>
            </div>
        </div>
        
        <div class="backtest-grades">
            <div class="backtest-grade-row" style="border-left:3px solid #00ffcc">
                <span class="grade-name">💎 CREAM</span>
                <span class="grade-stats">
                    <span>${results.byGrade.cream.trades} trades</span>
                    <span class="win-rate">${results.byGrade.cream.trades > 0 ? ((results.byGrade.cream.wins / results.byGrade.cream.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.cream.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.cream.pnl >= 0 ? '+' : ''}${results.byGrade.cream.pnl.toFixed(0)}%</span>
                </span>
            </div>
            <div class="backtest-grade-row" style="border-left:3px solid var(--gold)">
                <span class="grade-name">🥇 PERFECT</span>
                <span class="grade-stats">
                    <span>${results.byGrade.perfect.trades} trades</span>
                    <span class="win-rate">${results.byGrade.perfect.trades > 0 ? ((results.byGrade.perfect.wins / results.byGrade.perfect.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.perfect.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.perfect.pnl >= 0 ? '+' : ''}${results.byGrade.perfect.pnl.toFixed(0)}%</span>
                </span>
            </div>
            <div class="backtest-grade-row" style="border-left:3px solid var(--cyan)">
                <span class="grade-name">🥈 STRONG</span>
                <span class="grade-stats">
                    <span>${results.byGrade.strong.trades} trades</span>
                    <span class="win-rate">${results.byGrade.strong.trades > 0 ? ((results.byGrade.strong.wins / results.byGrade.strong.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.strong.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.strong.pnl >= 0 ? '+' : ''}${results.byGrade.strong.pnl.toFixed(0)}%</span>
                </span>
            </div>
            <div class="backtest-grade-row" style="border-left:3px solid var(--amber)">
                <span class="grade-name">🥉 VALID</span>
                <span class="grade-stats">
                    <span>${results.byGrade.valid.trades} trades</span>
                    <span class="win-rate">${results.byGrade.valid.trades > 0 ? ((results.byGrade.valid.wins / results.byGrade.valid.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.valid.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.valid.pnl >= 0 ? '+' : ''}${results.byGrade.valid.pnl.toFixed(0)}%</span>
                </span>
            </div>
        </div>
        
        <div class="backtest-insights">
            <div class="backtest-insight">
                <span class="icon">📈</span>
                <span>Best Coin: <span class="highlight">${bestCoin}</span> (${bestCoinWin.toFixed(0)}% win)</span>
            </div>
            <div class="backtest-insight">
                <span class="icon">📉</span>
                <span>Worst Coin: <span class="lowlight">${worstCoin}</span> (${worstCoinWin.toFixed(0)}% win)</span>
            </div>
            <div class="backtest-insight">
                <span class="icon">⏰</span>
                <span>Best TF: <span class="highlight">${bestTF}</span> (${bestTFWin.toFixed(0)}% win)</span>
            </div>
            <div class="backtest-insight">
                <span class="icon">📊</span>
                <span>Period: Last <span class="highlight">${days}</span> days</span>
            </div>
        </div>
    `;
}

function calculateSmartLimitEntry(currentPrice, direction, atr, zoneDetails, smcDetails, adx) {
    const result = {
        limitEntry: null,
        entryType: null,  // 'ZONE' or 'ATR'
        zoneScore: 0,
        atrScore: 0,
        confidence: 0
    };
    
    // Get relevant zone
    const zone = direction === 'LONG' ? zoneDetails.nearestSupport : zoneDetails.nearestResistance;
    
    // Calculate Zone Score (if zone exists)
    if (zone) {
        let zScore = 0;
        
        // Touch count (max 25)
        if (zone.touches >= 4) zScore += 25;
        else if (zone.touches >= 3) zScore += 20;
        else if (zone.touches >= 2) zScore += 15;
        else zScore += 5;
        
        // Distance to zone (max 25)
        const zonePrice = direction === 'LONG' ? zone.high : zone.low;
        const distancePct = currentPrice > 0 ? Math.abs(currentPrice - zonePrice) / currentPrice * 100 : 0;
        if (distancePct <= 0.5) zScore += 25;
        else if (distancePct <= 1.0) zScore += 22;
        else if (distancePct <= 1.5) zScore += 18;
        else if (distancePct <= 2.0) zScore += 12;
        else if (distancePct <= 3.0) zScore += 5;
        
        // Order Block confluence (max 20)
        if (smcDetails && smcDetails.orderBlocks) {
            const obs = direction === 'LONG' ? smcDetails.orderBlocks.bullish : smcDetails.orderBlocks.bearish;
            const obAtZone = obs && obs.some(ob => Math.abs(ob.price - zonePrice) / zonePrice < 0.01);
            if (obAtZone) zScore += 20;
        }
        
        // Zone strength (max 15)
        if (zone.strength >= 70) zScore += 15;
        else if (zone.strength >= 50) zScore += 10;
        else zScore += 5;
        
        result.zoneScore = Math.min(100, zScore);
        result.zoneEntry = direction === 'LONG' ? zone.high * 1.002 : zone.low * 0.998;
    }
    
    // Calculate ATR Entry
    let pullbackMult = 0.4;
    const adxVal = adx || 25;
    
    // Adjust by trend strength
    if (adxVal > 40) pullbackMult = 0.25;
    else if (adxVal > 30) pullbackMult = 0.35;
    else if (adxVal > 20) pullbackMult = 0.45;
    else pullbackMult = 0.55;
    
    result.atrEntry = direction === 'LONG' 
        ? currentPrice - (atr * pullbackMult)
        : currentPrice + (atr * pullbackMult);
    
    // ATR Score
    result.atrScore = 50;
    if (adxVal > 30) result.atrScore += 20;
    else if (adxVal > 25) result.atrScore += 10;
    if (!zone || result.zoneScore < 40) result.atrScore += 15;
    result.atrScore = Math.min(100, result.atrScore);
    
    // Decision: Zone vs ATR
    if (result.zoneScore >= 70 && zone) {
        const distPct = Math.abs(currentPrice - result.zoneEntry) / currentPrice * 100;
        if (distPct <= 2.0) {
            result.entryType = 'ZONE';
            result.limitEntry = result.zoneEntry;
            result.confidence = Math.round(result.zoneScore * 0.9);
        }
    }
    
    if (!result.entryType) {
        if (result.zoneScore > result.atrScore && result.zoneScore >= 50) {
            result.entryType = 'ZONE';
            result.limitEntry = result.zoneEntry;
            result.confidence = Math.round(result.zoneScore * 0.85);
        } else {
            result.entryType = 'ATR';
            result.limitEntry = result.atrEntry;
            result.confidence = Math.round(result.atrScore * 0.85);
        }
    }
    
    // Safety: max 3% from current price
    const maxDist = 0.03;
    const entryDist = Math.abs(currentPrice - result.limitEntry) / currentPrice;
    if (entryDist > maxDist) {
        result.limitEntry = direction === 'LONG'
            ? currentPrice * (1 - maxDist)
            : currentPrice * (1 + maxDist);
        result.confidence = Math.round(result.confidence * 0.8);
    }
    
    return result;
}


// ═══════════════════════════════════════════════════════════════════════════════
// ZONE ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════════

// Find swing highs and lows with configurable left/right bars
function findSwingPoints(klines, leftBars = 5, rightBars = 5) {
    const swingHighs = [];
    const swingLows = [];
    
    if (!klines || klines.length < leftBars + rightBars + 1) return { highs: [], lows: [] };
    
    for (let i = leftBars; i < klines.length - rightBars; i++) {
        let isHigh = true;
        let isLow = true;
        
        const currentHigh = klines[i].high;
        const currentLow = klines[i].low;
        
        // Check left bars
        for (let j = i - leftBars; j < i; j++) {
            if (klines[j].high >= currentHigh) isHigh = false;
            if (klines[j].low <= currentLow) isLow = false;
        }
        
        // Check right bars
        for (let j = i + 1; j <= i + rightBars; j++) {
            if (klines[j].high >= currentHigh) isHigh = false;
            if (klines[j].low <= currentLow) isLow = false;
        }
        
        if (isHigh) {
            swingHighs.push({
                index: i,
                price: currentHigh,
                time: klines[i].time,
                volume: klines[i].volume
            });
        }
        
        if (isLow) {
            swingLows.push({
                index: i,
                price: currentLow,
                time: klines[i].time,
                volume: klines[i].volume
            });
        }
    }
    
    return { highs: swingHighs, lows: swingLows };
}

// Cluster nearby price levels into zones
function clusterZones(points, threshold = 0.005) {
    if (!points || points.length === 0) return [];
    
    const sorted = [...points].sort((a, b) => a.price - b.price);
    const clusters = [];
    let currentCluster = [sorted[0]];
    
    for (let i = 1; i < sorted.length; i++) {
        const clusterAvg = currentCluster.reduce((sum, p) => sum + p.price, 0) / currentCluster.length;
        const pctDiff = Math.abs(sorted[i].price - clusterAvg) / clusterAvg;
        
        if (pctDiff <= threshold) {
            currentCluster.push(sorted[i]);
        } else {
            clusters.push(currentCluster);
            currentCluster = [sorted[i]];
        }
    }
    clusters.push(currentCluster);
    
    // Convert clusters to zones
    return clusters.map(cluster => {
        const prices = cluster.map(p => p.price);
        const high = Math.max(...prices);
        const low = Math.min(...prices);
        const totalVolume = cluster.reduce((sum, p) => sum + (p.volume || 0), 0);
        const times = cluster.map(p => p.time);
        
        return {
            high: high,
            low: low,
            price: (high + low) / 2,
            touches: cluster.length,
            volume: totalVolume,
            firstTouch: Math.min(...times),
            lastTouch: Math.max(...times),
            indices: cluster.map(p => p.index)
        };
    });
}

// Calculate zone strength with decay over time
function calcZoneStrength(zone, currentIndex, totalBars, avgVolume) {
    // SAFETY: Validate inputs
    if (!zone) return 0;
    
    let strength = 0;
    const touches = zone.touches || 0;
    const volume = zone.volume || 0;
    const indices = zone.indices || [];
    
    // Touch count bonus (max 30 points)
    if (touches >= 5) strength += 30;
    else if (touches >= 4) strength += 25;
    else if (touches >= 3) strength += 20;
    else if (touches >= 2) strength += 12;
    else strength += 5;
    
    // Volume bonus (max 20 points) - FIXED: Safe division
    if (avgVolume > 0 && touches > 0) {
        const volRatio = volume / (avgVolume * touches);
        if (!isNaN(volRatio) && isFinite(volRatio)) {
            if (volRatio >= 2.0) strength += 20;
            else if (volRatio >= 1.5) strength += 15;
            else if (volRatio >= 1.2) strength += 10;
            else if (volRatio >= 1.0) strength += 5;
        }
    }
    
    // Freshness bonus (max 20 points) - newer zones are stronger
    // SAFETY: Check indices array is not empty
    if (indices.length > 0) {
        const lastTouchIndex = Math.max(...indices);
        const barsSinceTouch = currentIndex - lastTouchIndex;
        if (barsSinceTouch <= 10) strength += 20;
        else if (barsSinceTouch <= 25) strength += 15;
        else if (barsSinceTouch <= 50) strength += 10;
        else if (barsSinceTouch <= 100) strength += 5;
        
        // Age decay - reduce strength for very old zones
        const firstTouchIndex = Math.min(...indices);
        const zoneAge = currentIndex - firstTouchIndex;
        if (zoneAge > 150) strength -= 10;
        else if (zoneAge > 100) strength -= 5;
    }
    
    return Math.max(0, Math.min(100, strength));
}

// Check if price is at a round number
function checkRoundNumber(price) {
    let bonus = 0;
    const priceStr = price.toString();
    
    // Check for major round numbers
    if (price >= 1000) {
        if (price % 10000 === 0) bonus = 8;      // 10000, 20000, etc.
        else if (price % 5000 === 0) bonus = 6;  // 5000, 15000, etc.
        else if (price % 1000 === 0) bonus = 4;  // 1000, 2000, etc.
        else if (price % 500 === 0) bonus = 3;
        else if (price % 100 === 0) bonus = 2;
    } else if (price >= 1) {
        if (price % 100 === 0) bonus = 5;
        else if (price % 50 === 0) bonus = 4;
        else if (price % 10 === 0) bonus = 3;
        else if (price % 5 === 0) bonus = 2;
        else if (price % 1 === 0) bonus = 1;
    } else {
        // For small prices like 0.00001234
        const decimals = priceStr.split('.')[1] || '';
        const zeros = (decimals.match(/0+$/) || [''])[0].length;
        if (zeros >= 4) bonus = 4;
        else if (zeros >= 3) bonus = 3;
        else if (zeros >= 2) bonus = 2;
    }
    
    return bonus;
}

// Calculate Fibonacci levels from swing high to swing low
function calcFibLevels(swingHigh, swingLow) {
    const range = swingHigh - swingLow;
    return {
        level_0: swingLow,
        level_236: swingLow + range * 0.236,
        level_382: swingLow + range * 0.382,
        level_5: swingLow + range * 0.5,
        level_618: swingLow + range * 0.618,
        level_786: swingLow + range * 0.786,
        level_1: swingHigh
    };
}

// Check if zone aligns with Fibonacci level
function checkFibAlignment(zonePrice, fibLevels, tolerance = 0.005) {
    const fibs = [0.236, 0.382, 0.5, 0.618, 0.786];
    const fibPrices = [fibLevels.level_236, fibLevels.level_382, fibLevels.level_5, fibLevels.level_618, fibLevels.level_786];
    
    for (let i = 0; i < fibPrices.length; i++) {
        const pctDiff = Math.abs(zonePrice - fibPrices[i]) / fibPrices[i];
        if (pctDiff <= tolerance) {
            return { aligned: true, level: fibs[i], bonus: fibs[i] === 0.618 ? 8 : fibs[i] === 0.5 ? 6 : 4 };
        }
    }
    return { aligned: false, level: null, bonus: 0 };
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🎯 ADVANCED GP (GOLDEN POCKET) & OTE (OPTIMAL TRADE ENTRY) SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

/*
 * SMC FIBONACCI ZONES - INSTITUTIONAL GRADE:
 * 
 * GP (Golden Pocket): 0.618 - 0.65 (tightest reversal zone - highest probability)
 * OTE (Optimal Trade Entry): 0.62 - 0.79 (wider high-probability zone)
 * 
 * ADVANCED FEATURES:
 * - Multi-swing detection (finds best impulse)
 * - Volume confirmation at zones
 * - OB/FVG confluence detection
 * - Liquidity sweep confirmation
 * - Time-based decay
 * - HTF alignment bonus
 * 
 * COLOR LOGIC:
 * - BULLISH impulse + price retracing DOWN into GP/OTE = GREEN (LONG setup)
 * - BEARISH impulse + price retracing UP into GP/OTE = RED (SHORT setup)
 */

// GP/OTE Configuration
const GP_OTE_CONFIG = {
    // Zone definitions
    GP: { start: 0.618, end: 0.65, name: 'Golden Pocket', icon: '🎯', weight: 1.3 },
    OTE: { start: 0.62, end: 0.79, name: 'Optimal Trade Entry', icon: '📍', weight: 1.0 },
    
    // Extended zones for context
    DEEP: { start: 0.79, end: 0.886, name: 'Deep Retracement', icon: '⚠️', weight: 0.7 },
    SHALLOW: { start: 0.382, end: 0.5, name: 'Shallow Pullback', icon: '📉', weight: 0.5 },
    
    // Minimum impulse size (as % of price)
    minImpulsePercent: 1.0,
    
    // Distance thresholds
    distances: {
        IN_ZONE: 0.15,      // Within 0.15% = IN ZONE
        TOUCHING: 0.3,      // Within 0.3% = TOUCHING
        NEAR: 0.8,          // Within 0.8% = NEAR
        APPROACHING: 1.5,   // Within 1.5% = APPROACHING
        FAR: 999            // Beyond = FAR
    },
    
    // Score bonuses
    scores: {
        IN_GP: 25,
        IN_OTE: 18,
        TOUCHING_GP: 15,
        TOUCHING_OTE: 10,
        NEAR_GP: 8,
        NEAR_OTE: 5,
        VOLUME_CONFIRM: 8,
        OB_CONFLUENCE: 12,
        FVG_CONFLUENCE: 10,
        LIQUIDITY_SWEEP: 15,
        HTF_ALIGNMENT: 10,
        FRESH_ZONE: 5,
        STALE_PENALTY: -5
    }
};

// Find significant swing points for GP/OTE
function findGPOTESwings(klines, leftBars = 5, rightBars = 5) {
    if (!klines || klines.length < leftBars + rightBars + 10) return { highs: [], lows: [] };
    
    const len = klines.length;
    const highs = [];
    const lows = [];
    
    for (let i = leftBars; i < len - rightBars; i++) {
        let isHigh = true;
        let isLow = true;
        
        for (let j = i - leftBars; j <= i + rightBars; j++) {
            if (j === i) continue;
            if (klines[j].high >= klines[i].high) isHigh = false;
            if (klines[j].low <= klines[i].low) isLow = false;
        }
        
        if (isHigh) {
            highs.push({
                index: i,
                price: klines[i].high,
                time: klines[i].time,
                volume: klines[i].volume,
                candle: klines[i]
            });
        }
        if (isLow) {
            lows.push({
                index: i,
                price: klines[i].low,
                time: klines[i].time,
                volume: klines[i].volume,
                candle: klines[i]
            });
        }
    }
    
    return { highs, lows };
}

// Find the best impulse move for GP/OTE calculation
function findBestImpulse(klines, swings) {
    if (!swings || !klines || klines.length < 30) return null;
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    const avgVolume = klines.slice(-50).reduce((s, k) => s + k.volume, 0) / 50;
    
    // Get recent swings (prioritize last 40 bars for freshness)
    const recentHighs = swings.highs.filter(s => s.index > len - 50).sort((a, b) => b.price - a.price);
    const recentLows = swings.lows.filter(s => s.index > len - 50).sort((a, b) => a.price - b.price);
    
    if (recentHighs.length === 0 || recentLows.length === 0) return null;
    
    // Find potential impulse pairs
    const impulses = [];
    
    for (const high of recentHighs.slice(0, 3)) {
        for (const low of recentLows.slice(0, 3)) {
            const range = high.price - low.price;
            const rangePercent = (range / low.price) * 100;
            
            // Skip if impulse too small
            if (rangePercent < GP_OTE_CONFIG.minImpulsePercent) continue;
            
            // Determine direction
            let direction, isValid;
            if (high.index > low.index) {
                // Low → High = BULLISH impulse (look for LONG on pullback)
                direction = 'BULLISH';
                // Valid if price has pulled back from high
                isValid = currentPrice < high.price && currentPrice > low.price;
            } else {
                // High → Low = BEARISH impulse (look for SHORT on pullback)
                direction = 'BEARISH';
                // Valid if price has pulled back from low
                isValid = currentPrice > low.price && currentPrice < high.price;
            }
            
            if (!isValid) continue;
            
            // Calculate retracement level
            const retracement = direction === 'BULLISH'
                ? (high.price - currentPrice) / range
                : (currentPrice - low.price) / range;
            
            // Score this impulse
            let score = 50;
            score += rangePercent * 5;  // Bigger impulse = better
            score += (len - Math.max(high.index, low.index)) < 20 ? 20 : 0;  // Fresh = better
            score += (high.volume + low.volume) > avgVolume * 2 ? 10 : 0;  // Volume confirmation
            
            impulses.push({
                high,
                low,
                direction,
                range,
                rangePercent,
                retracement,
                score,
                freshness: len - Math.max(high.index, low.index)
            });
        }
    }
    
    if (impulses.length === 0) return null;
    
    // Return best impulse
    return impulses.sort((a, b) => b.score - a.score)[0];
}

// Calculate GP and OTE zones from impulse
function calculateGPOTEZones(impulse) {
    if (!impulse) return null;
    
    const { high, low, direction, range } = impulse;
    
    let zones;
    
    if (direction === 'BULLISH') {
        // BULLISH: Fib from LOW to HIGH, retracement DOWN
        // GP/OTE are measured from HIGH going down
        zones = {
            direction: 'LONG',
            impulseDirection: 'BULLISH',
            swingHigh: high.price,
            swingLow: low.price,
            range: range,
            
            // Golden Pocket (0.618 - 0.65 retracement from high)
            GP: {
                high: high.price - (range * GP_OTE_CONFIG.GP.start),
                low: high.price - (range * GP_OTE_CONFIG.GP.end),
                mid: high.price - (range * ((GP_OTE_CONFIG.GP.start + GP_OTE_CONFIG.GP.end) / 2)),
                name: GP_OTE_CONFIG.GP.name,
                icon: GP_OTE_CONFIG.GP.icon,
                weight: GP_OTE_CONFIG.GP.weight,
                fibLevels: { start: GP_OTE_CONFIG.GP.start, end: GP_OTE_CONFIG.GP.end }
            },
            
            // OTE Zone (0.62 - 0.79 retracement from high)
            OTE: {
                high: high.price - (range * GP_OTE_CONFIG.OTE.start),
                low: high.price - (range * GP_OTE_CONFIG.OTE.end),
                mid: high.price - (range * ((GP_OTE_CONFIG.OTE.start + GP_OTE_CONFIG.OTE.end) / 2)),
                name: GP_OTE_CONFIG.OTE.name,
                icon: GP_OTE_CONFIG.OTE.icon,
                weight: GP_OTE_CONFIG.OTE.weight,
                fibLevels: { start: GP_OTE_CONFIG.OTE.start, end: GP_OTE_CONFIG.OTE.end }
            },
            
            // Deep zone (warning)
            DEEP: {
                high: high.price - (range * GP_OTE_CONFIG.DEEP.start),
                low: high.price - (range * GP_OTE_CONFIG.DEEP.end),
                mid: high.price - (range * ((GP_OTE_CONFIG.DEEP.start + GP_OTE_CONFIG.DEEP.end) / 2)),
                name: GP_OTE_CONFIG.DEEP.name,
                icon: GP_OTE_CONFIG.DEEP.icon
            },
            
            // Key fib levels
            fib_0: low.price,
            fib_236: high.price - (range * 0.236),
            fib_382: high.price - (range * 0.382),
            fib_5: high.price - (range * 0.5),
            fib_618: high.price - (range * 0.618),
            fib_65: high.price - (range * 0.65),
            fib_705: high.price - (range * 0.705),
            fib_79: high.price - (range * 0.79),
            fib_886: high.price - (range * 0.886),
            fib_1: high.price
        };
    } else {
        // BEARISH: Fib from HIGH to LOW, retracement UP
        // GP/OTE are measured from LOW going up
        zones = {
            direction: 'SHORT',
            impulseDirection: 'BEARISH',
            swingHigh: high.price,
            swingLow: low.price,
            range: range,
            
            // Golden Pocket (0.618 - 0.65 retracement from low)
            GP: {
                low: low.price + (range * GP_OTE_CONFIG.GP.start),
                high: low.price + (range * GP_OTE_CONFIG.GP.end),
                mid: low.price + (range * ((GP_OTE_CONFIG.GP.start + GP_OTE_CONFIG.GP.end) / 2)),
                name: GP_OTE_CONFIG.GP.name,
                icon: GP_OTE_CONFIG.GP.icon,
                weight: GP_OTE_CONFIG.GP.weight,
                fibLevels: { start: GP_OTE_CONFIG.GP.start, end: GP_OTE_CONFIG.GP.end }
            },
            
            // OTE Zone (0.62 - 0.79 retracement from low)
            OTE: {
                low: low.price + (range * GP_OTE_CONFIG.OTE.start),
                high: low.price + (range * GP_OTE_CONFIG.OTE.end),
                mid: low.price + (range * ((GP_OTE_CONFIG.OTE.start + GP_OTE_CONFIG.OTE.end) / 2)),
                name: GP_OTE_CONFIG.OTE.name,
                icon: GP_OTE_CONFIG.OTE.icon,
                weight: GP_OTE_CONFIG.OTE.weight,
                fibLevels: { start: GP_OTE_CONFIG.OTE.start, end: GP_OTE_CONFIG.OTE.end }
            },
            
            // Deep zone (warning)
            DEEP: {
                low: low.price + (range * GP_OTE_CONFIG.DEEP.start),
                high: low.price + (range * GP_OTE_CONFIG.DEEP.end),
                mid: low.price + (range * ((GP_OTE_CONFIG.DEEP.start + GP_OTE_CONFIG.DEEP.end) / 2)),
                name: GP_OTE_CONFIG.DEEP.name,
                icon: GP_OTE_CONFIG.DEEP.icon
            },
            
            // Key fib levels
            fib_0: high.price,
            fib_236: low.price + (range * 0.236),
            fib_382: low.price + (range * 0.382),
            fib_5: low.price + (range * 0.5),
            fib_618: low.price + (range * 0.618),
            fib_65: low.price + (range * 0.65),
            fib_705: low.price + (range * 0.705),
            fib_79: low.price + (range * 0.79),
            fib_886: low.price + (range * 0.886),
            fib_1: low.price
        };
    }
    
    return zones;
}

// Get price position relative to GP/OTE zones
function getPricePositionInZones(currentPrice, zones) {
    if (!zones) return null;
    
    const { GP, OTE, DEEP, direction } = zones;
    const cfg = GP_OTE_CONFIG.distances;
    
    // Helper to check if price is in zone
    const inZone = (price, zone) => price >= zone.low && price <= zone.high;
    
    // Helper to get distance to zone
    const distanceToZone = (price, zone) => {
        if (price >= zone.low && price <= zone.high) return 0;
        if (price < zone.low) return ((zone.low - price) / price) * 100;
        return ((price - zone.high) / price) * 100;
    };
    
    // Calculate positions
    const gpDistance = distanceToZone(currentPrice, GP);
    const oteDistance = distanceToZone(currentPrice, OTE);
    const deepDistance = distanceToZone(currentPrice, DEEP);
    
    const inGP = inZone(currentPrice, GP);
    const inOTE = inZone(currentPrice, OTE);
    const inDEEP = inZone(currentPrice, DEEP);
    
    // Determine status for each zone
    const getStatus = (distance, inZoneFlag) => {
        if (inZoneFlag) return 'IN_ZONE';
        if (distance <= cfg.TOUCHING) return 'TOUCHING';
        if (distance <= cfg.NEAR) return 'NEAR';
        if (distance <= cfg.APPROACHING) return 'APPROACHING';
        return 'FAR';
    };
    
    // Progress percentage (0-100, where 100 = in zone)
    const getProgress = (distance) => {
        if (distance === 0) return 100;
        if (distance >= 2) return 0;
        return Math.round((1 - distance / 2) * 100);
    };
    
    return {
        direction,
        currentPrice,
        
        GP: {
            ...GP,
            inZone: inGP,
            distance: gpDistance,
            status: getStatus(gpDistance, inGP),
            progress: getProgress(gpDistance),
            color: direction === 'LONG' ? 'var(--long)' : 'var(--short)',
            bgColor: direction === 'LONG' ? 'var(--long-dim)' : 'var(--short-dim)'
        },
        
        OTE: {
            ...OTE,
            inZone: inOTE,
            distance: oteDistance,
            status: getStatus(oteDistance, inOTE),
            progress: getProgress(oteDistance),
            color: direction === 'LONG' ? 'var(--long)' : 'var(--short)',
            bgColor: direction === 'LONG' ? 'var(--long-dim)' : 'var(--short-dim)'
        },
        
        DEEP: {
            ...DEEP,
            inZone: inDEEP,
            distance: deepDistance,
            status: getStatus(deepDistance, inDEEP),
            isWarning: inDEEP
        },
        
        // Summary
        bestZone: inGP ? 'GP' : inOTE ? 'OTE' : inDEEP ? 'DEEP' : 'NONE',
        isInOptimalZone: inGP || inOTE,
        overallStatus: inGP ? 'PERFECT_ENTRY' : inOTE ? 'GOOD_ENTRY' : inDEEP ? 'RISKY_ENTRY' : 
                       gpDistance < 0.5 ? 'APPROACHING_GP' : oteDistance < 0.5 ? 'APPROACHING_OTE' : 'WAITING'
    };
}

// Check for confluence with OB/FVG
function checkGPOTEConfluence(zones, orderBlocks, fvgs, currentPrice) {
    if (!zones) return { hasConfluence: false, factors: [] };
    
    const factors = [];
    let confluenceScore = 0;
    const { GP, OTE, direction } = zones;
    
    // Check OB confluence
    if (orderBlocks && orderBlocks.length > 0) {
        for (const ob of orderBlocks) {
            const obMid = (ob.high + ob.low) / 2;
            
            // Check if OB overlaps with GP
            if (obMid >= GP.low && obMid <= GP.high) {
                factors.push({ type: 'OB_AT_GP', text: 'Order Block at GP', score: GP_OTE_CONFIG.scores.OB_CONFLUENCE });
                confluenceScore += GP_OTE_CONFIG.scores.OB_CONFLUENCE;
            }
            // Check if OB overlaps with OTE
            else if (obMid >= OTE.low && obMid <= OTE.high) {
                factors.push({ type: 'OB_AT_OTE', text: 'Order Block at OTE', score: GP_OTE_CONFIG.scores.OB_CONFLUENCE * 0.8 });
                confluenceScore += GP_OTE_CONFIG.scores.OB_CONFLUENCE * 0.8;
            }
        }
    }
    
    // Check FVG confluence
    if (fvgs && fvgs.length > 0) {
        for (const fvg of fvgs) {
            const fvgMid = (fvg.high + fvg.low) / 2;
            
            // Check if FVG overlaps with GP
            if (fvgMid >= GP.low && fvgMid <= GP.high) {
                factors.push({ type: 'FVG_AT_GP', text: 'FVG at GP', score: GP_OTE_CONFIG.scores.FVG_CONFLUENCE });
                confluenceScore += GP_OTE_CONFIG.scores.FVG_CONFLUENCE;
            }
            // Check if FVG overlaps with OTE
            else if (fvgMid >= OTE.low && fvgMid <= OTE.high) {
                factors.push({ type: 'FVG_AT_OTE', text: 'FVG at OTE', score: GP_OTE_CONFIG.scores.FVG_CONFLUENCE * 0.8 });
                confluenceScore += GP_OTE_CONFIG.scores.FVG_CONFLUENCE * 0.8;
            }
        }
    }
    
    return {
        hasConfluence: factors.length > 0,
        factors,
        confluenceScore,
        confluenceCount: factors.length
    };
}

// Check for liquidity sweep at GP/OTE
function checkLiquiditySweepAtZone(klines, zones, lookback = 10) {
    if (!klines || !zones || klines.length < lookback) return { swept: false };
    
    const recent = klines.slice(-lookback);
    const { GP, OTE, direction } = zones;
    
    for (const candle of recent) {
        const wickLow = candle.low;
        const wickHigh = candle.high;
        const bodyLow = Math.min(candle.open, candle.close);
        const bodyHigh = Math.max(candle.open, candle.close);
        
        if (direction === 'LONG') {
            // For LONG: Look for wick below GP/OTE that closed back inside
            if (wickLow < GP.low && bodyLow > GP.low) {
                return {
                    swept: true,
                    zone: 'GP',
                    type: 'BULLISH_SWEEP',
                    description: 'Liquidity swept below GP',
                    score: GP_OTE_CONFIG.scores.LIQUIDITY_SWEEP
                };
            }
            if (wickLow < OTE.low && bodyLow > OTE.low) {
                return {
                    swept: true,
                    zone: 'OTE',
                    type: 'BULLISH_SWEEP',
                    description: 'Liquidity swept below OTE',
                    score: GP_OTE_CONFIG.scores.LIQUIDITY_SWEEP * 0.8
                };
            }
        } else {
            // For SHORT: Look for wick above GP/OTE that closed back inside
            if (wickHigh > GP.high && bodyHigh < GP.high) {
                return {
                    swept: true,
                    zone: 'GP',
                    type: 'BEARISH_SWEEP',
                    description: 'Liquidity swept above GP',
                    score: GP_OTE_CONFIG.scores.LIQUIDITY_SWEEP
                };
            }
            if (wickHigh > OTE.high && bodyHigh < OTE.high) {
                return {
                    swept: true,
                    zone: 'OTE',
                    type: 'BEARISH_SWEEP',
                    description: 'Liquidity swept above OTE',
                    score: GP_OTE_CONFIG.scores.LIQUIDITY_SWEEP * 0.8
                };
            }
        }
    }
    
    return { swept: false };
}

// MASTER FUNCTION: Complete GP/OTE Analysis
function analyzeGPOTE(klines, orderBlocks = [], fvgs = []) {
    try {
        if (!klines || klines.length < 50) {
            return {
                valid: false,
                reason: 'Insufficient data',
                zones: null,
                position: null,
                score: 0
            };
        }
        
        const len = klines.length;
        const currentPrice = klines[len - 1].close;
        
        // Step 1: Find swing points
        const swings = findGPOTESwings(klines, 5, 5);
        
        // Step 2: Find best impulse
        const impulse = findBestImpulse(klines, swings);
        
        if (!impulse) {
            return {
                valid: false,
                reason: 'No valid impulse found',
                zones: null,
                position: null,
                score: 0
            };
        }
        
        // Step 3: Calculate GP/OTE zones
        const zones = calculateGPOTEZones(impulse);
        
        if (!zones) {
            return {
                valid: false,
                reason: 'Could not calculate zones',
                zones: null,
                position: null,
                score: 0
            };
        }
        
        // Step 4: Get price position
        const position = getPricePositionInZones(currentPrice, zones);
        
        // Safety check for position
        if (!position || !position.GP || !position.OTE) {
            return {
                valid: false,
                reason: 'Could not calculate position',
                zones: zones,
                position: null,
                score: 0
            };
        }
        
        // Step 5: Check confluence
        const confluence = checkGPOTEConfluence(zones, orderBlocks, fvgs, currentPrice);
        
        // Step 6: Check liquidity sweep
        const sweep = checkLiquiditySweepAtZone(klines, zones);
        
        // Step 7: Calculate total score
        let score = 0;
        const factors = [];
        
        // Position score - with null checks
        if (position.GP && position.GP.inZone) {
            score += GP_OTE_CONFIG.scores.IN_GP;
            factors.push({ text: '🎯 IN Golden Pocket', score: GP_OTE_CONFIG.scores.IN_GP });
        } else if (position.OTE && position.OTE.inZone) {
            score += GP_OTE_CONFIG.scores.IN_OTE;
            factors.push({ text: '📍 IN OTE Zone', score: GP_OTE_CONFIG.scores.IN_OTE });
        } else if (position.GP && position.GP.status === 'TOUCHING') {
            score += GP_OTE_CONFIG.scores.TOUCHING_GP;
            factors.push({ text: '🎯 Touching GP', score: GP_OTE_CONFIG.scores.TOUCHING_GP });
        } else if (position.OTE && position.OTE.status === 'TOUCHING') {
            score += GP_OTE_CONFIG.scores.TOUCHING_OTE;
            factors.push({ text: '📍 Touching OTE', score: GP_OTE_CONFIG.scores.TOUCHING_OTE });
        } else if (position.GP && position.GP.status === 'NEAR') {
            score += GP_OTE_CONFIG.scores.NEAR_GP;
            factors.push({ text: '🎯 Near GP', score: GP_OTE_CONFIG.scores.NEAR_GP });
        } else if (position.OTE && position.OTE.status === 'NEAR') {
            score += GP_OTE_CONFIG.scores.NEAR_OTE;
            factors.push({ text: '📍 Near OTE', score: GP_OTE_CONFIG.scores.NEAR_OTE });
        }
        
        // Confluence score
        if (confluence && confluence.hasConfluence) {
            score += confluence.confluenceScore || 0;
            if (confluence.factors) {
                confluence.factors.forEach(f => factors.push({ text: f.text, score: f.score }));
            }
        }
        
        // Sweep score
        if (sweep && sweep.swept) {
            score += sweep.score || 0;
            factors.push({ text: '💧 ' + (sweep.description || 'Sweep'), score: sweep.score || 0 });
        }
        
        // Freshness bonus/penalty
        if (impulse.freshness < 15) {
            score += GP_OTE_CONFIG.scores.FRESH_ZONE;
            factors.push({ text: '✨ Fresh zone', score: GP_OTE_CONFIG.scores.FRESH_ZONE });
        } else if (impulse.freshness > 40) {
            score += GP_OTE_CONFIG.scores.STALE_PENALTY;
            factors.push({ text: '⏳ Stale zone', score: GP_OTE_CONFIG.scores.STALE_PENALTY });
        }
        
        // Deep zone warning
        if (position.DEEP && position.DEEP.inZone) {
            factors.push({ text: '⚠️ Deep retracement - risky', score: 0, warning: true });
        }
        
        return {
            valid: true,
            direction: zones.direction,
            impulse: {
                type: impulse.direction,
                range: impulse.range,
                rangePercent: impulse.rangePercent,
                freshness: impulse.freshness,
                swingHigh: zones.swingHigh,
                swingLow: zones.swingLow
            },
            zones: zones,
            position: position,
            confluence: confluence,
            sweep: sweep,
            score: Math.min(100, Math.max(0, score)),
            factors: factors,
            
            // Quick access - with null safety
            isInGP: position.GP ? position.GP.inZone : false,
            isInOTE: position.OTE ? position.OTE.inZone : false,
            isOptimalEntry: (position.GP && position.GP.inZone) || (position.OTE && position.OTE.inZone),
            
            // Colors for UI
            color: zones.direction === 'LONG' ? 'var(--long)' : 'var(--short)',
            bgColor: zones.direction === 'LONG' ? 'var(--long-dim)' : 'var(--short-dim)',
            
            // Display data - with null safety
            display: {
                GP: {
                    range: position.GP ? `${fmtPrice(position.GP.low)} - ${fmtPrice(position.GP.high)}` : 'N/A',
                    status: position.GP ? position.GP.status : 'FAR',
                    progress: position.GP ? position.GP.progress : 0,
                    distance: position.GP ? position.GP.distance.toFixed(2) + '%' : 'N/A',
                    icon: GP_OTE_CONFIG.GP.icon,
                    name: GP_OTE_CONFIG.GP.name
                },
                OTE: {
                    range: position.OTE ? `${fmtPrice(position.OTE.low)} - ${fmtPrice(position.OTE.high)}` : 'N/A',
                    status: position.OTE ? position.OTE.status : 'FAR',
                    progress: position.OTE ? position.OTE.progress : 0,
                    distance: position.OTE ? position.OTE.distance.toFixed(2) + '%' : 'N/A',
                    icon: GP_OTE_CONFIG.OTE.icon,
                    name: GP_OTE_CONFIG.OTE.name
                }
            }
        };
    } catch (gpoteError) {
        console.error('GP/OTE Analysis Error:', gpoteError);
        return {
            valid: false,
            reason: 'Analysis error: ' + gpoteError.message,
            zones: null,
            position: null,
            score: 0
        };
    }
}

// Generate GP/OTE HTML display
function generateGPOTEDisplay(gpoteData, compact = false) {
    if (!gpoteData || !gpoteData.valid) {
        return '<div style="color:var(--text3);font-size:11px;padding:8px">No GP/OTE zones detected</div>';
    }
    
    const { direction, position, display, score, factors, isInGP, isInOTE, color, bgColor } = gpoteData;
    const dirIcon = direction === 'LONG' ? '🟢' : '🔴';
    const dirText = direction === 'LONG' ? 'LONG SETUP' : 'SHORT SETUP';
    
    // Status icons
    const getStatusIcon = (status) => {
        switch(status) {
            case 'IN_ZONE': return '✓';
            case 'TOUCHING': return '◉';
            case 'NEAR': return '○';
            case 'APPROACHING': return '◌';
            default: return '·';
        }
    };
    
    // Progress bar
    const progressBar = (progress, color) => {
        const filled = Math.round(progress / 10);
        const empty = 10 - filled;
        return `<span style="font-family:monospace;font-size:10px;color:${color}">${'█'.repeat(filled)}${'░'.repeat(empty)}</span>`;
    };
    
    if (compact) {
        // Compact single-row display
        return `
            <div style="display:flex;align-items:center;gap:8px;padding:6px 10px;background:${bgColor};border:1px solid ${color};border-radius:6px;font-size:11px">
                <span style="font-weight:700;color:${color}">${dirIcon} ${dirText}</span>
                <span style="color:var(--text2)">|</span>
                <span>${display.GP.icon} GP ${getStatusIcon(display.GP.status)}</span>
                <span>${display.OTE.icon} OTE ${getStatusIcon(display.OTE.status)}</span>
                <span style="margin-left:auto;font-weight:700;color:${color}">${score}</span>
            </div>
        `;
    }
    
    // Full detailed display
    return `
        <div style="background:var(--bg3);border:1px solid ${color};border-radius:8px;overflow:hidden">
            <!-- Header -->
            <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:${bgColor};border-bottom:1px solid ${color}">
                <div style="display:flex;align-items:center;gap:8px">
                    <span style="font-size:13px;font-weight:700;color:${color}">${dirIcon} FIB ZONES</span>
                    <span style="font-size:10px;padding:2px 6px;background:${color};color:var(--bg1);border-radius:3px;font-weight:700">${dirText}</span>
                </div>
                <div style="font-size:14px;font-weight:700;color:${color}">${score}/100</div>
            </div>
            
            <!-- GP Row -->
            <div style="display:flex;align-items:center;padding:10px 12px;border-bottom:1px solid var(--border);gap:10px">
                <div style="font-size:16px">${display.GP.icon}</div>
                <div style="flex:1">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
                        <span style="font-size:11px;font-weight:700;color:${color}">GOLDEN POCKET</span>
                        <span style="font-size:10px;padding:2px 6px;background:${isInGP ? color : 'var(--bg4)'};color:${isInGP ? 'var(--bg1)' : 'var(--text2)'};border-radius:3px;font-weight:700">
                            ${display.GP.status.replace('_', ' ')}
                        </span>
                    </div>
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
                        <span style="font-size:12px;color:var(--text)">${display.GP.range}</span>
                        <span style="font-size:10px;color:var(--text3)">${display.GP.distance} away</span>
                    </div>
                    <div style="display:flex;align-items:center;gap:6px">
                        ${progressBar(display.GP.progress, color)}
                        <span style="font-size:10px;color:var(--text3)">${display.GP.progress}%</span>
                    </div>
                </div>
            </div>
            
            <!-- OTE Row -->
            <div style="display:flex;align-items:center;padding:10px 12px;border-bottom:1px solid var(--border);gap:10px">
                <div style="font-size:16px">${display.OTE.icon}</div>
                <div style="flex:1">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
                        <span style="font-size:11px;font-weight:700;color:${color}">OPTIMAL TRADE ENTRY</span>
                        <span style="font-size:10px;padding:2px 6px;background:${isInOTE ? color : 'var(--bg4)'};color:${isInOTE ? 'var(--bg1)' : 'var(--text2)'};border-radius:3px;font-weight:700">
                            ${display.OTE.status.replace('_', ' ')}
                        </span>
                    </div>
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
                        <span style="font-size:12px;color:var(--text)">${display.OTE.range}</span>
                        <span style="font-size:10px;color:var(--text3)">${display.OTE.distance} away</span>
                    </div>
                    <div style="display:flex;align-items:center;gap:6px">
                        ${progressBar(display.OTE.progress, color)}
                        <span style="font-size:10px;color:var(--text3)">${display.OTE.progress}%</span>
                    </div>
                </div>
            </div>
            
            <!-- Factors -->
            ${factors.length > 0 ? `
                <div style="padding:8px 12px;background:var(--bg4)">
                    <div style="display:flex;flex-wrap:wrap;gap:4px">
                        ${factors.map(f => `
                            <span style="font-size:9px;padding:2px 6px;background:${f.warning ? 'var(--amber-dim)' : 'var(--bg3)'};color:${f.warning ? 'var(--amber)' : 'var(--text2)'};border-radius:3px">
                                ${f.text} ${f.score > 0 ? '+' + f.score : f.score < 0 ? f.score : ''}
                            </span>
                        `).join('')}
                    </div>
                </div>
            ` : ''}
        </div>
    `;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF ADVANCED GP/OTE SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Detect fakeout (wick through zone but close back inside)
function detectFakeout(klines, zone, lookback = 5) {
    if (!klines || klines.length < lookback) return { detected: false };
    
    const recent = klines.slice(-lookback);
    
    for (const candle of recent) {
        // Bullish fakeout: wick below support but close above
        if (candle.low < zone.low && candle.close > zone.low && candle.close > candle.open) {
            return { detected: true, type: 'bullish', strength: 'strong' };
        }
        // Bearish fakeout: wick above resistance but close below
        if (candle.high > zone.high && candle.close < zone.high && candle.close < candle.open) {
            return { detected: true, type: 'bearish', strength: 'strong' };
        }
    }
    
    return { detected: false };
}

// Get distance status from current price to zone
function getZoneDistance(currentPrice, zone) {
    const zoneMid = zone.price;
    const pctDistance = Math.abs(currentPrice - zoneMid) / currentPrice * 100;
    
    let status, score;
    if (pctDistance <= 0.3) {
        status = 'AT';
        score = 40;
    } else if (pctDistance <= 0.8) {
        status = 'CLOSE';
        score = 30;
    } else if (pctDistance <= 1.5) {
        status = 'NEAR';
        score = 20;
    } else if (pctDistance <= 3.0) {
        status = 'APPROACHING';
        score = 10;
    } else {
        status = 'FAR';
        score = 0;
    }
    
    return { status, score, pctDistance };
}

// Multi-timeframe zone confluence analysis
async function analyzeZoneConfluence(symbol, currentPrice, entryTF) {
    const confluenceTFs = CONFIG.ZONE_TFS;
    const allZones = { support: [], resistance: [] };
    
    for (const tf of confluenceTFs) {
        try {
            const klines = await fetchKlines(symbol, tf, 200);
            if (!klines || klines.length < 50) continue;
            
            const swings = findSwingPoints(klines, 5, 5);
            const supportZones = clusterZones(swings.lows, 0.005);
            const resistanceZones = clusterZones(swings.highs, 0.005);
            
            // Tag zones with their timeframe
            supportZones.forEach(z => {
                z.tf = tf;
                z.type = 'support';
                if (z.price < currentPrice) allZones.support.push(z);
            });
            
            resistanceZones.forEach(z => {
                z.tf = tf;
                z.type = 'resistance';
                if (z.price > currentPrice) allZones.resistance.push(z);
            });
            
            await sleep(50);
        } catch (e) {
            console.error(`Zone confluence error for ${tf}:`, e);
        }
    }
    
    // Find confluent zones (zones that appear in multiple TFs)
    const findConfluent = (zones) => {
        const confluent = [];
        const used = new Set();
        
        for (let i = 0; i < zones.length; i++) {
            if (used.has(i)) continue;
            
            const zone = zones[i];
            const matching = [zone];
            
            for (let j = i + 1; j < zones.length; j++) {
                if (used.has(j)) continue;
                
                const other = zones[j];
                const pctDiff = Math.abs(zone.price - other.price) / zone.price;
                
                if (pctDiff <= 0.015) { // 1.5% tolerance for confluence
                    matching.push(other);
                    used.add(j);
                }
            }
            
            if (matching.length >= 1) {
                const tfs = [...new Set(matching.map(m => m.tf))];
                const avgPrice = matching.reduce((sum, m) => sum + m.price, 0) / matching.length;
                const totalTouches = matching.reduce((sum, m) => sum + m.touches, 0);
                
                confluent.push({
                    price: avgPrice,
                    high: Math.max(...matching.map(m => m.high)),
                    low: Math.min(...matching.map(m => m.low)),
                    tfs: tfs,
                    tfCount: tfs.length,
                    totalTouches: totalTouches,
                    type: zone.type
                });
            }
            used.add(i);
        }
        
        return confluent.sort((a, b) => b.tfCount - a.tfCount);
    };
    
    return {
        support: findConfluent(allZones.support),
        resistance: findConfluent(allZones.resistance)
    };
}

// MAIN ZONE ANALYSIS FUNCTION
async function performZoneAnalysis(klines, symbol, tf, currentPrice) {
    const result = {
        score: 0,
        direction: null,
        status: 'FAR',
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const len = klines.length;
    // FIXED: Safe volume calculation
    const volSlice = klines.slice(-50).filter(k => k?.volume > 0);
    const avgVolume = volSlice.length > 0 ? volSlice.reduce((sum, k) => sum + k.volume, 0) / volSlice.length : 1;
    
    // Find swing points
    const swings = findSwingPoints(klines, 5, 5);
    
    // Cluster into zones
    const supportZones = clusterZones(swings.lows, 0.005).filter(z => z.price < currentPrice);
    const resistanceZones = clusterZones(swings.highs, 0.005).filter(z => z.price > currentPrice);
    
    // Calculate strength for each zone
    supportZones.forEach(z => {
        z.strength = calcZoneStrength(z, len - 1, len, avgVolume);
    });
    resistanceZones.forEach(z => {
        z.strength = calcZoneStrength(z, len - 1, len, avgVolume);
    });
    
    // Sort by strength
    supportZones.sort((a, b) => b.strength - a.strength);
    resistanceZones.sort((a, b) => b.strength - a.strength);
    
    // Get nearest zones
    const nearestSupport = supportZones.length > 0 ? supportZones[0] : null;
    const nearestResistance = resistanceZones.length > 0 ? resistanceZones[0] : null;
    
    result.details.nearestSupport = nearestSupport;
    result.details.nearestResistance = nearestResistance;
    result.details.supportCount = supportZones.length;
    result.details.resistanceCount = resistanceZones.length;
    
    // Calculate Fib levels
    const recentHigh = Math.max(...klines.slice(-100).map(k => k.high));
    const recentLow = Math.min(...klines.slice(-100).map(k => k.low));
    const fibLevels = calcFibLevels(recentHigh, recentLow);
    result.details.fibLevels = fibLevels;
    
    let score = 0;
    
    // Check support zone
    if (nearestSupport) {
        const dist = getZoneDistance(currentPrice, nearestSupport);
        
        if (dist.status !== 'FAR') {
            result.direction = 'LONG';
            result.status = dist.status;
            score += dist.score;
            result.factors.push(`${dist.status} Support`);
            
            // Touch count bonus
            if (nearestSupport.touches >= 4) {
                score += 15;
                result.factors.push(`${nearestSupport.touches} touches`);
            } else if (nearestSupport.touches >= 3) {
                score += 10;
                result.factors.push(`${nearestSupport.touches} touches`);
            } else if (nearestSupport.touches >= 2) {
                score += 5;
            }
            
            // Strength bonus
            if (nearestSupport.strength >= 60) {
                score += 10;
                result.factors.push('Strong zone');
            } else if (nearestSupport.strength >= 40) {
                score += 5;
            }
            
            // Round number bonus
            const roundBonus = checkRoundNumber(nearestSupport.price);
            if (roundBonus >= 4) {
                score += roundBonus;
                result.factors.push('Round number');
            }
            
            // Fib alignment bonus
            const fibCheck = checkFibAlignment(nearestSupport.price, fibLevels);
            if (fibCheck.aligned) {
                score += fibCheck.bonus;
                result.factors.push(`Fib ${fibCheck.level}`);
            }
            
            // Fakeout bonus
            const fakeout = detectFakeout(klines, nearestSupport);
            if (fakeout.detected && fakeout.type === 'bullish') {
                score += 12;
                result.factors.push('Fakeout sweep ✓');
            }
        }
    }
    
    // Check resistance zone
    if (nearestResistance) {
        const dist = getZoneDistance(currentPrice, nearestResistance);
        
        if (dist.status !== 'FAR' && !result.direction) {
            result.direction = 'SHORT';
            result.status = dist.status;
            score += dist.score;
            result.factors.push(`${dist.status} Resistance`);
            
            // Touch count bonus
            if (nearestResistance.touches >= 4) {
                score += 15;
                result.factors.push(`${nearestResistance.touches} touches`);
            } else if (nearestResistance.touches >= 3) {
                score += 10;
                result.factors.push(`${nearestResistance.touches} touches`);
            } else if (nearestResistance.touches >= 2) {
                score += 5;
            }
            
            // Strength bonus
            if (nearestResistance.strength >= 60) {
                score += 10;
                result.factors.push('Strong zone');
            } else if (nearestResistance.strength >= 40) {
                score += 5;
            }
            
            // Round number bonus
            const roundBonus = checkRoundNumber(nearestResistance.price);
            if (roundBonus >= 4) {
                score += roundBonus;
                result.factors.push('Round number');
            }
            
            // Fib alignment bonus
            const fibCheck = checkFibAlignment(nearestResistance.price, fibLevels);
            if (fibCheck.aligned) {
                score += fibCheck.bonus;
                result.factors.push(`Fib ${fibCheck.level}`);
            }
            
            // Fakeout bonus
            const fakeout = detectFakeout(klines, nearestResistance);
            if (fakeout.detected && fakeout.type === 'bearish') {
                score += 12;
                result.factors.push('Fakeout sweep ✓');
            }
        }
    }
    
    // If price is between zones (no clear direction)
    if (!result.direction && nearestSupport && nearestResistance) {
        const supDist = (currentPrice - nearestSupport.price) / currentPrice;
        const resDist = (nearestResistance.price - currentPrice) / currentPrice;
        
        if (supDist < resDist) {
            result.direction = 'LONG';
            result.factors.push('Closer to support');
            score += 5;
        } else {
            result.direction = 'SHORT';
            result.factors.push('Closer to resistance');
            score += 5;
        }
        result.status = 'BETWEEN';
        result.warnings.push('Mid-range - wait for zone');
    }
    
    result.score = Math.min(100, Math.max(0, score));
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF PART 1 - Zone Analysis Complete
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// SMC ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════════

// Detect market structure (HH, HL, LH, LL)
function detectStructure(klines, lookback = 50) {
    if (!klines || klines.length < lookback) return { trend: 'NEUTRAL', swings: [], counts: {} };
    
    const swings = findSwingPoints(klines, 3, 3);
    const allSwings = [];
    
    // Combine and sort swings by index
    swings.highs.forEach(h => allSwings.push({ ...h, type: 'high' }));
    swings.lows.forEach(l => allSwings.push({ ...l, type: 'low' }));
    allSwings.sort((a, b) => a.index - b.index);
    
    // Label structure points
    let lastHigh = null;
    let lastLow = null;
    const structure = [];
    const counts = { HH: 0, HL: 0, LH: 0, LL: 0 };
    
    for (const swing of allSwings) {
        if (swing.type === 'high') {
            if (lastHigh !== null) {
                if (swing.price > lastHigh.price) {
                    structure.push({ ...swing, label: 'HH' });
                    counts.HH++;
                } else {
                    structure.push({ ...swing, label: 'LH' });
                    counts.LH++;
                }
            } else {
                structure.push({ ...swing, label: 'H' });
            }
            lastHigh = swing;
        } else {
            if (lastLow !== null) {
                if (swing.price > lastLow.price) {
                    structure.push({ ...swing, label: 'HL' });
                    counts.HL++;
                } else {
                    structure.push({ ...swing, label: 'LL' });
                    counts.LL++;
                }
            } else {
                structure.push({ ...swing, label: 'L' });
            }
            lastLow = swing;
        }
    }
    
    // Determine trend from recent structure
    const recentStructure = structure.slice(-6);
    let bullishPoints = 0;
    let bearishPoints = 0;
    
    recentStructure.forEach(s => {
        if (s.label === 'HH' || s.label === 'HL') bullishPoints++;
        if (s.label === 'LH' || s.label === 'LL') bearishPoints++;
    });
    
    let trend = 'NEUTRAL';
    if (bullishPoints >= 3 && bullishPoints > bearishPoints) trend = 'BULLISH';
    else if (bearishPoints >= 3 && bearishPoints > bullishPoints) trend = 'BEARISH';
    
    return { trend, swings: structure, counts, lastHigh, lastLow };
}

// Detect Break of Structure (BOS) - BODY CLOSE confirmation
function detectBOS(klines, structure) {
    if (!klines || klines.length < 10 || !structure.swings || structure.swings.length < 2) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const prevCandle = klines[len - 2];
    
    // Get recent swing highs and lows
    const recentHighs = structure.swings.filter(s => s.type === 'high').slice(-3);
    const recentLows = structure.swings.filter(s => s.type === 'low').slice(-3);
    
    // Bullish BOS: Current candle BODY CLOSES above recent swing high
    for (const high of recentHighs) {
        if (prevCandle.close <= high.price && currentCandle.close > high.price) {
            // Confirm it's a body close, not just wick
            if (currentCandle.close > currentCandle.open) { // Green candle
                const bodyTop = currentCandle.close;
                if (bodyTop > high.price) {
                    return {
                        detected: true,
                        direction: 'BULLISH',
                        type: 'BOS',
                        level: high.price,
                        strength: currentCandle.close - high.price > (currentCandle.high - currentCandle.low) * 0.3 ? 'STRONG' : 'NORMAL'
                    };
                }
            }
        }
    }
    
    // Bearish BOS: Current candle BODY CLOSES below recent swing low
    for (const low of recentLows) {
        if (prevCandle.close >= low.price && currentCandle.close < low.price) {
            // Confirm it's a body close, not just wick
            if (currentCandle.close < currentCandle.open) { // Red candle
                const bodyBottom = currentCandle.close;
                if (bodyBottom < low.price) {
                    return {
                        detected: true,
                        direction: 'BEARISH',
                        type: 'BOS',
                        level: low.price,
                        strength: low.price - currentCandle.close > (currentCandle.high - currentCandle.low) * 0.3 ? 'STRONG' : 'NORMAL'
                    };
                }
            }
        }
    }
    
    return { detected: false };
}

// Detect Change of Character (CHoCH)
function detectCHoCH(klines, structure) {
    if (!klines || klines.length < 10 || !structure.swings || structure.swings.length < 4) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const trend = structure.trend;
    
    const recentHighs = structure.swings.filter(s => s.type === 'high').slice(-3);
    const recentLows = structure.swings.filter(s => s.type === 'low').slice(-3);
    
    // Bullish CHoCH: In a downtrend, price breaks above a lower high
    if (trend === 'BEARISH' && recentHighs.length >= 2) {
        const lastLH = recentHighs.find(h => h.label === 'LH');
        if (lastLH && currentCandle.close > lastLH.price) {
            return {
                detected: true,
                direction: 'BULLISH',
                type: 'CHoCH',
                level: lastLH.price,
                previousTrend: 'BEARISH'
            };
        }
    }
    
    // Bearish CHoCH: In an uptrend, price breaks below a higher low
    if (trend === 'BULLISH' && recentLows.length >= 2) {
        const lastHL = recentLows.find(l => l.label === 'HL');
        if (lastHL && currentCandle.close < lastHL.price) {
            return {
                detected: true,
                direction: 'BEARISH',
                type: 'CHoCH',
                level: lastHL.price,
                previousTrend: 'BULLISH'
            };
        }
    }
    
    return { detected: false };
}

// Detect Order Blocks with Mitigation Tracking
function detectOrderBlocks(klines, lookback = 50) {
    if (!klines || klines.length < lookback) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const bullishOBs = [];
    const bearishOBs = [];
    const currentPrice = klines[len - 1].close;
    
    // Calculate average volume for filtering - FIXED: Safe calculation
    const volSlice = klines.slice(-50).filter(k => k?.volume > 0);
    const avgVolume = volSlice.length > 0 ? volSlice.reduce((sum, k) => sum + k.volume, 0) / volSlice.length : 1;
    
    for (let i = len - lookback; i < len - 3; i++) {
        if (i < 1) continue;
        
        const candle = klines[i];
        const nextCandle = klines[i + 1];
        const followCandle = klines[i + 2];
        
        // Bullish Order Block: Down candle followed by strong up move
        if (candle.close < candle.open) { // Red candle
            const moveUp = followCandle.close - candle.low;
            const candleRange = candle.high - candle.low;
            
            // Strong impulse move away
            if (moveUp > candleRange * 2 && candle.volume > avgVolume * 0.8) {
                // Check if OB has been mitigated
                let mitigated = false;
                let mitigationPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].low <= candle.high) {
                        mitigated = true;
                        mitigationPct = Math.min(100, ((candle.high - klines[j].low) / candleRange) * 100);
                        break;
                    }
                }
                
                // Only add if not fully mitigated and price is above
                if (mitigationPct < 100 && currentPrice > candle.low) {
                    bullishOBs.push({
                        high: candle.high,
                        low: candle.low,
                        price: (candle.high + candle.low) / 2,
                        index: i,
                        time: candle.time,
                        volume: candle.volume,
                        mitigated: mitigated,
                        mitigationPct: mitigationPct,
                        fresh: !mitigated
                    });
                }
            }
        }
        
        // Bearish Order Block: Up candle followed by strong down move
        if (candle.close > candle.open) { // Green candle
            const moveDown = candle.high - followCandle.close;
            const candleRange = candle.high - candle.low;
            
            // Strong impulse move away
            if (moveDown > candleRange * 2 && candle.volume > avgVolume * 0.8) {
                // Check if OB has been mitigated
                let mitigated = false;
                let mitigationPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].high >= candle.low) {
                        mitigated = true;
                        mitigationPct = Math.min(100, ((klines[j].high - candle.low) / candleRange) * 100);
                        break;
                    }
                }
                
                // Only add if not fully mitigated and price is below
                if (mitigationPct < 100 && currentPrice < candle.high) {
                    bearishOBs.push({
                        high: candle.high,
                        low: candle.low,
                        price: (candle.high + candle.low) / 2,
                        index: i,
                        time: candle.time,
                        volume: candle.volume,
                        mitigated: mitigated,
                        mitigationPct: mitigationPct,
                        fresh: !mitigated
                    });
                }
            }
        }
    }
    
    // Sort by freshness and proximity to current price
    bullishOBs.sort((a, b) => {
        if (a.fresh !== b.fresh) return a.fresh ? -1 : 1;
        return Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price);
    });
    
    bearishOBs.sort((a, b) => {
        if (a.fresh !== b.fresh) return a.fresh ? -1 : 1;
        return Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price);
    });
    
    return { bullish: bullishOBs.slice(0, 5), bearish: bearishOBs.slice(0, 5) };
}

// Detect Breaker Blocks (Mitigated OB that becomes S/R)
function detectBreakerBlocks(klines, orderBlocks) {
    if (!klines || !orderBlocks) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    const bullishBreakers = [];
    const bearishBreakers = [];
    
    // Bullish Breaker: Former bearish OB that got broken and now acts as support
    for (const ob of orderBlocks.bearish) {
        if (ob.mitigated && ob.mitigationPct >= 80) {
            // Check if price broke through and is now above
            if (currentPrice > ob.high) {
                // This bearish OB is now a bullish breaker (support)
                bullishBreakers.push({
                    high: ob.high,
                    low: ob.low,
                    price: ob.price,
                    type: 'BREAKER',
                    originalType: 'BEARISH_OB',
                    index: ob.index
                });
            }
        }
    }
    
    // Bearish Breaker: Former bullish OB that got broken and now acts as resistance
    for (const ob of orderBlocks.bullish) {
        if (ob.mitigated && ob.mitigationPct >= 80) {
            // Check if price broke through and is now below
            if (currentPrice < ob.low) {
                // This bullish OB is now a bearish breaker (resistance)
                bearishBreakers.push({
                    high: ob.high,
                    low: ob.low,
                    price: ob.price,
                    type: 'BREAKER',
                    originalType: 'BULLISH_OB',
                    index: ob.index
                });
            }
        }
    }
    
    return { bullish: bullishBreakers, bearish: bearishBreakers };
}

// Detect Fair Value Gaps (FVG) with Fill Tracking
function detectFVG(klines, lookback = 30) {
    if (!klines || klines.length < lookback) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const bullishFVGs = [];
    const bearishFVGs = [];
    const currentPrice = klines[len - 1].close;
    
    for (let i = len - lookback; i < len - 2; i++) {
        if (i < 1) continue;
        
        const candle1 = klines[i];
        const candle2 = klines[i + 1];
        const candle3 = klines[i + 2];
        
        // Bullish FVG: Gap between candle1 high and candle3 low
        if (candle3.low > candle1.high) {
            const gapHigh = candle3.low;
            const gapLow = candle1.high;
            const gapSize = gapHigh - gapLow;
            const gapPct = (gapSize / candle2.close) * 100;
            
            if (gapPct >= 0.1) { // Minimum gap size
                // Check if FVG has been filled
                let filled = false;
                let fillPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].low <= gapHigh) {
                        const fillAmount = gapHigh - Math.max(klines[j].low, gapLow);
                        fillPct = Math.min(100, (fillAmount / gapSize) * 100);
                        if (fillPct >= 100) {
                            filled = true;
                            break;
                        }
                    }
                }
                
                // Check if price is in the FVG zone
                const inZone = currentPrice >= gapLow && currentPrice <= gapHigh;
                
                if (!filled) {
                    bullishFVGs.push({
                        high: gapHigh,
                        low: gapLow,
                        price: (gapHigh + gapLow) / 2,
                        size: gapSize,
                        sizePct: gapPct,
                        index: i + 1,
                        time: candle2.time,
                        filled: filled,
                        fillPct: fillPct,
                        inZone: inZone
                    });
                }
            }
        }
        
        // Bearish FVG: Gap between candle1 low and candle3 high
        if (candle3.high < candle1.low) {
            const gapHigh = candle1.low;
            const gapLow = candle3.high;
            const gapSize = gapHigh - gapLow;
            const gapPct = (gapSize / candle2.close) * 100;
            
            if (gapPct >= 0.1) { // Minimum gap size
                // Check if FVG has been filled
                let filled = false;
                let fillPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].high >= gapLow) {
                        const fillAmount = Math.min(klines[j].high, gapHigh) - gapLow;
                        fillPct = Math.min(100, (fillAmount / gapSize) * 100);
                        if (fillPct >= 100) {
                            filled = true;
                            break;
                        }
                    }
                }
                
                // Check if price is in the FVG zone
                const inZone = currentPrice >= gapLow && currentPrice <= gapHigh;
                
                if (!filled) {
                    bearishFVGs.push({
                        high: gapHigh,
                        low: gapLow,
                        price: (gapHigh + gapLow) / 2,
                        size: gapSize,
                        sizePct: gapPct,
                        index: i + 1,
                        time: candle2.time,
                        filled: filled,
                        fillPct: fillPct,
                        inZone: inZone
                    });
                }
            }
        }
    }
    
    // Sort by proximity to current price
    bullishFVGs.sort((a, b) => Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price));
    bearishFVGs.sort((a, b) => Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price));
    
    return { bullish: bullishFVGs.slice(0, 5), bearish: bearishFVGs.slice(0, 5) };
}


// Detect Equal Highs and Equal Lows (Liquidity Pools)
function detectEqualLevels(klines, tolerance = 0.002) {
    if (!klines || klines.length < 50) return { equalHighs: [], equalLows: [] };
    
    const swings = findSwingPoints(klines, 4, 4);
    const equalHighs = [];
    const equalLows = [];
    
    // Find equal highs
    for (let i = 0; i < swings.highs.length; i++) {
        const matches = [swings.highs[i]];
        
        for (let j = i + 1; j < swings.highs.length; j++) {
            const pctDiff = Math.abs(swings.highs[i].price - swings.highs[j].price) / swings.highs[i].price;
            if (pctDiff <= tolerance) {
                matches.push(swings.highs[j]);
            }
        }
        
        if (matches.length >= 2) {
            const avgPrice = matches.reduce((sum, m) => sum + m.price, 0) / matches.length;
            // Check if not already added
            const exists = equalHighs.some(eh => Math.abs(eh.price - avgPrice) / avgPrice < tolerance);
            if (!exists) {
                equalHighs.push({
                    price: avgPrice,
                    count: matches.length,
                    indices: matches.map(m => m.index),
                    type: 'EQH'
                });
            }
        }
    }
    
    // Find equal lows
    for (let i = 0; i < swings.lows.length; i++) {
        const matches = [swings.lows[i]];
        
        for (let j = i + 1; j < swings.lows.length; j++) {
            const pctDiff = Math.abs(swings.lows[i].price - swings.lows[j].price) / swings.lows[i].price;
            if (pctDiff <= tolerance) {
                matches.push(swings.lows[j]);
            }
        }
        
        if (matches.length >= 2) {
            const avgPrice = matches.reduce((sum, m) => sum + m.price, 0) / matches.length;
            // Check if not already added
            const exists = equalLows.some(el => Math.abs(el.price - avgPrice) / avgPrice < tolerance);
            if (!exists) {
                equalLows.push({
                    price: avgPrice,
                    count: matches.length,
                    indices: matches.map(m => m.index),
                    type: 'EQL'
                });
            }
        }
    }
    
    return { equalHighs, equalLows };
}

// Detect Liquidity Sweep
function detectLiquiditySweep(klines, equalLevels) {
    if (!klines || klines.length < 5 || !equalLevels) return { detected: false };
    
    const len = klines.length;
    const lastCandle = klines[len - 1];
    const prevCandle = klines[len - 2];
    
    // Check sweep of equal highs (bullish reversal setup after sweep)
    for (const eqh of equalLevels.equalHighs) {
        // Wick above EQH but close below (sweep and reject)
        if (lastCandle.high > eqh.price && lastCandle.close < eqh.price && lastCandle.close < lastCandle.open) {
            const wickAbove = lastCandle.high - Math.max(lastCandle.open, lastCandle.close);
            const body = Math.abs(lastCandle.close - lastCandle.open);
            
            if (wickAbove > body * 0.5) {
                return {
                    detected: true,
                    direction: 'BEARISH', // Swept highs = bearish
                    type: 'SWEEP',
                    level: eqh.price,
                    sweepType: 'EQH',
                    significance: eqh.count >= 3 ? 'HIGH' : 'MEDIUM'
                };
            }
        }
    }
    
    // Check sweep of equal lows (bearish reversal setup after sweep)
    for (const eql of equalLevels.equalLows) {
        // Wick below EQL but close above (sweep and reject)
        if (lastCandle.low < eql.price && lastCandle.close > eql.price && lastCandle.close > lastCandle.open) {
            const wickBelow = Math.min(lastCandle.open, lastCandle.close) - lastCandle.low;
            const body = Math.abs(lastCandle.close - lastCandle.open);
            
            if (wickBelow > body * 0.5) {
                return {
                    detected: true,
                    direction: 'BULLISH', // Swept lows = bullish
                    type: 'SWEEP',
                    level: eql.price,
                    sweepType: 'EQL',
                    significance: eql.count >= 3 ? 'HIGH' : 'MEDIUM'
                };
            }
        }
    }
    
    return { detected: false };
}

// Get Premium/Discount Zones
function getPremiumDiscount(klines, lookback = 100) {
    if (!klines || klines.length < lookback) return null;
    
    const recent = klines.slice(-lookback);
    const high = Math.max(...recent.map(k => k.high));
    const low = Math.min(...recent.map(k => k.low));
    const range = high - low;
    const currentPrice = klines[klines.length - 1].close;
    
    const equilibrium = (high + low) / 2;
    const premium = high - range * 0.3;      // Top 30%
    const discount = low + range * 0.3;      // Bottom 30%
    
    let zone;
    if (currentPrice >= premium) zone = 'PREMIUM';
    else if (currentPrice <= discount) zone = 'DISCOUNT';
    else zone = 'EQUILIBRIUM';
    
    const percentFromEQ = ((currentPrice - equilibrium) / equilibrium) * 100;
    const positionPct = ((currentPrice - low) / range) * 100;
    
    return {
        high,
        low,
        equilibrium,
        premium,
        discount,
        currentPrice,
        zone,
        percentFromEQ,
        positionPct,
        favorsBuy: zone === 'DISCOUNT',
        favorsSell: zone === 'PREMIUM'
    };
}

// Detect Kill Zone (Trading Sessions)
function getKillZone() {
    const now = new Date();
    const utcHour = now.getUTCHours();
    
    const sessions = [
        { name: 'ASIA', start: 0, end: 3, color: '#06b6d4', active: false },
        { name: 'LONDON', start: 7, end: 10, color: '#a855f7', active: false },
        { name: 'NY_AM', start: 12, end: 15, color: '#f59e0b', active: false },
        { name: 'NY_PM', start: 15, end: 17, color: '#ef4444', active: false }
    ];
    
    for (const session of sessions) {
        if (utcHour >= session.start && utcHour < session.end) {
            return { ...session, active: true, bonus: session.name === 'LONDON' || session.name === 'NY_AM' ? 10 : 5 };
        }
    }
    
    return { name: 'OFF_SESSION', active: false, bonus: 0, color: '#64748b' };
}

// Signal State Machine
function getSignalState(bos, choch, ob, fvg, currentPrice) {
    // LOCKED: Clear trigger present (BOS or CHoCH)
    if (bos.detected || choch.detected) {
        // Check if we're in pullback to OB or FVG
        const direction = bos.detected ? bos.direction : choch.direction;
        
        if (direction === 'BULLISH') {
            // Check if price pulled back to bullish OB or FVG
            const nearOB = ob.bullish.length > 0 && 
                Math.abs(currentPrice - ob.bullish[0].price) / currentPrice < 0.01;
            const nearFVG = fvg.bullish.length > 0 && 
                (currentPrice >= fvg.bullish[0].low && currentPrice <= fvg.bullish[0].high);
            
            if (nearOB || nearFVG) {
                return { state: 'ENTRY', reason: nearOB ? 'At Bullish OB' : 'In Bullish FVG' };
            }
            return { state: 'PULLBACK', reason: 'Waiting for pullback to OB/FVG' };
        } else {
            // Check if price pulled back to bearish OB or FVG
            const nearOB = ob.bearish.length > 0 && 
                Math.abs(currentPrice - ob.bearish[0].price) / currentPrice < 0.01;
            const nearFVG = fvg.bearish.length > 0 && 
                (currentPrice >= fvg.bearish[0].low && currentPrice <= fvg.bearish[0].high);
            
            if (nearOB || nearFVG) {
                return { state: 'ENTRY', reason: nearOB ? 'At Bearish OB' : 'In Bearish FVG' };
            }
            return { state: 'PULLBACK', reason: 'Waiting for pullback to OB/FVG' };
        }
    }
    
    // FORMING: OB or FVG present but no trigger yet
    if (ob.bullish.length > 0 || ob.bearish.length > 0 || fvg.bullish.length > 0 || fvg.bearish.length > 0) {
        return { state: 'FORMING', reason: 'Waiting for BOS/CHoCH trigger' };
    }
    
    return { state: 'WAITING', reason: 'No setup detected' };
}

// MAIN SMC ANALYSIS FUNCTION
function performSMCAnalysis(klines, tf) {
    const result = {
        score: 0,
        direction: null,
        trigger: null,
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    
    // Get market structure
    const structure = detectStructure(klines);
    result.details.structure = structure;
    result.details.trend = structure.trend;
    
    // Detect BOS
    const bos = detectBOS(klines, structure);
    result.details.bos = bos;
    
    // Detect CHoCH
    const choch = detectCHoCH(klines, structure);
    result.details.choch = choch;
    
    // Detect Order Blocks
    const orderBlocks = detectOrderBlocks(klines);
    result.details.orderBlocks = orderBlocks;
    
    // Detect Breaker Blocks
    const breakerBlocks = detectBreakerBlocks(klines, orderBlocks);
    result.details.breakerBlocks = breakerBlocks;
    
    // Detect FVG
    const fvg = detectFVG(klines);
    result.details.fvg = fvg;
    
    // Detect Equal Levels
    const equalLevels = detectEqualLevels(klines);
    result.details.equalLevels = equalLevels;
    
    // Detect Liquidity Sweep
    const sweep = detectLiquiditySweep(klines, equalLevels);
    result.details.sweep = sweep;
    
    // Get Premium/Discount
    const pdZone = getPremiumDiscount(klines);
    result.details.pdZone = pdZone;
    
    // Get Kill Zone
    const killZone = getKillZone();
    result.details.killZone = killZone;
    
    // Get Signal State
    const signalState = getSignalState(bos, choch, orderBlocks, fvg, currentPrice);
    result.details.signalState = signalState;
    
    // SCORING
    let score = 0;
    let bullScore = 0;
    let bearScore = 0;
    
    // Structure trend (10 points)
    if (structure.trend === 'BULLISH') {
        bullScore += 10;
        result.factors.push('Bullish Structure');
    } else if (structure.trend === 'BEARISH') {
        bearScore += 10;
        result.factors.push('Bearish Structure');
    }
    
    // BOS (25 points)
    if (bos.detected) {
        if (bos.direction === 'BULLISH') {
            bullScore += 25;
            result.factors.push('BOS↑');
            if (bos.strength === 'STRONG') {
                bullScore += 5;
                result.factors.push('Strong BOS');
            }
        } else {
            bearScore += 25;
            result.factors.push('BOS↓');
            if (bos.strength === 'STRONG') {
                bearScore += 5;
                result.factors.push('Strong BOS');
            }
        }
        result.trigger = 'BOS';
    }
    
    // CHoCH (30 points - stronger signal)
    if (choch.detected) {
        if (choch.direction === 'BULLISH') {
            bullScore += 30;
            result.factors.push('CHoCH↑');
        } else {
            bearScore += 30;
            result.factors.push('CHoCH↓');
        }
        result.trigger = result.trigger ? result.trigger + '+CHoCH' : 'CHoCH';
    }
    
    // Order Blocks (15 points)
    if (orderBlocks.bullish.length > 0) {
        const nearestOB = orderBlocks.bullish[0];
        const distance = Math.abs(currentPrice - nearestOB.price) / currentPrice;
        if (distance < 0.01) {
            bullScore += 15;
            result.factors.push(nearestOB.fresh ? 'Fresh Bull OB' : 'Bull OB');
        } else if (distance < 0.02) {
            bullScore += 8;
        }
    }
    if (orderBlocks.bearish.length > 0) {
        const nearestOB = orderBlocks.bearish[0];
        const distance = Math.abs(currentPrice - nearestOB.price) / currentPrice;
        if (distance < 0.01) {
            bearScore += 15;
            result.factors.push(nearestOB.fresh ? 'Fresh Bear OB' : 'Bear OB');
        } else if (distance < 0.02) {
            bearScore += 8;
        }
    }
    
    // Breaker Blocks (12 points)
    if (breakerBlocks.bullish.length > 0) {
        const distance = Math.abs(currentPrice - breakerBlocks.bullish[0].price) / currentPrice;
        if (distance < 0.015) {
            bullScore += 12;
            result.factors.push('Bull Breaker');
        }
    }
    if (breakerBlocks.bearish.length > 0) {
        const distance = Math.abs(currentPrice - breakerBlocks.bearish[0].price) / currentPrice;
        if (distance < 0.015) {
            bearScore += 12;
            result.factors.push('Bear Breaker');
        }
    }
    
    // FVG (10 points)
    if (fvg.bullish.length > 0 && fvg.bullish[0].inZone) {
        bullScore += 10;
        result.factors.push('In Bull FVG');
    }
    if (fvg.bearish.length > 0 && fvg.bearish[0].inZone) {
        bearScore += 10;
        result.factors.push('In Bear FVG');
    }
    
    // Liquidity Sweep (15 points)
    if (sweep.detected) {
        if (sweep.direction === 'BULLISH') {
            bullScore += sweep.significance === 'HIGH' ? 18 : 12;
            result.factors.push('Liq Sweep↑');
        } else {
            bearScore += sweep.significance === 'HIGH' ? 18 : 12;
            result.factors.push('Liq Sweep↓');
        }
        result.trigger = result.trigger ? result.trigger + '+Sweep' : 'Sweep';
    }
    
    // Premium/Discount (10 points)
    if (pdZone) {
        if (pdZone.zone === 'DISCOUNT') {
            bullScore += 10;
            result.factors.push('Discount Zone');
        } else if (pdZone.zone === 'PREMIUM') {
            bearScore += 10;
            result.factors.push('Premium Zone');
        }
    }
    
    // Kill Zone bonus
    if (killZone.active) {
        score += killZone.bonus;
        result.factors.push(killZone.name + ' Session');
    }
    
    // Determine direction and final score
    if (bullScore > bearScore + 10) {
        result.direction = 'LONG';
        score += bullScore;
    } else if (bearScore > bullScore + 10) {
        result.direction = 'SHORT';
        score += bearScore;
    } else {
        // Mixed signals
        score += Math.max(bullScore, bearScore) * 0.5;
        result.warnings.push('Mixed SMC signals');
    }
    
    // Signal state bonus/penalty
    if (signalState.state === 'ENTRY') {
        score += 10;
        result.factors.push(signalState.reason);
    } else if (signalState.state === 'FORMING') {
        result.warnings.push(signalState.reason);
    }
    
    result.score = Math.min(100, Math.max(0, Math.round(score)));
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF PART 2 - SMC Analysis Complete
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// CANDLE PATTERN DETECTION ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

function analyzeCandlePatterns(klines) {
    if (!klines || klines.length < 10) {
        return { patterns: [], currentCandle: null, behavior: null, strength: 0 };
    }
    
    const result = {
        patterns: [],
        currentCandle: null,
        behavior: null,
        strength: 0,
        control: 'NEUTRAL',
        factors: []
    };
    
    // Get recent candles
    const candles = klines.slice(-10);
    const current = candles[candles.length - 1];
    const prev = candles[candles.length - 2];
    const prev2 = candles[candles.length - 3];
    
    // Calculate candle metrics
    const calcCandleMetrics = (c) => {
        const range = c.high - c.low;
        const body = Math.abs(c.close - c.open);
        const upperWick = c.high - Math.max(c.close, c.open);
        const lowerWick = Math.min(c.close, c.open) - c.low;
        const isBullish = c.close > c.open;
        
        return {
            range,
            body,
            bodyPercent: range > 0 ? (body / range) * 100 : 0,
            upperWick,
            lowerWick,
            upperWickPercent: range > 0 ? (upperWick / range) * 100 : 0,
            lowerWickPercent: range > 0 ? (lowerWick / range) * 100 : 0,
            isBullish,
            isBearish: !isBullish && c.close !== c.open
        };
    };
    
    const cm = calcCandleMetrics(current);
    const pm = calcCandleMetrics(prev);
    
    // Current candle analysis
    result.currentCandle = {
        type: 'Unknown',
        bodyPercent: Math.round(cm.bodyPercent || 0),
        upperWickPercent: Math.round(cm.upperWickPercent || 0),
        lowerWickPercent: Math.round(cm.lowerWickPercent || 0),
        isBullish: cm.isBullish,
        behavior: ''
    };
    
    // Calculate average volume - FIXED: Safe calculation
    const volumes = candles.map(c => c?.volume || 0).filter(v => v > 0);
    const avgVolume = volumes.length > 0 ? volumes.reduce((a, b) => a + b, 0) / volumes.length : 1;
    const volumeRatio = avgVolume > 0 ? (current?.volume || 0) / avgVolume : 1;
    result.currentCandle.volumeRatio = isNaN(volumeRatio) ? 1 : Math.round(volumeRatio * 10) / 10;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // PATTERN DETECTION
    // ═══════════════════════════════════════════════════════════════════════════
    
    // 1. DOJI - Small body, indecision
    const isDoji = cm.bodyPercent < 10;
    if (isDoji) {
        result.patterns.push({ 
            name: 'Doji', 
            signal: 'NEUTRAL', 
            strength: 'Medium',
            meaning: 'Indecision - trend may pause or reverse'
        });
        result.currentCandle.type = 'Doji';
    }
    
    // 2. HAMMER / HANGING MAN - Long lower wick at bottom
    const isHammer = cm.lowerWickPercent > 60 && cm.upperWickPercent < 15 && cm.bodyPercent < 35;
    if (isHammer) {
        // Hammer at support = bullish, at resistance = bearish (hanging man)
        result.patterns.push({ 
            name: cm.isBullish ? 'Hammer' : 'Hanging Man', 
            signal: 'BULLISH', 
            strength: 'High',
            meaning: 'Buyers rejected lower prices - potential reversal up'
        });
        result.currentCandle.type = cm.isBullish ? 'Hammer' : 'Hanging Man';
    }
    
    // 3. SHOOTING STAR / INVERTED HAMMER - Long upper wick at top
    const isShootingStar = cm.upperWickPercent > 60 && cm.lowerWickPercent < 15 && cm.bodyPercent < 35;
    if (isShootingStar) {
        result.patterns.push({ 
            name: cm.isBullish ? 'Inverted Hammer' : 'Shooting Star', 
            signal: 'BEARISH', 
            strength: 'High',
            meaning: 'Sellers rejected higher prices - potential reversal down'
        });
        result.currentCandle.type = cm.isBullish ? 'Inverted Hammer' : 'Shooting Star';
    }
    
    // 4. BULLISH ENGULFING
    const isBullishEngulfing = cm.isBullish && pm.isBearish && 
        current.close > prev.open && current.open < prev.close &&
        cm.body > pm.body;
    if (isBullishEngulfing) {
        result.patterns.push({ 
            name: 'Bullish Engulfing', 
            signal: 'BULLISH', 
            strength: 'Very High',
            meaning: 'Strong buying pressure - buyers overwhelmed sellers'
        });
        result.currentCandle.type = 'Bullish Engulfing';
        result.strength += 25;
    }
    
    // 5. BEARISH ENGULFING
    const isBearishEngulfing = cm.isBearish && pm.isBullish && 
        current.close < prev.open && current.open > prev.close &&
        cm.body > pm.body;
    if (isBearishEngulfing) {
        result.patterns.push({ 
            name: 'Bearish Engulfing', 
            signal: 'BEARISH', 
            strength: 'Very High',
            meaning: 'Strong selling pressure - sellers overwhelmed buyers'
        });
        result.currentCandle.type = 'Bearish Engulfing';
        result.strength += 25;
    }
    
    // 6. MORNING STAR (3 candle bullish reversal)
    if (candles.length >= 3) {
        const pm2 = calcCandleMetrics(prev2);
        const isMorningStar = pm2.isBearish && pm2.bodyPercent > 50 && // Strong red
            pm.bodyPercent < 30 && // Small body (star)
            cm.isBullish && cm.bodyPercent > 50 && // Strong green
            current.close > (prev2.open + prev2.close) / 2;
        if (isMorningStar) {
            result.patterns.push({ 
                name: 'Morning Star', 
                signal: 'BULLISH', 
                strength: 'Very High',
                meaning: 'Major bullish reversal - high probability long'
            });
            result.strength += 30;
        }
    }
    
    // 7. EVENING STAR (3 candle bearish reversal)
    if (candles.length >= 3) {
        const pm2 = calcCandleMetrics(prev2);
        const isEveningStar = pm2.isBullish && pm2.bodyPercent > 50 && // Strong green
            pm.bodyPercent < 30 && // Small body (star)
            cm.isBearish && cm.bodyPercent > 50 && // Strong red
            current.close < (prev2.open + prev2.close) / 2;
        if (isEveningStar) {
            result.patterns.push({ 
                name: 'Evening Star', 
                signal: 'BEARISH', 
                strength: 'Very High',
                meaning: 'Major bearish reversal - high probability short'
            });
            result.strength += 30;
        }
    }
    
    // 8. INSIDE BAR - Consolidation, breakout coming
    const isInsideBar = current.high < prev.high && current.low > prev.low;
    if (isInsideBar) {
        result.patterns.push({ 
            name: 'Inside Bar', 
            signal: 'NEUTRAL', 
            strength: 'Medium',
            meaning: 'Consolidation - breakout expected soon'
        });
        result.currentCandle.type = 'Inside Bar';
    }
    
    // 9. PIN BAR - Rejection candle
    const isPinBar = (cm.upperWickPercent > 65 || cm.lowerWickPercent > 65) && cm.bodyPercent < 25;
    if (isPinBar && !isHammer && !isShootingStar) {
        const pinSignal = cm.lowerWickPercent > cm.upperWickPercent ? 'BULLISH' : 'BEARISH';
        result.patterns.push({ 
            name: 'Pin Bar', 
            signal: pinSignal, 
            strength: 'High',
            meaning: pinSignal === 'BULLISH' ? 'Strong rejection of lows' : 'Strong rejection of highs'
        });
        result.currentCandle.type = 'Pin Bar';
        result.strength += 20;
    }
    
    // 10. MARUBOZU - Full body, strong momentum
    const isMarubozu = cm.bodyPercent > 85 && cm.upperWickPercent < 8 && cm.lowerWickPercent < 8;
    if (isMarubozu) {
        result.patterns.push({ 
            name: cm.isBullish ? 'Bullish Marubozu' : 'Bearish Marubozu', 
            signal: cm.isBullish ? 'BULLISH' : 'BEARISH', 
            strength: 'Very High',
            meaning: cm.isBullish ? 'Extreme buying pressure - no resistance' : 'Extreme selling pressure - no support'
        });
        result.currentCandle.type = cm.isBullish ? 'Bullish Marubozu' : 'Bearish Marubozu';
        result.strength += 25;
    }
    
    // 11. TWEEZER TOP/BOTTOM
    const isTweezerBottom = Math.abs(current.low - prev.low) / current.low < 0.001 && cm.isBullish && pm.isBearish;
    const isTweezerTop = Math.abs(current.high - prev.high) / current.high < 0.001 && cm.isBearish && pm.isBullish;
    if (isTweezerBottom) {
        result.patterns.push({ 
            name: 'Tweezer Bottom', 
            signal: 'BULLISH', 
            strength: 'High',
            meaning: 'Double rejection at support - reversal likely'
        });
        result.strength += 20;
    }
    if (isTweezerTop) {
        result.patterns.push({ 
            name: 'Tweezer Top', 
            signal: 'BEARISH', 
            strength: 'High',
            meaning: 'Double rejection at resistance - reversal likely'
        });
        result.strength += 20;
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // BEHAVIOR ANALYSIS
    // ═══════════════════════════════════════════════════════════════════════════
    
    // Determine who's in control (last 3 candles)
    let bullishCandles = 0;
    let bearishCandles = 0;
    let totalBullishBody = 0;
    let totalBearishBody = 0;
    
    for (let i = candles.length - 3; i < candles.length; i++) {
        if (i >= 0) {
            const c = candles[i];
            if (c.close > c.open) {
                bullishCandles++;
                totalBullishBody += c.close - c.open;
            } else {
                bearishCandles++;
                totalBearishBody += c.open - c.close;
            }
        }
    }
    
    if (bullishCandles > bearishCandles && totalBullishBody > totalBearishBody) {
        result.control = 'BUYERS';
        result.controlBuyers = true;
        result.controlSellers = false;
    } else if (bearishCandles > bullishCandles && totalBearishBody > totalBullishBody) {
        result.control = 'SELLERS';
        result.controlBuyers = false;
        result.controlSellers = true;
    } else {
        result.control = 'CONTESTED';
        result.controlBuyers = false;
        result.controlSellers = false;
    }
    
    // Momentum direction
    let momentum = 'NEUTRAL';
    const bodyTrend = [];
    for (let i = candles.length - 5; i < candles.length; i++) {
        if (i >= 0) {
            const c = candles[i];
            bodyTrend.push(Math.abs(c.close - c.open));
        }
    }
    if (bodyTrend.length >= 3) {
        const recentAvg = bodyTrend.slice(-2).reduce((a, b) => a + b, 0) / 2;
        const olderAvg = bodyTrend.slice(0, 2).reduce((a, b) => a + b, 0) / 2;
        if (recentAvg > olderAvg * 1.2) momentum = 'INCREASING';
        else if (recentAvg < olderAvg * 0.8) momentum = 'DECREASING';
    }
    
    // Check for exhaustion
    let exhaustionSigns = [];
    if (isDoji && volumeRatio > 1.5) exhaustionSigns.push('Doji on high volume');
    if (cm.upperWickPercent > 50 && cm.isBullish) exhaustionSigns.push('Long upper wick on green');
    if (cm.lowerWickPercent > 50 && cm.isBearish) exhaustionSigns.push('Long lower wick on red');
    
    // Check for trap potential
    let trapPotential = 'LOW';
    if (isShootingStar && volumeRatio < 0.7) trapPotential = 'HIGH - Low volume rejection';
    if (isBullishEngulfing && volumeRatio < 0.8) trapPotential = 'MEDIUM - Engulfing on weak volume';
    
    // Build behavior object
    result.behavior = {
        control: result.control,
        momentum: momentum,
        exhaustionSigns: exhaustionSigns.length > 0 ? exhaustionSigns : ['None detected'],
        trapPotential: trapPotential,
        volumeConfirmation: volumeRatio > 1.2 ? 'STRONG' : volumeRatio > 0.8 ? 'NORMAL' : 'WEAK'
    };
    
    // Current candle behavior text
    if (cm.isBullish && cm.bodyPercent > 60) {
        result.currentCandle.behavior = 'Aggressive buying, strong conviction';
    } else if (cm.isBearish && cm.bodyPercent > 60) {
        result.currentCandle.behavior = 'Aggressive selling, strong conviction';
    } else if (cm.lowerWickPercent > 40) {
        result.currentCandle.behavior = 'Buyers absorbed selling pressure';
    } else if (cm.upperWickPercent > 40) {
        result.currentCandle.behavior = 'Sellers absorbed buying pressure';
    } else if (isDoji) {
        result.currentCandle.behavior = 'Indecision, equilibrium between buyers and sellers';
    } else {
        result.currentCandle.behavior = cm.isBullish ? 'Mild buying pressure' : 'Mild selling pressure';
    }
    
    // Set default type if none detected
    if (result.currentCandle.type === 'Unknown') {
        if (cm.isBullish && cm.bodyPercent > 60) result.currentCandle.type = 'Strong Bullish';
        else if (cm.isBearish && cm.bodyPercent > 60) result.currentCandle.type = 'Strong Bearish';
        else if (cm.isBullish) result.currentCandle.type = 'Bullish';
        else if (cm.isBearish) result.currentCandle.type = 'Bearish';
        else result.currentCandle.type = 'Neutral';
    }
    
    // Calculate overall pattern strength
    const patternCount = result.patterns.length;
    const bullishPatterns = result.patterns.filter(p => p.signal === 'BULLISH').length;
    const bearishPatterns = result.patterns.filter(p => p.signal === 'BEARISH').length;
    
    result.patternSignal = bullishPatterns > bearishPatterns ? 'BULLISH' : 
                           bearishPatterns > bullishPatterns ? 'BEARISH' : 'NEUTRAL';
    
    // Strength score (0-100)
    result.strength = Math.min(100, result.strength + (patternCount * 10) + (volumeRatio > 1.2 ? 15 : 0));
    
    // Add factors for display
    if (result.patterns.length > 0) {
        result.factors = result.patterns.map(p => p.name + ' (' + p.signal + ')');
    }
    
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// V1 ULTIMATE - NEW ENGINES (Sequence, Pattern-at-Level, Rejection Score)
// ═══════════════════════════════════════════════════════════════════════════════

// SEQUENCE VALIDATOR - Checks if signal follows proper SMC sequence
// FIX #1: Added direction parameter to filter zones/OBs/FVGs by signal direction
function validateSequence(smcData, zoneData, candlePatterns, klines, direction) {
    const result = {
        steps: {
            sweep: false,
            bos: false,
            fvg: false,
            ob: false,
            pullback: false,
            pattern: false
        },
        completed: 0,
        total: 6,
        score: 0,
        state: 'NEUTRAL',
        quality: 'WEAK',
        details: []
    };
    
    const smcD = smcData.details || {};
    const currentPrice = klines[klines.length - 1].close;
    
    // Step 1: Check for Liquidity Sweep
    if (smcD.liquidityData && (smcD.liquidityData.recentSweep || smcD.liquidityData.sweepCount > 0)) {
        result.steps.sweep = true;
        result.details.push('✅ Sweep: Liquidity taken');
    }
    
    // Step 2: Check for BOS/CHoCH
    if (smcD.structure && (smcD.structure.bos || smcD.structure.choch)) {
        result.steps.bos = true;
        result.details.push('✅ BOS/CHoCH: Structure confirmed');
    }
    
    // Step 3: Check for FVG (direction-appropriate ONLY)
    const fvgData = smcD.fvg || {};
    let hasFVG = false;
    if (direction === 'LONG' && fvgData.bullish && fvgData.bullish.length > 0) {
        hasFVG = true;
        result.details.push('✅ FVG: Bullish imbalance detected');
    } else if (direction === 'SHORT' && fvgData.bearish && fvgData.bearish.length > 0) {
        hasFVG = true;
        result.details.push('✅ FVG: Bearish imbalance detected');
    } else if ((fvgData.bullish && fvgData.bullish.length > 0) || (fvgData.bearish && fvgData.bearish.length > 0)) {
        // FIX: Wrong direction FVG = NO step credit (hasFVG stays false)
        result.details.push('❌ FVG: Found but OPPOSITE direction (no credit)');
    }
    if (hasFVG) {
        result.steps.fvg = true;
    }
    
    // Step 4: Check for Order Block (direction-appropriate ONLY)
    const obData = smcD.orderBlocks || {};
    let hasOB = false;
    if (direction === 'LONG' && obData.bullish && obData.bullish.length > 0) {
        hasOB = true;
        result.details.push('✅ OB: Bullish Order Block identified');
    } else if (direction === 'SHORT' && obData.bearish && obData.bearish.length > 0) {
        hasOB = true;
        result.details.push('✅ OB: Bearish Order Block identified');
    } else if ((obData.bullish && obData.bullish.length > 0) || (obData.bearish && obData.bearish.length > 0)) {
        // FIX: Wrong direction OB = NO step credit (hasOB stays false)
        result.details.push('❌ OB: Found but OPPOSITE direction (no credit)');
    }
    if (hasOB) {
        result.steps.ob = true;
    }
    
    // Step 5: Check if price pulled back to DIRECTION-APPROPRIATE POI
    const zoneD = zoneData.details || {};
    let atCorrectZone = false;
    let atOB = false;
    let atFVG = false;
    let poiType = '';
    
    // For LONG: Check support zones, bullish OBs, bullish FVGs
    // For SHORT: Check resistance zones, bearish OBs, bearish FVGs
    if (direction === 'LONG') {
        // Check support zone
        if (zoneD.nearestSupport) {
            const distPct = Math.abs(currentPrice - zoneD.nearestSupport.price) / currentPrice;
            if (distPct < 0.015) {
                atCorrectZone = true;
                poiType = 'Support';
            }
        }
        // Check bullish OB
        if (obData.bullish && obData.bullish.length > 0) {
            atOB = obData.bullish.some(ob => currentPrice >= ob.low && currentPrice <= ob.high * 1.005);
            if (atOB) poiType = 'Bullish OB';
        }
        // Check bullish FVG
        if (fvgData.bullish && fvgData.bullish.length > 0) {
            atFVG = fvgData.bullish.some(fvg => currentPrice >= fvg.low && currentPrice <= fvg.high * 1.005);
            if (atFVG) poiType = 'Bullish FVG';
        }
    } else if (direction === 'SHORT') {
        // Check resistance zone
        if (zoneD.nearestResistance) {
            const distPct = Math.abs(currentPrice - zoneD.nearestResistance.price) / currentPrice;
            if (distPct < 0.015) {
                atCorrectZone = true;
                poiType = 'Resistance';
            }
        }
        // Check bearish OB
        if (obData.bearish && obData.bearish.length > 0) {
            atOB = obData.bearish.some(ob => currentPrice >= ob.low * 0.995 && currentPrice <= ob.high);
            if (atOB) poiType = 'Bearish OB';
        }
        // Check bearish FVG
        if (fvgData.bearish && fvgData.bearish.length > 0) {
            atFVG = fvgData.bearish.some(fvg => currentPrice >= fvg.low * 0.995 && currentPrice <= fvg.high);
            if (atFVG) poiType = 'Bearish FVG';
        }
    }
    
    if (atCorrectZone || atOB || atFVG) {
        result.steps.pullback = true;
        result.details.push(`✅ Pullback: Price at ${poiType}`);
    } else {
        result.details.push(`❌ Pullback: Price not at ${direction === 'LONG' ? 'support/bullish' : 'resistance/bearish'} POI`);
    }
    
    // Step 6: Check for Pattern at Level
    if (candlePatterns && candlePatterns.patterns && candlePatterns.patterns.length > 0) {
        if (result.steps.pullback) {
            result.steps.pattern = true;
            result.details.push('✅ Pattern: Confirmation at POI');
        } else {
            result.details.push('⚠️ Pattern: Found but NOT at POI');
        }
    }
    
    // Calculate completion
    result.completed = Object.values(result.steps).filter(Boolean).length;
    
    // Calculate score (0-100)
    result.score = Math.round((result.completed / result.total) * 100);
    
    // Determine state
    if (result.completed >= 5) {
        result.state = 'ENTRY_READY';
        result.quality = 'PERFECT';
    } else if (result.completed >= 4) {
        result.state = 'PATTERN_CONFIRMED';
        result.quality = 'STRONG';
    } else if (result.completed >= 3) {
        result.state = 'PULLBACK_TO_POI';
        result.quality = 'VALID';
    } else if (result.completed >= 2) {
        result.state = 'POI_IDENTIFIED';
        result.quality = 'DEVELOPING';
    } else {
        result.state = 'FORMING';
        result.quality = 'WEAK';
    }
    
    return result;
}

// PATTERN-AT-LEVEL - Checks if pattern is at a significant level
// FIX #2: Added direction parameter to only check direction-appropriate levels
function checkPatternAtLevel(candlePatterns, zoneData, smcData, currentPrice, direction) {
    const result = {
        atLevel: false,
        levelType: 'NONE',
        levelPrice: null,
        distance: 999,
        distancePercent: 999,
        bonus: 0,
        details: ''
    };
    
    if (!candlePatterns || !candlePatterns.patterns || candlePatterns.patterns.length === 0) {
        result.details = 'No pattern detected';
        return result;
    }
    
    const zoneD = zoneData.details || {};
    const smcD = smcData.details || {};
    const levels = [];
    const obData = smcD.orderBlocks || {};
    const fvgData = smcD.fvg || {};
    
    // Collect DIRECTION-APPROPRIATE levels only
    if (direction === 'LONG') {
        // For LONG: Support zones, Bullish OBs, Bullish FVGs
        if (zoneD.nearestSupport) {
            levels.push({ type: 'SUPPORT', price: zoneD.nearestSupport.price, strength: zoneD.nearestSupport.strength || 50 });
        }
        if (obData.bullish) {
            obData.bullish.forEach(ob => {
                levels.push({ type: 'BULLISH_OB', price: (ob.high + ob.low) / 2, high: ob.high, low: ob.low, strength: 70 });
            });
        }
        if (fvgData.bullish) {
            fvgData.bullish.forEach(fvg => {
                levels.push({ type: 'BULLISH_FVG', price: (fvg.high + fvg.low) / 2, high: fvg.high, low: fvg.low, strength: 60 });
            });
        }
    } else if (direction === 'SHORT') {
        // For SHORT: Resistance zones, Bearish OBs, Bearish FVGs
        if (zoneD.nearestResistance) {
            levels.push({ type: 'RESISTANCE', price: zoneD.nearestResistance.price, strength: zoneD.nearestResistance.strength || 50 });
        }
        if (obData.bearish) {
            obData.bearish.forEach(ob => {
                levels.push({ type: 'BEARISH_OB', price: (ob.high + ob.low) / 2, high: ob.high, low: ob.low, strength: 70 });
            });
        }
        if (fvgData.bearish) {
            fvgData.bearish.forEach(fvg => {
                levels.push({ type: 'BEARISH_FVG', price: (fvg.high + fvg.low) / 2, high: fvg.high, low: fvg.low, strength: 60 });
            });
        }
    }
    
    // If no direction-appropriate levels found, return early
    if (levels.length === 0) {
        result.details = `No ${direction === 'LONG' ? 'support/bullish' : 'resistance/bearish'} levels found`;
        return result;
    }
    
    // Find closest level
    let closestLevel = null;
    let closestDist = Infinity;
    
    for (const level of levels) {
        let dist;
        if (level.high && level.low) {
            // For ranges (OB, FVG), check if price is within range
            if (currentPrice >= level.low && currentPrice <= level.high) {
                dist = 0;
            } else {
                dist = Math.min(
                    Math.abs(currentPrice - level.high),
                    Math.abs(currentPrice - level.low)
                );
            }
        } else {
            dist = Math.abs(currentPrice - level.price);
        }
        
        if (dist < closestDist) {
            closestDist = dist;
            closestLevel = level;
        }
    }
    
    if (closestLevel) {
        result.levelType = closestLevel.type;
        result.levelPrice = closestLevel.price;
        result.distance = closestDist;
        result.distancePercent = (closestDist / currentPrice) * 100;
        
        // Determine if "at level" (within 0.5%)
        if (result.distancePercent <= 0.5) {
            result.atLevel = true;
            result.bonus = 25;
            result.details = `Pattern AT ${closestLevel.type} (${result.distancePercent.toFixed(2)}%)`;
        } else if (result.distancePercent <= 1.0) {
            result.atLevel = true;
            result.bonus = 15;
            result.details = `Pattern CLOSE to ${closestLevel.type} (${result.distancePercent.toFixed(2)}%)`;
        } else if (result.distancePercent <= 1.5) {
            result.bonus = 5;
            result.details = `Pattern NEAR ${closestLevel.type} (${result.distancePercent.toFixed(2)}%)`;
        } else {
            result.details = `Pattern FAR from levels (${result.distancePercent.toFixed(2)}%)`;
        }
    }
    
    return result;
}

// REJECTION SCORE - Rates quality of price rejection at level
function calculateRejectionScore(klines, zoneData, smcData, direction) {
    const result = {
        score: 0,
        breakdown: {
            wickTouch: 0,
            bodyClosed: 0,
            wickRatio: 0,
            volumeConfirm: 0,
            followThrough: 0
        },
        quality: 'NONE',
        details: []
    };
    
    if (!klines || klines.length < 3) return result;
    
    const current = klines[klines.length - 1];
    const prev = klines[klines.length - 2];
    const zoneD = zoneData.details || {};
    const smcD = smcData.details || {};
    
    // Get target level based on direction
    let targetLevel = null;
    if (direction === 'LONG') {
        if (zoneD.nearestSupport) targetLevel = zoneD.nearestSupport.price;
        const obData = smcD.orderBlocks || {};
        if (obData.bullish && obData.bullish.length > 0) {
            const obLevel = obData.bullish[0].low;
            if (!targetLevel || Math.abs(current.close - obLevel) < Math.abs(current.close - targetLevel)) {
                targetLevel = obLevel;
            }
        }
    } else if (direction === 'SHORT') {
        if (zoneD.nearestResistance) targetLevel = zoneD.nearestResistance.price;
        const obData = smcD.orderBlocks || {};
        if (obData.bearish && obData.bearish.length > 0) {
            const obLevel = obData.bearish[0].high;
            if (!targetLevel || Math.abs(current.close - obLevel) < Math.abs(current.close - targetLevel)) {
                targetLevel = obLevel;
            }
        }
    }
    
    if (!targetLevel) {
        result.details.push('No target level found');
        return result;
    }
    
    const distanceToLevel = Math.abs(current.close - targetLevel) / targetLevel * 100;
    
    // 1. WICK TOUCH (max 30 points) - Proximity based
    const wickTouchLevel = direction === 'LONG' ? current.low : current.high;
    const wickDistance = Math.abs(wickTouchLevel - targetLevel) / targetLevel * 100;
    
    if (wickDistance <= 0.1) {
        result.breakdown.wickTouch = 30;
        result.details.push('Wick touched level exactly (+30)');
    } else if (wickDistance <= 0.3) {
        result.breakdown.wickTouch = 25;
        result.details.push('Wick very close to level (+25)');
    } else if (wickDistance <= 0.5) {
        result.breakdown.wickTouch = 20;
        result.details.push('Wick near level (+20)');
    } else if (wickDistance <= 1.0) {
        result.breakdown.wickTouch = 10;
        result.details.push('Wick approaching level (+10)');
    }
    
    // 2. BODY CLOSED (max 25 points)
    if (direction === 'LONG' && current.close > current.open && current.close > targetLevel) {
        result.breakdown.bodyClosed = 25;
        result.details.push('Body closed bullish above level (+25)');
    } else if (direction === 'SHORT' && current.close < current.open && current.close < targetLevel) {
        result.breakdown.bodyClosed = 25;
        result.details.push('Body closed bearish below level (+25)');
    } else if (direction === 'LONG' && current.close > current.open) {
        result.breakdown.bodyClosed = 15;
        result.details.push('Body closed bullish (+15)');
    } else if (direction === 'SHORT' && current.close < current.open) {
        result.breakdown.bodyClosed = 15;
        result.details.push('Body closed bearish (+15)');
    }
    
    // 3. WICK RATIO (max 20 points)
    const bodySize = Math.abs(current.close - current.open);
    const upperWick = current.high - Math.max(current.open, current.close);
    const lowerWick = Math.min(current.open, current.close) - current.low;
    const relevantWick = direction === 'LONG' ? lowerWick : upperWick;
    const wickRatio = bodySize > 0 ? relevantWick / bodySize : 0;
    
    if (wickRatio > 2) {
        result.breakdown.wickRatio = 20;
        result.details.push('Strong wick ratio >2x (+20)');
    } else if (wickRatio > 1.5) {
        result.breakdown.wickRatio = 15;
        result.details.push('Good wick ratio >1.5x (+15)');
    } else if (wickRatio > 1) {
        result.breakdown.wickRatio = 10;
        result.details.push('Moderate wick ratio >1x (+10)');
    }
    
    // 4. VOLUME CONFIRMATION (max 15 points) - FIXED: Safe calculation
    const volSlice = klines.slice(-20).filter(k => k?.volume > 0);
    const avgVolume = volSlice.length > 0 ? volSlice.reduce((sum, k) => sum + k.volume, 0) / volSlice.length : 1;
    const volumeRatio = avgVolume > 0 ? ((current?.volume || 0) / avgVolume) : 1;
    
    if (!isNaN(volumeRatio) && volumeRatio > 1.5) {
        result.breakdown.volumeConfirm = 15;
        result.details.push('High volume confirmation (+15)');
    } else if (volumeRatio > 1.2) {
        result.breakdown.volumeConfirm = 10;
        result.details.push('Good volume (+10)');
    } else if (volumeRatio > 1.0) {
        result.breakdown.volumeConfirm = 5;
        result.details.push('Normal volume (+5)');
    }
    
    // 5. FOLLOW THROUGH (max 10 points) - Check previous candle direction
    const prevDirection = prev.close > prev.open ? 'BULLISH' : 'BEARISH';
    const currDirection = current.close > current.open ? 'BULLISH' : 'BEARISH';
    
    if (direction === 'LONG' && currDirection === 'BULLISH' && prevDirection === 'BEARISH') {
        result.breakdown.followThrough = 10;
        result.details.push('Reversal follow-through (+10)');
    } else if (direction === 'SHORT' && currDirection === 'BEARISH' && prevDirection === 'BULLISH') {
        result.breakdown.followThrough = 10;
        result.details.push('Reversal follow-through (+10)');
    } else if ((direction === 'LONG' && currDirection === 'BULLISH') || 
               (direction === 'SHORT' && currDirection === 'BEARISH')) {
        result.breakdown.followThrough = 5;
        result.details.push('Directional alignment (+5)');
    }
    
    // Calculate total
    result.score = Object.values(result.breakdown).reduce((sum, v) => sum + v, 0);
    
    // Determine quality
    if (result.score >= 80) result.quality = 'PERFECT';
    else if (result.score >= 60) result.quality = 'STRONG';
    else if (result.score >= 40) result.quality = 'MODERATE';
    else if (result.score >= 20) result.quality = 'WEAK';
    else result.quality = 'NONE';
    
    return result;
}

// ZONE OVERRIDE CHECK - Can bypass weak SMC if zone is strong
function checkZoneOverride(zoneData, smcData, momentumData, direction, currentPrice) {
    const result = {
        eligible: false,
        conditions: {
            zoneScore: false,
            priceAtZone: false,
            touchCount: false,
            directionMatch: false,
            momentumNotOpposing: false,
            zoneFresh: false
        },
        passed: 0,
        required: 5,
        reason: ''
    };
    
    const zoneD = zoneData.details || {};
    const zoneScore = zoneData.score || 0;
    
    // Condition 1: Zone Score >= 75
    if (zoneScore >= 75) {
        result.conditions.zoneScore = true;
        result.passed++;
    }
    
    // Condition 2: Price within 1% of zone
    let targetZone = null;
    let distancePercent = 999;
    
    if (direction === 'LONG' && zoneD.nearestSupport) {
        targetZone = zoneD.nearestSupport;
        distancePercent = Math.abs(currentPrice - targetZone.price) / currentPrice * 100;
    } else if (direction === 'SHORT' && zoneD.nearestResistance) {
        targetZone = zoneD.nearestResistance;
        distancePercent = Math.abs(currentPrice - targetZone.price) / currentPrice * 100;
    }
    
    if (distancePercent <= 1.0) {
        result.conditions.priceAtZone = true;
        result.passed++;
    }
    
    // Condition 3: Zone has 3+ touches
    if (targetZone && targetZone.touches >= 3) {
        result.conditions.touchCount = true;
        result.passed++;
    }
    
    // Condition 4: Direction matches (LONG at support, SHORT at resistance)
    if ((direction === 'LONG' && zoneD.nearestSupport) || 
        (direction === 'SHORT' && zoneD.nearestResistance)) {
        result.conditions.directionMatch = true;
        result.passed++;
    }
    
    // Condition 5: Momentum NOT strongly opposing
    const momDir = momentumData.direction || 'NEUTRAL';
    const momScore = momentumData.score || 0;
    const momOpposing = (direction === 'LONG' && momDir === 'SHORT') || 
                        (direction === 'SHORT' && momDir === 'LONG');
    
    if (!momOpposing || momScore < 60) {
        result.conditions.momentumNotOpposing = true;
        result.passed++;
    }
    
    // Condition 6: Zone freshness (at least 1 touch in last 50 candles) - bonus
    if (targetZone && targetZone.lastTouch && targetZone.lastTouch < 50) {
        result.conditions.zoneFresh = true;
    }
    
    // Check eligibility (need 5 of 5 main conditions)
    result.eligible = result.passed >= 5;
    
    if (result.eligible) {
        result.reason = `Zone Override ACTIVE: ${result.passed}/5 conditions met`;
    } else {
        const missing = [];
        if (!result.conditions.zoneScore) missing.push('Zone<75');
        if (!result.conditions.priceAtZone) missing.push('Price>1%');
        if (!result.conditions.touchCount) missing.push('Touches<3');
        if (!result.conditions.directionMatch) missing.push('Direction');
        if (!result.conditions.momentumNotOpposing) missing.push('Momentum opposing');
        result.reason = `Zone Override DENIED: Missing ${missing.join(', ')}`;
    }
    
    return result;
}

// CONFLICT DETECTOR - Identifies and handles engine conflicts
function detectEngineConflicts(zoneData, smcData, momentumData, candlePatterns) {
    const result = {
        hasConflict: false,
        conflictCount: 0,
        neutralCount: 0,
        conflicts: [],
        directions: {
            zone: 'NEUTRAL',
            smc: 'NEUTRAL',
            momentum: 'NEUTRAL',
            candle: 'NEUTRAL'
        },
        votes: { LONG: 0, SHORT: 0, NEUTRAL: 0 },
        shouldSkip: false,
        reason: ''
    };
    
    // Get directions (treat score < 30 as NEUTRAL)
    result.directions.zone = (zoneData.score >= 30) ? (zoneData.direction || 'NEUTRAL') : 'NEUTRAL';
    result.directions.smc = (smcData.score >= 30) ? (smcData.direction || 'NEUTRAL') : 'NEUTRAL';
    result.directions.momentum = (momentumData.score >= 30) ? (momentumData.direction || 'NEUTRAL') : 'NEUTRAL';
    result.directions.candle = candlePatterns.patternSignal || 'NEUTRAL';
    
    // Normalize candle direction
    if (result.directions.candle === 'BULLISH') result.directions.candle = 'LONG';
    if (result.directions.candle === 'BEARISH') result.directions.candle = 'SHORT';
    
    // Count votes
    for (const [engine, dir] of Object.entries(result.directions)) {
        if (dir === 'LONG') result.votes.LONG++;
        else if (dir === 'SHORT') result.votes.SHORT++;
        else result.votes.NEUTRAL++;
    }
    
    result.neutralCount = result.votes.NEUTRAL;
    
    // Check for LONG vs SHORT conflicts
    const activeEngines = Object.entries(result.directions).filter(([k, v]) => v !== 'NEUTRAL');
    const longEngines = activeEngines.filter(([k, v]) => v === 'LONG').map(([k]) => k);
    const shortEngines = activeEngines.filter(([k, v]) => v === 'SHORT').map(([k]) => k);
    
    if (longEngines.length > 0 && shortEngines.length > 0) {
        result.hasConflict = true;
        result.conflictCount = Math.min(longEngines.length, shortEngines.length);
        result.conflicts.push(`${longEngines.join('+')} say LONG vs ${shortEngines.join('+')} say SHORT`);
    }
    
    // RULE 3: 2+ engines conflict → SKIP
    if (result.conflictCount >= 2) {
        result.shouldSkip = true;
        result.reason = 'RULE 3: 2+ engines conflict';
    }
    
    // RULE 4: 2+ engines NEUTRAL → WAIT (not skip, but warning)
    if (result.neutralCount >= 2 && !result.shouldSkip) {
        result.reason = 'RULE 4: 2+ engines neutral - low conviction';
    }
    
    return result;
}

// V5.1 ULTRA-RELAXED MANDATORY RULES - Almost never blocks
function checkMandatoryRules(zoneData, smcData, momentumData, htfBias, conflictResult, zoneOverride, trapDetection) {
    const result = {
        allPassed: true,
        rules: {
            rule1: { passed: true, description: 'SMC >= 10', reason: '' },
            rule2: { passed: true, description: 'Info only', reason: '' },
            rule3: { passed: true, description: 'Info only', reason: '' },
            rule4: { passed: true, description: 'Info only', reason: '' },
            rule5: { passed: true, description: 'Info only', reason: '' },
            rule6: { passed: true, description: 'Info only', reason: '' },
            rule7: { passed: true, description: 'Info only', reason: '' }
        },
        verdict: 'TAKE',
        violations: []
    };
    
    const smcScore = smcData.score || 0;
    const zoneScore = zoneData.score || 0;
    
    // RULE 1: SMC < 10 → NO_TRADE only if Zone also weak (ultra relaxed)
    if (smcScore < 10 && zoneScore < 30) {
        result.rules.rule1.passed = false;
        result.rules.rule1.reason = `SMC ${smcScore}, Zone ${zoneScore} both weak`;
        result.violations.push('⚠️ Very weak setup');
        result.verdict = 'NO_TRADE';
        result.allPassed = false;
    }
    
    // ALL OTHER RULES: INFO ONLY - Never block
    if (smcScore < 25) {
        result.violations.push(`ℹ️ SMC: ${smcScore}`);
    }
    
    if (conflictResult.conflictCount >= 2) {
        result.violations.push(`ℹ️ ${conflictResult.conflictCount} conflicts`);
    }
    
    if (conflictResult.neutralCount >= 2) {
        result.violations.push(`ℹ️ ${conflictResult.neutralCount} neutral`);
    }
    
    const htfPct = htfBias.total > 0 ? (htfBias.aligned / htfBias.total) * 100 : 50;
    if (htfPct < 50) {
        result.violations.push(`ℹ️ HTF: ${htfPct.toFixed(0)}%`);
    }
    
    if (trapDetection && trapDetection.confidence === 'HIGH') {
        result.violations.push(`⚠️ ${trapDetection.type}`);
    }
    
    return result;
}

// ULTIMATE SCORE CALCULATOR - New formula
function calculateUltimateScore(sequenceResult, rejectionResult, htfBias, momentumData, volumeConfirmed) {
    // NEW FORMULA: Sequence 40% + Rejection 25% + HTF 15% + Momentum 10% + Volume 10%
    const sequenceScore = sequenceResult.score || 0;
    const rejectionScore = rejectionResult.score || 0;
    const htfScore = htfBias.total > 0 ? (htfBias.aligned / htfBias.total) * 100 : 50;
    // FIX: Use typeof check so score of 0 is valid (not replaced with 50)
    const momentumScore = typeof momentumData.score === 'number' ? momentumData.score : 50;
    const volumeScore = volumeConfirmed ? 100 : 50;
    
    const finalScore = 
        (sequenceScore * 0.40) +
        (rejectionScore * 0.25) +
        (htfScore * 0.15) +
        (momentumScore * 0.10) +
        (volumeScore * 0.10);
    
    return {
        final: Math.round(finalScore),
        breakdown: {
            sequence: { raw: sequenceScore, weighted: Math.round(sequenceScore * 0.40), weight: '40%' },
            rejection: { raw: rejectionScore, weighted: Math.round(rejectionScore * 0.25), weight: '25%' },
            htf: { raw: Math.round(htfScore), weighted: Math.round(htfScore * 0.15), weight: '15%' },
            momentum: { raw: momentumScore, weighted: Math.round(momentumScore * 0.10), weight: '10%' },
            volume: { raw: volumeScore, weighted: Math.round(volumeScore * 0.10), weight: '10%' }
        }
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// MOMENTUM ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════════

// Calculate RSI with Wilder Smoothing (correct implementation)
function calcRSI(closes, period = 14) {
    if (!closes || closes.length < period + 1) return { value: 50, trend: 'NEUTRAL' };
    
    const gains = [];
    const losses = [];
    
    for (let i = 1; i < closes.length; i++) {
        const change = closes[i] - closes[i - 1];
        gains.push(change > 0 ? change : 0);
        losses.push(change < 0 ? -change : 0);
    }
    
    // Initial average (SMA)
    let avgGain = 0;
    let avgLoss = 0;
    for (let i = 0; i < period; i++) {
        avgGain += gains[i];
        avgLoss += losses[i];
    }
    avgGain /= period;
    avgLoss /= period;
    
    // Wilder smoothing for remaining values
    for (let i = period; i < gains.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
    }
    
    if (avgLoss === 0) return { value: 100, trend: 'OVERBOUGHT' };
    
    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));
    
    let trend = 'NEUTRAL';
    if (rsi >= 70) trend = 'OVERBOUGHT';
    else if (rsi >= 60) trend = 'BULLISH';
    else if (rsi <= 30) trend = 'OVERSOLD';
    else if (rsi <= 40) trend = 'BEARISH';
    
    return { value: rsi, trend, avgGain, avgLoss };
}

// Calculate MACD with Signal Line and Histogram
function calcMACD(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
    if (!closes || closes.length < slowPeriod + signalPeriod) {
        return { macd: 0, signal: 0, histogram: 0, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate EMAs
    const calcEMA = (data, period) => {
        const k = 2 / (period + 1);
        let ema = data[0];
        const emaValues = [ema];
        
        for (let i = 1; i < data.length; i++) {
            ema = data[i] * k + ema * (1 - k);
            emaValues.push(ema);
        }
        return emaValues;
    };
    
    const ema12 = calcEMA(closes, fastPeriod);
    const ema26 = calcEMA(closes, slowPeriod);
    
    // MACD Line
    const macdLine = [];
    for (let i = 0; i < closes.length; i++) {
        macdLine.push(ema12[i] - ema26[i]);
    }
    
    // Signal Line (EMA of MACD)
    const signalLine = calcEMA(macdLine.slice(slowPeriod - 1), signalPeriod);
    
    const currentMACD = macdLine[macdLine.length - 1];
    const currentSignal = signalLine[signalLine.length - 1];
    const prevMACD = macdLine[macdLine.length - 2];
    const prevSignal = signalLine[signalLine.length - 2];
    const histogram = currentMACD - currentSignal;
    const prevHistogram = prevMACD - prevSignal;
    
    // Detect crossover
    let crossover = null;
    if (prevMACD <= prevSignal && currentMACD > currentSignal) {
        crossover = 'BULLISH';
    } else if (prevMACD >= prevSignal && currentMACD < currentSignal) {
        crossover = 'BEARISH';
    }
    
    // Histogram momentum
    let histogramTrend = 'NEUTRAL';
    if (histogram > 0 && histogram > prevHistogram) histogramTrend = 'BULLISH_EXPANDING';
    else if (histogram > 0 && histogram < prevHistogram) histogramTrend = 'BULLISH_CONTRACTING';
    else if (histogram < 0 && histogram < prevHistogram) histogramTrend = 'BEARISH_EXPANDING';
    else if (histogram < 0 && histogram > prevHistogram) histogramTrend = 'BEARISH_CONTRACTING';
    
    let trend = 'NEUTRAL';
    if (currentMACD > 0 && currentMACD > currentSignal) trend = 'BULLISH';
    else if (currentMACD < 0 && currentMACD < currentSignal) trend = 'BEARISH';
    
    return {
        macd: currentMACD,
        signal: currentSignal,
        histogram,
        histogramTrend,
        trend,
        crossover,
        ema12: ema12[ema12.length - 1],
        ema26: ema26[ema26.length - 1]
    };
}

// Calculate ADX with DI+ and DI-
function calcADX(klines, period = 14) {
    // SAFETY: Comprehensive null/edge case checks
    if (!klines || !Array.isArray(klines) || klines.length < period * 2) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK', crossover: null, trending: false };
    }
    
    const plusDM = [];
    const minusDM = [];
    const tr = [];
    
    for (let i = 1; i < klines.length; i++) {
        const candle = klines[i];
        const prevCandle = klines[i - 1];
        
        // SAFETY: Validate candle data exists
        if (!candle || !prevCandle) continue;
        
        const high = candle.high || 0;
        const low = candle.low || 0;
        const prevHigh = prevCandle.high || 0;
        const prevLow = prevCandle.low || 0;
        const prevClose = prevCandle.close || 0;
        
        // Directional Movement
        const upMove = high - prevHigh;
        const downMove = prevLow - low;
        
        plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
        minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);
        
        // True Range
        tr.push(Math.max(
            high - low,
            Math.abs(high - prevClose),
            Math.abs(low - prevClose)
        ));
    }
    
    // SAFETY: Check we have enough data after filtering
    if (plusDM.length < period || minusDM.length < period || tr.length < period) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK', crossover: null, trending: false };
    }
    
    // Smoothed values
    let smoothPlusDM = 0;
    let smoothMinusDM = 0;
    let smoothTR = 0;
    
    for (let i = 0; i < period; i++) {
        smoothPlusDM += plusDM[i] || 0;
        smoothMinusDM += minusDM[i] || 0;
        smoothTR += tr[i] || 0;
    }
    
    const dxValues = [];
    
    for (let i = period; i < plusDM.length; i++) {
        smoothPlusDM = smoothPlusDM - smoothPlusDM / period + (plusDM[i] || 0);
        smoothMinusDM = smoothMinusDM - smoothMinusDM / period + (minusDM[i] || 0);
        smoothTR = smoothTR - smoothTR / period + (tr[i] || 0);
        
        // SAFETY: Prevent division by zero
        const diPlus = smoothTR > 0 ? (smoothPlusDM / smoothTR) * 100 : 0;
        const diMinus = smoothTR > 0 ? (smoothMinusDM / smoothTR) * 100 : 0;
        const diSum = diPlus + diMinus;
        const dx = diSum > 0 ? Math.abs(diPlus - diMinus) / diSum * 100 : 0;
        
        dxValues.push({ dx, diPlus, diMinus });
    }
    
    if (dxValues.length < period) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK', crossover: null, trending: false };
    }
    
    // ADX (smoothed DX)
    let adx = 0;
    for (let i = 0; i < period; i++) {
        adx += dxValues[i]?.dx || 0;
    }
    adx /= period;
    
    for (let i = period; i < dxValues.length; i++) {
        adx = (adx * (period - 1) + (dxValues[i]?.dx || 0)) / period;
    }
    
    // SAFETY: Ensure we have DI values
    const lastDI = dxValues[dxValues.length - 1] || { diPlus: 0, diMinus: 0 };
    const prevDI = dxValues[dxValues.length - 2] || { diPlus: 0, diMinus: 0 };
    
    // Trend direction and strength
    let trend = 'NEUTRAL';
    if (lastDI.diPlus > lastDI.diMinus) trend = 'BULLISH';
    else if (lastDI.diMinus > lastDI.diPlus) trend = 'BEARISH';
    
    let strength = 'WEAK';
    if (adx >= 50) strength = 'VERY_STRONG';
    else if (adx >= 35) strength = 'STRONG';
    else if (adx >= 25) strength = 'TRENDING';
    else if (adx >= 20) strength = 'WEAK_TREND';
    
    // DI crossover detection
    let crossover = null;
    if (prevDI.diPlus <= prevDI.diMinus && lastDI.diPlus > lastDI.diMinus) {
        crossover = 'BULLISH';
    } else if (prevDI.diPlus >= prevDI.diMinus && lastDI.diPlus < lastDI.diMinus) {
        crossover = 'BEARISH';
    }
    
    return {
        adx: isNaN(adx) ? 0 : adx,
        diPlus: isNaN(lastDI.diPlus) ? 0 : lastDI.diPlus,
        diMinus: isNaN(lastDI.diMinus) ? 0 : lastDI.diMinus,
        trend,
        strength,
        crossover,
        trending: adx >= 25
    };
}

// Calculate Stochastic RSI
function calcStochRSI(closes, rsiPeriod = 14, stochPeriod = 14, kPeriod = 3, dPeriod = 3) {
    if (!closes || closes.length < rsiPeriod + stochPeriod + kPeriod) {
        return { k: 50, d: 50, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate RSI values
    const rsiValues = [];
    for (let i = rsiPeriod; i < closes.length; i++) {
        const rsi = calcRSI(closes.slice(0, i + 1), rsiPeriod);
        rsiValues.push(rsi.value);
    }
    
    if (rsiValues.length < stochPeriod) {
        return { k: 50, d: 50, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate Stochastic of RSI
    const stochRSI = [];
    for (let i = stochPeriod - 1; i < rsiValues.length; i++) {
        const period = rsiValues.slice(i - stochPeriod + 1, i + 1);
        const minRSI = Math.min(...period);
        const maxRSI = Math.max(...period);
        const range = maxRSI - minRSI;
        
        if (range === 0) {
            stochRSI.push(50);
        } else {
            stochRSI.push(((rsiValues[i] - minRSI) / range) * 100);
        }
    }
    
    // Calculate %K (SMA of Stochastic RSI)
    const kValues = [];
    for (let i = kPeriod - 1; i < stochRSI.length; i++) {
        const sum = stochRSI.slice(i - kPeriod + 1, i + 1).reduce((a, b) => a + b, 0);
        kValues.push(sum / kPeriod);
    }
    
    // Calculate %D (SMA of %K)
    const dValues = [];
    for (let i = dPeriod - 1; i < kValues.length; i++) {
        const sum = kValues.slice(i - dPeriod + 1, i + 1).reduce((a, b) => a + b, 0);
        dValues.push(sum / dPeriod);
    }
    
    const k = kValues[kValues.length - 1] || 50;
    const d = dValues[dValues.length - 1] || 50;
    const prevK = kValues[kValues.length - 2] || 50;
    const prevD = dValues[dValues.length - 2] || 50;
    
    // Crossover detection
    let crossover = null;
    if (prevK <= prevD && k > d) crossover = 'BULLISH';
    else if (prevK >= prevD && k < d) crossover = 'BEARISH';
    
    let trend = 'NEUTRAL';
    if (k >= 80) trend = 'OVERBOUGHT';
    else if (k <= 20) trend = 'OVERSOLD';
    else if (k > d && k > 50) trend = 'BULLISH';
    else if (k < d && k < 50) trend = 'BEARISH';
    
    return { k, d, trend, crossover };
}

// Calculate On-Balance Volume (OBV) with trend
function calcOBV(klines) {
    if (!klines || klines.length < 20) {
        return { obv: 0, trend: 'NEUTRAL', divergence: null };
    }
    
    let obv = 0;
    const obvValues = [0];
    
    for (let i = 1; i < klines.length; i++) {
        if (klines[i].close > klines[i - 1].close) {
            obv += klines[i].volume;
        } else if (klines[i].close < klines[i - 1].close) {
            obv -= klines[i].volume;
        }
        obvValues.push(obv);
    }
    
    // Calculate OBV trend using EMA
    const len = obvValues.length;
    const shortEMA = obvValues.slice(-10).reduce((a, b) => a + b, 0) / 10;
    const longEMA = obvValues.slice(-20).reduce((a, b) => a + b, 0) / 20;
    
    let trend = 'NEUTRAL';
    if (shortEMA > longEMA * 1.05) trend = 'BULLISH';
    else if (shortEMA < longEMA * 0.95) trend = 'BEARISH';
    
    // Check for OBV divergence with price
    const recentOBV = obvValues.slice(-20);
    const recentClose = klines.slice(-20).map(k => k.close);
    
    const priceUp = recentClose[recentClose.length - 1] > recentClose[0];
    const obvUp = recentOBV[recentOBV.length - 1] > recentOBV[0];
    
    let divergence = null;
    if (priceUp && !obvUp) divergence = 'BEARISH'; // Price up, OBV down
    else if (!priceUp && obvUp) divergence = 'BULLISH'; // Price down, OBV up
    
    return {
        obv: obvValues[obvValues.length - 1],
        obvValues,
        trend,
        divergence,
        shortEMA,
        longEMA
    };
}

// Calculate Volume Metrics
function calcVolumeMetrics(klines) {
    if (!klines || klines.length < 25) {
        return { ratio: 1, spike: false, trend: 'NEUTRAL' };
    }
    
    const len = klines.length;
    const currentVolume = klines[len - 1].volume;
    
    // Average volume (20 period)
    const avgVolume = klines.slice(-21, -1).reduce((sum, k) => sum + k.volume, 0) / 20;
    
    const ratio = avgVolume > 0 ? currentVolume / avgVolume : 1;
    const spike = ratio >= 2.5;
    
    // Volume trend
    const recentAvg = klines.slice(-5).reduce((sum, k) => sum + k.volume, 0) / 5;
    const olderAvg = klines.slice(-15, -10).reduce((sum, k) => sum + k.volume, 0) / 5;
    
    let trend = 'NEUTRAL';
    if (recentAvg > olderAvg * 1.3) trend = 'INCREASING';
    else if (recentAvg < olderAvg * 0.7) trend = 'DECREASING';
    
    return {
        current: currentVolume,
        average: avgVolume,
        ratio,
        spike,
        trend,
        percentAboveAvg: ((ratio - 1) * 100)
    };
}


// Calculate EMA values
function calcEMA(closes, period) {
    if (!closes || closes.length < period) return null;
    
    const k = 2 / (period + 1);
    let ema = closes.slice(0, period).reduce((a, b) => a + b, 0) / period;
    
    for (let i = period; i < closes.length; i++) {
        ema = closes[i] * k + ema * (1 - k);
    }
    
    return ema;
}

// Get EMA Cross signals (9/21 for scalping, 50/200 for trend)
function getEMACross(closes) {
    if (!closes || closes.length < 200) {
        return { 
            ema9: 0, ema21: 0, ema50: 0, ema200: 0,
            shortCross: null, longCross: null, 
            priceVsEMA: 'NEUTRAL'
        };
    }
    
    const ema9 = calcEMA(closes, 9);
    const ema21 = calcEMA(closes, 21);
    const ema50 = calcEMA(closes, 50);
    const ema200 = calcEMA(closes, 200);
    const currentPrice = closes[closes.length - 1];
    
    // Calculate previous EMAs for crossover detection
    const prevCloses = closes.slice(0, -1);
    const prevEma9 = calcEMA(prevCloses, 9);
    const prevEma21 = calcEMA(prevCloses, 21);
    const prevEma50 = calcEMA(prevCloses, 50);
    const prevEma200 = calcEMA(prevCloses, 200);
    
    // Short-term cross (9/21)
    let shortCross = null;
    if (prevEma9 <= prevEma21 && ema9 > ema21) shortCross = 'BULLISH';
    else if (prevEma9 >= prevEma21 && ema9 < ema21) shortCross = 'BEARISH';
    
    // Long-term cross (50/200 - Golden/Death Cross)
    let longCross = null;
    if (prevEma50 <= prevEma200 && ema50 > ema200) longCross = 'GOLDEN';
    else if (prevEma50 >= prevEma200 && ema50 < ema200) longCross = 'DEATH';
    
    // Price position vs EMAs
    let priceVsEMA = 'NEUTRAL';
    if (currentPrice > ema9 && currentPrice > ema21 && currentPrice > ema50) {
        priceVsEMA = 'STRONG_BULLISH';
    } else if (currentPrice > ema9 && currentPrice > ema21) {
        priceVsEMA = 'BULLISH';
    } else if (currentPrice < ema9 && currentPrice < ema21 && currentPrice < ema50) {
        priceVsEMA = 'STRONG_BEARISH';
    } else if (currentPrice < ema9 && currentPrice < ema21) {
        priceVsEMA = 'BEARISH';
    }
    
    return {
        ema9, ema21, ema50, ema200,
        shortCross, longCross,
        priceVsEMA,
        aboveEMA200: currentPrice > ema200,
        aboveEMA50: currentPrice > ema50
    };
}

// Detect Divergence (Regular, Hidden, Compound)
function detectDivergence(klines, indicatorFn = 'rsi') {
    if (!klines || klines.length < 50) {
        return { type: null, strength: null, direction: null };
    }
    
    const closes = klines.map(k => k.close);
    const highs = klines.map(k => k.high);
    const lows = klines.map(k => k.low);
    
    // Find swing points in price
    const priceSwings = findSwingPoints(klines, 4, 4);
    
    // Calculate indicator values
    let indicatorValues = [];
    if (indicatorFn === 'rsi') {
        for (let i = 14; i < closes.length; i++) {
            indicatorValues.push({
                index: i,
                value: calcRSI(closes.slice(0, i + 1), 14).value
            });
        }
    } else if (indicatorFn === 'macd') {
        for (let i = 35; i < closes.length; i++) {
            indicatorValues.push({
                index: i,
                value: calcMACD(closes.slice(0, i + 1)).histogram
            });
        }
    }
    
    if (indicatorValues.length < 20 || priceSwings.highs.length < 2 || priceSwings.lows.length < 2) {
        return { type: null, strength: null, direction: null };
    }
    
    // Get indicator values at swing points
    const getIndicatorAtIndex = (idx) => {
        const found = indicatorValues.find(v => v.index === idx);
        if (found) return found.value;
        // Find closest
        const closest = indicatorValues.reduce((prev, curr) => 
            Math.abs(curr.index - idx) < Math.abs(prev.index - idx) ? curr : prev
        );
        return closest.value;
    };
    
    // Check for Regular Bullish Divergence (price lower low, indicator higher low)
    const recentLows = priceSwings.lows.slice(-4);
    for (let i = 0; i < recentLows.length - 1; i++) {
        const firstLow = recentLows[i];
        const secondLow = recentLows[i + 1];
        
        const ind1 = getIndicatorAtIndex(firstLow.index);
        const ind2 = getIndicatorAtIndex(secondLow.index);
        
        // Price makes lower low, indicator makes higher low
        if (secondLow.price < firstLow.price && ind2 > ind1) {
            // Check for compound (3+ swings)
            if (i > 0) {
                const thirdLow = recentLows[i - 1];
                const ind0 = getIndicatorAtIndex(thirdLow.index);
                if (thirdLow.price > firstLow.price && ind0 < ind1) {
                    return { type: 'COMPOUND', strength: 'STRONG', direction: 'BULLISH' };
                }
            }
            return { type: 'REGULAR', strength: 'MEDIUM', direction: 'BULLISH' };
        }
        
        // Hidden Bullish: price higher low, indicator lower low
        if (secondLow.price > firstLow.price && ind2 < ind1) {
            return { type: 'HIDDEN', strength: 'MEDIUM', direction: 'BULLISH' };
        }
    }
    
    // Check for Regular Bearish Divergence (price higher high, indicator lower high)
    const recentHighs = priceSwings.highs.slice(-4);
    for (let i = 0; i < recentHighs.length - 1; i++) {
        const firstHigh = recentHighs[i];
        const secondHigh = recentHighs[i + 1];
        
        const ind1 = getIndicatorAtIndex(firstHigh.index);
        const ind2 = getIndicatorAtIndex(secondHigh.index);
        
        // Price makes higher high, indicator makes lower high
        if (secondHigh.price > firstHigh.price && ind2 < ind1) {
            // Check for compound
            if (i > 0) {
                const thirdHigh = recentHighs[i - 1];
                const ind0 = getIndicatorAtIndex(thirdHigh.index);
                if (thirdHigh.price < firstHigh.price && ind0 > ind1) {
                    return { type: 'COMPOUND', strength: 'STRONG', direction: 'BEARISH' };
                }
            }
            return { type: 'REGULAR', strength: 'MEDIUM', direction: 'BEARISH' };
        }
        
        // Hidden Bearish: price lower high, indicator higher high
        if (secondHigh.price < firstHigh.price && ind2 > ind1) {
            return { type: 'HIDDEN', strength: 'MEDIUM', direction: 'BEARISH' };
        }
    }
    
    return { type: null, strength: null, direction: null };
}

// Detect Momentum Exhaustion
function detectExhaustion(klines, rsi, macd, volume) {
    if (!klines || klines.length < 20) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const isBullishCandle = currentCandle.close > currentCandle.open;
    
    // Bullish Exhaustion: RSI overbought + volume spike + small body or doji
    if (rsi.value >= 70 && volume.spike) {
        const body = Math.abs(currentCandle.close - currentCandle.open);
        const range = currentCandle.high - currentCandle.low;
        const bodyRatio = range > 0 ? body / range : 0;
        
        if (bodyRatio < 0.3) { // Small body (doji-like)
            return {
                detected: true,
                direction: 'BEARISH', // Bullish exhaustion = bearish signal
                reason: 'RSI OB + Vol spike + weak candle'
            };
        }
        
        // Check for shooting star / hanging man
        const upperWick = currentCandle.high - Math.max(currentCandle.open, currentCandle.close);
        if (upperWick > body * 2) {
            return {
                detected: true,
                direction: 'BEARISH',
                reason: 'Rejection candle at RSI OB'
            };
        }
    }
    
    // Bearish Exhaustion: RSI oversold + volume spike + small body
    if (rsi.value <= 30 && volume.spike) {
        const body = Math.abs(currentCandle.close - currentCandle.open);
        const range = currentCandle.high - currentCandle.low;
        const bodyRatio = range > 0 ? body / range : 0;
        
        if (bodyRatio < 0.3) {
            return {
                detected: true,
                direction: 'BULLISH', // Bearish exhaustion = bullish signal
                reason: 'RSI OS + Vol spike + weak candle'
            };
        }
        
        // Check for hammer
        const lowerWick = Math.min(currentCandle.open, currentCandle.close) - currentCandle.low;
        if (lowerWick > body * 2) {
            return {
                detected: true,
                direction: 'BULLISH',
                reason: 'Hammer candle at RSI OS'
            };
        }
    }
    
    // MACD histogram exhaustion
    if (macd.histogramTrend === 'BULLISH_CONTRACTING' && rsi.value > 65) {
        return {
            detected: true,
            direction: 'BEARISH',
            reason: 'MACD momentum fading'
        };
    }
    
    if (macd.histogramTrend === 'BEARISH_CONTRACTING' && rsi.value < 35) {
        return {
            detected: true,
            direction: 'BULLISH',
            reason: 'MACD momentum fading'
        };
    }
    
    return { detected: false };
}

// Calculate ATR for volatility
function calcATR(klines, period = 14) {
    if (!klines || klines.length < period + 1) return 0;
    
    const tr = [];
    for (let i = 1; i < klines.length; i++) {
        tr.push(Math.max(
            klines[i].high - klines[i].low,
            Math.abs(klines[i].high - klines[i - 1].close),
            Math.abs(klines[i].low - klines[i - 1].close)
        ));
    }
    
    // Wilder smoothing
    let atr = tr.slice(0, period).reduce((a, b) => a + b, 0) / period;
    
    for (let i = period; i < tr.length; i++) {
        atr = (atr * (period - 1) + tr[i]) / period;
    }
    
    return atr;
}

// MAIN MOMENTUM ANALYSIS FUNCTION
function performMomentumAnalysis(klines) {
    const result = {
        score: 0,
        direction: null,
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const closes = klines.map(k => k.close);
    
    // Calculate all indicators
    const rsi = calcRSI(closes, 14);
    result.details.rsi = rsi;
    
    const macd = calcMACD(closes);
    result.details.macd = macd;
    
    const adx = calcADX(klines, 14);
    result.details.adx = adx;
    
    const stochRSI = calcStochRSI(closes);
    result.details.stochRSI = stochRSI;
    
    const obv = calcOBV(klines);
    result.details.obv = obv;
    
    const volume = calcVolumeMetrics(klines);
    result.details.volume = volume;
    
    const emaCross = getEMACross(closes);
    result.details.emaCross = emaCross;
    
    const divergenceRSI = detectDivergence(klines, 'rsi');
    const divergenceMACD = detectDivergence(klines, 'macd');
    result.details.divergence = { rsi: divergenceRSI, macd: divergenceMACD };
    
    const exhaustion = detectExhaustion(klines, rsi, macd, volume);
    result.details.exhaustion = exhaustion;
    
    const atr = calcATR(klines);
    result.details.atr = atr;
    
    // SCORING
    let bullScore = 0;
    let bearScore = 0;
    
    // RSI (max 25 points)
    if (rsi.value <= 30) {
        bullScore += 25;
        result.factors.push(`RSI OS(${rsi.value.toFixed(0)})`);
    } else if (rsi.value <= 40) {
        bullScore += 12;
        result.factors.push(`RSI Low(${rsi.value.toFixed(0)})`);
    } else if (rsi.value >= 70) {
        bearScore += 25;
        result.factors.push(`RSI OB(${rsi.value.toFixed(0)})`);
    } else if (rsi.value >= 60) {
        bearScore += 12;
        result.factors.push(`RSI High(${rsi.value.toFixed(0)})`);
    }
    
    // MACD (max 20 points)
    if (macd.crossover === 'BULLISH') {
        bullScore += 20;
        result.factors.push('MACD Cross↑');
    } else if (macd.crossover === 'BEARISH') {
        bearScore += 20;
        result.factors.push('MACD Cross↓');
    } else if (macd.trend === 'BULLISH') {
        bullScore += 10;
        result.factors.push('MACD+');
    } else if (macd.trend === 'BEARISH') {
        bearScore += 10;
        result.factors.push('MACD-');
    }
    
    // MACD Histogram momentum
    if (macd.histogramTrend === 'BULLISH_EXPANDING') {
        bullScore += 8;
        result.factors.push('Hist↑↑');
    } else if (macd.histogramTrend === 'BEARISH_EXPANDING') {
        bearScore += 8;
        result.factors.push('Hist↓↓');
    }
    
    // ADX (max 15 points)
    if (adx.trending) {
        if (adx.trend === 'BULLISH') {
            bullScore += 15;
            result.factors.push(`ADX↑(${adx.adx.toFixed(0)})`);
        } else if (adx.trend === 'BEARISH') {
            bearScore += 15;
            result.factors.push(`ADX↓(${adx.adx.toFixed(0)})`);
        }
        
        if (adx.crossover === 'BULLISH') {
            bullScore += 8;
            result.factors.push('DI+ Cross');
        } else if (adx.crossover === 'BEARISH') {
            bearScore += 8;
            result.factors.push('DI- Cross');
        }
    } else {
        result.warnings.push('Weak trend (ADX<25)');
    }
    
    // Stochastic RSI (max 15 points)
    if (stochRSI.trend === 'OVERSOLD') {
        bullScore += 12;
        result.factors.push('StochRSI OS');
    } else if (stochRSI.trend === 'OVERBOUGHT') {
        bearScore += 12;
        result.factors.push('StochRSI OB');
    }
    
    if (stochRSI.crossover === 'BULLISH' && stochRSI.k < 30) {
        bullScore += 10;
        result.factors.push('StochRSI Cross↑');
    } else if (stochRSI.crossover === 'BEARISH' && stochRSI.k > 70) {
        bearScore += 10;
        result.factors.push('StochRSI Cross↓');
    }
    
    // OBV (max 10 points)
    if (obv.trend === 'BULLISH') {
        bullScore += 8;
        result.factors.push('OBV+');
    } else if (obv.trend === 'BEARISH') {
        bearScore += 8;
        result.factors.push('OBV-');
    }
    
    if (obv.divergence === 'BULLISH') {
        bullScore += 10;
        result.factors.push('OBV Div↑');
    } else if (obv.divergence === 'BEARISH') {
        bearScore += 10;
        result.factors.push('OBV Div↓');
    }
    
    // Volume (max 10 points)
    if (volume.spike) {
        result.factors.push(`Vol Spike(${volume.ratio.toFixed(1)}x)`);
        // Volume confirms direction
    }
    
    // EMA Cross (max 12 points)
    if (emaCross.shortCross === 'BULLISH') {
        bullScore += 12;
        result.factors.push('EMA 9/21↑');
    } else if (emaCross.shortCross === 'BEARISH') {
        bearScore += 12;
        result.factors.push('EMA 9/21↓');
    }
    
    if (emaCross.priceVsEMA === 'STRONG_BULLISH') {
        bullScore += 8;
    } else if (emaCross.priceVsEMA === 'STRONG_BEARISH') {
        bearScore += 8;
    }
    
    if (emaCross.longCross === 'GOLDEN') {
        bullScore += 15;
        result.factors.push('Golden Cross!');
    } else if (emaCross.longCross === 'DEATH') {
        bearScore += 15;
        result.factors.push('Death Cross!');
    }
    
    // Divergence (max 25 points)
    const div = divergenceRSI.type ? divergenceRSI : divergenceMACD;
    if (div.type) {
        const divPoints = div.type === 'COMPOUND' ? 25 : div.type === 'REGULAR' ? 18 : 10;
        if (div.direction === 'BULLISH') {
            bullScore += divPoints;
            result.factors.push(`${div.type} Div↑`);
        } else {
            bearScore += divPoints;
            result.factors.push(`${div.type} Div↓`);
        }
    }
    
    // Exhaustion (warning)
    if (exhaustion.detected) {
        result.warnings.push(exhaustion.reason);
        if (exhaustion.direction === 'BULLISH') {
            bullScore += 5;
        } else {
            bearScore += 5;
        }
    }
    
    // Determine direction
    if (bullScore > bearScore + 10) {
        result.direction = 'LONG';
        result.score = Math.min(100, bullScore);
    } else if (bearScore > bullScore + 10) {
        result.direction = 'SHORT';
        result.score = Math.min(100, bearScore);
    } else {
        result.direction = null;
        result.score = Math.min(100, Math.max(bullScore, bearScore) * 0.6);
        result.warnings.push('Mixed momentum signals');
    }
    
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF PART 3 - Momentum Analysis Complete
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// 🧠 SMART TRADE SYSTEM - 6 INTELLIGENT ENGINES
// ═══════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 1: SMART STOP LOSS
// Finds structure-based SL that avoids liquidity traps
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartSL(direction, currentPrice, klines, atr) {
    const result = {
        price: null,
        reason: '',
        riskPct: 0,
        trapAvoided: false,
        structureUsed: null,
        score: 0
    };
    
    if (!klines || klines.length < 50) {
        // Fallback to ATR-based SL
        result.price = direction === 'LONG' 
            ? currentPrice - (atr * 2)
            : currentPrice + (atr * 2);
        result.reason = 'ATR fallback';
        result.riskPct = ((Math.abs(currentPrice - result.price) / currentPrice) * 100).toFixed(2);
        return result;
    }
    
    // Get all structure data
    const swings = findSwingPoints(klines, 5, 5);
    const equalLevels = detectEqualLevels(klines, 0.002);
    const orderBlocks = detectOrderBlocks(klines, 50);
    
    // Collect candidate SL levels
    const candidates = [];
    
    if (direction === 'LONG') {
        // Find swing lows below current price
        swings.lows.filter(s => s.price < currentPrice).forEach(swing => {
            const dist = ((currentPrice - swing.price) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) { // Between 0.3% and 5%
                candidates.push({
                    price: swing.price * 0.998, // Buffer below
                    type: 'SWING',
                    dist: dist,
                    score: 50
                });
            }
        });
        
        // Find bullish OBs below current price (SL below OB low)
        orderBlocks.bullish.filter(ob => ob.low < currentPrice && ob.fresh).forEach(ob => {
            const dist = ((currentPrice - ob.low) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) {
                candidates.push({
                    price: ob.low * 0.997, // Buffer below OB
                    type: 'OB',
                    dist: dist,
                    score: ob.fresh ? 70 : 40
                });
            }
        });
        
        // Check for equal lows (TRAP ZONES - avoid these!)
        const trapZones = equalLevels.equalLows.filter(el => el.price < currentPrice);
        
        // Score and filter candidates - FIXED: No distance bonus, stronger penalties
        candidates.forEach(c => {
            // FIX 1: REMOVED distance bonus - SL should be structure-based, not R:R optimized
            // Tight SLs are NOT better - they get hunted
            
            // FIX 2: ATR validation with STRONGER penalty
            const atrRatio = (currentPrice - c.price) / atr;
            if (atrRatio >= 1.5) c.score += 20;      // Good - gives room
            else if (atrRatio >= 1) c.score += 10;   // OK
            else c.score -= 30;                       // FIX: Was -10, now -30 (HARD penalty)
            
            // FIX 3: Check if SL is ABOVE any trap zone - DISQUALIFY completely
            trapZones.forEach(trap => {
                if (c.price > trap.price && c.price < trap.price * 1.01) {
                    c.disqualified = true;  // FIX: Was score -= 30, now DISQUALIFIED
                    c.inTrap = true;
                }
            });
            
            // Check if SL is BELOW trap zone (good - survives hunt)
            trapZones.forEach(trap => {
                if (c.price < trap.price * 0.995) {
                    c.score += 20; // Increased bonus for being below trap
                    c.belowTrap = true;
                }
            });
        });
        
        // FIX 3b: Filter out disqualified candidates BEFORE sorting
        const validCandidates = candidates.filter(c => !c.disqualified);
        
        // Select best candidate from VALID (non-disqualified) candidates
        validCandidates.sort((a, b) => b.score - a.score);
        
        if (validCandidates.length > 0 && validCandidates[0].score >= 40) {
            const best = validCandidates[0];
            result.price = best.price;
            result.structureUsed = best.type;
            result.score = best.score;
            result.trapAvoided = best.belowTrap || false;
            
            if (best.type === 'SWING') {
                result.reason = best.belowTrap 
                    ? 'Below swing + avoids EQL trap'
                    : 'Below swing low';
            } else if (best.type === 'OB') {
                result.reason = best.belowTrap
                    ? 'Below OB + avoids EQL trap'
                    : 'Below fresh OB';
            }
        } else {
            // Fallback - check if we need to go below trap zones
            if (trapZones.length > 0) {
                const lowestTrap = Math.min(...trapZones.map(t => t.price));
                result.price = lowestTrap * 0.995; // Below all traps
                result.reason = 'Below liquidity trap zone';
                result.trapAvoided = true;
            } else {
                result.price = currentPrice - (atr * 2);
                result.reason = 'ATR-based (no structure)';
            }
        }
        
    } else { // SHORT
        // Find swing highs above current price
        swings.highs.filter(s => s.price > currentPrice).forEach(swing => {
            const dist = ((swing.price - currentPrice) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) {
                candidates.push({
                    price: swing.price * 1.002, // Buffer above
                    type: 'SWING',
                    dist: dist,
                    score: 50
                });
            }
        });
        
        // Find bearish OBs above current price
        orderBlocks.bearish.filter(ob => ob.high > currentPrice && ob.fresh).forEach(ob => {
            const dist = ((ob.high - currentPrice) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) {
                candidates.push({
                    price: ob.high * 1.003,
                    type: 'OB',
                    dist: dist,
                    score: ob.fresh ? 70 : 40
                });
            }
        });
        
        // Check for equal highs (TRAP ZONES)
        const trapZones = equalLevels.equalHighs.filter(eh => eh.price > currentPrice);
        
        // Score and filter candidates - FIXED: No distance bonus, stronger penalties
        candidates.forEach(c => {
            // FIX 1: REMOVED distance bonus - SL should be structure-based
            
            // FIX 2: ATR validation with STRONGER penalty
            const atrRatio = (c.price - currentPrice) / atr;
            if (atrRatio >= 1.5) c.score += 20;
            else if (atrRatio >= 1) c.score += 10;
            else c.score -= 30;  // FIX: Was -10, now -30
            
            // FIX 3: DISQUALIFY trapped SLs
            trapZones.forEach(trap => {
                if (c.price < trap.price && c.price > trap.price * 0.99) {
                    c.disqualified = true;  // FIX: Was score -= 30
                    c.inTrap = true;
                }
            });
            
            trapZones.forEach(trap => {
                if (c.price > trap.price * 1.005) {
                    c.score += 20;  // Increased bonus
                    c.aboveTrap = true;
                }
            });
        });
        
        // FIX 3b: Filter out disqualified candidates
        const validCandidates = candidates.filter(c => !c.disqualified);
        validCandidates.sort((a, b) => b.score - a.score);
        
        if (validCandidates.length > 0 && validCandidates[0].score >= 40) {
            const best = validCandidates[0];
            result.price = best.price;
            result.structureUsed = best.type;
            result.score = best.score;
            result.trapAvoided = best.aboveTrap || false;
            
            if (best.type === 'SWING') {
                result.reason = best.aboveTrap
                    ? 'Above swing + avoids EQH trap'
                    : 'Above swing high';
            } else if (best.type === 'OB') {
                result.reason = best.aboveTrap
                    ? 'Above OB + avoids EQH trap'
                    : 'Above fresh OB';
            }
        } else {
            if (trapZones.length > 0) {
                const highestTrap = Math.max(...trapZones.map(t => t.price));
                result.price = highestTrap * 1.005;
                result.reason = 'Above liquidity trap zone';
                result.trapAvoided = true;
            } else {
                result.price = currentPrice + (atr * 2);
                result.reason = 'ATR-based (no structure)';
            }
        }
    }
    
    // Calculate risk percentage
    result.riskPct = ((Math.abs(currentPrice - result.price) / currentPrice) * 100).toFixed(2);
    
    // Cap SL at max 3%
    if (parseFloat(result.riskPct) > 3) {
        result.price = direction === 'LONG'
            ? currentPrice * 0.97
            : currentPrice * 1.03;
        result.riskPct = '3.00';
        result.reason += ' (capped at 3%)';
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 2: SMART PULLBACK LEVELS
// Finds 2 best add levels between Entry and SL
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartPullbacks(direction, currentPrice, slPrice, klines, atr) {
    const result = {
        pullback1: null,
        pullback2: null,
        marketOnly: false,
        reason: ''
    };
    
    if (!klines || klines.length < 50) {
        result.marketOnly = true;
        result.reason = 'Insufficient data';
        return result;
    }
    
    const orderBlocks = detectOrderBlocks(klines, 50);
    const fvgs = detectFVG(klines, 30);
    const swings = findSwingPoints(klines, 4, 4);
    
    // Collect candidate pullback levels
    const candidates = [];
    const minGapFromSL = 0.005; // Min 0.5% above SL
    
    if (direction === 'LONG') {
        // Entry is above, SL is below. Find levels IN BETWEEN.
        const slBuffer = slPrice * (1 + minGapFromSL);
        
        // FIX: Include ALL bullish OBs, fresh ones get higher score
        orderBlocks.bullish.filter(ob => {
            return ob.high < currentPrice && ob.high > slBuffer;
        }).forEach(ob => {
            candidates.push({
                price: ob.high,
                type: 'OB',
                reason: ob.fresh ? 'Fresh bullish OB' : 'Bullish OB',
                dist: ((currentPrice - ob.high) / currentPrice) * 100,
                score: ob.fresh ? 80 : 55
            });
        });
        
        // FIX: Include ALL bullish FVGs, unfilled ones get higher score
        fvgs.bullish.filter(fvg => {
            return fvg.high < currentPrice && fvg.low > slBuffer;
        }).forEach(fvg => {
            candidates.push({
                price: fvg.high, // Enter at top of FVG
                type: 'FVG',
                reason: fvg.filled ? 'Bullish FVG' : 'Unfilled bullish FVG',
                dist: ((currentPrice - fvg.high) / currentPrice) * 100,
                score: fvg.filled ? 55 : 70
            });
        });
        
        // Swing lows between entry and SL
        swings.lows.filter(s => {
            return s.price < currentPrice && s.price > slBuffer;
        }).forEach(swing => {
            candidates.push({
                price: swing.price * 1.002, // Slightly above swing
                type: 'SWING',
                reason: 'Swing low support',
                dist: ((currentPrice - swing.price) / currentPrice) * 100,
                score: 55
            });
        });
        
    } else { // SHORT
        const slBuffer = slPrice * (1 - minGapFromSL);
        
        // FIX: Include ALL bearish OBs, fresh ones get higher score
        orderBlocks.bearish.filter(ob => {
            return ob.low > currentPrice && ob.low < slBuffer;
        }).forEach(ob => {
            candidates.push({
                price: ob.low,
                type: 'OB',
                reason: ob.fresh ? 'Fresh bearish OB' : 'Bearish OB',
                dist: ((ob.low - currentPrice) / currentPrice) * 100,
                score: ob.fresh ? 80 : 55
            });
        });
        
        // FIX: Include ALL bearish FVGs, unfilled ones get higher score
        fvgs.bearish.filter(fvg => {
            return fvg.low > currentPrice && fvg.high < slBuffer;
        }).forEach(fvg => {
            candidates.push({
                price: fvg.low,
                type: 'FVG',
                reason: fvg.filled ? 'Bearish FVG' : 'Unfilled bearish FVG',
                dist: ((fvg.low - currentPrice) / currentPrice) * 100,
                score: fvg.filled ? 55 : 70
            });
        });
        
        // Swing highs
        swings.highs.filter(s => {
            return s.price > currentPrice && s.price < slBuffer;
        }).forEach(swing => {
            candidates.push({
                price: swing.price * 0.998,
                type: 'SWING',
                reason: 'Swing high resistance',
                dist: ((swing.price - currentPrice) / currentPrice) * 100,
                score: 55
            });
        });
    }
    
    // Score adjustments
    candidates.forEach(c => {
        // Prefer levels 0.5% - 1.5% from entry (optimal pullback)
        if (c.dist >= 0.5 && c.dist <= 1.5) c.score += 20;
        else if (c.dist > 1.5 && c.dist <= 2.5) c.score += 10;
        else if (c.dist < 0.5) c.score -= 10; // Too close
        
        // OB + FVG confluence
        if (c.type === 'OB') {
            const hasFvgConfluence = candidates.some(other => 
                other.type === 'FVG' && 
                Math.abs(other.price - c.price) / c.price < 0.005
            );
            if (hasFvgConfluence) {
                c.score += 25;
                c.reason += ' + FVG confluence';
            }
        }
    });
    
    // Sort by score and remove duplicates (within 0.3% of each other)
    candidates.sort((a, b) => b.score - a.score);
    
    const uniqueCandidates = [];
    candidates.forEach(c => {
        const isDuplicate = uniqueCandidates.some(u => 
            Math.abs(u.price - c.price) / c.price < 0.003
        );
        if (!isDuplicate) uniqueCandidates.push(c);
    });
    
    // Select top 2 with minimum 0.5% gap between them
    if (uniqueCandidates.length >= 1) {
        result.pullback1 = {
            price: uniqueCandidates[0].price,
            type: uniqueCandidates[0].type,
            reason: uniqueCandidates[0].reason,
            distPct: uniqueCandidates[0].dist.toFixed(2),
            score: uniqueCandidates[0].score
        };
        
        // Find second pullback with min gap from first
        for (let i = 1; i < uniqueCandidates.length; i++) {
            const gap = Math.abs(uniqueCandidates[i].price - result.pullback1.price) / result.pullback1.price;
            if (gap >= 0.005) { // Min 0.5% gap
                result.pullback2 = {
                    price: uniqueCandidates[i].price,
                    type: uniqueCandidates[i].type,
                    reason: uniqueCandidates[i].reason,
                    distPct: uniqueCandidates[i].dist.toFixed(2),
                    score: uniqueCandidates[i].score
                };
                break;
            }
        }
    }
    
    if (!result.pullback1) {
        // FIX: ATR-based fallback pullbacks when no SMC structure found
        const atrValue = atr || (Math.abs(currentPrice - slPrice) * 0.3);
        
        if (direction === 'LONG') {
            // Pullback 1: 0.5 ATR below entry
            const pb1Price = currentPrice - (atrValue * 0.5);
            if (pb1Price > slPrice * 1.01) { // Must be above SL with buffer
                result.pullback1 = {
                    price: pb1Price,
                    type: 'ATR',
                    reason: 'ATR-based (0.5 ATR)',
                    distPct: ((currentPrice - pb1Price) / currentPrice * 100).toFixed(2),
                    score: 50
                };
                
                // Pullback 2: 1 ATR below entry
                const pb2Price = currentPrice - (atrValue * 1.0);
                if (pb2Price > slPrice * 1.01) {
                    result.pullback2 = {
                        price: pb2Price,
                        type: 'ATR',
                        reason: 'ATR-based (1.0 ATR)',
                        distPct: ((currentPrice - pb2Price) / currentPrice * 100).toFixed(2),
                        score: 45
                    };
                }
            }
        } else { // SHORT
            // Pullback 1: 0.5 ATR above entry
            const pb1Price = currentPrice + (atrValue * 0.5);
            if (pb1Price < slPrice * 0.99) { // Must be below SL with buffer
                result.pullback1 = {
                    price: pb1Price,
                    type: 'ATR',
                    reason: 'ATR-based (0.5 ATR)',
                    distPct: ((pb1Price - currentPrice) / currentPrice * 100).toFixed(2),
                    score: 50
                };
                
                // Pullback 2: 1 ATR above entry
                const pb2Price = currentPrice + (atrValue * 1.0);
                if (pb2Price < slPrice * 0.99) {
                    result.pullback2 = {
                        price: pb2Price,
                        type: 'ATR',
                        reason: 'ATR-based (1.0 ATR)',
                        distPct: ((pb2Price - currentPrice) / currentPrice * 100).toFixed(2),
                        score: 45
                    };
                }
            }
        }
        
        if (!result.pullback1) {
            result.marketOnly = true;
            result.reason = 'SL too tight for pullbacks';
        } else {
            result.reason = 'ATR fallback (no SMC structure)';
        }
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 3: SMART TAKE PROFITS
// Finds liquidity-based targets with probability
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartTPs(direction, currentPrice, slPrice, klines, zoneDetails) {
    const result = {
        tp1: null,
        tp2: null,
        tp3: null,
        fallbackUsed: false
    };
    
    if (!klines || klines.length < 50) {
        // Fallback to R:R based
        const risk = Math.abs(currentPrice - slPrice);
        result.tp1 = { price: direction === 'LONG' ? currentPrice + risk * 1.5 : currentPrice - risk * 1.5, reason: 'R:R fallback', probability: 60 };
        result.tp2 = { price: direction === 'LONG' ? currentPrice + risk * 2.5 : currentPrice - risk * 2.5, reason: 'R:R fallback', probability: 45 };
        result.tp3 = { price: direction === 'LONG' ? currentPrice + risk * 4 : currentPrice - risk * 4, reason: 'R:R fallback', probability: 30 };
        result.fallbackUsed = true;
        return result;
    }
    
    const equalLevels = detectEqualLevels(klines, 0.002);
    const orderBlocks = detectOrderBlocks(klines, 50);
    const risk = Math.abs(currentPrice - slPrice);
    
    // Collect target candidates
    const candidates = [];
    const minDist = 0.01; // Min 1% from entry
    const maxDist = 0.15; // Max 15% from entry
    
    if (direction === 'LONG') {
        // Equal Highs = Liquidity targets (highest probability)
        equalLevels.equalHighs.filter(eh => {
            const dist = (eh.price - currentPrice) / currentPrice;
            return dist > minDist && dist < maxDist;
        }).forEach(eh => {
            candidates.push({
                price: eh.price,
                type: 'EQH',
                reason: `Equal Highs (${eh.count} touches)`,
                dist: ((eh.price - currentPrice) / currentPrice) * 100,
                probability: 80, // High prob - liquidity always gets grabbed
                score: 90 + (eh.count * 5)
            });
        });
        
        // Bearish OBs = Reversal zones (medium probability)
        orderBlocks.bearish.filter(ob => {
            const dist = (ob.low - currentPrice) / currentPrice;
            return dist > minDist && dist < maxDist && ob.fresh;
        }).forEach(ob => {
            candidates.push({
                price: ob.low,
                type: 'BEAR_OB',
                reason: 'Bearish OB (reversal zone)',
                dist: ((ob.low - currentPrice) / currentPrice) * 100,
                probability: 65,
                score: 75
            });
        });
        
        // Resistance zones (medium probability)
        if (zoneDetails && zoneDetails.nearestResistance) {
            const res = zoneDetails.nearestResistance;
            const dist = (res.low - currentPrice) / currentPrice;
            if (dist > minDist && dist < maxDist) {
                candidates.push({
                    price: res.low,
                    type: 'RESISTANCE',
                    reason: 'Resistance zone',
                    dist: dist * 100,
                    probability: 60,
                    score: 60
                });
            }
        }
        
    } else { // SHORT
        // Equal Lows = Liquidity targets
        equalLevels.equalLows.filter(el => {
            const dist = (currentPrice - el.price) / currentPrice;
            return dist > minDist && dist < maxDist;
        }).forEach(el => {
            candidates.push({
                price: el.price,
                type: 'EQL',
                reason: `Equal Lows (${el.count} touches)`,
                dist: ((currentPrice - el.price) / currentPrice) * 100,
                probability: 80,
                score: 90 + (el.count * 5)
            });
        });
        
        // Bullish OBs = Reversal zones
        orderBlocks.bullish.filter(ob => {
            const dist = (currentPrice - ob.high) / currentPrice;
            return dist > minDist && dist < maxDist && ob.fresh;
        }).forEach(ob => {
            candidates.push({
                price: ob.high,
                type: 'BULL_OB',
                reason: 'Bullish OB (reversal zone)',
                dist: ((currentPrice - ob.high) / currentPrice) * 100,
                probability: 65,
                score: 75
            });
        });
        
        // Support zones
        if (zoneDetails && zoneDetails.nearestSupport) {
            const sup = zoneDetails.nearestSupport;
            const dist = (currentPrice - sup.high) / currentPrice;
            if (dist > minDist && dist < maxDist) {
                candidates.push({
                    price: sup.high,
                    type: 'SUPPORT',
                    reason: 'Support zone',
                    dist: dist * 100,
                    probability: 60,
                    score: 60
                });
            }
        }
    }
    
    // Sort by distance (closer first for TP1, further for TP3)
    candidates.sort((a, b) => a.dist - b.dist);
    
    // Select TPs with minimum 1.5% gap between them
    const selectedTPs = [];
    const minGap = 1.5;
    
    for (const c of candidates) {
        if (selectedTPs.length === 0) {
            // First TP - must be at least 1.5R
            const rrRatio = c.dist / (parseFloat(result.tp1?.dist) || (Math.abs(currentPrice - slPrice) / currentPrice * 100));
            selectedTPs.push(c);
        } else {
            // Check gap from last selected TP
            const lastTP = selectedTPs[selectedTPs.length - 1];
            const gap = Math.abs(c.dist - lastTP.dist);
            if (gap >= minGap && selectedTPs.length < 3) {
                // Reduce probability for further TPs
                c.probability = Math.max(30, c.probability - (selectedTPs.length * 15));
                selectedTPs.push(c);
            }
        }
        if (selectedTPs.length >= 3) break;
    }
    
    // Assign to result
    if (selectedTPs.length >= 1) {
        result.tp1 = {
            price: selectedTPs[0].price,
            type: selectedTPs[0].type,
            reason: selectedTPs[0].reason,
            distPct: selectedTPs[0].dist.toFixed(2),
            probability: selectedTPs[0].probability,
            rrRatio: (selectedTPs[0].dist / (Math.abs(currentPrice - slPrice) / currentPrice * 100)).toFixed(1)
        };
    }
    
    if (selectedTPs.length >= 2) {
        result.tp2 = {
            price: selectedTPs[1].price,
            type: selectedTPs[1].type,
            reason: selectedTPs[1].reason,
            distPct: selectedTPs[1].dist.toFixed(2),
            probability: selectedTPs[1].probability,
            rrRatio: (selectedTPs[1].dist / (Math.abs(currentPrice - slPrice) / currentPrice * 100)).toFixed(1)
        };
    }
    
    if (selectedTPs.length >= 3) {
        result.tp3 = {
            price: selectedTPs[2].price,
            type: selectedTPs[2].type,
            reason: selectedTPs[2].reason,
            distPct: selectedTPs[2].dist.toFixed(2),
            probability: selectedTPs[2].probability,
            rrRatio: (selectedTPs[2].dist / (Math.abs(currentPrice - slPrice) / currentPrice * 100)).toFixed(1)
        };
    }
    
    // Fallback for missing TPs
    if (!result.tp1) {
        result.tp1 = { price: direction === 'LONG' ? currentPrice + risk * 1.5 : currentPrice - risk * 1.5, reason: '1.5R (fallback)', probability: 65, distPct: ((risk * 1.5) / currentPrice * 100).toFixed(2) };
        result.fallbackUsed = true;
    }
    if (!result.tp2) {
        result.tp2 = { price: direction === 'LONG' ? currentPrice + risk * 2.5 : currentPrice - risk * 2.5, reason: '2.5R (fallback)', probability: 50, distPct: ((risk * 2.5) / currentPrice * 100).toFixed(2) };
    }
    if (!result.tp3) {
        result.tp3 = { price: direction === 'LONG' ? currentPrice + risk * 4 : currentPrice - risk * 4, reason: '4R (fallback)', probability: 35, distPct: ((risk * 4) / currentPrice * 100).toFixed(2) };
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 4: ENTRY GRADE CALCULATOR
// Grades entries from A+ to D based on SL distance, ATR, structure
// ─────────────────────────────────────────────────────────────────────────────────
function calculateEntryGrade(entryPrice, slPrice, atr, structureScore = 70) {
    const result = {
        grade: 'C',
        score: 50,
        slDistScore: 0,
        atrScore: 0,
        structureScore: 0,
        leverage: { safe: 5, max: 10 },
        size: '50%',
        confidence: 'MEDIUM'
    };
    
    const slDist = Math.abs(entryPrice - slPrice) / entryPrice * 100;
    const atrRatio = Math.abs(entryPrice - slPrice) / atr;
    
    // SL Distance Score (40% weight)
    if (slDist < 0.5) result.slDistScore = 100;
    else if (slDist < 0.75) result.slDistScore = 90;
    else if (slDist < 1.0) result.slDistScore = 80;
    else if (slDist < 1.25) result.slDistScore = 70;
    else if (slDist < 1.5) result.slDistScore = 60;
    else if (slDist < 2.0) result.slDistScore = 50;
    else if (slDist < 2.5) result.slDistScore = 40;
    else result.slDistScore = 25;
    
    // ATR Safety Score (30% weight) - SL should be 1-2x ATR
    if (atrRatio >= 2.0) result.atrScore = 100;
    else if (atrRatio >= 1.5) result.atrScore = 90;
    else if (atrRatio >= 1.2) result.atrScore = 75;
    else if (atrRatio >= 1.0) result.atrScore = 60;
    else if (atrRatio >= 0.7) result.atrScore = 40;
    else result.atrScore = 20; // Too tight, will get stopped
    
    // Structure Score (30% weight) - passed in
    result.structureScore = Math.min(100, Math.max(0, structureScore));
    
    // Calculate final score
    result.score = Math.round(
        (result.slDistScore * 0.4) +
        (result.atrScore * 0.3) +
        (result.structureScore * 0.3)
    );
    
    // Assign grade
    if (result.score >= 85) {
        result.grade = 'A+';
        result.leverage = { safe: 12, max: 20 };
        result.size = '100%';
        result.confidence = 'VERY HIGH';
    } else if (result.score >= 75) {
        result.grade = 'A';
        result.leverage = { safe: 10, max: 15 };
        result.size = '100%';
        result.confidence = 'HIGH';
    } else if (result.score >= 65) {
        result.grade = 'B+';
        result.leverage = { safe: 8, max: 12 };
        result.size = '75%';
        result.confidence = 'GOOD';
    } else if (result.score >= 55) {
        result.grade = 'B';
        result.leverage = { safe: 6, max: 10 };
        result.size = '75%';
        result.confidence = 'GOOD';
    } else if (result.score >= 45) {
        result.grade = 'C';
        result.leverage = { safe: 5, max: 7 };
        result.size = '50%';
        result.confidence = 'MEDIUM';
    } else {
        result.grade = 'D';
        result.leverage = { safe: 3, max: 5 };
        result.size = '25%';
        result.confidence = 'LOW';
    }
    
    result.slDistPct = slDist.toFixed(2);
    result.atrRatio = atrRatio.toFixed(2);
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 5: SMART ENTRY DECISION
// Decides MARKET / LIMIT / WAIT / SKIP
// ─────────────────────────────────────────────────────────────────────────────────
function determineSmartEntry(direction, grade, momentumData, candleData, pullbacks) {
    const result = {
        decision: 'MARKET',
        reason: '',
        sizing: {
            market: 25,
            pullback1: 50,
            pullback2: 25
        }
    };
    
    // Check if price is running (strong momentum)
    const isRunning = momentumData && (
        (direction === 'LONG' && momentumData.details.rsi && momentumData.details.rsi.value > 65) ||
        (direction === 'SHORT' && momentumData.details.rsi && momentumData.details.rsi.value < 35)
    );
    
    // Check if extended (overbought/oversold)
    const isExtended = momentumData && (
        (direction === 'LONG' && momentumData.details.rsi && momentumData.details.rsi.value > 75) ||
        (direction === 'SHORT' && momentumData.details.rsi && momentumData.details.rsi.value < 25)
    );
    
    // Check candle pattern
    const hasBullishPattern = candleData && candleData.patternSignal === 'BULLISH';
    const hasBearishPattern = candleData && candleData.patternSignal === 'BEARISH';
    const controlBuyers = candleData && candleData.behavior && candleData.behavior.control === 'BUYERS';
    const controlSellers = candleData && candleData.behavior && candleData.behavior.control === 'SELLERS';
    
    // Decision logic
    if (isExtended) {
        result.decision = 'WAIT';
        result.reason = 'Price extended - wait for pullback';
        result.sizing = { market: 0, pullback1: 60, pullback2: 40 };
    } else if (isRunning && grade.score >= 65) {
        result.decision = 'MARKET';
        result.reason = 'Strong momentum - enter now';
        result.sizing = { market: 50, pullback1: 35, pullback2: 15 };
    } else if (!isRunning && pullbacks.pullback1) {
        result.decision = 'LIMIT';
        result.reason = 'Moderate momentum - wait for pullback';
        result.sizing = { market: 25, pullback1: 50, pullback2: 25 };
    } else if (grade.grade === 'D') {
        result.decision = 'WAIT';
        result.reason = 'Low grade entry - wait for better setup';
        result.sizing = { market: 0, pullback1: 75, pullback2: 25 };
    } else {
        result.decision = 'MARKET';
        result.reason = 'Standard entry';
        result.sizing = { market: 25, pullback1: 50, pullback2: 25 };
    }
    
    // Adjust sizing based on grade
    if (grade.grade === 'A+' || grade.grade === 'A') {
        if (result.decision === 'MARKET') {
            result.sizing.market = Math.min(100, result.sizing.market + 25);
        }
    } else if (grade.grade === 'D') {
        result.sizing.market = Math.max(0, result.sizing.market - 15);
        result.sizing.pullback1 = Math.min(75, result.sizing.pullback1 + 10);
    }
    
    // Check for conflicting patterns
    if (direction === 'LONG' && hasBearishPattern) {
        result.decision = 'WAIT';
        result.reason = 'Bearish candle pattern - wait for confirmation';
    } else if (direction === 'SHORT' && hasBullishPattern) {
        result.decision = 'WAIT';
        result.reason = 'Bullish candle pattern - wait for confirmation';
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 6: SMART EXIT MONITOR
// Real-time monitoring for exit signals
// ─────────────────────────────────────────────────────────────────────────────────
function monitorTradeExit(direction, entryPrice, currentPrice, tpData, klines) {
    const result = {
        recommendation: 'HOLD',
        reason: '',
        tp1Prob: tpData.tp1 ? tpData.tp1.probability : 65,
        tp2Prob: tpData.tp2 ? tpData.tp2.probability : 50,
        tp3Prob: tpData.tp3 ? tpData.tp3.probability : 35,
        warnings: [],
        urgency: 'LOW'
    };
    
    if (!klines || klines.length < 10) return result;
    
    const recentKlines = klines.slice(-10);
    const candlePatterns = analyzeCandlePatterns(klines);
    const closes = klines.map(k => k.close);
    const rsi = calcRSI(closes, 14);
    const macd = calcMACD(closes);
    
    // Check for reversal candle patterns
    if (candlePatterns.patterns && candlePatterns.patterns.length > 0) {
        const recentPatterns = candlePatterns.patterns.filter(p => p.index >= klines.length - 3);
        
        for (const pattern of recentPatterns) {
            if (direction === 'LONG') {
                if (['Shooting Star', 'Bearish Engulfing', 'Evening Star', 'Hanging Man'].includes(pattern.name)) {
                    result.warnings.push(`${pattern.name} detected`);
                    result.tp2Prob = Math.max(15, result.tp2Prob - 20);
                    result.tp3Prob = Math.max(10, result.tp3Prob - 25);
                }
            } else {
                if (['Hammer', 'Bullish Engulfing', 'Morning Star', 'Inverted Hammer'].includes(pattern.name)) {
                    result.warnings.push(`${pattern.name} detected`);
                    result.tp2Prob = Math.max(15, result.tp2Prob - 20);
                    result.tp3Prob = Math.max(10, result.tp3Prob - 25);
                }
            }
        }
    }
    
    // Check for momentum divergence
    if (direction === 'LONG') {
        // Price making higher high but RSI lower high = bearish divergence
        const priceHigh = Math.max(...recentKlines.map(k => k.high));
        const prevPriceHigh = Math.max(...klines.slice(-20, -10).map(k => k.high));
        
        if (priceHigh > prevPriceHigh && rsi < 60) {
            result.warnings.push('RSI divergence forming');
            result.tp2Prob = Math.max(20, result.tp2Prob - 15);
            result.tp3Prob = Math.max(15, result.tp3Prob - 20);
        }
    } else {
        const priceLow = Math.min(...recentKlines.map(k => k.low));
        const prevPriceLow = Math.min(...klines.slice(-20, -10).map(k => k.low));
        
        if (priceLow < prevPriceLow && rsi > 40) {
            result.warnings.push('RSI divergence forming');
            result.tp2Prob = Math.max(20, result.tp2Prob - 15);
            result.tp3Prob = Math.max(15, result.tp3Prob - 20);
        }
    }
    
    // Check for volume dying
    const recentVol = recentKlines.slice(-3).reduce((s, k) => s + k.volume, 0) / 3;
    const avgVol = klines.slice(-20).reduce((s, k) => s + k.volume, 0) / 20;
    
    if (recentVol < avgVol * 0.6) {
        result.warnings.push('Volume declining');
        result.tp2Prob = Math.max(20, result.tp2Prob - 10);
        result.tp3Prob = Math.max(15, result.tp3Prob - 15);
    }
    
    // Check for failed breakout
    if (direction === 'LONG' && tpData.tp1) {
        const nearTP1 = Math.abs(currentPrice - tpData.tp1.price) / tpData.tp1.price < 0.005;
        if (nearTP1) {
            // Check if rejected
            const rejectionCandle = recentKlines[recentKlines.length - 1];
            const upperWick = rejectionCandle.high - Math.max(rejectionCandle.open, rejectionCandle.close);
            const body = Math.abs(rejectionCandle.close - rejectionCandle.open);
            
            if (upperWick > body * 2) {
                result.warnings.push('Rejection at TP1 level');
                result.tp2Prob = Math.max(15, result.tp2Prob - 25);
                result.tp3Prob = Math.max(10, result.tp3Prob - 30);
            }
        }
    }
    
    // Determine recommendation
    if (result.warnings.length >= 3) {
        result.recommendation = 'EXIT';
        result.reason = 'Multiple warning signals - exit recommended';
        result.urgency = 'HIGH';
    } else if (result.warnings.length >= 2) {
        result.recommendation = 'REDUCE';
        result.reason = 'Warning signals detected - consider reducing position';
        result.urgency = 'MEDIUM';
    } else if (result.warnings.length === 1) {
        result.recommendation = 'CAUTION';
        result.reason = 'Minor warning - monitor closely';
        result.urgency = 'LOW';
    } else {
        result.recommendation = 'HOLD';
        result.reason = 'No warning signals - trade on track';
    }
    
    // MACD cross check
    if (macd && macd.histogram) {
        const histLen = macd.histogram.length;
        if (histLen >= 2) {
            const currentHist = macd.histogram[histLen - 1];
            const prevHist = macd.histogram[histLen - 2];
            
            if (direction === 'LONG' && currentHist < prevHist && currentHist < 0) {
                result.warnings.push('MACD momentum weakening');
                result.tp2Prob = Math.max(20, result.tp2Prob - 10);
            } else if (direction === 'SHORT' && currentHist > prevHist && currentHist > 0) {
                result.warnings.push('MACD momentum weakening');
                result.tp2Prob = Math.max(20, result.tp2Prob - 10);
            }
        }
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// MASTER FUNCTION: CALCULATE SMART TRADE LEVELS
// Combines all 6 engines into one comprehensive output
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartTradeLevels(currentPrice, direction, atr, klines, zoneDetails, smcDetails, momentumData, candleData) {
    // Engine 1: Smart SL
    const smartSL = calculateSmartSL(direction, currentPrice, klines, atr);
    
    // Engine 2: Smart Pullbacks (needs SL)
    const smartPullbacks = calculateSmartPullbacks(direction, currentPrice, smartSL.price, klines, atr);
    
    // Engine 3: Smart TPs (needs SL)
    const smartTPs = calculateSmartTPs(direction, currentPrice, smartSL.price, klines, zoneDetails);
    
    // Calculate structure score for grade
    let structureScore = 50;
    if (smartSL.structureUsed === 'OB') structureScore += 20;
    if (smartSL.structureUsed === 'SWING') structureScore += 15;
    if (smartSL.trapAvoided) structureScore += 15;
    if (smartPullbacks.pullback1 && smartPullbacks.pullback1.type === 'OB') structureScore += 10;
    if (smartTPs.tp1 && smartTPs.tp1.type === 'EQH') structureScore += 10;
    
    // Engine 4: Entry Grade for Market entry
    const marketGrade = calculateEntryGrade(currentPrice, smartSL.price, atr, structureScore);
    
    // Entry grades for pullback levels
    let pb1Grade = null, pb2Grade = null;
    if (smartPullbacks.pullback1) {
        pb1Grade = calculateEntryGrade(smartPullbacks.pullback1.price, smartSL.price, atr, structureScore + 10);
    }
    if (smartPullbacks.pullback2) {
        pb2Grade = calculateEntryGrade(smartPullbacks.pullback2.price, smartSL.price, atr, structureScore + 15);
    }
    
    // Engine 5: Smart Entry Decision
    const entryDecision = determineSmartEntry(direction, marketGrade, momentumData, candleData, smartPullbacks);
    
    // Engine 6: Exit Monitor (initial state)
    const exitMonitor = monitorTradeExit(direction, currentPrice, currentPrice, smartTPs, klines);
    
    // Calculate average entry if all levels fill
    let avgEntry = currentPrice;
    if (smartPullbacks.pullback1 && smartPullbacks.pullback2) {
        avgEntry = (currentPrice * 0.25 + smartPullbacks.pullback1.price * 0.5 + smartPullbacks.pullback2.price * 0.25);
    } else if (smartPullbacks.pullback1) {
        avgEntry = (currentPrice * 0.4 + smartPullbacks.pullback1.price * 0.6);
    }
    
    // Calculate R:R from average entry
    const avgRisk = Math.abs(avgEntry - smartSL.price);
    const avgRewardTP2 = smartTPs.tp2 ? Math.abs(smartTPs.tp2.price - avgEntry) : avgRisk * 2.5;
    const avgRR = avgRisk > 0 ? (avgRewardTP2 / avgRisk).toFixed(2) : '0';
    
    return {
        // Entry Plan
        entry: {
            market: {
                price: currentPrice,
                grade: marketGrade,
                size: entryDecision.sizing.market + '%'
            },
            pullback1: smartPullbacks.pullback1 ? {
                price: smartPullbacks.pullback1.price,
                reason: smartPullbacks.pullback1.reason,
                distPct: smartPullbacks.pullback1.distPct,
                grade: pb1Grade,
                size: entryDecision.sizing.pullback1 + '%'
            } : null,
            pullback2: smartPullbacks.pullback2 ? {
                price: smartPullbacks.pullback2.price,
                reason: smartPullbacks.pullback2.reason,
                distPct: smartPullbacks.pullback2.distPct,
                grade: pb2Grade,
                size: entryDecision.sizing.pullback2 + '%'
            } : null,
            decision: entryDecision.decision,
            decisionReason: entryDecision.reason,
            avgEntry: avgEntry,
            marketOnly: smartPullbacks.marketOnly
        },
        
        // Stop Loss
        sl: {
            price: smartSL.price,
            reason: smartSL.reason,
            riskPct: smartSL.riskPct,
            trapAvoided: smartSL.trapAvoided,
            structureUsed: smartSL.structureUsed
        },
        
        // Take Profits
        tp1: smartTPs.tp1,
        tp2: smartTPs.tp2,
        tp3: smartTPs.tp3,
        
        // Risk/Reward
        rr: avgRR,
        avgEntry: avgEntry,
        
        // Exit Monitor
        exitMonitor: exitMonitor,
        
        // Legacy compatibility
        limitEntry: smartPullbacks.pullback1 ? smartPullbacks.pullback1.price : currentPrice * (direction === 'LONG' ? 0.995 : 1.005),
        limitType: smartPullbacks.pullback1 ? smartPullbacks.pullback1.type : 'ATR',
        limitConfidence: smartPullbacks.pullback1 ? smartPullbacks.pullback1.score : 50,
        limitRR: (smartPullbacks.pullback1 && smartTPs.tp2) ? 
            ((Math.abs(smartTPs.tp2.price - smartPullbacks.pullback1.price)) / (Math.abs(smartPullbacks.pullback1.price - smartSL.price))).toFixed(2) : avgRR,
        risk: Math.abs(currentPrice - smartSL.price),
        reward: smartTPs.tp2 ? Math.abs(smartTPs.tp2.price - currentPrice) : Math.abs(currentPrice - smartSL.price) * 2.5,
        riskPct: smartSL.riskPct
    };
}


// ═══════════════════════════════════════════════════════════════════════════════
// END OF SMART TRADE SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// MASTER INTEGRATION ENGINE - WEIGHTED AVERAGE SCORING
// ═══════════════════════════════════════════════════════════════════════════════

// HTF Bias Analysis
async function analyzeHTFBias(symbol, entryTF, direction) {
    const htfList = CONFIG.HTF_MAP[entryTF] || ['60', '240', 'D'];
    const result = {
        aligned: 0,
        total: htfList.length,
        bias: {},
        score: 0
    };
    
    for (const tf of htfList) {
        try {
            const klines = await fetchKlines(symbol, tf, 100);
            if (!klines || klines.length < 50) {
                result.bias[CONFIG.TF_LABELS[tf] || tf] = 'N/A';
                continue;
            }
            
            const closes = klines.map(k => k.close);
            const currentPrice = closes[closes.length - 1];
            
            // EMA 20 for trend
            const ema20 = calcEMA(closes, 20);
            // EMA 50 for stronger trend
            const ema50 = calcEMA(closes, 50);
            
            // Structure analysis
            const structure = detectStructure(klines);
            
            let bias = 'NEUTRAL';
            let biasStrength = 0;
            
            // Price above both EMAs = bullish
            if (currentPrice > ema20 && currentPrice > ema50 && structure.trend === 'BULLISH') {
                bias = 'BULLISH';
                biasStrength = 2;
            } else if (currentPrice > ema20 && currentPrice > ema50) {
                bias = 'BULLISH';
                biasStrength = 1;
            } else if (currentPrice < ema20 && currentPrice < ema50 && structure.trend === 'BEARISH') {
                bias = 'BEARISH';
                biasStrength = 2;
            } else if (currentPrice < ema20 && currentPrice < ema50) {
                bias = 'BEARISH';
                biasStrength = 1;
            }
            
            result.bias[CONFIG.TF_LABELS[tf] || tf] = bias;
            
            // Check alignment with entry direction
            if ((direction === 'LONG' && bias === 'BULLISH') ||
                (direction === 'SHORT' && bias === 'BEARISH')) {
                result.aligned++;
            }
            
            await sleep(50);
        } catch (e) {
            console.error(`HTF analysis error for ${tf}:`, e);
            result.bias[CONFIG.TF_LABELS[tf] || tf] = 'ERR';
        }
    }
    
    // Score based on alignment
    if (result.aligned === result.total) {
        result.score = 30; // Full alignment bonus
    } else if (result.aligned >= result.total - 1) {
        result.score = 20;
    } else if (result.aligned >= 1) {
        result.score = 10;
    }
    
    return result;
}

// Detect Conflicts between analyses
function detectConflicts(zone, smc, momentum) {
    const conflicts = [];
    let penalty = 0;
    
    // Zone vs SMC direction conflict
    if (zone.direction && smc.direction && zone.direction !== smc.direction) {
        conflicts.push('Zone vs SMC conflict');
        penalty += CONFIG.PENALTIES.ZONE_SMC_CONFLICT;
    }
    
    // SMC bullish but RSI overbought (exhaustion risk)
    if (smc.direction === 'LONG' && momentum.details.rsi && momentum.details.rsi.value >= 75) {
        conflicts.push('RSI exhaustion risk');
        penalty += CONFIG.PENALTIES.EXHAUSTION;
    }
    
    // SMC bearish but RSI oversold (exhaustion risk)
    if (smc.direction === 'SHORT' && momentum.details.rsi && momentum.details.rsi.value <= 25) {
        conflicts.push('RSI exhaustion risk');
        penalty += CONFIG.PENALTIES.EXHAUSTION;
    }
    
    // Divergence against trade direction
    const div = momentum.details.divergence;
    if (div) {
        if (smc.direction === 'LONG' && (div.rsi.direction === 'BEARISH' || div.macd.direction === 'BEARISH')) {
            conflicts.push('Divergence against long');
            penalty += CONFIG.PENALTIES.DIVERGENCE_AGAINST;
        }
        if (smc.direction === 'SHORT' && (div.rsi.direction === 'BULLISH' || div.macd.direction === 'BULLISH')) {
            conflicts.push('Divergence against short');
            penalty += CONFIG.PENALTIES.DIVERGENCE_AGAINST;
        }
    }
    
    return { conflicts, penalty };
}

// Calculate Trade Levels
function calculateTradeLevels(currentPrice, direction, atr, zoneDetails, smcDetails, adx) {
    let entry = currentPrice;
    let sl, tp1, tp2, tp3;
    
    const atrMultiplier = 2.0;
    
    // Calculate Smart Limit Entry
    const limitData = calculateSmartLimitEntry(currentPrice, direction, atr, zoneDetails, smcDetails, adx);
    
    if (direction === 'LONG') {
        // Stop loss below support or ATR-based
        if (zoneDetails.nearestSupport) {
            sl = Math.min(
                zoneDetails.nearestSupport.low * 0.998,
                currentPrice - atr * atrMultiplier
            );
        } else {
            sl = currentPrice - atr * atrMultiplier;
        }
        
        // Take profit levels
        const risk = entry - sl;
        tp1 = entry + risk * 1.5;  // 1:1.5 RR
        tp2 = entry + risk * 2.5;  // 1:2.5 RR
        tp3 = entry + risk * 4.0;  // 1:4 RR
        
        // Adjust TP if near resistance - ONLY if resistance is ABOVE calculated TP
        if (zoneDetails.nearestResistance && zoneDetails.nearestResistance.low > entry) {
            tp1 = Math.min(tp1, zoneDetails.nearestResistance.low * 0.998);
            // Ensure TP1 is still above entry
            if (tp1 <= entry) {
                tp1 = entry + risk * 1.5;
            }
        }
        
    } else { // SHORT
        // Stop loss above resistance or ATR-based
        if (zoneDetails.nearestResistance) {
            sl = Math.max(
                zoneDetails.nearestResistance.high * 1.002,
                currentPrice + atr * atrMultiplier
            );
        } else {
            sl = currentPrice + atr * atrMultiplier;
        }
        
        // Take profit levels
        const risk = sl - entry;
        tp1 = entry - risk * 1.5;
        tp2 = entry - risk * 2.5;
        tp3 = entry - risk * 4.0;
        
        // Adjust TP if near support - ONLY if support is BELOW calculated TP
        if (zoneDetails.nearestSupport && zoneDetails.nearestSupport.high < entry) {
            tp1 = Math.max(tp1, zoneDetails.nearestSupport.high * 1.002);
            // Ensure TP1 is still below entry
            if (tp1 >= entry) {
                tp1 = entry - risk * 1.5;
            }
        }
    }
    
    const risk = Math.abs(entry - sl);
    const reward = Math.abs(tp2 - entry);
    const rr = risk > 0 ? (reward / risk).toFixed(2) : '0';
    
    // Calculate R:R for limit entry
    const limitRisk = Math.abs(limitData.limitEntry - sl);
    const limitReward = Math.abs(tp2 - limitData.limitEntry);
    const limitRR = limitRisk > 0 ? (limitReward / limitRisk).toFixed(2) : '0';
    
    return {
        entry,
        limitEntry: limitData.limitEntry,
        limitType: limitData.entryType,
        limitConfidence: limitData.confidence,
        sl,
        tp1,
        tp2,
        tp3,
        rr,
        limitRR,
        risk,
        reward,
        riskPct: ((risk / entry) * 100).toFixed(2)
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// COIN RELATIVE STRENGTH (RS) - Compare coin performance vs BTC
// ═══════════════════════════════════════════════════════════════════════════════

async function calculateCoinRS(symbol, klines) {
    try {
        // Skip for BTC itself
        if (symbol === 'BTCUSDT') return 1.0;
        
        // Use cached BTC klines or fetch
        if (!STATE.btcKlines || STATE.btcKlines.length < 20) {
            STATE.btcKlines = await fetchKlines('BTCUSDT', '1h', 50);
        }
        
        if (!STATE.btcKlines || STATE.btcKlines.length < 20 || !klines || klines.length < 20) {
            return 1.0; // Default neutral RS
        }
        
        // Calculate 24h performance for both
        const coinStart = klines[klines.length - 25]?.close || klines[0].close;
        const coinEnd = klines[klines.length - 1].close;
        const coinChange = ((coinEnd - coinStart) / coinStart) * 100;
        
        const btcStart = STATE.btcKlines[STATE.btcKlines.length - 25]?.close || STATE.btcKlines[0].close;
        const btcEnd = STATE.btcKlines[STATE.btcKlines.length - 1].close;
        const btcChange = ((btcEnd - btcStart) / btcStart) * 100;
        
        // RS = coin performance / BTC performance
        // RS > 1 = outperforming BTC
        // RS < 1 = underperforming BTC
        
        // Handle zero/negative cases
        if (btcChange === 0) {
            return coinChange > 0 ? 1.5 : coinChange < 0 ? 0.5 : 1.0;
        }
        
        // Calculate relative strength ratio
        let rs;
        if (btcChange > 0 && coinChange > 0) {
            // Both up: coin/btc ratio
            rs = coinChange / btcChange;
        } else if (btcChange < 0 && coinChange < 0) {
            // Both down: inverse ratio (less down = stronger)
            rs = btcChange / coinChange;
        } else if (btcChange < 0 && coinChange > 0) {
            // BTC down, coin up = very strong
            rs = 1.5 + (coinChange / 10); // Bonus for going against BTC
        } else {
            // BTC up, coin down = very weak
            rs = 0.5 - (Math.abs(coinChange) / 20);
        }
        
        // Clamp to reasonable range (0.3 - 2.0)
        return Math.max(0.3, Math.min(2.0, rs));
        
    } catch (e) {
        // Silent: RS calc
        return 1.0; // Default neutral
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// SMART MATRIX - DYNAMIC ADAPTIVE WEIGHTING SYSTEM V1.0
// ═══════════════════════════════════════════════════════════════════════════════

// SECTION 1: ZONE CONFIDENCE (Touch-based)
function getZoneConfidence(zone) {
    if (!zone || typeof zone.touches !== 'number') {
        return { level: 'NONE', multiplier: 0.5, score: 0 }; // Low but not zero
    }
    
    const touches = zone.touches;
    
    // < 3 touches = WEAK (reduced weight but not zero)
    if (touches < 3) return { level: 'WEAK', multiplier: 0.5, score: 20 };
    
    // 3 touches = BASELINE (minimum to qualify, no penalty)
    if (touches === 3) return { level: 'BASELINE', multiplier: 1.00, score: 60 };
    
    // 4+ touches = BONUS (more = stronger)
    if (touches === 4) return { level: 'GOOD', multiplier: 1.10, score: 70 };
    if (touches === 5) return { level: 'STRONG', multiplier: 1.20, score: 80 };
    if (touches === 6) return { level: 'HIGH', multiplier: 1.30, score: 85 };
    if (touches === 7) return { level: 'VERY_HIGH', multiplier: 1.40, score: 90 };
    
    // 8+ touches = MAX (capped)
    return { level: 'MAXIMUM', multiplier: 1.50, score: 95 };
}

// SECTION 2: SMC CONFIDENCE
function getSMCConfidence(smc) {
    if (!smc) return { level: 'NONE', multiplier: 0.5, score: 0 };
    
    let confidenceScore = 0;
    const factors = [];
    
    // BOS with body close = +25, wick only = +15
    if (smc.details?.bos?.detected && smc.details?.bos?.bodyClose) {
        confidenceScore += 25;
        factors.push('BOS_BODY');
    } else if (smc.details?.bos?.detected) {
        confidenceScore += 15;
        factors.push('BOS_WICK');
    }
    
    // CHoCH = +20
    if (smc.details?.choch?.detected) {
        confidenceScore += 20;
        factors.push('CHOCH');
    }
    
    // Unmitigated Order Block = +20, mitigated = +10
    const obs = smc.details?.orderBlocks;
    if (obs) {
        const hasUnmitigated = [...(obs.bullish || []), ...(obs.bearish || [])].some(ob => !ob.mitigated);
        if (hasUnmitigated) {
            confidenceScore += 20;
            factors.push('OB_FRESH');
        } else if (obs.bullish?.length || obs.bearish?.length) {
            confidenceScore += 10;
            factors.push('OB_MITIGATED');
        }
    }
    
    // Unfilled FVG (<50%) = +15, filled = +5
    const fvgs = smc.details?.fvg;
    if (fvgs) {
        const hasUnfilled = [...(fvgs.bullish || []), ...(fvgs.bearish || [])].some(f => (f.fillPercent || 0) < 50);
        if (hasUnfilled) {
            confidenceScore += 15;
            factors.push('FVG_OPEN');
        } else if (fvgs.bullish?.length || fvgs.bearish?.length) {
            confidenceScore += 5;
            factors.push('FVG_FILLED');
        }
    }
    
    // Liquidity sweep = +15
    if (smc.details?.liquiditySweep?.detected) {
        confidenceScore += 15;
        factors.push('SWEEP');
    }
    
    // Equal Highs/Lows = +10
    if (smc.details?.equalHL?.hasEQL || smc.details?.equalHL?.hasEQH) {
        confidenceScore += 10;
        factors.push('EQ_HL');
    }
    
    // Determine level and multiplier
    let level, multiplier;
    if (confidenceScore >= 70) { level = 'HIGH'; multiplier = 1.30; }
    else if (confidenceScore >= 50) { level = 'MEDIUM_HIGH'; multiplier = 1.15; }
    else if (confidenceScore >= 35) { level = 'MEDIUM'; multiplier = 1.00; }
    else if (confidenceScore >= 20) { level = 'LOW'; multiplier = 0.85; }
    else { level = 'VERY_LOW'; multiplier = 0.70; }
    
    return { level, multiplier, score: confidenceScore, factors };
}

// SECTION 3: MOMENTUM CONFIDENCE
function getMomentumConfidence(momentum) {
    if (!momentum) return { level: 'NONE', multiplier: 0.5, score: 0 };
    
    let confidenceScore = 0;
    const factors = [];
    
    // RSI extreme = +25
    const rsi = momentum.details?.rsi?.value || 50;
    if (rsi <= 30 || rsi >= 70) {
        confidenceScore += 25;
        factors.push('RSI_EXTREME');
    } else if (rsi <= 40 || rsi >= 60) {
        confidenceScore += 10;
        factors.push('RSI_MODERATE');
    }
    
    // MACD crossover = +20, aligned = +10
    const macd = momentum.details?.macd;
    if (macd?.crossover) {
        confidenceScore += 20;
        factors.push('MACD_CROSS');
    } else if (macd?.histogram > 0 || macd?.histogram < 0) {
        confidenceScore += 10;
        factors.push('MACD_ALIGNED');
    }
    
    // ADX trending (>25) = +15, moderate (>20) = +8
    const adx = momentum.details?.adx?.adx || 20;
    if (adx >= 25) {
        confidenceScore += 15;
        factors.push('ADX_TRENDING');
    } else if (adx >= 20) {
        confidenceScore += 8;
        factors.push('ADX_MODERATE');
    }
    
    // Volume spike = +15, above avg = +8
    const volRatio = momentum.details?.volume?.ratio || 1;
    if (volRatio >= 1.5) {
        confidenceScore += 15;
        factors.push('VOL_SPIKE');
    } else if (volRatio >= 1.2) {
        confidenceScore += 8;
        factors.push('VOL_ABOVE_AVG');
    }
    
    // Divergence = +20 compound, +12 regular
    if (momentum.details?.divergence?.type === 'COMPOUND') {
        confidenceScore += 20;
        factors.push('DIV_COMPOUND');
    } else if (momentum.details?.divergence?.detected) {
        confidenceScore += 12;
        factors.push('DIV_REGULAR');
    }
    
    // Determine level and multiplier
    let level, multiplier;
    if (confidenceScore >= 60) { level = 'HIGH'; multiplier = 1.30; }
    else if (confidenceScore >= 45) { level = 'MEDIUM_HIGH'; multiplier = 1.15; }
    else if (confidenceScore >= 30) { level = 'MEDIUM'; multiplier = 1.00; }
    else if (confidenceScore >= 15) { level = 'LOW'; multiplier = 0.85; }
    else { level = 'VERY_LOW'; multiplier = 0.70; }
    
    return { level, multiplier, score: confidenceScore, factors };
}

// SECTION 4: MARKET REGIME DETECTION
function detectMarketRegime(klines, adxValue) {
    if (!klines || klines.length < 20) {
        return { regime: 'UNKNOWN', confidence: 0, advice: { bias: 'NEUTRAL', strategy: 'Insufficient data' } };
    }
    
    const closes = klines.slice(-20).map(k => parseFloat(k.close || k[4] || 0));
    const len = closes.length;
    
    // Calculate direction changes (chop indicator)
    let dirChanges = 0;
    for (let i = 2; i < len; i++) {
        const prev = closes[i-1] > closes[i-2] ? 'UP' : 'DOWN';
        const curr = closes[i] > closes[i-1] ? 'UP' : 'DOWN';
        if (prev !== curr) dirChanges++;
    }
    
    // Calculate range percent
    const high20 = Math.max(...closes);
    const low20 = Math.min(...closes);
    const rangePercent = low20 > 0 ? ((high20 - low20) / low20) * 100 : 0;
    
    // Use provided ADX or default
    const adx = adxValue || 20;
    
    // Determine regime
    let regime, confidence, advice;
    
    if (adx > 25 && dirChanges < 8) {
        const direction = closes[len-1] > closes[0] ? 'UPTREND' : 'DOWNTREND';
        regime = direction;
        confidence = Math.min(100, adx * 2);
        advice = direction === 'UPTREND' 
            ? { bias: 'LONG', strategy: 'Buy dips to support' }
            : { bias: 'SHORT', strategy: 'Sell rallies to resistance' };
    } else if (adx < 20 && rangePercent < 8) {
        regime = 'RANGING';
        confidence = 100 - adx * 2;
        advice = { bias: 'NEUTRAL', strategy: 'Fade extremes, tight stops' };
    } else if (dirChanges > 12) {
        regime = 'CHOPPY';
        confidence = Math.min(100, dirChanges * 5);
        advice = { bias: 'AVOID', strategy: 'Reduce size or skip' };
    } else {
        regime = 'TRANSITIONAL';
        confidence = 50;
        advice = { bias: 'CAUTION', strategy: 'Wait for clarity' };
    }
    
    // 🛡️ HARDENING: Apply regime cooldown to prevent whipsaw
    if (typeof Hardening !== 'undefined') {
        const allowed = Hardening.updateRegime(regime);
        if (!allowed) {
            // Regime change was blocked by cooldown - use previous regime
            regime = Hardening.getRegime();
            advice.cooldownActive = true;
        }
    }
    
    return { regime, confidence, dirChanges, rangePercent, adx, advice };
}

// SECTION 5: DIRECTION AGREEMENT CHECK
function checkSmartAgreement(zoneDir, smcDir, momentumDir) {
    const directions = [zoneDir, smcDir, momentumDir].filter(d => d && d !== 'NEUTRAL');
    
    if (directions.length === 0) {
        return { agreement: 'NONE', count: 0, bonus: 1.0, direction: null };
    }
    
    const longCount = directions.filter(d => d === 'LONG').length;
    const shortCount = directions.filter(d => d === 'SHORT').length;
    
    // All 3 agree
    if (longCount === 3 || shortCount === 3) {
        return { 
            agreement: 'FULL', 
            direction: longCount === 3 ? 'LONG' : 'SHORT',
            count: 3, 
            bonus: 1.20 
        };
    }
    
    // 2 out of 3 agree
    if (longCount === 2 || shortCount === 2) {
        return { 
            agreement: 'MAJORITY', 
            direction: longCount > shortCount ? 'LONG' : 'SHORT',
            count: 2, 
            bonus: 1.10 
        };
    }
    
    // Conflict (1 LONG, 1 SHORT)
    if (longCount === 1 && shortCount === 1) {
        return { 
            agreement: 'CONFLICT', 
            direction: 'MIXED',
            count: 0, 
            bonus: 0.70 
        };
    }
    
    // Only 1 has direction
    return { 
        agreement: 'SINGLE', 
        direction: longCount === 1 ? 'LONG' : 'SHORT',
        count: 1, 
        bonus: 0.90 
    };
}

// SECTION 6: SMART MATRIX - MAIN WEIGHT CALCULATOR
function calculateSmartMatrix(zoneAnalysis, smcAnalysis, momentumAnalysis, klines) {
    
    // Step 1: Get confidence for each engine
    const zoneConf = getZoneConfidence(zoneAnalysis?.details?.primaryZone || zoneAnalysis?.details);
    const smcConf = getSMCConfidence(smcAnalysis);
    const momConf = getMomentumConfidence(momentumAnalysis);
    
    // Step 2: Detect market regime
    const adxValue = momentumAnalysis?.details?.adx?.adx || 20;
    const regime = detectMarketRegime(klines, adxValue);
    
    // Step 3: Check direction agreement
    const agreement = checkSmartAgreement(
        zoneAnalysis?.direction,
        smcAnalysis?.direction,
        momentumAnalysis?.direction
    );
    
    // Step 4: Calculate base weights from confidence
    let zoneWeight = 0.33 * (zoneConf.multiplier || 1);
    let smcWeight = 0.33 * (smcConf.multiplier || 1);
    let momWeight = 0.34 * (momConf.multiplier || 1);
    
    // Step 5: Apply regime adjustments
    switch (regime.regime) {
        case 'UPTREND':
        case 'DOWNTREND':
            smcWeight *= 1.15;
            momWeight *= 1.10;
            zoneWeight *= 0.90;
            break;
        case 'RANGING':
            zoneWeight *= 1.25;
            smcWeight *= 0.90;
            momWeight *= 0.85;
            break;
        case 'CHOPPY':
            momWeight *= 1.20;
            zoneWeight *= 0.85;
            smcWeight *= 0.85;
            break;
    }
    
    // Step 6: Normalize weights to 100%
    const totalWeight = zoneWeight + smcWeight + momWeight;
    if (totalWeight > 0) {
        zoneWeight = zoneWeight / totalWeight;
        smcWeight = smcWeight / totalWeight;
        momWeight = momWeight / totalWeight;
    } else {
        zoneWeight = 0.33; smcWeight = 0.33; momWeight = 0.34;
    }
    
    // Step 7: Determine dominant engine
    let dominant = 'BALANCED';
    if (zoneWeight > 0.40) dominant = 'ZONE';
    else if (smcWeight > 0.40) dominant = 'SMC';
    else if (momWeight > 0.40) dominant = 'MOMENTUM';
    
    return {
        weights: {
            zone: Math.round(zoneWeight * 100),
            smc: Math.round(smcWeight * 100),
            momentum: Math.round(momWeight * 100)
        },
        confidence: {
            zone: zoneConf,
            smc: smcConf,
            momentum: momConf
        },
        regime,
        agreement,
        dominant,
        display: `Z:${Math.round(zoneWeight * 100)}% S:${Math.round(smcWeight * 100)}% M:${Math.round(momWeight * 100)}%`
    };
}

// SECTION 7: APPLY SMART MATRIX TO SCORE
function applySmartMatrixScore(zoneScore, smcScore, momentumScore, smartMatrix) {
    // Null safety
    if (!smartMatrix || !smartMatrix.weights) {
        return {
            finalScore: Math.round((zoneScore * 0.35) + (smcScore * 0.35) + (momentumScore * 0.30)),
            breakdown: {
                zone: { raw: zoneScore, weighted: Math.round(zoneScore * 0.35), weight: '35%' },
                smc: { raw: smcScore, weighted: Math.round(smcScore * 0.35), weight: '35%' },
                momentum: { raw: momentumScore, weighted: Math.round(momentumScore * 0.30), weight: '30%' }
            }
        };
    }
    
    const w = smartMatrix.weights;
    
    // Apply weighted scores
    const weightedZone = zoneScore * ((w.zone || 33) / 100);
    const weightedSMC = smcScore * ((w.smc || 33) / 100);
    const weightedMom = momentumScore * ((w.momentum || 34) / 100);
    
    let finalScore = weightedZone + weightedSMC + weightedMom;
    
    // Apply agreement bonus/penalty (with null safety)
    finalScore *= smartMatrix.agreement?.bonus || 1.0;
    
    // Apply regime penalty for choppy (with null safety)
    if (smartMatrix.regime?.regime === 'CHOPPY') {
        finalScore *= 0.90;
    } else if ((smartMatrix.regime?.confidence || 0) > 70) {
        finalScore *= 1.05;
    }
    
    return {
        finalScore: Math.min(100, Math.round(finalScore)),
        breakdown: {
            zone: { raw: zoneScore, weighted: Math.round(weightedZone), weight: (w.zone || 33) + '%' },
            smc: { raw: smcScore, weighted: Math.round(weightedSMC), weight: (w.smc || 33) + '%' },
            momentum: { raw: momentumScore, weighted: Math.round(weightedMom), weight: (w.momentum || 34) + '%' }
        }
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🔥 PHASE 1: TOP TIER LIVE DATA SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════════
// FEATURE 1: LIQUIDATION STREAM (WebSocket)
// ═══════════════════════════════════════════════════════════════════════════════

let liqWebSocket = null;
let liqReconnectTimer = null;

function initLiquidationStream() {
    if (liqWebSocket && liqWebSocket.readyState === WebSocket.OPEN) return;
    
    try {
        console.log('💀 Connecting to Bybit Liquidation Stream...');
        STATE.liveData.wsReconnectAttempts++;
        
        liqWebSocket = new WebSocket('wss://stream.bybit.com/v5/public/linear');
        
        liqWebSocket.onopen = () => {
            console.log('💀 Liquidation WebSocket CONNECTED');
            STATE.liveData.wsConnected = true;
            STATE.liveData.wsReconnectAttempts = 0;
            updateLiveDataBar();
            
            // Subscribe to all liquidations
            liqWebSocket.send(JSON.stringify({
                op: 'subscribe',
                args: ['allLiquidation.USDT']
            }));
            
            // Heartbeat every 20 seconds
            setInterval(() => {
                if (liqWebSocket && liqWebSocket.readyState === WebSocket.OPEN) {
                    liqWebSocket.send(JSON.stringify({ op: 'ping' }));
                    STATE.liveData.wsLastHeartbeat = Date.now();
                }
            }, 20000);
        };
        
        liqWebSocket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                
                if (data.topic === 'allLiquidation.USDT' && data.data) {
                    processLiquidation(data.data);
                }
            } catch (e) {
                // Silent: Liq parse
            }
        };
        
        liqWebSocket.onerror = (error) => {
            // Silent fail - WebSocket error
            STATE.liveData.wsConnected = false;
            updateLiveDataBar();
        };
        
        liqWebSocket.onclose = () => {
            console.log('💀 Liquidation WebSocket CLOSED');
            STATE.liveData.wsConnected = false;
            updateLiveDataBar();
            
            // Auto-reconnect with backoff
            if (STATE.liveData.wsReconnectAttempts < 10) {
                const delay = Math.min(5000 * STATE.liveData.wsReconnectAttempts, 30000);
                console.log(`💀 Reconnecting in ${delay/1000}s...`);
                liqReconnectTimer = setTimeout(initLiquidationStream, delay);
            }
        };
        
    } catch (e) {
        console.error('💀 Failed to init liquidation stream:', e);
    }
}

function processLiquidation(liqData) {
    const liq = {
        symbol: liqData.symbol,
        side: liqData.side, // Buy = Short liquidated, Sell = Long liquidated
        size: parseFloat(liqData.size) || 0,
        price: parseFloat(liqData.price) || 0,
        value: (parseFloat(liqData.size) || 0) * (parseFloat(liqData.price) || 0),
        time: Date.now(),
        isLongLiq: liqData.side === 'Sell', // Sell order = Long position liquidated
        isShortLiq: liqData.side === 'Buy'  // Buy order = Short position liquidated
    };
    
    // Add to recent
    STATE.liveData.liquidations.recent.unshift(liq);
    if (STATE.liveData.liquidations.recent.length > 100) {
        STATE.liveData.liquidations.recent.pop();
    }
    
    // Update per-coin tracking
    if (!STATE.liveData.liquidations.byCoin[liq.symbol]) {
        STATE.liveData.liquidations.byCoin[liq.symbol] = { long: 0, short: 0 };
    }
    if (liq.isLongLiq) STATE.liveData.liquidations.byCoin[liq.symbol].long += liq.value;
    else STATE.liveData.liquidations.byCoin[liq.symbol].short += liq.value;
    
    // Track big liquidations
    if (liq.value > 500000) {
        STATE.liveData.liquidations.lastBigLiq = liq;
        showWhaleAlert({
            type: 'LIQUIDATION',
            symbol: liq.symbol,
            side: liq.isLongLiq ? 'LONG REKT' : 'SHORT REKT',
            amount: liq.value,
            price: liq.price
        });
    }
    
    // Recalculate totals
    calculateLiquidationTotals();
    updateLiveDataBar();
}

function calculateLiquidationTotals() {
    const now = Date.now();
    const fiveMinAgo = now - 5 * 60 * 1000;
    const fifteenMinAgo = now - 15 * 60 * 1000;
    
    let long5m = 0, short5m = 0, long15m = 0, short15m = 0;
    
    for (const liq of STATE.liveData.liquidations.recent) {
        if (liq.time > fifteenMinAgo) {
            if (liq.isLongLiq) long15m += liq.value;
            else short15m += liq.value;
            
            if (liq.time > fiveMinAgo) {
                if (liq.isLongLiq) long5m += liq.value;
                else short5m += liq.value;
            }
        }
    }
    
    STATE.liveData.liquidations.longTotal5m = long5m;
    STATE.liveData.liquidations.shortTotal5m = short5m;
    STATE.liveData.liquidations.longTotal15m = long15m;
    STATE.liveData.liquidations.shortTotal15m = short15m;
    
    // Calculate bias
    const total5m = long5m + short5m;
    if (total5m > 100000) { // Only calculate if significant volume
        const shortRatio = short5m / total5m;
        if (shortRatio > 0.65) {
            STATE.liveData.liquidations.bias = 'BULLISH'; // Shorts getting rekt = bullish
            STATE.liveData.liquidations.biasStrength = Math.round(shortRatio * 100);
        } else if (shortRatio < 0.35) {
            STATE.liveData.liquidations.bias = 'BEARISH'; // Longs getting rekt = bearish
            STATE.liveData.liquidations.biasStrength = Math.round((1 - shortRatio) * 100);
        } else {
            STATE.liveData.liquidations.bias = 'NEUTRAL';
            STATE.liveData.liquidations.biasStrength = 50;
        }
    } else {
        STATE.liveData.liquidations.bias = 'NEUTRAL';
        STATE.liveData.liquidations.biasStrength = 50;
    }
    
    // Detect cascade
    STATE.liveData.liquidations.cascadeDetected = total5m > 5000000; // $5M in 5 min = cascade
}

function getLiqBiasForCoin(symbol) {
    const coinLiqs = STATE.liveData.liquidations.byCoin[symbol];
    if (!coinLiqs) return { bias: 'NEUTRAL', strength: 0 };
    
    const total = coinLiqs.long + coinLiqs.short;
    if (total < 10000) return { bias: 'NEUTRAL', strength: 0 };
    
    const shortRatio = coinLiqs.short / total;
    if (shortRatio > 0.6) return { bias: 'BULLISH', strength: Math.round(shortRatio * 100) };
    if (shortRatio < 0.4) return { bias: 'BEARISH', strength: Math.round((1 - shortRatio) * 100) };
    return { bias: 'NEUTRAL', strength: 50 };
}

// ═══════════════════════════════════════════════════════════════════════════════
// FEATURE 2: OPEN INTEREST DELTA TRACKING
// ═══════════════════════════════════════════════════════════════════════════════

let oiHistory = {}; // Store OI history for delta calculation

// fetchOpenInterest is defined above (line ~4563) with comprehensive analysis

async function updateAllOpenInterest() {
    try {
        // Fetch BTC and ETH OI
        const btcOI = await fetchOpenInterest('BTCUSDT');
        const ethOI = await fetchOpenInterest('ETHUSDT');
        
        if (btcOI) {
            STATE.liveData.openInterest.btc = btcOI;
        }
        if (ethOI) {
            STATE.liveData.openInterest.eth = ethOI;
        }
        
        // Calculate total trend
        if (btcOI && ethOI) {
            const avgChange = (btcOI.changePct + ethOI.changePct) / 2;
            STATE.liveData.openInterest.total.trend = avgChange > 1 ? 'RISING' : avgChange < -1 ? 'FALLING' : 'FLAT';
            STATE.liveData.openInterest.total.change5m = avgChange;
        }
        
        STATE.liveData.openInterest.lastUpdate = Date.now();
        updateLiveDataBar();
        
    } catch (e) {
        // Silent: OI update
    }
}

function getOIForCoin(symbol) {
    return STATE.liveData.openInterest.byCoin[symbol] || STATE.liveData.openInterest.btc;
}

// ═══════════════════════════════════════════════════════════════════════════════
// FEATURE 3: WHALE / LARGE TRADE DETECTION
// ═══════════════════════════════════════════════════════════════════════════════

let tradeWebSocket = null;
const WHALE_THRESHOLD = 100000; // $100K minimum

function initWhaleStream() {
    // Use the same WebSocket approach but for trades
    // Note: Bybit public trade stream for major coins
    
    try {
        console.log('🐋 Initializing Whale Detection...');
        
        // We'll poll large trades instead of WebSocket for reliability
        setInterval(checkForWhaleTrades, 10000); // Every 10 seconds
        
    } catch (e) {
        console.error('🐋 Failed to init whale stream:', e);
    }
}

async function checkForWhaleTrades() {
    try {
        // Check recent trades for BTC
        const response = await fetch(`${CONFIG.BYBIT_V5}/market/recent-trade?category=linear&symbol=BTCUSDT&limit=50`);
        const data = await response.json();
        
        if (data.retCode === 0 && data.result?.list) {
            const now = Date.now();
            
            for (const trade of data.result.list) {
                const tradeValue = parseFloat(trade.size) * parseFloat(trade.price);
                const tradeTime = parseInt(trade.time);
                
                // Only process recent trades (last 30 seconds) above threshold
                if (tradeValue >= WHALE_THRESHOLD && (now - tradeTime) < 30000) {
                    // Check if we already processed this trade
                    const tradeId = `${trade.execId || trade.time}_${trade.size}`;
                    const alreadyProcessed = STATE.liveData.whales.recent.some(w => w.id === tradeId);
                    
                    if (!alreadyProcessed) {
                        processWhaleTrade({
                            id: tradeId,
                            symbol: 'BTCUSDT',
                            side: trade.side,
                            size: parseFloat(trade.size),
                            price: parseFloat(trade.price),
                            value: tradeValue,
                            time: tradeTime,
                            isBuy: trade.side === 'Buy'
                        });
                    }
                }
            }
        }
    } catch (e) {
        // Silent fail - Whale check
    }
}

function processWhaleTrade(trade) {
    // Add to recent
    STATE.liveData.whales.recent.unshift(trade);
    if (STATE.liveData.whales.recent.length > 50) {
        STATE.liveData.whales.recent.pop();
    }
    
    // Update volume tracking
    const fiveMinAgo = Date.now() - 5 * 60 * 1000;
    let buy5m = 0, sell5m = 0;
    
    for (const w of STATE.liveData.whales.recent) {
        if (w.time > fiveMinAgo) {
            if (w.isBuy) buy5m += w.value;
            else sell5m += w.value;
        }
    }
    
    STATE.liveData.whales.buyVolume5m = buy5m;
    STATE.liveData.whales.sellVolume5m = sell5m;
    
    // Calculate bias
    const total = buy5m + sell5m;
    if (total > 500000) {
        const buyRatio = buy5m / total;
        if (buyRatio > 0.6) STATE.liveData.whales.bias = 'BUYING';
        else if (buyRatio < 0.4) STATE.liveData.whales.bias = 'SELLING';
        else STATE.liveData.whales.bias = 'NEUTRAL';
    }
    
    STATE.liveData.whales.lastWhale = trade;
    
    // Show alert for big whales
    if (trade.value >= 250000) { // $250K+ gets alert
        showWhaleAlert({
            type: 'WHALE',
            symbol: trade.symbol,
            side: trade.isBuy ? 'BUY' : 'SELL',
            amount: trade.value,
            price: trade.price
        });
    }
    
    updateLiveDataBar();
}

function showWhaleAlert(alert) {
    // Add to queue
    STATE.liveData.whales.alertQueue.push(alert);
    
    // Create popup
    const popup = document.createElement('div');
    popup.className = 'whale-alert-popup';
    popup.innerHTML = `
        <div style="display:flex;align-items:center">
            <span class="whale-icon">${alert.type === 'WHALE' ? '🐋' : '💀'}</span>
            <div class="whale-info">
                <span class="whale-coin">${alert.symbol} ${alert.side}</span>
                <span class="whale-details">@ $${formatPrice(alert.price)}</span>
            </div>
            <span class="whale-amount ${alert.side === 'BUY' || alert.side === 'SHORT REKT' ? 'buy' : 'sell'}">
                $${formatLargeNumber(alert.amount)}
            </span>
        </div>
    `;
    
    document.body.appendChild(popup);
    
    // Play sound if enabled
    if (STATE.alertSound) {
        try {
            const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2IkZmgnpmOgXJkWVBLR0dKT1dfaXN/iZKZnp+elI2BeG1iVk5JR0hMUlpkaHJ9h5CXnJ6dmpaOgndpXVNKRkVGSk9ZYmtye4WNk5eZl5KLgXZqXlNKRkRERktRWWJqc3yFjZKVlpSQiX50aF1TSkhFRUhLUVliand/ho2Sk5OQjIR6b2RaUUpHRUVITFJaY2t0fYWMkJKRjoqCeG5kWlFKR0VFR0tQV19nbHR8g4mNj46Lh391a2FXUEpGRERGSk5VXWVscnl/hYqMjIqGgHdtY1lRSkZEREZKTlReZWxze4GGioqKhoJ8dGpiWFFLR0VFR0tPVl5lbHJ5f4SHiYiGgn15cWlgWFBKRkRERkhMUVhfZmxzeX6Dhodd');
            audio.volume = 0.3;
            audio.play();
        } catch(e) {}
    }
    
    // Remove after 4 seconds
    setTimeout(() => {
        popup.style.animation = 'whaleSlideIn 0.3s ease-out reverse';
        setTimeout(() => popup.remove(), 300);
    }, 4000);
}

// ═══════════════════════════════════════════════════════════════════════════════
// FEATURE 4: FUNDING RATE TRACKER
// ═══════════════════════════════════════════════════════════════════════════════

async function fetchFundingRates() {
    try {
        // Fetch funding rates for major coins
        const coins = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'BNBUSDT', 'XRPUSDT'];
        const rates = {};
        let extremeCoins = [];
        
        for (const coin of coins) {
            try {
                const response = await fetch(`${CONFIG.BYBIT_V5}/market/tickers?category=linear&symbol=${coin}`);
                const data = await response.json();
                
                if (data.retCode === 0 && data.result?.list?.[0]) {
                    const ticker = data.result.list[0];
                    const rate = parseFloat(ticker.fundingRate) * 100 || 0;
                    const nextTime = parseInt(ticker.nextFundingTime) || 0;
                    
                    rates[coin] = {
                        rate: rate,
                        predicted: rate, // Could be enhanced with prediction logic
                        nextTime: nextTime,
                        countdown: formatCountdown(nextTime - Date.now())
                    };
                    
                    // Track extreme funding
                    if (Math.abs(rate) > 0.03) { // > 0.03% is elevated
                        extremeCoins.push({ coin, rate });
                    }
                }
                
                await new Promise(r => setTimeout(r, 100)); // Rate limit
            } catch (e) {
                // Silent fail - Funding fetch
            }
        }
        
        // Update state
        if (rates.BTCUSDT) STATE.liveData.funding.btc = rates.BTCUSDT;
        if (rates.ETHUSDT) STATE.liveData.funding.eth = rates.ETHUSDT;
        STATE.liveData.funding.byCoin = rates;
        STATE.liveData.funding.extremeCoins = extremeCoins;
        
        // Calculate average
        const allRates = Object.values(rates).map(r => r.rate);
        STATE.liveData.funding.average = allRates.length > 0 
            ? allRates.reduce((a, b) => a + b, 0) / allRates.length 
            : 0;
        
        STATE.liveData.funding.lastUpdate = Date.now();
        updateLiveDataBar();
        
    } catch (e) {
        // Silent: Funding update
    }
}

function formatCountdown(ms) {
    if (ms <= 0) return '00:00';
    const hours = Math.floor(ms / 3600000);
    const minutes = Math.floor((ms % 3600000) / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    if (hours > 0) return `${hours}h ${minutes}m`;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function getFundingForCoin(symbol) {
    return STATE.liveData.funding.byCoin[symbol] || STATE.liveData.funding.btc;
}

// ═══════════════════════════════════════════════════════════════════════════════
// LIVE DATA BAR UI UPDATE
// ═══════════════════════════════════════════════════════════════════════════════

function updateLiveDataBar() {
    const bar = document.getElementById('liveDataBar');
    if (!bar) return;
    
    const liq = STATE.liveData.liquidations;
    const oi = STATE.liveData.openInterest;
    const whale = STATE.liveData.whales;
    const funding = STATE.liveData.funding;
    
    // Format large numbers
    const fmtM = (v) => v >= 1000000 ? (v/1000000).toFixed(1) + 'M' : v >= 1000 ? (v/1000).toFixed(0) + 'K' : v.toFixed(0);
    
    // Determine classes
    const liqClass = liq.bias === 'BULLISH' ? 'bullish' : liq.bias === 'BEARISH' ? 'bearish' : 'neutral';
    const oiClass = oi.btc.trend === 'RISING' ? 'bullish' : oi.btc.trend === 'FALLING' ? 'bearish' : 'neutral';
    const whaleClass = whale.bias === 'BUYING' ? 'bullish' : whale.bias === 'SELLING' ? 'bearish' : 'neutral';
    const fundingClass = funding.btc.rate > 0.02 ? 'bullish' : funding.btc.rate < -0.02 ? 'bearish' : 'neutral';
    
    bar.innerHTML = `
        <div class="live-dot ${STATE.liveData.wsConnected ? '' : 'disconnected'}"></div>
        
        <div class="live-badge liq-badge ${liqClass} ${liq.cascadeDetected ? 'liq-cascade' : ''}">
            <span class="icon">💀</span>
            <span class="label">LIQS</span>
            <span class="value">
                <span class="liq-long">L:$${fmtM(liq.longTotal5m)}</span>
                <span class="liq-short">S:$${fmtM(liq.shortTotal5m)}</span>
            </span>
        </div>
        
        <div class="live-badge oi-badge ${oiClass}">
            <span class="icon">📊</span>
            <span class="label">OI</span>
            <span class="value ${oi.btc.trend === 'RISING' ? 'oi-up' : oi.btc.trend === 'FALLING' ? 'oi-down' : ''}">
                ${oi.btc.changePct > 0 ? '+' : ''}${oi.btc.changePct?.toFixed(1) || '0'}%
            </span>
            <div class="oi-bar">
                <div class="oi-bar-fill ${oi.btc.changePct >= 0 ? 'positive' : 'negative'}" 
                     style="width:${Math.min(100, Math.abs(oi.btc.changePct || 0) * 10)}%"></div>
            </div>
        </div>
        
        <div class="live-badge whale-badge ${whaleClass} ${whale.lastWhale && Date.now() - whale.lastWhale.time < 60000 ? 'active' : ''}">
            <span class="icon">🐋</span>
            <span class="label">WHALE</span>
            <span class="value">${whale.bias}</span>
        </div>
        
        <div class="live-badge funding-badge ${fundingClass}">
            <span class="icon">💰</span>
            <span class="label">FUND</span>
            <span class="value">${funding.btc.rate?.toFixed(3) || '0.000'}%</span>
            <span class="countdown">${funding.btc.countdown || '--:--'}</span>
        </div>
    `;
}

function formatLargeNumber(num) {
    if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(0) + 'K';
    return num.toFixed(0);
}

function formatPrice(price) {
    if (price >= 10000) return price.toFixed(0);
    if (price >= 100) return price.toFixed(1);
    if (price >= 1) return price.toFixed(2);
    return price.toFixed(4);
}

// ═══════════════════════════════════════════════════════════════════════════════
// GET LIVE DATA FOR SIGNAL CARD
// ═══════════════════════════════════════════════════════════════════════════════

function getLiveDataForSignal(symbol, direction) {
    const liqBias = getLiqBiasForCoin(symbol);
    const funding = getFundingForCoin(symbol);
    const oi = getOIForCoin(symbol);
    
    // Determine if live data supports or opposes signal direction
    let liqSupport = 'neutral';
    let fundingSupport = 'neutral';
    let oiSupport = 'neutral';
    
    // Liquidation: shorts rekt = bullish, longs rekt = bearish
    if (liqBias.bias === 'BULLISH' && direction === 'LONG') liqSupport = 'support';
    else if (liqBias.bias === 'BEARISH' && direction === 'SHORT') liqSupport = 'support';
    else if (liqBias.bias === 'BULLISH' && direction === 'SHORT') liqSupport = 'oppose';
    else if (liqBias.bias === 'BEARISH' && direction === 'LONG') liqSupport = 'oppose';
    
    // Funding: positive funding = more longs (bearish for longs due to cost)
    if (funding) {
        if (funding.rate > 0.03 && direction === 'SHORT') fundingSupport = 'support';
        else if (funding.rate < -0.03 && direction === 'LONG') fundingSupport = 'support';
        else if (funding.rate > 0.03 && direction === 'LONG') fundingSupport = 'oppose';
        else if (funding.rate < -0.03 && direction === 'SHORT') fundingSupport = 'oppose';
    }
    
    // OI: Rising OI = trend continuation, Falling OI = potential reversal
    if (oi) {
        if (oi.trend === 'RISING') oiSupport = 'support'; // Trend confirmation
        else if (oi.trend === 'FALLING') oiSupport = 'caution';
    }
    
    return {
        liq: liqBias,
        funding: funding,
        oi: oi,
        liqSupport,
        fundingSupport,
        oiSupport,
        whale: STATE.liveData.whales.bias
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// INITIALIZE ALL PHASE 1 FEATURES
// ═══════════════════════════════════════════════════════════════════════════════

function initPhase1LiveData() {
    console.log('🔥 Initializing Phase 1 Live Data System...');
    
    // Start liquidation stream
    initLiquidationStream();
    
    // Start whale detection
    initWhaleStream();
    
    // Initial data fetch
    updateAllOpenInterest();
    fetchFundingRates();
    
    // Set up periodic updates
    setInterval(updateAllOpenInterest, 60000);   // OI every 1 min
    setInterval(fetchFundingRates, 30000);       // Funding every 30 sec
    setInterval(calculateLiquidationTotals, 5000); // Recalc liqs every 5 sec
    
    // Update funding countdown every second
    setInterval(() => {
        if (STATE.liveData.funding.btc.nextTime) {
            STATE.liveData.funding.btc.countdown = formatCountdown(STATE.liveData.funding.btc.nextTime - Date.now());
            updateLiveDataBar();
        }
    }, 1000);
    
    console.log('🔥 Phase 1 Live Data System READY!');
}

// ═══════════════════════════════════════════════════════════════════════════════
// 📊 PHASE 2: VOLUME PROFILE ANALYSIS
// ═══════════════════════════════════════════════════════════════════════════════

function calculateVolumeProfile(klines, numLevels = 24) {
    if (!klines || klines.length < 20) {
        return { poc: 0, valueAreaHigh: 0, valueAreaLow: 0, levels: [], hvnZones: [], lvnZones: [] };
    }
    
    // Find price range
    let highestHigh = 0;
    let lowestLow = Infinity;
    let totalVolume = 0;
    
    for (const k of klines) {
        if (k.high > highestHigh) highestHigh = k.high;
        if (k.low < lowestLow) lowestLow = k.low;
        totalVolume += k.volume;
    }
    
    const range = highestHigh - lowestLow;
    if (range <= 0) return { poc: klines[klines.length - 1].close, valueAreaHigh: highestHigh, valueAreaLow: lowestLow, levels: [] };
    
    const levelSize = range / numLevels;
    const levels = [];
    
    // Initialize levels
    for (let i = 0; i < numLevels; i++) {
        levels.push({
            priceHigh: highestHigh - (i * levelSize),
            priceLow: highestHigh - ((i + 1) * levelSize),
            priceMid: highestHigh - (i * levelSize) - (levelSize / 2),
            volume: 0,
            buyVolume: 0,
            sellVolume: 0,
            trades: 0
        });
    }
    
    // Distribute volume across levels
    for (const k of klines) {
        const candleRange = k.high - k.low;
        const isBullish = k.close > k.open;
        
        for (let i = 0; i < numLevels; i++) {
            const level = levels[i];
            
            // Check if candle touches this level
            if (k.high >= level.priceLow && k.low <= level.priceHigh) {
                // Calculate overlap
                const overlapHigh = Math.min(k.high, level.priceHigh);
                const overlapLow = Math.max(k.low, level.priceLow);
                const overlapPct = candleRange > 0 ? (overlapHigh - overlapLow) / candleRange : 1;
                
                const volAtLevel = k.volume * overlapPct;
                level.volume += volAtLevel;
                level.trades++;
                
                // Estimate buy/sell based on candle direction
                if (isBullish) {
                    level.buyVolume += volAtLevel * 0.6;
                    level.sellVolume += volAtLevel * 0.4;
                } else {
                    level.sellVolume += volAtLevel * 0.6;
                    level.buyVolume += volAtLevel * 0.4;
                }
            }
        }
    }
    
    // Find POC (Point of Control) - highest volume level
    let poc = levels[0];
    for (const level of levels) {
        if (level.volume > poc.volume) {
            poc = level;
        }
    }
    
    // Calculate Value Area (70% of volume)
    const sortedByVolume = [...levels].sort((a, b) => b.volume - a.volume);
    const targetVolume = totalVolume * 0.70;
    let accumulatedVolume = 0;
    const valueAreaLevels = [];
    
    for (const level of sortedByVolume) {
        if (accumulatedVolume < targetVolume) {
            valueAreaLevels.push(level);
            accumulatedVolume += level.volume;
        }
    }
    
    // Find VAH and VAL
    let valueAreaHigh = 0;
    let valueAreaLow = Infinity;
    for (const level of valueAreaLevels) {
        if (level.priceHigh > valueAreaHigh) valueAreaHigh = level.priceHigh;
        if (level.priceLow < valueAreaLow) valueAreaLow = level.priceLow;
    }
    
    // Identify HVN (High Volume Nodes) and LVN (Low Volume Nodes)
    const avgVolume = totalVolume / numLevels;
    const hvnZones = levels.filter(l => l.volume > avgVolume * 1.5).map(l => ({ price: l.priceMid, volume: l.volume, type: 'HVN' }));
    const lvnZones = levels.filter(l => l.volume < avgVolume * 0.5 && l.volume > 0).map(l => ({ price: l.priceMid, volume: l.volume, type: 'LVN' }));
    
    return {
        poc: poc.priceMid,
        pocVolume: poc.volume,
        valueAreaHigh,
        valueAreaLow,
        levels,
        hvnZones,
        lvnZones,
        totalVolume,
        avgVolume,
        range: { high: highestHigh, low: lowestLow }
    };
}

function analyzeVolumeProfileSignal(klines, currentPrice, direction) {
    const vp = calculateVolumeProfile(klines);
    
    if (!vp || !vp.poc) {
        return { valid: false, score: 0, factors: [], support: 'neutral' };
    }
    
    const factors = [];
    let score = 50;
    let support = 'neutral';
    
    const priceVsPOC = ((currentPrice - vp.poc) / vp.poc) * 100;
    const priceVsVAH = ((currentPrice - vp.valueAreaHigh) / vp.valueAreaHigh) * 100;
    const priceVsVAL = ((currentPrice - vp.valueAreaLow) / vp.valueAreaLow) * 100;
    
    // Check if price is at POC (strong support/resistance)
    if (Math.abs(priceVsPOC) < 0.5) {
        factors.push('📊 At POC (strong level)');
        score += 15;
    }
    
    // Check if price is at Value Area boundaries
    if (direction === 'LONG') {
        if (Math.abs(priceVsVAL) < 0.5) {
            factors.push('📊 At VAL (support)');
            score += 20;
            support = 'strong';
        } else if (currentPrice < vp.valueAreaLow) {
            factors.push('📊 Below Value Area');
            score += 10;
            support = 'support';
        } else if (currentPrice > vp.valueAreaHigh) {
            factors.push('⚠️ Above Value Area');
            score -= 10;
            support = 'caution';
        }
    } else { // SHORT
        if (Math.abs(priceVsVAH) < 0.5) {
            factors.push('📊 At VAH (resistance)');
            score += 20;
            support = 'strong';
        } else if (currentPrice > vp.valueAreaHigh) {
            factors.push('📊 Above Value Area');
            score += 10;
            support = 'support';
        } else if (currentPrice < vp.valueAreaLow) {
            factors.push('⚠️ Below Value Area');
            score -= 10;
            support = 'caution';
        }
    }
    
    // Check for LVN (fast move zones)
    const nearbyLVN = vp.lvnZones.find(z => Math.abs((currentPrice - z.price) / z.price) < 0.01);
    if (nearbyLVN) {
        factors.push('⚡ Near LVN (fast move zone)');
        score += 10;
    }
    
    // Check for HVN (accumulation zones)
    const nearbyHVN = vp.hvnZones.find(z => Math.abs((currentPrice - z.price) / z.price) < 0.01);
    if (nearbyHVN) {
        factors.push('🏦 Near HVN (accumulation)');
        score += 5;
    }
    
    return {
        valid: true,
        score: Math.min(100, Math.max(0, score)),
        factors,
        support,
        profile: vp,
        analysis: {
            priceVsPOC,
            priceVsVAH,
            priceVsVAL,
            inValueArea: currentPrice >= vp.valueAreaLow && currentPrice <= vp.valueAreaHigh
        }
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🌊 PHASE 3: ORDER FLOW LITE - AGGRESSION & ABSORPTION DETECTION
// ═══════════════════════════════════════════════════════════════════════════════

function analyzeOrderFlow(klines) {
    if (!klines || klines.length < 20) {
        return { delta: 0, aggression: 'NEUTRAL', absorption: false, imbalance: [], stackedBids: false, stackedAsks: false };
    }
    
    const recentKlines = klines.slice(-20);
    let buyPressure = 0;
    let sellPressure = 0;
    let absorptionCandles = 0;
    let imbalances = [];
    let consecutiveBuy = 0;
    let consecutiveSell = 0;
    let maxConsecBuy = 0;
    let maxConsecSell = 0;
    
    for (let i = 0; i < recentKlines.length; i++) {
        const k = recentKlines[i];
        const body = Math.abs(k.close - k.open);
        const upperWick = k.high - Math.max(k.open, k.close);
        const lowerWick = Math.min(k.open, k.close) - k.low;
        const totalRange = k.high - k.low;
        const isBullish = k.close > k.open;
        
        // Estimate buy/sell pressure based on candle structure
        if (isBullish) {
            // Bullish candle - buying pressure
            const buyStrength = body / (totalRange || 1);
            buyPressure += k.volume * (0.5 + buyStrength * 0.5);
            sellPressure += k.volume * (0.5 - buyStrength * 0.5);
            
            consecutiveBuy++;
            consecutiveSell = 0;
            if (consecutiveBuy > maxConsecBuy) maxConsecBuy = consecutiveBuy;
        } else {
            // Bearish candle - selling pressure
            const sellStrength = body / (totalRange || 1);
            sellPressure += k.volume * (0.5 + sellStrength * 0.5);
            buyPressure += k.volume * (0.5 - sellStrength * 0.5);
            
            consecutiveSell++;
            consecutiveBuy = 0;
            if (consecutiveSell > maxConsecSell) maxConsecSell = consecutiveSell;
        }
        
        // Detect absorption (large wick with high volume, small body)
        const wickRatio = (upperWick + lowerWick) / (totalRange || 1);
        const bodyRatio = body / (totalRange || 1);
        const avgVol = recentKlines.reduce((s, c) => s + c.volume, 0) / recentKlines.length;
        
        if (wickRatio > 0.6 && bodyRatio < 0.3 && k.volume > avgVol * 1.5) {
            absorptionCandles++;
        }
        
        // Detect imbalance (3+ consecutive same direction with increasing volume)
        if (i >= 2) {
            const prev1 = recentKlines[i - 1];
            const prev2 = recentKlines[i - 2];
            const allBullish = isBullish && prev1.close > prev1.open && prev2.close > prev2.open;
            const allBearish = !isBullish && prev1.close < prev1.open && prev2.close < prev2.open;
            const volIncreasing = k.volume > prev1.volume && prev1.volume > prev2.volume;
            
            if ((allBullish || allBearish) && volIncreasing) {
                imbalances.push({
                    index: i,
                    direction: allBullish ? 'BUY' : 'SELL',
                    strength: 'STACKED'
                });
            }
        }
    }
    
    // Calculate delta
    const delta = buyPressure - sellPressure;
    const totalPressure = buyPressure + sellPressure;
    const deltaPercent = totalPressure > 0 ? (delta / totalPressure) * 100 : 0;
    
    // Determine aggression
    let aggression = 'NEUTRAL';
    if (deltaPercent > 20) aggression = 'STRONG_BUY';
    else if (deltaPercent > 10) aggression = 'BUY';
    else if (deltaPercent < -20) aggression = 'STRONG_SELL';
    else if (deltaPercent < -10) aggression = 'SELL';
    
    // Check for stacked imbalances
    const stackedBids = maxConsecBuy >= 3;
    const stackedAsks = maxConsecSell >= 3;
    
    return {
        delta,
        deltaPercent,
        buyPressure,
        sellPressure,
        aggression,
        absorption: absorptionCandles >= 2,
        absorptionCount: absorptionCandles,
        imbalance: imbalances,
        stackedBids,
        stackedAsks,
        maxConsecBuy,
        maxConsecSell
    };
}

function getOrderFlowSignal(klines, direction) {
    const of = analyzeOrderFlow(klines);
    
    let support = 'neutral';
    let score = 50;
    const factors = [];
    
    // Check aggression alignment
    if (direction === 'LONG') {
        if (of.aggression === 'STRONG_BUY') {
            support = 'strong';
            score += 25;
            factors.push('🌊 Strong Buy Aggression');
        } else if (of.aggression === 'BUY') {
            support = 'support';
            score += 15;
            factors.push('🌊 Buy Aggression');
        } else if (of.aggression === 'STRONG_SELL') {
            support = 'oppose';
            score -= 20;
            factors.push('⚠️ Strong Sell Aggression');
        } else if (of.aggression === 'SELL') {
            support = 'caution';
            score -= 10;
            factors.push('⚠️ Sell Aggression');
        }
        
        if (of.stackedBids) {
            score += 15;
            factors.push('📈 Stacked Buy Imbalance');
        }
    } else { // SHORT
        if (of.aggression === 'STRONG_SELL') {
            support = 'strong';
            score += 25;
            factors.push('🌊 Strong Sell Aggression');
        } else if (of.aggression === 'SELL') {
            support = 'support';
            score += 15;
            factors.push('🌊 Sell Aggression');
        } else if (of.aggression === 'STRONG_BUY') {
            support = 'oppose';
            score -= 20;
            factors.push('⚠️ Strong Buy Aggression');
        } else if (of.aggression === 'BUY') {
            support = 'caution';
            score -= 10;
            factors.push('⚠️ Buy Aggression');
        }
        
        if (of.stackedAsks) {
            score += 15;
            factors.push('📉 Stacked Sell Imbalance');
        }
    }
    
    // Absorption detection
    if (of.absorption) {
        factors.push('🛡️ Absorption Detected');
        score += 10;
    }
    
    return {
        score: Math.min(100, Math.max(0, score)),
        support,
        factors,
        flow: of
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🤖 PHASE 4: ML-LITE PATTERN RECOGNITION & WIN PROBABILITY
// ═══════════════════════════════════════════════════════════════════════════════

// Pattern memory (persisted)
let ML_PATTERN_DB = [];
const ML_MIN_PATTERNS = 20;

function initMLSystem() {
    try {
        const saved = localStorage.getItem('ml_pattern_db');
        if (saved) {
            ML_PATTERN_DB = JSON.parse(saved);
            console.log(`🤖 ML System loaded: ${ML_PATTERN_DB.length} patterns`);
        }
    } catch (e) {
        console.warn('ML init error:', e);
        ML_PATTERN_DB = [];
    }
}

function saveMLPatterns() {
    try {
        // Keep only last 1000 patterns
        if (ML_PATTERN_DB.length > 1000) {
            ML_PATTERN_DB = ML_PATTERN_DB.slice(-1000);
        }
        localStorage.setItem('ml_pattern_db', JSON.stringify(ML_PATTERN_DB));
    } catch (e) {
        console.warn('ML save error:', e);
    }
}

function extractSignalFeatures(signal, klines) {
    // Extract normalized features for pattern matching
    const features = {
        // Score features (normalized 0-1)
        zoneScore: (signal.scores?.zone || 0) / 100,
        smcScore: (signal.scores?.smc || 0) / 100,
        momentumScore: (signal.scores?.momentum || 0) / 100,
        totalScore: (signal.score || 0) / 100,
        
        // Direction (1 = LONG, 0 = SHORT)
        direction: signal.direction === 'LONG' ? 1 : 0,
        
        // Agreement (normalized)
        agreement: (signal.agreed || 0) / 3,
        
        // Timeframe bucket
        tfBucket: ['5', '15', '30'].includes(signal.tfRaw) ? 0 : 
                  signal.tfRaw === '60' ? 0.5 : 1,
        
        // Price position features
        rsi: 0.5,
        atrRatio: 0,
        volumeRatio: 0
    };
    
    // Extract from klines if available
    if (klines && klines.length > 0) {
        const closes = klines.slice(-14).map(k => k.close);
        const volumes = klines.slice(-20).map(k => k.volume);
        
        // Simple RSI approximation
        let gains = 0, losses = 0;
        for (let i = 1; i < closes.length; i++) {
            const change = closes[i] - closes[i-1];
            if (change > 0) gains += change;
            else losses -= change;
        }
        const rs = losses > 0 ? gains / losses : 100;
        features.rsi = Math.min(1, rs / (1 + rs));
        
        // Volume ratio
        const avgVol = volumes.reduce((a, b) => a + b, 0) / volumes.length;
        const lastVol = volumes[volumes.length - 1] || avgVol;
        features.volumeRatio = Math.min(1, lastVol / (avgVol * 2));
    }
    
    return features;
}

function calculateFeatureDistance(f1, f2) {
    // Euclidean distance between feature vectors
    let sum = 0;
    const weights = {
        zoneScore: 1.5,
        smcScore: 1.5,
        momentumScore: 1.0,
        totalScore: 2.0,
        direction: 3.0, // Direction is very important
        agreement: 1.5,
        tfBucket: 0.5,
        rsi: 0.8,
        volumeRatio: 0.5
    };
    
    for (const key in weights) {
        const diff = (f1[key] || 0) - (f2[key] || 0);
        sum += (diff * diff) * weights[key];
    }
    
    return Math.sqrt(sum);
}

function findSimilarPatterns(features, maxDistance = 0.5, limit = 20) {
    const similar = [];
    
    for (const pattern of ML_PATTERN_DB) {
        const distance = calculateFeatureDistance(features, pattern.features);
        if (distance <= maxDistance) {
            similar.push({ pattern, distance });
        }
    }
    
    // Sort by distance (closest first)
    similar.sort((a, b) => a.distance - b.distance);
    
    return similar.slice(0, limit);
}

function predictWinProbability(signal, klines) {
    if (ML_PATTERN_DB.length < ML_MIN_PATTERNS) {
        return {
            probability: 50,
            confidence: 'LOW',
            sampleSize: ML_PATTERN_DB.length,
            message: `Need ${ML_MIN_PATTERNS - ML_PATTERN_DB.length} more trades for prediction`
        };
    }
    
    const features = extractSignalFeatures(signal, klines);
    const similar = findSimilarPatterns(features);
    
    if (similar.length < 5) {
        return {
            probability: 50,
            confidence: 'LOW',
            sampleSize: similar.length,
            message: 'Not enough similar patterns'
        };
    }
    
    // Calculate win rate from similar patterns
    let wins = 0;
    let totalPnL = 0;
    let weightedWins = 0;
    let totalWeight = 0;
    
    for (const { pattern, distance } of similar) {
        const weight = 1 / (1 + distance); // Closer patterns have more weight
        totalWeight += weight;
        
        if (pattern.outcome === 'WIN') {
            wins++;
            weightedWins += weight;
        }
        totalPnL += pattern.pnl || 0;
    }
    
    const rawWinRate = (wins / similar.length) * 100;
    const weightedWinRate = (weightedWins / totalWeight) * 100;
    const avgPnL = totalPnL / similar.length;
    
    // Confidence based on sample size and consistency
    let confidence = 'LOW';
    if (similar.length >= 15 && Math.abs(weightedWinRate - 50) > 15) {
        confidence = 'HIGH';
    } else if (similar.length >= 10) {
        confidence = 'MEDIUM';
    }
    
    return {
        probability: Math.round(weightedWinRate),
        rawWinRate: Math.round(rawWinRate),
        confidence,
        sampleSize: similar.length,
        avgPnL: avgPnL.toFixed(2),
        suggestion: weightedWinRate >= 60 ? 'FAVORABLE' : 
                   weightedWinRate <= 40 ? 'UNFAVORABLE' : 'NEUTRAL'
    };
}

function recordTradeOutcome(signal, outcome, pnl) {
    // Record trade for ML learning
    const features = extractSignalFeatures(signal, null);
    
    ML_PATTERN_DB.push({
        features,
        outcome, // 'WIN' or 'LOSS'
        pnl,
        timestamp: Date.now(),
        symbol: signal.symbol,
        tf: signal.tfRaw,
        direction: signal.direction,
        grade: signal.grade
    });
    
    saveMLPatterns();
    console.log(`🤖 ML: Recorded ${outcome} trade. Total patterns: ${ML_PATTERN_DB.length}`);
    
    // V10: Also record to Adaptive Learning system
    recordAdaptiveLearning(signal, outcome, pnl);
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🧠 V10 ADAPTIVE LEARNING - Records trade outcomes per coin/tf/direction
// ═══════════════════════════════════════════════════════════════════════════════

function recordAdaptiveLearning(signal, outcome, pnl) {
    try {
        const learningKey = `${signal.symbol}_${signal.tfRaw || signal.tf}_${signal.direction}`;
        
        // Load existing data
        let learningData = {};
        const saved = localStorage.getItem('bs_learning_v10');
        if (saved) {
            learningData = JSON.parse(saved);
        }
        
        // Initialize if new
        if (!learningData[learningKey]) {
            learningData[learningKey] = {
                wins: 0,
                losses: 0,
                trades: 0,
                totalPnl: 0,
                avgPnl: 0,
                lastTrade: null,
                history: []
            };
        }
        
        const data = learningData[learningKey];
        
        // Update stats
        data.trades++;
        if (outcome === 'WIN') {
            data.wins++;
        } else {
            data.losses++;
        }
        data.totalPnl += pnl || 0;
        data.avgPnl = data.totalPnl / data.trades;
        data.lastTrade = Date.now();
        
        // Keep last 50 trades in history
        data.history.push({
            outcome,
            pnl,
            timestamp: Date.now()
        });
        if (data.history.length > 50) {
            data.history.shift();
        }
        
        // Save back
        localStorage.setItem('bs_learning_v10', JSON.stringify(learningData));
        
        const winRate = ((data.wins / data.trades) * 100).toFixed(0);
        console.log(`🧠 V10 Learning: ${learningKey} - ${winRate}% WR (${data.trades} trades)`);
        
    } catch (e) {
        console.warn('Adaptive learning save error:', e);
    }
}

// Get learning stats for display
function getLearningStats() {
    try {
        const saved = localStorage.getItem('bs_learning_v10');
        if (!saved) return { total: 0, combos: [] };
        
        const learningData = JSON.parse(saved);
        const combos = [];
        let totalTrades = 0;
        
        for (const [key, data] of Object.entries(learningData)) {
            if (data.trades >= 5) {
                const [symbol, tf, dir] = key.split('_');
                const winRate = (data.wins / data.trades * 100).toFixed(0);
                combos.push({
                    key,
                    symbol: symbol.replace('USDT', ''),
                    tf,
                    direction: dir,
                    winRate: parseFloat(winRate),
                    trades: data.trades,
                    avgPnl: data.avgPnl.toFixed(2),
                    status: winRate >= 60 ? 'GOOD' : winRate >= 50 ? 'OK' : 'BAD'
                });
                totalTrades += data.trades;
            }
        }
        
        // Sort by trades (most traded first)
        combos.sort((a, b) => b.trades - a.trades);
        
        return { total: totalTrades, combos };
    } catch (e) {
        return { total: 0, combos: [] };
    }
}

// Clear learning data (reset)
function clearLearningData() {
    if (confirm('Clear all learning data? This cannot be undone.')) {
        localStorage.removeItem('bs_learning_v10');
        alert('Learning data cleared. Scanner will start fresh.');
        console.log('🧠 V10 Learning data cleared');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🎯 PHASE 2-4 COMBINED: ADVANCED SIGNAL ANALYSIS
// ═══════════════════════════════════════════════════════════════════════════════

function getAdvancedAnalysis(signal, klines) {
    const result = {
        volumeProfile: null,
        orderFlow: null,
        mlPrediction: null,
        combinedScore: 0,
        confidence: 'LOW',
        factors: [],
        warnings: []
    };
    
    try {
        // Phase 2: Volume Profile
        result.volumeProfile = analyzeVolumeProfileSignal(klines, signal.price, signal.direction);
        if (result.volumeProfile.valid) {
            result.factors.push(...result.volumeProfile.factors);
        }
        
        // Phase 3: Order Flow
        result.orderFlow = getOrderFlowSignal(klines, signal.direction);
        result.factors.push(...result.orderFlow.factors);
        
        // Phase 4: ML Prediction
        result.mlPrediction = predictWinProbability(signal, klines);
        if (result.mlPrediction.confidence !== 'LOW') {
            if (result.mlPrediction.suggestion === 'FAVORABLE') {
                result.factors.push(`🤖 ML: ${result.mlPrediction.probability}% win rate`);
            } else if (result.mlPrediction.suggestion === 'UNFAVORABLE') {
                result.warnings.push(`⚠️ ML: Only ${result.mlPrediction.probability}% win rate`);
            }
        }
        
        // Calculate combined score
        const vpScore = result.volumeProfile?.score || 50;
        const ofScore = result.orderFlow?.score || 50;
        const mlScore = result.mlPrediction?.probability || 50;
        
        // Weighted combination
        result.combinedScore = Math.round(
            (vpScore * 0.30) +
            (ofScore * 0.35) +
            (mlScore * 0.35)
        );
        
        // Determine overall confidence
        const supports = [
            result.volumeProfile?.support,
            result.orderFlow?.support,
            result.mlPrediction?.suggestion === 'FAVORABLE' ? 'support' : 
            result.mlPrediction?.suggestion === 'UNFAVORABLE' ? 'oppose' : 'neutral'
        ];
        
        const strongSupports = supports.filter(s => s === 'strong' || s === 'support').length;
        const opposes = supports.filter(s => s === 'oppose' || s === 'caution').length;
        
        if (strongSupports >= 2 && opposes === 0) {
            result.confidence = 'HIGH';
        } else if (strongSupports >= 1 && opposes <= 1) {
            result.confidence = 'MEDIUM';
        } else {
            result.confidence = 'LOW';
        }
        
    } catch (e) {
        console.warn('Advanced analysis error:', e);
    }
    
    return result;
}

// Initialize ML on load
initMLSystem();

// ═══════════════════════════════════════════════════════════════════════════════
// V10.3 STRUCTURE ENGINE (FROM QUANTUM CHART)
// ═══════════════════════════════════════════════════════════════════════════════

const StructureEngine = {
    
    // Find swing points for trendline detection
    findSwings: function(klines, period) {
        const swings = { highs: [], lows: [] };
        if (!klines || klines.length < period * 2 + 1) return swings;
        
        for (let i = period; i < klines.length - period; i++) {
            let isHigh = true, isLow = true;
            
            for (let j = 1; j <= period; j++) {
                if (klines[i].high <= klines[i - j].high || klines[i].high <= klines[i + j].high) isHigh = false;
                if (klines[i].low >= klines[i - j].low || klines[i].low >= klines[i + j].low) isLow = false;
            }
            
            if (isHigh) swings.highs.push({ idx: i, price: klines[i].high, time: klines[i].time });
            if (isLow) swings.lows.push({ idx: i, price: klines[i].low, time: klines[i].time });
        }
        
        return swings;
    },
    
    // Build liquidity channel from OBs, zones, and swings
    buildChannel: function(klines, orderBlocks, zones) {
        const result = { isValid: false, upper: null, lower: null, midline: 0, widthPct: 0, score: 0 };
        if (!klines || klines.length < 50) return result;
        
        const currentPrice = klines[klines.length - 1].close;
        const cfg = CONFIG.STRUCTURE.channel;
        
        // Collect all potential boundaries
        const upperBoundaries = [];
        const lowerBoundaries = [];
        
        // Add OBs as boundaries (highest priority)
        if (orderBlocks && orderBlocks.length > 0) {
            orderBlocks.forEach(ob => {
                if (ob.type === 'bear' && ob.bottom > currentPrice) {
                    upperBoundaries.push({ price: ob.bottom, type: 'ob', score: cfg.boundaryScores.ob });
                } else if (ob.type === 'bull' && ob.top < currentPrice) {
                    lowerBoundaries.push({ price: ob.top, type: 'ob', score: cfg.boundaryScores.ob });
                }
            });
        }
        
        // Add zones as boundaries
        if (zones && zones.length > 0) {
            zones.forEach(z => {
                if (z.high > currentPrice) {
                    upperBoundaries.push({ price: z.high, type: 'zone', score: cfg.boundaryScores.zone });
                }
                if (z.low < currentPrice) {
                    lowerBoundaries.push({ price: z.low, type: 'zone', score: cfg.boundaryScores.zone });
                }
            });
        }
        
        // Add swing points as boundaries (lowest priority)
        const swings = this.findSwings(klines, 5);
        swings.highs.slice(-5).forEach(s => {
            if (s.price > currentPrice) {
                upperBoundaries.push({ price: s.price, type: 'swing', score: cfg.boundaryScores.swing });
            }
        });
        swings.lows.slice(-5).forEach(s => {
            if (s.price < currentPrice) {
                lowerBoundaries.push({ price: s.price, type: 'swing', score: cfg.boundaryScores.swing });
            }
        });
        
        // Get best boundaries (closest with highest score)
        upperBoundaries.sort((a, b) => a.price - b.price); // Closest first
        lowerBoundaries.sort((a, b) => b.price - a.price); // Closest first (highest)
        
        const upper = upperBoundaries[0];
        const lower = lowerBoundaries[0];
        
        if (!upper || !lower) return result;
        
        const width = upper.price - lower.price;
        const widthPct = width / currentPrice;
        
        // Validate channel width
        if (widthPct < cfg.minWidth || widthPct > cfg.maxWidth) return result;
        
        result.isValid = true;
        result.upper = upper;
        result.lower = lower;
        result.midline = (upper.price + lower.price) / 2;
        result.widthPct = widthPct;
        result.score = upper.score + lower.score;
        
        return result;
    },
    
    // Detect trendlines
    detectTrendlines: function(klines) {
        const result = { bull: [], bear: [], score: 0 };
        if (!klines || klines.length < 30) return result;
        
        const cfg = CONFIG.STRUCTURE.trendlines;
        
        // Check each swing period
        cfg.swingPeriods.forEach(period => {
            const swings = this.findSwings(klines, period);
            
            // Bullish trendlines (connecting lows)
            if (swings.lows.length >= 2) {
                for (let i = 0; i < swings.lows.length - 1; i++) {
                    for (let j = i + 1; j < swings.lows.length; j++) {
                        const p1 = swings.lows[i];
                        const p2 = swings.lows[j];
                        
                        // Must be ascending
                        if (p2.price > p1.price) {
                            const slope = (p2.price - p1.price) / (p2.idx - p1.idx);
                            let touches = 2;
                            
                            // Count additional touches
                            swings.lows.forEach(s => {
                                if (s.idx !== p1.idx && s.idx !== p2.idx) {
                                    const expectedPrice = p1.price + slope * (s.idx - p1.idx);
                                    if (Math.abs(s.price - expectedPrice) / expectedPrice < 0.005) {
                                        touches++;
                                    }
                                }
                            });
                            
                            if (touches >= cfg.minTouches) {
                                result.bull.push({ p1, p2, slope, touches, period });
                            }
                        }
                    }
                }
            }
            
            // Bearish trendlines (connecting highs)
            if (swings.highs.length >= 2) {
                for (let i = 0; i < swings.highs.length - 1; i++) {
                    for (let j = i + 1; j < swings.highs.length; j++) {
                        const p1 = swings.highs[i];
                        const p2 = swings.highs[j];
                        
                        // Must be descending
                        if (p2.price < p1.price) {
                            const slope = (p2.price - p1.price) / (p2.idx - p1.idx);
                            let touches = 2;
                            
                            swings.highs.forEach(s => {
                                if (s.idx !== p1.idx && s.idx !== p2.idx) {
                                    const expectedPrice = p1.price + slope * (s.idx - p1.idx);
                                    if (Math.abs(s.price - expectedPrice) / expectedPrice < 0.005) {
                                        touches++;
                                    }
                                }
                            });
                            
                            if (touches >= cfg.minTouches) {
                                result.bear.push({ p1, p2, slope, touches, period });
                            }
                        }
                    }
                }
            }
        });
        
        // Sort by touches and keep top N
        result.bull.sort((a, b) => b.touches - a.touches);
        result.bear.sort((a, b) => b.touches - a.touches);
        result.bull = result.bull.slice(0, cfg.maxLines);
        result.bear = result.bear.slice(0, cfg.maxLines);
        
        // Calculate score
        result.score = (result.bull.length + result.bear.length) * 10;
        result.bull.forEach(t => result.score += t.touches * 5);
        result.bear.forEach(t => result.score += t.touches * 5);
        
        return result;
    },
    
    // Detect compression (low volatility)
    detectCompression: function(klines) {
        const result = { isCompressed: false, atr: 0, avgAtr: 0, ratio: 1 };
        if (!klines || klines.length < 30) return result;
        
        const cfg = CONFIG.STRUCTURE.compression;
        const atrValues = [];
        
        for (let i = 1; i < klines.length; i++) {
            const tr = Math.max(
                klines[i].high - klines[i].low,
                Math.abs(klines[i].high - klines[i - 1].close),
                Math.abs(klines[i].low - klines[i - 1].close)
            );
            atrValues.push(tr);
        }
        
        // Current ATR (last 14 periods)
        const recentATR = atrValues.slice(-cfg.atrPeriod);
        result.atr = recentATR.reduce((a, b) => a + b, 0) / recentATR.length;
        
        // Average ATR (full period)
        result.avgAtr = atrValues.reduce((a, b) => a + b, 0) / atrValues.length;
        
        result.ratio = result.atr / result.avgAtr;
        result.isCompressed = result.ratio < cfg.compressionThreshold;
        result.isExpanding = result.ratio > cfg.expansionThreshold;
        
        return result;
    },
    
    // Calculate channel bias (premium/discount/equilibrium)
    calcBias: function(currentPrice, channel) {
        if (!channel || !channel.isValid) return { bias: 'NEUTRAL', position: 0.5, score: 0 };
        
        const cfg = CONFIG.STRUCTURE.bias;
        const range = channel.upper.price - channel.lower.price;
        const position = (currentPrice - channel.lower.price) / range;
        
        let bias = 'EQUILIBRIUM';
        let score = 0;
        
        if (position >= cfg.premiumZone) {
            bias = 'PREMIUM';
            score = -10; // Bearish bias
        } else if (position <= cfg.discountZone) {
            bias = 'DISCOUNT';
            score = 10; // Bullish bias
        } else if (Math.abs(position - 0.5) <= cfg.equilibriumTolerance) {
            bias = 'EQUILIBRIUM';
            score = 0;
        }
        
        return { bias, position, score };
    },
    
    // Main analysis function
    analyze: function(klines, orderBlocks, zones) {
        const result = {
            channel: null,
            trendlines: { bull: [], bear: [] },
            compression: { isCompressed: false },
            bias: 'NEUTRAL',
            biasPosition: 0.5,
            gatePass: true,
            score: 0,
            factors: []
        };
        
        if (!klines || klines.length < 50) return result;
        if (!CONFIG.STRUCTURE.enabled) return result;
        
        const currentPrice = klines[klines.length - 1].close;
        
        // 1. Build channel
        result.channel = this.buildChannel(klines, orderBlocks, zones);
        if (result.channel.isValid) {
            result.score += result.channel.score;
            result.factors.push('Channel ' + (result.channel.widthPct * 100).toFixed(1) + '%');
        }
        
        // 2. Detect trendlines
        result.trendlines = this.detectTrendlines(klines);
        result.score += result.trendlines.score;
        if (result.trendlines.bull.length > 0) result.factors.push('Bull TL x' + result.trendlines.bull.length);
        if (result.trendlines.bear.length > 0) result.factors.push('Bear TL x' + result.trendlines.bear.length);
        
        // 3. Detect compression
        result.compression = this.detectCompression(klines);
        if (result.compression.isCompressed) {
            result.score += 15;
            result.factors.push('Compressed');
        }
        
        // 4. Calculate bias
        const biasResult = this.calcBias(currentPrice, result.channel);
        result.bias = biasResult.bias;
        result.biasPosition = biasResult.position;
        result.score += Math.abs(biasResult.score);
        if (result.bias !== 'EQUILIBRIUM') result.factors.push(result.bias);
        
        // 5. Structure Gate Check
        const gate = CONFIG.STRUCTURE.gate;
        if (gate.enabled) {
            let gatePass = true;
            
            if (gate.requireChannel && !result.channel.isValid) {
                gatePass = false;
            }
            
            if (gate.requireTrendlineOrZone) {
                const hasTrendline = result.trendlines.bull.length > 0 || result.trendlines.bear.length > 0;
                const hasZone = zones && zones.length > 0;
                if (!hasTrendline && !hasZone) {
                    gatePass = false;
                }
            }
            
            result.gatePass = gatePass;
        }
        
        result.score = Math.min(100, result.score);
        return result;
    },
    
    // Check if direction aligns with structure bias
    checkBiasAlignment: function(direction, bias) {
        if (bias === 'EQUILIBRIUM' || bias === 'NEUTRAL') return true;
        if (direction === 'LONG' && bias === 'DISCOUNT') return true;
        if (direction === 'SHORT' && bias === 'PREMIUM') return true;
        return false;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// END STRUCTURE ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

// MASTER SIGNAL ANALYSIS - Combines all three engines (V1 ULTIMATE)
async function analyzeSignal(symbol, tf) {
    try {
        // Fetch klines
        const klines = await fetchKlines(symbol, tf, 200);
        if (!klines || klines.length < 100) return null;
        
        const currentPrice = safeNum(klines[klines.length - 1].close, 0);
        if (currentPrice === 0) return null;
        
        const atr = safeNum(calcATR(klines), currentPrice * 0.02);
        
        // Run all three analyses with safety wrappers
        let zoneAnalysis = { score: 0, direction: null, factors: [], warnings: [], details: {} };
        let smcAnalysis = { score: 0, direction: null, factors: [], warnings: [], details: {} };
        let momentumAnalysis = { score: 0, direction: null, factors: [], warnings: [], details: {} };
        let candlePatterns = { patterns: [], currentCandle: null, behavior: null, strength: 0 };
        
        try {
            zoneAnalysis = await performZoneAnalysis(klines, symbol, tf, currentPrice) || zoneAnalysis;
        } catch (e) { console.warn('Zone analysis error:', e.message); }
        
        try {
            smcAnalysis = performSMCAnalysis(klines, tf) || smcAnalysis;
        } catch (e) { console.warn('SMC analysis error:', e.message); }
        
        try {
            momentumAnalysis = performMomentumAnalysis(klines) || momentumAnalysis;
        } catch (e) { console.warn('Momentum analysis error:', e.message); }
        
        try {
            candlePatterns = analyzeCandlePatterns(klines) || candlePatterns;
        } catch (e) { console.warn('Candle patterns error:', e.message); }
        
        // 📐 V10.3 STRUCTURE ENGINE ANALYSIS (FROM QUANTUM CHART)
        let structureAnalysis = { channel: null, trendlines: { bull: [], bear: [] }, compression: { isCompressed: false }, bias: 'NEUTRAL', gatePass: true, score: 0, factors: [] };
        try {
            const smcOBsForStructure = safeGet(smcAnalysis, 'details.orderBlocks', { bullish: [], bearish: [] });
            const allOBsForStructure = [...safeArr(smcOBsForStructure.bullish), ...safeArr(smcOBsForStructure.bearish)];
            const zonesForStructure = safeGet(zoneAnalysis, 'details.zones', []);
            structureAnalysis = StructureEngine.analyze(klines, allOBsForStructure, zonesForStructure) || structureAnalysis;
        } catch (strErr) {
            console.warn('Structure analysis error:', strErr.message);
        }
        
        // 🎯 GP/OTE ANALYSIS - Advanced Fibonacci Zones (with safety wrap)
        let gpoteAnalysis = { valid: false, score: 0 };
        try {
            const smcOBs = safeGet(smcAnalysis, 'details.orderBlocks', { bullish: [], bearish: [] });
            const smcFVGs = safeGet(smcAnalysis, 'details.fvg', { bullish: [], bearish: [] });
            // Flatten OBs and FVGs for GP/OTE confluence check
            const allOBs = [...safeArr(smcOBs.bullish), ...safeArr(smcOBs.bearish)];
            const allFVGs = [...safeArr(smcFVGs.bullish), ...safeArr(smcFVGs.bearish)];
            gpoteAnalysis = analyzeGPOTE(klines, allOBs, allFVGs) || gpoteAnalysis;
        } catch (gpErr) {
            console.warn('GP/OTE analysis skipped:', gpErr.message);
        }
        
        // Determine primary direction (voting system)
        let votes = { LONG: 0, SHORT: 0 };
        
        // Track individual engine directions for agreement display
        const candleDir = candlePatterns.patternSignal === 'BULLISH' ? 'LONG' : 
                          candlePatterns.patternSignal === 'BEARISH' ? 'SHORT' : 'NEUTRAL';
        const engineDirections = {
            zone: zoneAnalysis.direction,
            smc: smcAnalysis.direction,
            momentum: momentumAnalysis.direction,
            candle: candleDir,
            structure: structureAnalysis.bias === 'DISCOUNT' ? 'LONG' : structureAnalysis.bias === 'PREMIUM' ? 'SHORT' : 'NEUTRAL'
        };
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V5.3 NEW HIERARCHY: HTF → ZONE → SMC → MOMENTUM
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // STEP 1: Get HTF Bias FIRST (this is the KING)
        // We need to know the trend before deciding direction
        let htfDirection = null;
        let htfBias = { aligned: 0, total: 0, score: 50 };
        
        try {
            // Quick HTF check using the entry TF's higher timeframes
            const htfMap = { '5': '60', '15': '60', '30': '240', '60': '240', '240': 'D', 'D': 'D' };
            const htfTF = htfMap[tf] || '240';
            const htfKlines = await fetchKlines(symbol, htfTF, 50);
            
            if (htfKlines && htfKlines.length >= 20) {
                const htfCloses = htfKlines.map(k => k.close);
                const htfEma9 = calcEMA(htfCloses, 9);
                const htfEma21 = calcEMA(htfCloses, 21);
                const htfPrice = htfCloses[htfCloses.length - 1];
                
                // HTF Trend: EMA alignment
                if (htfPrice > htfEma9[htfEma9.length - 1] && htfEma9[htfEma9.length - 1] > htfEma21[htfEma21.length - 1]) {
                    htfDirection = 'LONG';
                    htfBias.score = 75;
                } else if (htfPrice < htfEma9[htfEma9.length - 1] && htfEma9[htfEma9.length - 1] < htfEma21[htfEma21.length - 1]) {
                    htfDirection = 'SHORT';
                    htfBias.score = 75;
                }
            }
        } catch (e) { console.warn('HTF check error:', e.message); }
        
        // STEP 2: DIRECTION DECISION
        let direction = null;
        
        // HTF is KING - if HTF has clear direction, that's our bias
        if (htfDirection) {
            direction = htfDirection;
            
            // STEP 3: Zone must support (or at least not oppose)
            if (zoneAnalysis.direction && zoneAnalysis.direction !== htfDirection) {
                // Zone opposes HTF - SKIP (don't trade against the trend)
                if (zoneAnalysis.score >= 60) {
                    // Strong zone against trend = no trade
                    return null;
                }
                // Weak zone against trend = proceed with caution (HTF wins)
            }
        }
        // If no HTF direction, fall back to Zone + confirmation
        else if (zoneAnalysis.direction && zoneAnalysis.score >= 50) {
            direction = zoneAnalysis.direction;
            // Need at least momentum to confirm
            if (momentumAnalysis.direction && momentumAnalysis.direction !== direction) {
                if (momentumAnalysis.score >= 60) return null; // Strong opposing momentum
            }
        }
        // Last resort: strong momentum with SMC
        else if (momentumAnalysis.direction && momentumAnalysis.score >= 60) {
            if (smcAnalysis.direction === momentumAnalysis.direction) {
                direction = momentumAnalysis.direction;
            }
        }
        
        if (!direction) return null;
        
        // Count how many engines agree with final direction
        let agreed = 0;
        if (zoneAnalysis.direction === direction) agreed++;
        if (smcAnalysis.direction === direction) agreed++;
        if (momentumAnalysis.direction === direction) agreed++;
        if (htfDirection === direction) agreed++;
        
        // Full HTF analysis for display
        htfBias = await analyzeHTFBias(symbol, tf, direction);
        htfBias.htfDirection = htfDirection;
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V1 ULTIMATE - NEW ENGINE INTEGRATIONS
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // 1. SEQUENCE VALIDATION (now with direction)
        const sequenceResult = validateSequence(smcAnalysis, zoneAnalysis, candlePatterns, klines, direction);
        
        // 2. PATTERN-AT-LEVEL CHECK (now with direction)
        const patternAtLevel = checkPatternAtLevel(candlePatterns, zoneAnalysis, smcAnalysis, currentPrice, direction);
        
        // 3. REJECTION SCORE
        const rejectionScore = calculateRejectionScore(klines, zoneAnalysis, smcAnalysis, direction);
        
        // 4. CONFLICT DETECTOR (Enhanced)
        const conflictResult = detectEngineConflicts(zoneAnalysis, smcAnalysis, momentumAnalysis, candlePatterns);
        
        // 5. ZONE OVERRIDE CHECK
        const zoneOverride = checkZoneOverride(zoneAnalysis, smcAnalysis, momentumAnalysis, direction, currentPrice);
        
        // 6. TRAP DETECTION (from candle patterns)
        // FIX #3: Improved trap detection logic
        // Bull Trap = Price broke up but will reverse down (traps longs)
        // Bear Trap = Price broke down but will reverse up (traps shorts)
        const trapPotential = candlePatterns.behavior?.trapPotential || 'LOW';
        const trapDetection = {
            isTrap: trapPotential === 'HIGH',
            type: trapPotential === 'HIGH' ? 
                  (direction === 'LONG' ? 'Bull Trap Risk' : 'Bear Trap Risk') : 'None',
            confidence: trapPotential === 'HIGH' ? 'HIGH' : 
                       trapPotential === 'MEDIUM' ? 'MEDIUM' : 'LOW',
            // Clear warning message
            warning: trapPotential === 'HIGH' ? 
                    `⚠️ HIGH ${direction === 'LONG' ? 'BULL' : 'BEAR'} TRAP RISK - ${direction} position may get trapped!` :
                    trapPotential === 'MEDIUM' ?
                    `⚠️ MEDIUM trap risk detected` : null
        };
        
        // 7. CHECK MANDATORY RULES
        const rulesResult = checkMandatoryRules(
            zoneAnalysis, smcAnalysis, momentumAnalysis, 
            htfBias, conflictResult, zoneOverride, trapDetection
        );
        
        // 8. RULE 5 CHECK - V5.1: Info only, never block
        const momDir = momentumAnalysis.direction || 'NEUTRAL';
        const momOpposing = (direction === 'LONG' && momDir === 'SHORT') || 
                           (direction === 'SHORT' && momDir === 'LONG');
        if (momOpposing && momentumAnalysis.score >= 60) {
            rulesResult.violations.push(`ℹ️ Momentum opposes (${momentumAnalysis.score})`);
            // V5.1: Info only, no blocking
        }
        
        // V5.1: Only NO_TRADE blocks signals
        const shouldSkip = rulesResult.verdict === 'NO_TRADE';
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V1 ULTIMATE - NEW SCORING FORMULA
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // Check volume confirmation
        const avgVolume = klines.slice(-20).reduce((sum, k) => sum + k.volume, 0) / 20;
        const currentVolume = klines[klines.length - 1].volume;
        const volumeConfirmed = currentVolume > avgVolume * 1.2;
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V9.6 SMART MATRIX - DYNAMIC ADAPTIVE WEIGHTING
        // ═══════════════════════════════════════════════════════════════════════════════
        let smartMatrix = null;
        let smartMatrixScore = null;
        try {
            smartMatrix = calculateSmartMatrix(zoneAnalysis, smcAnalysis, momentumAnalysis, klines);
            smartMatrixScore = applySmartMatrixScore(
                zoneAnalysis.score || 0,
                smcAnalysis.score || 0,
                momentumAnalysis.score || 0,
                smartMatrix
            );
        } catch (smErr) {
            console.warn('Smart Matrix error:', smErr.message);
            smartMatrix = {
                weights: { zone: 35, smc: 35, momentum: 30 },
                regime: { regime: 'UNKNOWN', confidence: 0 },
                agreement: { agreement: 'NONE', bonus: 1.0 },
                dominant: 'BALANCED',
                display: 'Z:35% S:35% M:30%'
            };
        }
        
        // Calculate ULTIMATE score
        const ultimateScore = calculateUltimateScore(
            sequenceResult, rejectionScore, htfBias, momentumAnalysis, volumeConfirmed
        );
        
        // Use ULTIMATE score as total score
        let totalScore = ultimateScore.final;
        
        // Add pattern-at-level bonus
        totalScore += patternAtLevel.bonus;
        
        // V10.3: Add Structure Engine bonus/penalty
        if (structureAnalysis && structureAnalysis.score > 0) {
            // Add up to 10 points for strong structure
            totalScore += Math.min(10, structureAnalysis.score * 0.15);
            
            // Bonus for structure-direction alignment
            if ((direction === 'LONG' && structureAnalysis.bias === 'DISCOUNT') ||
                (direction === 'SHORT' && structureAnalysis.bias === 'PREMIUM')) {
                totalScore += 5; // Alignment bonus
            }
            
            // Penalty for opposing structure
            if ((direction === 'LONG' && structureAnalysis.bias === 'PREMIUM') ||
                (direction === 'SHORT' && structureAnalysis.bias === 'DISCOUNT')) {
                totalScore -= 5; // Misalignment penalty
            }
            
            // Compression bonus (potential breakout)
            if (structureAnalysis.compression?.isCompressed) {
                totalScore += 3;
            }
        }
        
        // 🎯 Add GP/OTE bonus if in optimal zone
        if (gpoteAnalysis.valid && gpoteAnalysis.isOptimalEntry) {
            totalScore += gpoteAnalysis.score * 0.3; // Add 30% of GP/OTE score
        }
        
        // Apply conflict penalty (if conflicts exist but not severe enough to skip)
        if (conflictResult.hasConflict && !shouldSkip) {
            totalScore -= conflictResult.conflictCount * 10;
        }
        
        // Ensure score is within bounds
        totalScore = Math.max(0, Math.min(100, Math.round(totalScore)));
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V5.1 SELF-LEARNING ADJUSTMENT
        // ═══════════════════════════════════════════════════════════════════════════════
        let learningData = { adj: 0, confidence: 'N/A', winRate: 0, total: 0 };
        try {
            // Create temp signal for pattern matching
            const tempSignal = { 
                tfRaw: tf, 
                direction, 
                scores: { zone: zoneAnalysis.score, smc: smcAnalysis.score }
            };
            learningData = SelfLearning.getAdjustment(tempSignal);
            totalScore += learningData.adj;
            totalScore = Math.max(0, Math.min(100, Math.round(totalScore)));
        } catch (e) { console.warn('Learning adjustment error:', e); }
        
        // If rules say NO_TRADE, cap the score (V5.1: removed SKIP cap)
        if (rulesResult.verdict === 'NO_TRADE') {
            totalScore = Math.min(totalScore, 30); // Cap at BREWING
        }
        // V5.1: SKIP no longer caps score, just adds warnings
        
        // Determine grade (V1 ULTIMATE thresholds: 90/75/60/45)
        let grade, status;
        if (totalScore >= CONFIG.GRADES.PERFECT) {
            grade = 'PERFECT';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.STRONG) {
            grade = 'STRONG';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.VALID) {
            grade = 'VALID';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.HEATING) {
            grade = 'HEATING';
            status = 'early';
        } else {
            grade = 'BREWING';
            status = 'early';
        }
        
        // Calculate trade levels using SMART TRADE SYSTEM (with safety)
        const adxVal = safeNum(safeGet(momentumAnalysis, 'details.adx.adx', 25), 25);
        
        let smartLevels;
        try {
            smartLevels = calculateSmartTradeLevels(
                currentPrice, 
                direction, 
                atr, 
                klines, 
                safeObj(zoneAnalysis.details), 
                safeObj(smcAnalysis.details), 
                momentumAnalysis,
                candlePatterns
            );
        } catch (levelsErr) {
            console.warn('Smart levels calculation error:', levelsErr.message);
            // Fallback to basic levels
            const fallbackSL = direction === 'LONG' ? currentPrice * 0.98 : currentPrice * 1.02;
            const fallbackTP1 = direction === 'LONG' ? currentPrice * 1.02 : currentPrice * 0.98;
            const fallbackTP2 = direction === 'LONG' ? currentPrice * 1.04 : currentPrice * 0.96;
            const fallbackTP3 = direction === 'LONG' ? currentPrice * 1.06 : currentPrice * 0.94;
            smartLevels = {
                entry: { market: { price: currentPrice } },
                limitEntry: currentPrice,
                limitType: 'MARKET',
                limitConfidence: 50,
                sl: { price: fallbackSL },
                tp1: { price: fallbackTP1 },
                tp2: { price: fallbackTP2 },
                tp3: { price: fallbackTP3 },
                rr: 2.0,
                limitRR: 2.0,
                risk: Math.abs(currentPrice - fallbackSL),
                reward: Math.abs(fallbackTP2 - currentPrice),
                riskPct: 2.0
            };
        }
        
        // Build levels object with backward compatibility (with null safety)
        const levels = {
            entry: safeNum(safeGet(smartLevels, 'entry.market.price', currentPrice), currentPrice),
            limitEntry: safeNum(smartLevels.limitEntry, currentPrice),
            limitType: smartLevels.limitType || 'MARKET',
            limitConfidence: safeNum(smartLevels.limitConfidence, 50),
            sl: safeNum(safeGet(smartLevels, 'sl.price', currentPrice * 0.98), currentPrice * 0.98),
            tp1: safeNum(safeGet(smartLevels, 'tp1.price', currentPrice * 1.02), currentPrice * 1.02),
            tp2: safeNum(safeGet(smartLevels, 'tp2.price', currentPrice * 1.04), currentPrice * 1.04),
            tp3: safeNum(safeGet(smartLevels, 'tp3.price', currentPrice * 1.06), currentPrice * 1.06),
            rr: safeNum(smartLevels.rr, 2.0),
            limitRR: safeNum(smartLevels.limitRR, 2.0),
            risk: safeNum(smartLevels.risk, currentPrice * 0.02),
            reward: safeNum(smartLevels.reward, currentPrice * 0.04),
            riskPct: safeNum(smartLevels.riskPct, 2.0),
            // NEW SMART DATA
            smart: smartLevels
        };
        
        // 🏦 FETCH INSTITUTIONAL DATA (Funding, OI, L/S Ratio)
        let instData = null;
        let instAnalysis = null;
        try {
            instData = await fetchInstitutionalData(symbol, currentPrice);
            instAnalysis = analyzeInstitutionalData(instData, direction);
        } catch(e) {
            console.log('Institutional data fetch skipped:', e.message);
        }
        
        // Combine all factors (MUST be declared BEFORE using)
        const allFactors = [
            ...zoneAnalysis.factors,
            ...smcAnalysis.factors,
            ...momentumAnalysis.factors
        ];
        
        // Add V1 ULTIMATE factors
        if (sequenceResult.completed >= 4) {
            allFactors.push(`Sequence ${sequenceResult.completed}/6 (${sequenceResult.quality})`);
        }
        if (patternAtLevel.atLevel) {
            allFactors.push(patternAtLevel.details);
        }
        if (rejectionScore.score >= 60) {
            allFactors.push(`Rejection Score ${rejectionScore.score}/100 (${rejectionScore.quality})`);
        }
        if (zoneOverride.eligible) {
            allFactors.push('Zone Override Active');
        }
        
        // 🎯 Add GP/OTE factors
        if (gpoteAnalysis && gpoteAnalysis.valid) {
            if (gpoteAnalysis.isInGP) {
                allFactors.push('🎯 IN Golden Pocket');
            } else if (gpoteAnalysis.isInOTE) {
                allFactors.push('📍 IN OTE Zone');
            } else if (gpoteAnalysis.position && gpoteAnalysis.position.GP && gpoteAnalysis.position.GP.status === 'NEAR') {
                allFactors.push('🎯 Near GP');
            }
            // Add confluence factors
            if (gpoteAnalysis.confluence && gpoteAnalysis.confluence.hasConfluence && gpoteAnalysis.confluence.factors) {
                gpoteAnalysis.confluence.factors.forEach(f => {
                    if (f && f.text) allFactors.push(f.text);
                });
            }
            // Add sweep factor
            if (gpoteAnalysis.sweep && gpoteAnalysis.sweep.swept && gpoteAnalysis.sweep.description) {
                allFactors.push('💧 ' + gpoteAnalysis.sweep.description);
            }
        }
        
        const allWarnings = [
            ...zoneAnalysis.warnings,
            ...smcAnalysis.warnings,
            ...momentumAnalysis.warnings
        ];
        
        // Add V1 ULTIMATE warnings
        if (conflictResult.hasConflict) {
            allWarnings.push(...conflictResult.conflicts);
        }
        if (!rulesResult.allPassed) {
            allWarnings.push(...rulesResult.violations);
        }
        if (sequenceResult.completed < 4) {
            allWarnings.push(`Sequence incomplete: ${sequenceResult.completed}/6`);
        }
        if (!patternAtLevel.atLevel && candlePatterns.patterns?.length > 0) {
            allWarnings.push('Pattern not at key level');
        }
        if (rejectionScore.score < 40 && rejectionScore.score > 0) {
            allWarnings.push(`Weak rejection: ${rejectionScore.score}/100`);
        }
        // Add trap warning if exists
        if (trapDetection.warning) {
            allWarnings.push(trapDetection.warning);
        }
        
        // Add institutional factors if available (AFTER declaration)
        if (instAnalysis && instAnalysis.factors) {
            allFactors.push(...instAnalysis.factors);
        }
        if (instAnalysis && instAnalysis.warnings) {
            allWarnings.push(...instAnalysis.warnings);
        }
        
        return {
            symbol,
            tf: CONFIG.TF_LABELS[tf] || tf,
            tfRaw: tf,
            price: currentPrice,
            direction,
            grade,
            status,
            score: totalScore,
            agreed,  // How many engines agreed (2 or 3)
            engineDirections,  // Individual engine directions
            scores: {
                zone: Math.round(zoneAnalysis.score),
                smc: Math.round(smcAnalysis.score),
                momentum: Math.round(momentumAnalysis.score),
                htf: htfBias.score,
                institutional: instAnalysis ? instAnalysis.score : 0,
                // V1 ULTIMATE scores
                sequence: sequenceResult.score,
                rejection: rejectionScore.score,
                patternAtLevel: patternAtLevel.bonus
            },
            // V5.1 SELF-LEARNING DATA
            learning: learningData,
            // V1 ULTIMATE - Score breakdown
            ultimateScore: ultimateScore,
            zone: zoneAnalysis,
            smc: smcAnalysis,
            momentum: momentumAnalysis,
            candlePatterns: candlePatterns,
            htf: htfBias,
            levels,
            // 🏦 Institutional Data
            institutional: instData,
            instAnalysis: instAnalysis,
            factors: allFactors,
            warnings: allWarnings,
            conflicts: conflictResult.conflicts,
            atr,
            // ═══════════════════════════════════════════════════════════════════════════════
            // V1 ULTIMATE - NEW DATA
            // ═══════════════════════════════════════════════════════════════════════════════
            v1Ultimate: {
                sequence: sequenceResult,
                patternAtLevel: patternAtLevel,
                rejectionScore: rejectionScore,
                conflictDetector: conflictResult,
                zoneOverride: zoneOverride,
                trapDetection: trapDetection,
                rulesCheck: rulesResult,
                scoreBreakdown: ultimateScore.breakdown
            },
            // ═══════════════════════════════════════════════════════════════════════════════
            // V10.3 STRUCTURE ENGINE (FROM QUANTUM CHART)
            // ═══════════════════════════════════════════════════════════════════════════════
            structure: structureAnalysis,
            structureGatePass: structureAnalysis.gatePass,
            // ═══════════════════════════════════════════════════════════════════════════════
            // V9.6 SMART MATRIX - DYNAMIC ADAPTIVE WEIGHTING
            // ═══════════════════════════════════════════════════════════════════════════════
            smartMatrix: smartMatrix,
            smartMatrixScore: smartMatrixScore,
            // 🎯 GP/OTE Analysis - Advanced Fibonacci Zones
            gpote: gpoteAnalysis,
            // Coin Relative Strength (RS) vs BTC - calculated on the fly
            coinRS: await calculateCoinRS(symbol, klines),
            // ═══════════════════════════════════════════════════════════════════════════════
            // V9.8 ADVANCED ANALYSIS - VOLUME PROFILE + ORDER FLOW + ML
            // ═══════════════════════════════════════════════════════════════════════════════
            advanced: (() => {
                try {
                    return getAdvancedAnalysis({ symbol, tfRaw: tf, direction, price: currentPrice, score: totalScore, scores: { zone: zoneAnalysis.score, smc: smcAnalysis.score, momentum: momentumAnalysis.score }, agreed, grade }, klines);
                } catch(e) { return null; }
            })()
        };
        
    } catch (error) {
        console.error(`Analysis error for ${symbol} ${tf}:`, error);
        return null;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MULTI-AI PROVIDER SYSTEM (v13 UPGRADE)
// ═══════════════════════════════════════════════════════════════════════════════

// Call Groq AI
async function callGroqAI(prompt) {
    console.log('🚀 Trying Groq AI...');
    
    // Get all valid keys to try
    const validKeys = GROQ_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.groq[item.index]);
    
    if (validKeys.length === 0) {
        console.log('❌ No Groq keys available');
        return null;
    }
    
    // Try each key until one works
    for (let attempt = 0; attempt < validKeys.length; attempt++) {
        const keyItem = validKeys[(currentGroqKeyIndex + attempt) % validKeys.length];
        const apiKey = keyItem.key;
        
        console.log(`🔑 Trying Groq Key #${keyItem.index + 1} (attempt ${attempt + 1}/${validKeys.length})`);
        
        try {
            const response = await fetch(CONFIG.GROQ_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + apiKey
                },
                body: JSON.stringify({
                    model: STATE.aiModel || 'llama-3.3-70b-versatile',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.3,
                    max_tokens: 2000
                })
            });
            
            if (response.status === 429) {
                console.log(`⏳ Groq Key #${keyItem.index + 1} rate limited, trying next key...`);
                KEY_STATUS.groq[keyItem.index] = false;  // Mark as temporarily failed
                continue;  // Try next key
            }
            
            const data = await response.json();
            if (data.error) {
                console.warn(`❌ Groq Key #${keyItem.index + 1} error:`, data.error.message);
                // Auth errors (invalid key) - mark as failed and try next
                if (data.error.code === 'invalid_api_key' || data.error.type === 'invalid_request_error') {
                    KEY_STATUS.groq[keyItem.index] = false;
                }
                continue;  // Try next key
            }
            
            if (data.choices && data.choices[0] && data.choices[0].message) {
                console.log(`✅ Groq Key #${keyItem.index + 1} success!`);
                KEY_STATUS.groq[keyItem.index] = true;  // Mark as working
                currentGroqKeyIndex = (currentGroqKeyIndex + attempt + 1) % validKeys.length;  // Update rotation
                return parseAIResponse(data.choices[0].message.content);
            }
        } catch (error) {
            console.error(`❌ Groq Key #${keyItem.index + 1} request failed:`, error);
            continue;  // Try next key
        }
    }
    
    console.log('❌ All Groq keys exhausted');
    return null;
}

// Call DeepSeek AI
async function callDeepSeekAI(prompt) {
    console.log('🚀 Trying DeepSeek AI...');
    
    // Get all valid keys to try
    const validKeys = DEEPSEEK_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.deepseek[item.index]);
    
    if (validKeys.length === 0) {
        console.log('❌ No DeepSeek keys available');
        return null;
    }
    
    // Try each key until one works
    for (let attempt = 0; attempt < validKeys.length; attempt++) {
        const keyItem = validKeys[(currentDeepSeekKeyIndex + attempt) % validKeys.length];
        const apiKey = keyItem.key;
        
        console.log(`🔑 Trying DeepSeek Key #${keyItem.index + 1} (attempt ${attempt + 1}/${validKeys.length})`);
        
        try {
            const response = await fetch(CONFIG.DEEPSEEK_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + apiKey
                },
                body: JSON.stringify({
                    model: 'deepseek-chat',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.3,
                    max_tokens: 2000
                })
            });
            
            if (response.status === 429) {
                console.log(`⏳ DeepSeek Key #${keyItem.index + 1} rate limited, trying next key...`);
                KEY_STATUS.deepseek[keyItem.index] = false;
                continue;  // Try next key
            }
            
            const data = await response.json();
            if (data.error) {
                console.warn(`❌ DeepSeek Key #${keyItem.index + 1} error:`, data.error.message);
                continue;  // Try next key
            }
            
            if (data.choices && data.choices[0] && data.choices[0].message) {
                console.log(`✅ DeepSeek Key #${keyItem.index + 1} success!`);
                KEY_STATUS.deepseek[keyItem.index] = true;
                currentDeepSeekKeyIndex = (currentDeepSeekKeyIndex + attempt + 1) % validKeys.length;
                return parseAIResponse(data.choices[0].message.content);
            }
        } catch (error) {
            console.error(`❌ DeepSeek Key #${keyItem.index + 1} request failed:`, error);
            continue;  // Try next key
        }
    }
    
    console.log('❌ All DeepSeek keys exhausted');
    return null;
}

// Call Gemini AI
async function callGeminiAI(prompt) {
    console.log('🚀 Trying Gemini AI...');
    
    // Get all valid keys to try
    const validKeys = GEMINI_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.gemini[item.index]);
    
    if (validKeys.length === 0) {
        console.log('❌ No Gemini keys available');
        return null;
    }
    
    // Models to try in order
    const models = [
        'gemini-2.0-flash',
        'gemini-1.5-flash',
        'gemini-1.5-flash-latest'
    ];
    
    // Try each key
    for (let keyAttempt = 0; keyAttempt < validKeys.length; keyAttempt++) {
        const keyItem = validKeys[(currentGeminiKeyIndex + keyAttempt) % validKeys.length];
        const apiKey = keyItem.key;
        
        console.log(`🔑 Trying Gemini Key #${keyItem.index + 1} (key ${keyAttempt + 1}/${validKeys.length})`);
        
        // Try each model with this key
        for (const model of models) {
            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                console.log(`🧠 Trying Gemini ${model}...`);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 2000
                        }
                    })
                });
                
                if (response.status === 429) {
                    console.log(`⏳ Gemini ${model} rate limited, trying next model...`);
                    continue;  // Try next model
                }
                
                if (response.status === 404) {
                    console.log(`⚠️ Model ${model} not found, trying next model...`);
                    continue;  // Try next model
                }
                
                const data = await response.json();
                if (data.error) {
                    console.warn(`❌ Gemini ${model} error:`, data.error.message);
                    // Auth errors mean key is bad, try next key
                    if (data.error.code === 400 || data.error.code === 401 || data.error.code === 403) {
                        KEY_STATUS.gemini[keyItem.index] = false;
                        break;  // Break to try next key
                    }
                    continue;  // Try next model
                }
                
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    console.log(`✅ Gemini ${model} with Key #${keyItem.index + 1} success!`);
                    KEY_STATUS.gemini[keyItem.index] = true;
                    currentGeminiKeyIndex = (currentGeminiKeyIndex + keyAttempt + 1) % validKeys.length;
                    // Update CONFIG to remember working model
                    CONFIG.GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
                    return parseAIResponse(data.candidates[0].content.parts[0].text);
                }
            } catch (error) {
                console.error(`❌ Gemini ${model} request failed:`, error);
                continue;  // Try next model
            }
        }
        // All models failed with this key, try next key
        console.log(`⚠️ All models failed with Key #${keyItem.index + 1}, trying next key...`);
    }
    
    console.log('❌ All Gemini keys and models exhausted');
    return null;
}

// Multi-AI with Auto-Failover (v13 Feature)
async function callMultiAI(prompt) {
    // NOTE: Lock is managed by caller (getAIAnalysis) - DO NOT double-lock here
    console.log('🧠 Multi-AI System Starting...');
    
    try {
        // Try Groq first (free, fast)
        let result = await callGroqAI(prompt);
        if (result) {
            result.aiProvider = 'Groq';
            return result;
        }
        
        // Fallback to DeepSeek (paid, best value)
        result = await callDeepSeekAI(prompt);
        if (result) {
            result.aiProvider = 'DeepSeek';
            return result;
        }
        
        // Final fallback to Gemini (free backup)
        result = await callGeminiAI(prompt);
        if (result) {
            result.aiProvider = 'Gemini';
            return result;
        }
        
        console.error('❌ All AI providers failed');
        toast('All AI providers unavailable', 'error');
        return null;
    } catch (e) {
        console.error('❌ Multi-AI error:', e);
        return null;
    }
}

// Legacy function for backwards compatibility
async function callAI(prompt) {
    return await callMultiAI(prompt);
}

function parseAIResponse(text) {
    console.log('🔄 Parsing AI response...');
    try {
        // Clean up response
        let clean = text.replace(/```json/gi, '').replace(/```/g, '').trim();
        const match = clean.match(/\{[\s\S]*\}/);
        
        if (match) {
            console.log('📋 Found JSON in response');
            const parsed = JSON.parse(match[0]);
            console.log('✅ JSON parsed successfully');
            console.log('📊 Parsed fields:', Object.keys(parsed).join(', '));
            
            return {
                // Core fields
                myDirection: parsed.myDirection || null,
                agreesWithScanner: parsed.agreesWithScanner !== undefined ? parsed.agreesWithScanner : true,
                confidence: Math.min(100, Math.max(0, parsed.confidence || 50)),
                verdict: ['NO_TRADE', 'TAKE', 'SKIP', 'WAIT'].includes(parsed.verdict) ? parsed.verdict : 'WAIT',
                entryType: parsed.entryType || 'NONE',
                
                // Rules check
                rulesCheck: parsed.rulesCheck || null,
                
                // Summary
                executiveSummary: parsed.executiveSummary || '',
                whyDisagree: parsed.whyDisagree || null,
                reasoning: parsed.executiveSummary || 'Analysis complete',
                
                // Confluence Counter
                confluenceCounter: parsed.confluenceCounter || null,
                
                // Trap Detection
                trapDetection: parsed.trapDetection || null,
                
                // Entry Timing
                entryTiming: parsed.entryTiming || null,
                
                // Zone Analysis
                zoneAnalysis: parsed.zoneAnalysis || null,
                
                // SMC Analysis
                smcAnalysis: parsed.smcAnalysis || null,
                
                // Momentum Analysis
                momentumAnalysis: parsed.momentumAnalysis || null,
                
                // Trade Plan (includes add-ons, leverage, size)
                tradePlan: parsed.tradePlan || null,
                
                // Risk Assessment
                riskAssessment: parsed.riskAssessment || null,
                
                // Action Plan
                actionPlan: parsed.actionPlan || null,
                
                // Legacy fields (keep for backward compatibility)
                candlePatternAnalysis: parsed.candlePatternAnalysis || null,
                leverageRecommendation: parsed.leverageRecommendation || null,
                professionalNotes: parsed.professionalNotes || '',
                marketContext: parsed.marketContext || '',
                tradeManagement: parsed.tradeManagement || null,
                risks: Array.isArray(parsed.risks) ? parsed.risks : [],
                suggestions: Array.isArray(parsed.suggestions) ? parsed.suggestions : [],
                leverageAdvice: parsed.leverageAdvice || '',
                
                // Saved Trade AI fields (for progress updates)
                commentary: parsed.commentary || null,
                recommendation: parsed.recommendation || null,
                moveSlToBE: parsed.moveSlToBE || false,
                warnings: Array.isArray(parsed.warnings) ? parsed.warnings : []
            };
        } else {
            console.warn('⚠️ No JSON found in response');
            console.log('📄 Raw text:', text.substring(0, 500));
        }
    } catch (e) {
        console.error('❌ AI parse error:', e);
        console.log('📄 Failed text:', text.substring(0, 500));
    }
    
    // Default response when parsing fails
    return {
        myDirection: null,
        agreesWithScanner: true,
        confidence: 50,
        verdict: 'WAIT',
        entryType: 'NONE',
        rulesCheck: null,
        reasoning: 'Could not parse AI response',
        executiveSummary: '',
        whyDisagree: null,
        confluenceCounter: null,
        trapDetection: null,
        entryTiming: null,
        zoneAnalysis: null,
        smcAnalysis: null,
        momentumAnalysis: null,
        tradePlan: null,
        riskAssessment: null,
        actionPlan: null,
        candlePatternAnalysis: null,
        leverageRecommendation: null,
        professionalNotes: '',
        marketContext: '',
        tradeManagement: null,
        risks: [],
        suggestions: [],
        leverageAdvice: '',
        // Saved Trade AI fields
        commentary: null,
        recommendation: null,
        moveSlToBE: false,
        warnings: []
    };
}

async function getAIAnalysis(signal) {
    if (!signal || !STATE.aiKey) return null;
    
    // SAFETY: Prevent concurrent AI calls
    if (STATE.aiCallInProgress) {
        console.warn('⚠️ AI call already in progress');
        toast('AI analysis in progress...', 'warning');
        return null;
    }
    
    STATE.aiCallInProgress = true;
    
    try {
        // Safe helper functions to prevent undefined errors
        const sf = (val, decimals = 2) => {
            if (val === undefined || val === null || isNaN(val)) return 'N/A';
            return Number(val).toFixed(decimals);
        };
        const ss = (val, fallback = 'N/A') => val !== undefined && val !== null ? val : fallback;
        
        // Safe object access
        const levels = signal.levels || {};
        const smc = signal.smc || {};
        const smcD = smc.details || {};
        const zone = signal.zone || {};
        const zoneD = zone.details || {};
        const mom = signal.momentum || {};
        const momD = mom.details || {};
        const htf = signal.htf || {};
        const scores = signal.scores || {};
        const candle = signal.candlePatterns || {};
        const candleC = candle.currentCandle || {};
        const candleB = candle.behavior || {};
        
        // Pre-calculate engine directions (treat score < 30 as NEUTRAL)
        const zoneDir = scores.zone >= 30 ? (zone.direction || 'NEUTRAL') : 'NEUTRAL';
        const smcDir = scores.smc >= 30 ? (smc.direction || 'NEUTRAL') : 'NEUTRAL';
        const momDir = scores.momentum >= 30 ? (mom.direction || 'NEUTRAL') : 'NEUTRAL';
        const candleDir = candle.patternSignal || 'NEUTRAL';
        
        // Count directions
        const dirs = [zoneDir, smcDir, momDir, candleDir];
        const longCount = dirs.filter(d => d === 'LONG' || d === 'BULLISH').length;
        const shortCount = dirs.filter(d => d === 'SHORT' || d === 'BEARISH').length;
        const neutralCount = dirs.filter(d => d === 'NEUTRAL' || d === null).length;
        
        // Pre-calculate conflicts
        const conflicts = [];
        if (zoneDir !== 'NEUTRAL' && zoneDir !== signal.direction) conflicts.push('Zone opposes scanner');
        if (smcDir !== 'NEUTRAL' && smcDir !== signal.direction) conflicts.push('SMC opposes scanner');
        if (momDir !== 'NEUTRAL' && momDir !== signal.direction) conflicts.push('Momentum opposes scanner');
        if (candleDir !== 'NEUTRAL' && candleDir !== signal.direction && candleDir !== 'BULLISH' && candleDir !== 'BEARISH') conflicts.push('Candle pattern opposes');
        
        // Pre-calculate rule violations
    const ruleViolations = [];
    if (scores.smc < 20) ruleViolations.push('RULE 1 VIOLATED: SMC < 20 (score: ' + scores.smc + ') → NO_TRADE');
    if (scores.smc >= 20 && scores.smc < 30) ruleViolations.push('RULE 2 WARNING: SMC < 30 (score: ' + scores.smc + ') → SKIP unless Zone Override');
    if (conflicts.length >= 2) ruleViolations.push('RULE 3 VIOLATED: 2+ engines conflict → SKIP');
    if (neutralCount >= 3) ruleViolations.push('RULE 4 WARNING: 2+ engines NEUTRAL → WAIT');
    if (momDir !== 'NEUTRAL' && momDir !== signal.direction && scores.momentum >= 50) ruleViolations.push('RULE 5 VIOLATED: Strong momentum opposes → SKIP');
    const htfPct = htf.total > 0 ? (htf.aligned / htf.total) * 100 : 0;
    if (htfPct < 50) ruleViolations.push('RULE 6 VIOLATED: HTF < 50% (' + htfPct.toFixed(0) + '%) → SKIP');
    
    // Check Zone Override eligibility
    const supportDist = zoneD.nearestSupport ? Math.abs(signal.price - zoneD.nearestSupport.price) / signal.price * 100 : 999;
    const resistDist = zoneD.nearestResistance ? Math.abs(signal.price - zoneD.nearestResistance.price) / signal.price * 100 : 999;
    const atSupport = supportDist <= 1;
    const atResistance = resistDist <= 1;
    const zoneOverrideEligible = scores.zone >= 75 && 
        ((signal.direction === 'LONG' && atSupport && (zoneD.nearestSupport?.touches || 0) >= 3) ||
         (signal.direction === 'SHORT' && atResistance && (zoneD.nearestResistance?.touches || 0) >= 3)) &&
        !(momDir !== 'NEUTRAL' && momDir !== signal.direction && scores.momentum >= 60);
    
    const prompt = `You are an INDEPENDENT institutional crypto trading analyst. You must form YOUR OWN opinion.

═══════════════════════════════════════════════════════════════════════════════
⚠️ CRITICAL: YOU ARE INDEPENDENT - DO NOT BLINDLY FOLLOW SCANNER
═══════════════════════════════════════════════════════════════════════════════

The scanner has suggested a direction. But YOU must:
1. Analyze ALL raw data independently
2. Form YOUR OWN direction based on evidence
3. DISAGREE with scanner if data doesn't support it
4. Follow the MANDATORY RULES below

═══════════════════════════════════════════════════════════════════════════════
MANDATORY RULES (YOU MUST FOLLOW - NO EXCEPTIONS)
═══════════════════════════════════════════════════════════════════════════════

RULE 1: SMC < 20 → NO_TRADE (unless Zone Override applies)
RULE 2: SMC < 30 → SKIP (unless Zone Override applies)
RULE 3: 2+ engines oppose scanner direction → SKIP
RULE 4: 2+ engines NEUTRAL (no direction) → WAIT
RULE 5: Momentum opposes scanner AND momentum score ≥ 50 → SKIP
RULE 6: HTF alignment < 50% → SKIP
RULE 7: Trap detected with HIGH confidence → NO_TRADE

ZONE OVERRIDE (Exception to Rules 1-2):
Can override IF ALL of these are true:
✓ Zone Score ≥ 75
✓ Price within 1% of zone
✓ Zone has 3+ touches
✓ Zone direction matches scanner
✓ Momentum NOT strongly opposing (score < 60 if opposing)

═══════════════════════════════════════════════════════════════════════════════
PRE-CALCULATED RULE CHECK (by scanner)
═══════════════════════════════════════════════════════════════════════════════
${ruleViolations.length > 0 ? '🚨 VIOLATIONS DETECTED:\n' + ruleViolations.map(r => '• ' + r).join('\n') : '✅ No rule violations detected'}

Zone Override Eligible: ${zoneOverrideEligible ? 'YES ✅' : 'NO ❌'}
${zoneOverrideEligible ? '→ Zone Override allows entry despite weak SMC' : ''}

═══════════════════════════════════════════════════════════════════════════════
ENGINE DIRECTIONS (Score < 30 = Treated as NEUTRAL)
═══════════════════════════════════════════════════════════════════════════════
┌──────────────┬───────────┬────────┬─────────────────────────────┐
│ Engine       │ Direction │ Score  │ Status                      │
├──────────────┼───────────┼────────┼─────────────────────────────┤
│ Zone         │ ${zoneDir.padEnd(9)} │ ${String(scores.zone || 0).padEnd(6)} │ ${scores.zone >= 30 ? 'Reliable' : '⚠️ Weak (ignored)'} │
│ SMC          │ ${smcDir.padEnd(9)} │ ${String(scores.smc || 0).padEnd(6)} │ ${scores.smc >= 30 ? 'Reliable' : scores.smc < 20 ? '⛔ Critical' : '⚠️ Weak'} │
│ Momentum     │ ${momDir.padEnd(9)} │ ${String(scores.momentum || 0).padEnd(6)} │ ${scores.momentum >= 30 ? 'Reliable' : '⚠️ Weak (ignored)'} │
│ Candle       │ ${candleDir.padEnd(9)} │ ${String(candle.strength || 0).padEnd(6)} │ ${candle.strength >= 30 ? 'Reliable' : 'Weak'} │
└──────────────┴───────────┴────────┴─────────────────────────────┘

Scanner Direction: ${signal.direction}
Agreement: LONG=${longCount} | SHORT=${shortCount} | NEUTRAL=${neutralCount}
Conflicts: ${conflicts.length > 0 ? conflicts.join(', ') : 'None'}

═══════════════════════════════════════════════════════════════════════════════
SIGNAL DATA
═══════════════════════════════════════════════════════════════════════════════
Asset: ${ss(signal.symbol)}
Timeframe: ${ss(signal.tf)}
Current Price: $${ss(signal.price)}
Overall Grade: ${ss(signal.grade)} (${ss(signal.score, 0)}/100)
Warnings: ${signal.warnings?.length > 0 ? signal.warnings.join(', ') : 'None'}

═══════════════════════════════════════════════════════════════════════════════
ZONE DATA
═══════════════════════════════════════════════════════════════════════════════
Zone Score: ${scores.zone}/100
Zone Status: ${ss(zone.status)} ${atSupport ? '🎯 AT SUPPORT!' : atResistance ? '🎯 AT RESISTANCE!' : ''}

Support: ${zoneD.nearestSupport ? '$' + sf(zoneD.nearestSupport.price, 4) + ' (Strength: ' + (zoneD.nearestSupport.strength || 'N/A') + ', Touches: ' + (zoneD.nearestSupport.touches || 'N/A') + ', Distance: ' + sf(supportDist, 2) + '%)' : 'N/A'}
Resistance: ${zoneD.nearestResistance ? '$' + sf(zoneD.nearestResistance.price, 4) + ' (Strength: ' + (zoneD.nearestResistance.strength || 'N/A') + ', Touches: ' + (zoneD.nearestResistance.touches || 'N/A') + ', Distance: ' + sf(resistDist, 2) + '%)' : 'N/A'}

═══════════════════════════════════════════════════════════════════════════════
SMC DATA
═══════════════════════════════════════════════════════════════════════════════
SMC Score: ${scores.smc}/100 ${scores.smc < 20 ? '⛔ CRITICAL - NO STRUCTURE' : scores.smc < 30 ? '⚠️ WEAK' : ''}
Structure: ${smcD.structure ? ss(smcD.structure.trend) : 'N/A'}
Trigger: ${ss(smc.trigger, 'None')}
Order Blocks: ${smcD.orderBlocks ? 'Bull: ' + (smcD.orderBlocks.bullish?.length || 0) + ' Bear: ' + (smcD.orderBlocks.bearish?.length || 0) : 'N/A'}
FVGs: ${smcD.fvg ? 'Bull: ' + (smcD.fvg.bullish?.length || 0) + ' Bear: ' + (smcD.fvg.bearish?.length || 0) : 'N/A'}

═══════════════════════════════════════════════════════════════════════════════
MOMENTUM DATA
═══════════════════════════════════════════════════════════════════════════════
Momentum Score: ${scores.momentum}/100
Momentum Direction: ${momDir} ${momDir !== 'NEUTRAL' && momDir !== signal.direction ? '⚠️ OPPOSES SCANNER!' : ''}
RSI: ${momD.rsi ? sf(momD.rsi.value, 1) + ' (' + ss(momD.rsi.trend) + ')' : 'N/A'}
MACD: ${momD.macd ? ss(momD.macd.trend) + (momD.macd.crossover ? ' ' + momD.macd.crossover : '') : 'N/A'}
StochRSI: ${momD.stochRSI ? 'K:' + sf(momD.stochRSI.k, 1) + ' D:' + sf(momD.stochRSI.d, 1) : 'N/A'}

═══════════════════════════════════════════════════════════════════════════════
CANDLE PATTERN DATA
═══════════════════════════════════════════════════════════════════════════════
Current Candle: ${ss(candleC.type, 'Unknown')}
Pattern Signal: ${candleDir} ${candleDir !== 'NEUTRAL' && candleDir !== signal.direction ? '⚠️ OPPOSES SCANNER!' : ''}
Patterns: ${candle.patterns?.length > 0 ? candle.patterns.map(p => p.name + ' (' + p.signal + ')').join(', ') : 'None'}
Who's In Control: ${ss(candleB.control, 'Unknown')}
controlBuyers: ${candle.controlBuyers ? 'TRUE ✅' : 'FALSE'}
controlSellers: ${candle.controlSellers ? 'TRUE ✅' : 'FALSE'}
Trap Potential: ${ss(candleB.trapPotential, 'Low')}
${signal.v1Ultimate?.trapDetection?.warning ? '🚨 ' + signal.v1Ultimate.trapDetection.warning : ''}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - SEQUENCE VALIDATION (NEW!)
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Sequence State: ${signal.v1Ultimate.sequence.state}
Sequence Score: ${signal.v1Ultimate.sequence.score}/100
Steps Completed: ${signal.v1Ultimate.sequence.completed}/${signal.v1Ultimate.sequence.total}
Sequence Quality: ${signal.v1Ultimate.sequence.quality}

Steps:
• Sweep: ${signal.v1Ultimate.sequence.steps.sweep ? '✅' : '❌'}
• BOS/CHoCH: ${signal.v1Ultimate.sequence.steps.bos ? '✅' : '❌'}
• FVG: ${signal.v1Ultimate.sequence.steps.fvg ? '✅' : '❌'}
• Order Block: ${signal.v1Ultimate.sequence.steps.ob ? '✅' : '❌'}
• Pullback to POI: ${signal.v1Ultimate.sequence.steps.pullback ? '✅' : '❌'}
• Pattern at POI: ${signal.v1Ultimate.sequence.steps.pattern ? '✅' : '❌'}
` : 'Sequence data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - PATTERN-AT-LEVEL (NEW!)
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Pattern at Level: ${signal.v1Ultimate.patternAtLevel.atLevel ? 'YES ✅' : 'NO ❌'}
Level Type: ${signal.v1Ultimate.patternAtLevel.levelType}
Distance: ${signal.v1Ultimate.patternAtLevel.distancePercent?.toFixed(2) || 'N/A'}%
Bonus Points: +${signal.v1Ultimate.patternAtLevel.bonus}
Details: ${signal.v1Ultimate.patternAtLevel.details}
` : 'Pattern-at-Level data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - REJECTION SCORE (NEW!)
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Rejection Score: ${signal.v1Ultimate.rejectionScore.score}/100
Rejection Quality: ${signal.v1Ultimate.rejectionScore.quality}

Breakdown:
• Wick Touch: +${signal.v1Ultimate.rejectionScore.breakdown.wickTouch}
• Body Closed: +${signal.v1Ultimate.rejectionScore.breakdown.bodyClosed}
• Wick Ratio: +${signal.v1Ultimate.rejectionScore.breakdown.wickRatio}
• Volume Confirm: +${signal.v1Ultimate.rejectionScore.breakdown.volumeConfirm}
• Follow Through: +${signal.v1Ultimate.rejectionScore.breakdown.followThrough}
` : 'Rejection Score data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - ZONE OVERRIDE STATUS
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Zone Override Eligible: ${signal.v1Ultimate.zoneOverride.eligible ? 'YES ✅' : 'NO ❌'}
Conditions Passed: ${signal.v1Ultimate.zoneOverride.passed}/${signal.v1Ultimate.zoneOverride.required}
Reason: ${signal.v1Ultimate.zoneOverride.reason}
` : 'Zone Override data not available'}

═══════════════════════════════════════════════════════════════════════════════
V10.3 STRUCTURE ENGINE (Quantum Chart Integration)
═══════════════════════════════════════════════════════════════════════════════
${signal.structure ? `
Structure Score: ${signal.structure.score}/100
Structure Gate: ${signal.structureGatePass ? 'PASS ✅' : 'FAIL ❌'}

• Channel: ${signal.structure.channel?.isValid ? 'VALID (' + (signal.structure.channel.widthPct * 100).toFixed(1) + '% width)' : 'NO CHANNEL'}
• Trendlines: Bull: ${signal.structure.trendlines?.bull?.length || 0} | Bear: ${signal.structure.trendlines?.bear?.length || 0}
• Compression: ${signal.structure.compression?.isCompressed ? 'YES (ready to expand)' : signal.structure.compression?.isExpanding ? 'EXPANDING' : 'NO'}
• Bias: ${signal.structure.bias || 'NEUTRAL'} ${signal.structure.bias === 'DISCOUNT' && signal.direction === 'LONG' ? '✅ ALIGNED' : signal.structure.bias === 'PREMIUM' && signal.direction === 'SHORT' ? '✅ ALIGNED' : signal.structure.bias === 'EQUILIBRIUM' ? '⚖️ NEUTRAL' : '⚠️ CHECK'}
• Position: ${((signal.structure.biasPosition || 0.5) * 100).toFixed(0)}% of channel (0%=bottom, 100%=top)
• Factors: ${signal.structure.factors?.join(', ') || 'None'}
` : 'Structure data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - SCORE BREAKDOWN
═══════════════════════════════════════════════════════════════════════════════
${signal.ultimateScore ? `
FINAL SCORE: ${signal.score}/100

Components:
• Sequence (40%): ${signal.ultimateScore.breakdown.sequence.raw} → ${signal.ultimateScore.breakdown.sequence.weighted}
• Rejection (25%): ${signal.ultimateScore.breakdown.rejection.raw} → ${signal.ultimateScore.breakdown.rejection.weighted}
• HTF (15%): ${signal.ultimateScore.breakdown.htf.raw} → ${signal.ultimateScore.breakdown.htf.weighted}
• Momentum (10%): ${signal.ultimateScore.breakdown.momentum.raw} → ${signal.ultimateScore.breakdown.momentum.weighted}
• Volume (10%): ${signal.ultimateScore.breakdown.volume.raw} → ${signal.ultimateScore.breakdown.volume.weighted}
` : 'Score breakdown not available'}

═══════════════════════════════════════════════════════════════════════════════
HTF BIAS
═══════════════════════════════════════════════════════════════════════════════
${htf.bias ? Object.entries(htf.bias).map(([t, b]) => t + ':' + b).join(' | ') : 'N/A'}
Alignment: ${ss(htf.aligned, 0)}/${ss(htf.total, 0)} (${htfPct.toFixed(0)}%) ${htfPct < 50 ? '⚠️ BELOW 50%!' : ''}

═══════════════════════════════════════════════════════════════════════════════
MARKET ENVIRONMENT (Global Conditions)
═══════════════════════════════════════════════════════════════════════════════
${signal.environment ? `
Environment Score: ${signal.environment.score}/100 (${signal.environment.verdict})

• BTC Trend: ${STATE.environment.btcTrend?.direction || 'N/A'} ${(signal.direction === 'LONG' && STATE.environment.btcTrend?.direction === 'BULLISH') || (signal.direction === 'SHORT' && STATE.environment.btcTrend?.direction === 'BEARISH') ? '✅ ALIGNED' : STATE.environment.btcTrend?.direction === 'FLAT' ? '⚠️ FLAT' : '❌ CONFLICTS'}
• BTC.D Trend: ${STATE.environment.btcDominance?.trend || 'N/A'} ${(signal.direction === 'LONG' && STATE.environment.btcDominance?.trend === 'FALLING') || (signal.direction === 'SHORT' && STATE.environment.btcDominance?.trend === 'RISING') ? '✅ FAVORABLE' : STATE.environment.btcDominance?.trend === 'FLAT' ? '⚠️ NEUTRAL' : '❌ UNFAVORABLE'}
• DXY: ${STATE.environment.dxy?.value?.toFixed(1) || 'N/A'} ${STATE.environment.dxy?.trend || 'N/A'} ${STATE.environment.dxy?.trend === 'FALLING' ? '✅ GOOD' : STATE.environment.dxy?.trend === 'RISING' ? '⚠️ RISK-OFF' : ''}
• BTC Structure: ${STATE.environment.btcStructure?.status || 'N/A'} ${STATE.environment.btcStructure?.status === 'INTACT' ? '✅' : STATE.environment.btcStructure?.status === 'BROKEN_DOWN' && signal.direction === 'LONG' ? '❌ DANGEROUS' : '⚠️'}
• BTC RSI: ${STATE.environment.btcRSI?.value || 'N/A'} (${STATE.environment.btcRSI?.status || 'N/A'}) ${STATE.environment.btcRSI?.status === 'HEALTHY' ? '✅' : '⚠️ EXTENDED'}
• Funding: ${STATE.environment.funding?.rate ? (STATE.environment.funding.rate * 100).toFixed(3) + '%' : 'N/A'} (${STATE.environment.funding?.status || 'N/A'}) ${STATE.environment.funding?.status === 'EXTREME' && ((signal.direction === 'LONG' && STATE.environment.funding?.rate > 0) || (signal.direction === 'SHORT' && STATE.environment.funding?.rate < 0)) ? '❌ EXTREME AGAINST' : STATE.environment.funding?.status === 'NORMAL' ? '✅' : '⚠️'}

ENVIRONMENT VERDICT: ${signal.environment.verdict} ${signal.environment.verdict === 'GO' ? '✅ Favorable for ' + signal.direction : signal.environment.verdict === 'CAUTION' ? '⚠️ Proceed with caution' : signal.environment.verdict === 'RISKY' ? '🟠 High risk' : '❌ Unfavorable'}
` : 'Environment data not available'}

YOU MUST FACTOR ENVIRONMENT INTO YOUR DECISION:
• If Environment is NO-GO and signal is otherwise valid → WAIT or SKIP
• If Environment conflicts (BTC against direction) → Reduce confidence
• If Funding is EXTREME against direction → Strong caution or SKIP

═══════════════════════════════════════════════════════════════════════════════
SCANNER TRADE LEVELS (for reference)
═══════════════════════════════════════════════════════════════════════════════
Entry: $${sf(levels.entry, 4)}
SL: $${sf(levels.sl, 4)} (${ss(levels.riskPct)}%)
TP1: $${sf(levels.tp1, 4)} | TP2: $${sf(levels.tp2, 4)} | TP3: $${sf(levels.tp3, 4)}
R:R = 1:${ss(levels.rr)}

═══════════════════════════════════════════════════════════════════════════════
YOUR TASK
═══════════════════════════════════════════════════════════════════════════════

STEP 1: Form YOUR OWN direction based on engine data (ignore scanner initially)
STEP 2: Check if any MANDATORY RULES are violated
STEP 3: If Zone Override applies, you may proceed despite weak SMC
STEP 4: Compare YOUR direction with scanner - agree or disagree
STEP 5: Give final verdict: NO_TRADE / SKIP / WAIT / TAKE

ADD-ON LEVELS RULE (CRITICAL):
• For LONG: Add-on levels must be BELOW entry (buy dips)
• For SHORT: Add-on levels must be ABOVE entry (sell rips)

ENTRY TYPE:
• ZONE ENTRY (at strong zone, before confirmation): 50% size, 3-5x leverage
• CONFIRMED ENTRY (all engines agree): 100% size, 5-10x leverage

Respond ONLY with this JSON:
{
  "myDirection": "LONG" or "SHORT" or "NO_TRADE",
  "agreesWithScanner": true or false,
  "confidence": 0-100,
  "verdict": "NO_TRADE" or "SKIP" or "WAIT" or "TAKE",
  "entryType": "ZONE_ENTRY" or "CONFIRMED" or "NONE",
  "rulesCheck": {
    "smcRule": "PASS/FAIL - explanation",
    "conflictRule": "PASS/FAIL - explanation",
    "htfRule": "PASS/FAIL - explanation",
    "zoneOverride": "APPLIED/NOT_NEEDED/NOT_ELIGIBLE"
  },
  "executiveSummary": "2-3 sentences explaining your decision",
  "whyDisagree": "if you disagree with scanner, explain why (or null)",
  "confluenceCounter": {
    "alignedFactors": ["factor1", "factor2"],
    "conflictingFactors": ["conflict1", "conflict2"],
    "score": "X aligned vs Y conflicting"
  },
  "trapDetection": {
    "isTrap": true or false,
    "trapType": "None/Bull Trap/Bear Trap/Fakeout",
    "warning": "explanation"
  },
  "entryTiming": {
    "timing": "OPTIMAL/GOOD/SUBOPTIMAL/TOO_LATE",
    "recommendation": "Enter now/Wait for pullback/Skip"
  },
  "zoneAnalysis": {
    "quality": "Strong/Moderate/Weak/None",
    "pricePosition": "At Support/At Resistance/Mid-range"
  },
  "smcAnalysis": {
    "validity": "Valid/Weak/Invalid",
    "assessment": "your assessment"
  },
  "momentumAnalysis": {
    "direction": "Bullish/Bearish/Neutral",
    "alignsWithTrade": true or false
  },
  "tradePlan": {
    "entry": "price or NONE",
    "sl": "price",
    "tp1": "price",
    "tp2": "price",
    "tp3": "price",
    "addOnLevels": ["price1 - reason", "price2 - reason"],
    "positionSize": "50% or 100%",
    "leverage": "Xx-Xx"
  },
  "environmentAssessment": {
    "agrees": true or false,
    "concerns": ["concern1", "concern2"],
    "recommendation": "How environment affects this trade"
  },
  "riskAssessment": {
    "level": "Low/Medium/High/Extreme",
    "risks": ["risk1", "risk2"],
    "invalidation": "price that kills the trade"
  },
  "actionPlan": {
    "action": "what to do now",
    "conditions": "conditions to meet",
    "avoid": "what NOT to do"
  }
}`;

        return await callMultiAI(prompt);
    } finally {
        // SAFETY: Always release AI lock
        STATE.aiCallInProgress = false;
    }
}
// ═══════════════════════════════════════════════════════════════════════════════
// SCANNER ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

async function runScanner() {
    // 🛡️ HARDENING: Check if we can scan (error pause check)
    if (typeof Hardening !== 'undefined' && !Hardening.canScan()) {
        const stats = Hardening.getErrorStats();
        console.warn(`🛑 Scanning paused. Resume in ${Math.ceil(stats.resumeIn/1000)}s`);
        return;
    }
    
    // 🛡️ HARDENING: Acquire mutex lock
    if (typeof Hardening !== 'undefined') {
        const gotLock = await Hardening.acquireScanLock(5000);
        if (!gotLock) {
            console.warn('⚠️ Could not acquire scan lock');
            return;
        }
    }
    
    // SAFETY: Prevent concurrent scans
    if (STATE.scanInProgress) {
        console.warn('⚠️ Scan already in progress');
        toast('Scan already running...', 'warning');
        if (typeof Hardening !== 'undefined') Hardening.releaseScanLock();
        return;
    }
    
    if (!STATE.scanning) {
        if (typeof Hardening !== 'undefined') Hardening.releaseScanLock();
        return;
    }
    
    STATE.scanInProgress = true;  // Lock
    
    try {
        // 🛡️ HARDENING: Run memory cleanup
        if (typeof Hardening !== 'undefined') Hardening.cleanup();
        
        // UPDATE ENVIRONMENT FIRST
        await updateEnvironment();
        
        // Store previous signals for comparison (for status badges)
        STATE.previousSignals = [...STATE.signals];
        
        const signals = [];
        const filteredSignals = [];  // Signals blocked by environment
        
        let coins = CONFIG.COINS.length > 0 ? CONFIG.COINS : CONFIG.ALL_COINS.slice(0, STATE.coinCount);
        
        // SAFETY: Limit max coins per scan
        const maxCoins = CONFIG.SAFETY?.MAX_COINS_PER_SCAN || 300;
        if (coins.length > maxCoins) {
            console.warn(`⚠️ Limiting coins from ${coins.length} to ${maxCoins}`);
            toast(`⚠️ Coin limit: Scanning ${maxCoins} of ${coins.length} selected coins`, 'warning');
            coins = coins.slice(0, maxCoins);
        }
        
        let timeframes;
        
        if (STATE.mode === 'SCALP') {
            timeframes = CONFIG.TF_SCALP;
        } else if (STATE.mode === 'SWING') {
            timeframes = CONFIG.TF_SWING;
        } else {
            timeframes = CONFIG.TF_ALL;
        }
        
        // Filter by enabled timeframes from settings
        timeframes = timeframes.filter(tf => STATE.tfEnabled[tf]);
        
        if (timeframes.length === 0) {
            toast('No timeframes enabled! Enable at least one in Settings.', 'error');
            STATE.scanning = false;
            STATE.scanInProgress = false;
            document.getElementById('scanBtn').className = 'btn';
            document.getElementById('scanIcon').textContent = '●';
            return;
        }
        
        const total = coins.length * timeframes.length;
        let current = 0;
        
        // Track previous signal count for alerts
        const prevSignalCount = STATE.signals.length;
        
        STATE.scanProgress = { current: 0, total, coin: '', tf: '' };
        
        for (const coin of coins) {
            if (!STATE.scanning) break;
            
            for (const tf of timeframes) {
                if (!STATE.scanning) break;
                
                current++;
                STATE.scanProgress = {
                    current,
                    total,
                    coin: coin.replace('USDT', ''),
                    tf: CONFIG.TF_LABELS[tf] || tf
                };
                
                updateScanStatus();
                
                try {
                    const signal = await analyzeSignal(coin, tf);
                    
                    // 🛡️ HARDENING: Record success (reset error counter)
                    if (typeof Hardening !== 'undefined') Hardening.recordSuccess();
                    
                    if (signal) {
                        // 🛡️ HARDENING: Log signal for forward testing
                        if (typeof Hardening !== 'undefined') {
                            signal.hardeningId = Hardening.logSignal(signal, coin, tf);
                        }
                        
                        // Add environment data to signal (pass signal for RS/HTF)
                        const envResult = calculateEnvironmentScore(signal.direction, signal);
                        signal.environment = {
                            score: envResult.score,
                            verdict: envResult.verdict,
                            details: envResult.details,
                            icons: getEnvIcons(signal)
                        };
                        
                        // 🧠 APPLY INTELLIGENT BRAIN
                        const brainResult = applyIntelligentBrain(signal, signals);
                        signal.brain = brainResult;
                        
                        // Check if brain blocked the signal
                        if (brainResult.blocked) {
                            signal.filterReason = brainResult.blockReason;
                            signal.brainBlocked = true;
                            filteredSignals.push(signal);
                            continue;  // Skip to next signal
                        }
                        
                        // Apply brain modifications
                        if (brainResult.intent) {
                            signal.intent = brainResult.intent.intent;
                            signal.intentConfidence = brainResult.intent.confidence;
                        }
                        
                        if (brainResult.modifiedLevels) {
                            signal.intentLevels = brainResult.modifiedLevels;
                        }
                        
                        if (brainResult.positionSize) {
                            signal.smartPosition = brainResult.positionSize;
                        }
                        
                        if (brainResult.pattern && brainResult.pattern.patternData) {
                            signal.patternHistory = brainResult.pattern;
                        }
                        
                        // Add brain warnings to signal
                        if (brainResult.warnings && brainResult.warnings.length > 0) {
                            signal.brainWarnings = brainResult.warnings;
                        }
                        
                        // Adjust score based on brain
                        signal.originalScore = signal.score;
                        signal.score = brainResult.adjustedConfidence;
                        
                        // Check if signal should be filtered
                        const filterResult = shouldFilterSignal(signal);
                        if (filterResult.filter) {
                            // Add to filtered list instead
                            signal.filterReason = filterResult.reason;
                            filteredSignals.push(signal);
                        } else {
                            signals.push(signal);
                        }
                    }
                } catch (e) {
                    console.error(`Scan error ${coin} ${tf}:`, e);
                    
                    // 🛡️ HARDENING: Record error
                    if (typeof Hardening !== 'undefined') {
                        const shouldPause = Hardening.recordError(`${coin} ${tf}: ${e.message}`);
                        if (shouldPause) {
                            // Break out of scan loop if paused
                            break;
                        }
                    }
                }
                
                await sleep(CONFIG.SCAN_DELAY);
            }
        }
        
        // Sort by score descending
        signals.sort((a, b) => b.score - a.score);
        
        // Check for new high-grade signals and trigger alert
        const gradeOrder = ['PERFECT', 'STRONG', 'VALID', 'HEATING', 'BREWING'];
        const alertGradeIdx = gradeOrder.indexOf(STATE.alertGrade);
        
        // Get previous signal keys for comparison
        const prevSignalKeys = new Set(STATE.signals.map(s => `${s.symbol}-${s.tf}-${s.direction}`));
        
        const newHighGradeSignals = signals.filter(sig => {
            const sigGradeIdx = gradeOrder.indexOf(sig.grade);
            const isQualifying = sigGradeIdx <= alertGradeIdx && sigGradeIdx >= 0;
            const sigKey = `${sig.symbol}-${sig.tf}-${sig.direction}`;
            const isNew = !prevSignalKeys.has(sigKey);
            return isQualifying && isNew;
        });
        
        // Trigger alert if we have new qualifying signals
        if (newHighGradeSignals.length > 0) {
            console.log('🔔 New qualifying signal found:', newHighGradeSignals[0].symbol);
            triggerAlert(newHighGradeSignals[0]);
        }
        
        // SAFETY: Limit signals array size
        const maxSignals = CONFIG.SAFETY?.MAX_SIGNALS || 500;
        if (signals.length > maxSignals) {
            console.warn(`⚠️ Limiting signals from ${signals.length} to ${maxSignals}`);
            signals.splice(maxSignals);
        }
        
        STATE.signals = signals;
        STATE.filteredSignals = filteredSignals;
        STATE.filteredCount = filteredSignals.length;
        STATE.selected = null;
        STATE.current = null;
        STATE.aiResult = null;
        
        updateSignalList();
        updateCounts();
        updateMainPanel();
        
        // V10.3: Update structure bar with first signal's structure
        if (signals.length > 0 && signals[0].structure) {
            updateStructureBar(signals[0].structure);
        }
        
        const filteredMsg = filteredSignals.length > 0 ? ` (${filteredSignals.length} filtered)` : '';
        toast(`Scan complete: ${signals.length} signals${filteredMsg}`, 'success');
        
        // Auto-update saved trades with live prices
        updateAllSavedTradesLive();
        
        // Set progress bar to green (complete)
        setScanComplete();
        
        // Auto-rescan using configured interval
        if (STATE.scanning) {
            // SAFETY: Enforce minimum scan interval
            const minInterval = CONFIG.SAFETY?.MIN_SCAN_INTERVAL_MS || 30000;
            const interval = Math.max(STATE.scanInterval, minInterval);
            
            // Reset progress bar before next scan
            setTimeout(() => {
                resetScanProgress();
                runScanner();
            }, interval);
        }
        
    } catch (scanError) {
        console.error('🛑 Scan error:', scanError);
        toast('Scan error - retrying...', 'error');
        
        // Still try to auto-rescan even after error
        if (STATE.scanning) {
            setTimeout(() => {
                resetScanProgress();
                runScanner();
            }, 30000); // Retry after 30 seconds on error
        }
    } finally {
        // SAFETY: Always release scan lock
        STATE.scanInProgress = false;
        
        // 🛡️ HARDENING: Release mutex
        if (typeof Hardening !== 'undefined') Hardening.releaseScanLock();
    }
}

function updateScanStatus() {
    const el = document.getElementById('signalList');
    if (!el) return;
    
    const p = STATE.scanProgress;
    const pct = p.total > 0 ? Math.round((p.current / p.total) * 100) : 0;
    
    // Update progress bar (background scan - don't hide signals!)
    const progressBar = document.getElementById('scanProgressBar');
    const progressFill = document.getElementById('scanProgressFill');
    const progressText = document.getElementById('scanProgressText');
    const progressPct = document.getElementById('scanProgressPct');
    
    if (progressBar && STATE.scanning && p.total > 0) {
        progressBar.classList.add('active');
        if (progressFill) {
            progressFill.style.width = pct + '%';
            progressFill.classList.add('scanning');
        }
        if (progressText) {
            progressText.innerHTML = `<span class="scan-text-glow">🔄 ${p.coin}</span> <span class="scan-text-amber">${p.tf}</span>`;
        }
        if (progressPct) {
            progressPct.innerHTML = `<span class="scan-text-amber">${p.current}/${p.total}</span>`;
        }
    } else if (progressBar) {
        progressBar.classList.remove('active');
        if (progressFill) progressFill.classList.remove('scanning');
    }
    
    // Only show loading if NO signals yet (first scan)
    if (STATE.signals.length === 0 && el) {
        el.innerHTML = `
            <div class="empty">
                <div class="rainbow-circle-container">
                    <div class="rainbow-circle-ring"></div>
                    <div class="rainbow-circle-inner">
                        <div class="rainbow-circle-coin">${p.coin || 'Loading'}</div>
                        <div class="rainbow-circle-tf">${p.tf || '...'}</div>
                        <div class="rainbow-circle-pct">${pct}%</div>
                        <div class="rainbow-circle-count">${p.current}/${p.total}</div>
                    </div>
                </div>
            </div>
        `;
    }
    // Otherwise, signals stay visible during rescan!
}

// ═══════════════════════════════════════════════════════════════════════════════
// UI RENDERING
// ═══════════════════════════════════════════════════════════════════════════════

function updateSignalList() {
    try {
        const el = document.getElementById('signalList');
        if (!el) return;
        
        let filtered = [...safeArr(STATE.signals)];
        
        // Apply mode filter
        if (STATE.mode === 'SCALP') {
            filtered = filtered.filter(s => s && ['5m', '15m', '30m', '1H'].includes(s.tf));
        } else if (STATE.mode === 'SWING') {
            filtered = filtered.filter(s => s && ['1H', '4H', '1D'].includes(s.tf));
        }
        
        // Apply status filter
        if (STATE.filter === 'perfect') {
            filtered = filtered.filter(s => s && s.grade === 'PERFECT');
        } else if (STATE.filter === 'ready') {
            filtered = filtered.filter(s => s && s.status === 'ready');
        } else if (STATE.filter === 'early') {
            filtered = filtered.filter(s => s && s.status === 'early');
        }
        
        // Apply stats bar filter
        if (STATE.statsFilter === 'cream') {
            filtered = filtered.filter(s => s && isCreamSignal(s));
        } else if (STATE.statsFilter === 'perfect') {
            filtered = filtered.filter(s => s && s.grade === 'PERFECT');
        } else if (STATE.statsFilter === 'long') {
            filtered = filtered.filter(s => s && s.direction === 'LONG');
        } else if (STATE.statsFilter === 'short') {
            filtered = filtered.filter(s => s && s.direction === 'SHORT');
        } else if (STATE.statsFilter === 'agree3') {
            filtered = filtered.filter(s => s && s.agreed === 3);
        }
        
        if (filtered.length === 0) {
            el.innerHTML = `
                <div class="empty">
                    <div class="empty-icon" style="font-size:36px;color:var(--amber)">📊</div>
                    <div style="color:var(--text2)">${STATE.scanning ? 'Scanning...' : 'No signals found'}</div>
                </div>
            `;
            return;
        }
        
        el.innerHTML = filtered.map((sig, idx) => {
            try {
                if (!sig || !sig.symbol) return '';
                
                // SAFETY: Get direction first before anything else
                const sigDirection = sig.direction || 'LONG';
                const sigGrade = sig.grade || 'BREWING';
                const sigScore = safeNum(sig.score, 0);
                const sigPrice = safeNum(sig.price, 0);
                const sigLevels = safeObj(sig.levels);
                const sigScores = safeObj(sig.scores);
                const sigEngineDirections = safeObj(sig.engineDirections);
                const sigAgreed = safeNum(sig.agreed, 0);
                
                // FIX: Find index by matching symbol AND tf to avoid -1 issues
                const realIdx = STATE.signals.findIndex(s => s && s.symbol === sig.symbol && s.tf === sig.tf);
                if (realIdx === -1) {
                    console.warn('Signal not found in STATE.signals:', sig.symbol, sig.tf);
                }
                const isActive = STATE.selected === realIdx;
                const isScalp = ['5m', '15m', '30m', '1H'].includes(sig.tf);
                const htfOk = sig.htf && sig.htf.aligned >= 2;
                const agreementColor = sig.agreed === 3 ? 'var(--long)' : 'var(--amber)';
                const fullAgreeClass = sig.agreed === 3 ? 'full-agree' : '';
                const gradeClass = 'grade-' + sigGrade.toLowerCase();
                
                // Check if CREAM signal
                const isCream = isCreamSignal(sig);
                const creamBadge = isCream ? '<span style="color:#00ffcc;font-weight:700;text-shadow:0 0 8px #00ffcc;margin-left:4px">💎</span>' : '';
                
                // Calculate status badge (compare with previous scan)
                let statusBadge = '';
                const sigKey = sig.symbol + '_' + sig.tf;
                const prevSig = STATE.previousSignals.find(p => p.symbol === sig.symbol && p.tf === sig.tf);
                
                if (!prevSig) {
                    statusBadge = '<span class="status-badge new">🆕 NEW</span>';
                } else {
                    const scoreDiff = sigScore - safeNum(prevSig.score, 0);
                    if (scoreDiff >= 5) {
                        statusBadge = `<span class="status-badge up">⬆️+${scoreDiff}</span>`;
                    } else if (scoreDiff <= -5) {
                        statusBadge = `<span class="status-badge down">⬇️${scoreDiff}</span>`;
                    }
                }
                
                // Generate environment icons if available (with safety)
                let envIconsHtml = '';
                try {
                    if (sig.environment) {
                        envIconsHtml = generateEnvIconsHtml(sig);
                    }
                } catch (e) {
                    console.warn('Env icons error:', e.message);
                }
                
                return `
                    <div class="signal-card ${sigDirection.toLowerCase()} ${gradeClass} ${fullAgreeClass} ${isActive ? 'active' : ''}" 
                         onclick="selectSignalBySymbol('${sig.symbol}','${sig.tf}')"${isCream ? ' style="border:2px solid #00ffcc;box-shadow:0 0 12px rgba(0,255,204,0.3)"' : ''}>
                <div class="signal-top">
                    <div class="signal-pair">
                        ${sig.symbol.replace('USDT', '')}${creamBadge}
                        <span class="dir-tag ${sigDirection.toLowerCase()}">${sigDirection}</span>
                        <span class="tf-tag">${sig.tf}</span>
                        <span style="font-size:11px;color:${agreementColor};font-weight:700">${sigAgreed}/3</span>
                        ${htfOk ? '<span style="font-size:11px;color:var(--cyan)">HTF✓</span>' : ''}
                        ${statusBadge}
                    </div>
                    <span class="grade ${sigGrade.toLowerCase()}">${sigGrade}</span>
                </div>
                <div class="signal-meta">
                    <span>📊 ${sigScore}</span>
                    <span>💰 $${fmtPrice(sigPrice)}</span>
                    <span>R:R 1:${safeFixed(sigLevels.rr, 2)}</span>
                </div>
                <div class="signal-scores">
                    <span class="score-tag ${scoreClass(sigScores.zone)}" title="Zone: ${sigEngineDirections.zone || 'N/A'}">Z:${safeNum(sigScores.zone, 0)}${sigEngineDirections.zone === sigDirection ? '✓' : ''}</span>
                    <span class="score-tag ${scoreClass(sigScores.smc)}" title="SMC: ${sigEngineDirections.smc || 'N/A'}">S:${safeNum(sigScores.smc, 0)}${sigEngineDirections.smc === sigDirection ? '✓' : ''}</span>
                    <span class="score-tag ${scoreClass(sigScores.momentum)}" title="Momentum: ${sigEngineDirections.momentum || 'N/A'}">M:${safeNum(sigScores.momentum, 0)}${sigEngineDirections.momentum === sigDirection ? '✓' : ''}</span>
                    <span class="score-tag" style="color:var(--cyan)">H:${safeNum(sigScores.htf, 0)}</span>
                </div>
                ${sig.smartMatrix ? `
                <div class="smart-matrix">
                    <span class="regime-badge ${(sig.smartMatrix.regime?.regime || 'unknown').toLowerCase()}">${sig.smartMatrix.regime?.regime || '?'}</span>
                    <span class="weights"><span class="w-zone">Z:${sig.smartMatrix.weights?.zone || 33}%</span> <span class="w-smc">S:${sig.smartMatrix.weights?.smc || 33}%</span> <span class="w-mom">M:${sig.smartMatrix.weights?.momentum || 34}%</span></span>
                    <span class="dominant ${(sig.smartMatrix.dominant || 'balanced').toLowerCase()}-lead">${sig.smartMatrix.dominant || 'BAL'}</span>
                    <span class="agreement ${(sig.smartMatrix.agreement?.agreement || 'none').toLowerCase()}">${sig.smartMatrix.agreement?.count || 0}/3</span>
                </div>
                ` : ''}
                ${sig.smartBrain ? `
                <div class="smart-brain" style="display:flex;gap:4px;flex-wrap:wrap;margin-top:4px;padding:6px 8px;background:rgba(0,212,255,0.08);border-radius:4px;font-size:10px;border:1px solid rgba(0,212,255,0.2)">
                    <span style="color:var(--cyan);font-weight:600" title="Brain Score (0-100)">🧠${sig.smartBrain.brainScore || 0}</span>
                    <span title="Coin Personality: ${sig.smartBrain.personalityDesc || ''}" style="color:${sig.smartBrain.personality === 'MEME' ? 'var(--short)' : sig.smartBrain.personality === 'KING' ? 'var(--gold)' : sig.smartBrain.personality === 'BLUECHIP' ? 'var(--cyan)' : 'var(--text-dim)'}">🎭${sig.smartBrain.personality || '?'}</span>
                    <span title="Price position in range (${sig.smartBrain.positionThresholds || ''})" style="color:${sig.smartBrain.pricePosition < 35 ? 'var(--long)' : sig.smartBrain.pricePosition > 65 ? 'var(--short)' : 'var(--text-dim)'}">📍${sig.smartBrain.pricePosition}%</span>
                    <span title="Market trend" style="color:${sig.smartBrain.marketTrend === 'UPTREND' ? 'var(--long)' : sig.smartBrain.marketTrend === 'DOWNTREND' ? 'var(--short)' : 'var(--text-dim)'}">${sig.smartBrain.marketTrend === 'UPTREND' ? '📈' : sig.smartBrain.marketTrend === 'DOWNTREND' ? '📉' : '↔️'}</span>
                    <span title="Rejection type" style="color:var(--gold)">${sig.smartBrain.rejectionType || '?'}</span>
                    <span title="Volume (zone threshold: ${sig.smartBrain.zoneThreshold || '?'})" style="color:${sig.smartBrain.volumeStrength === 'HIGH' ? 'var(--long)' : sig.smartBrain.volumeStrength === 'LOW' ? 'var(--short)' : 'var(--text-dim)'}">V:${sig.smartBrain.volRatio}x</span>
                    ${sig.smartBrain.liquiditySweep ? '<span style="color:var(--gold)" title="Liquidity sweep detected - institutional entry">💀SWEEP</span>' : ''}
                    <span title="HTF bias" style="color:${sig.smartBrain.htfConflict ? 'var(--short)' : sig.smartBrain.htfBias === 'BULLISH' ? 'var(--long)' : sig.smartBrain.htfBias === 'BEARISH' ? 'var(--short)' : 'var(--text-dim)'}">HTF:${sig.smartBrain.htfBias?.charAt(0) || '?'}${sig.smartBrain.htfConflict ? '⚠️' : ''}</span>
                </div>
                ` : ''}
                ${sig.structure ? `
                <div class="signal-structure">
                    ${sig.structure.channel?.isValid ? `<span class="str-tag channel"><span class="icon">📊</span>CH ${(sig.structure.channel.widthPct * 100).toFixed(1)}%</span>` : ''}
                    ${sig.structure.trendlines?.bull?.length > 0 ? `<span class="str-tag trendline"><span class="icon">📈</span>TL↑${sig.structure.trendlines.bull.length}</span>` : ''}
                    ${sig.structure.trendlines?.bear?.length > 0 ? `<span class="str-tag trendline"><span class="icon">📉</span>TL↓${sig.structure.trendlines.bear.length}</span>` : ''}
                    ${sig.structure.compression?.isCompressed ? `<span class="str-tag compression"><span class="icon">🔄</span>COMP</span>` : ''}
                    ${sig.structure.bias && sig.structure.bias !== 'NEUTRAL' && sig.structure.bias !== 'EQUILIBRIUM' ? `<span class="str-tag bias"><span class="icon">🎯</span>${sig.structure.bias}</span>` : ''}
                    <span class="str-tag ${sig.structureGatePass ? 'gate-pass' : 'gate-fail'}"><span class="icon">${sig.structureGatePass ? '✅' : '⚠️'}</span>GATE</span>
                </div>
                ` : ''}
                ${(() => {
                    try {
                        const liveInfo = getLiveDataForSignal(sig.symbol, sigDirection);
                        const liqClass = liveInfo.liqSupport === 'support' ? 'liq-bullish' : liveInfo.liqSupport === 'oppose' ? 'liq-bearish' : '';
                        const oiClass = liveInfo.oiSupport === 'support' ? 'oi-rising' : liveInfo.oiSupport === 'caution' ? 'oi-falling' : '';
                        const fundClass = liveInfo.fundingSupport === 'support' ? 'funding-pos' : liveInfo.fundingSupport === 'oppose' ? 'funding-neg' : '';
                        const whaleClass = (liveInfo.whale === 'BUYING' && sigDirection === 'LONG') || (liveInfo.whale === 'SELLING' && sigDirection === 'SHORT') ? 'whale-buy' : '';
                        return `
                        <div class="signal-live-data">
                            ${liveInfo.liq.bias !== 'NEUTRAL' ? `<span class="live-tag ${liqClass}">💀 ${liveInfo.liq.bias}</span>` : ''}
                            ${liveInfo.oi?.trend && liveInfo.oi.trend !== 'FLAT' ? `<span class="live-tag ${oiClass}">📊 OI ${liveInfo.oi.trend}</span>` : ''}
                            ${liveInfo.whale !== 'NEUTRAL' ? `<span class="live-tag ${whaleClass}">🐋 ${liveInfo.whale}</span>` : ''}
                            ${liveInfo.funding?.rate && Math.abs(liveInfo.funding.rate) > 0.02 ? `<span class="live-tag ${fundClass}">💰 ${liveInfo.funding.rate.toFixed(3)}%</span>` : ''}
                        </div>
                        `;
                    } catch(e) { return ''; }
                })()}
                ${(() => {
                    try {
                        if (!sig.advanced) return '';
                        const adv = sig.advanced;
                        const vp = adv.volumeProfile;
                        const of = adv.orderFlow;
                        const ml = adv.mlPrediction;
                        
                        let vpTag = '';
                        if (vp && vp.valid && vp.factors.length > 0) {
                            const vpClass = vp.support === 'strong' ? 'at-val' : vp.support === 'support' ? 'vp-tag' : 'at-vah';
                            vpTag = `<span class="adv-tag vp-tag ${vpClass}"><span class="icon">📊</span>${vp.support === 'strong' ? 'VP✓' : 'VP'}</span>`;
                        }
                        
                        let ofTag = '';
                        if (of && of.flow) {
                            const ofClass = of.support === 'strong' ? 'buy-aggro' : of.support === 'oppose' ? 'sell-aggro' : 'of-tag';
                            const ofLabel = of.flow.aggression.replace('STRONG_', '').replace('_', ' ');
                            ofTag = `<span class="adv-tag of-tag ${ofClass}"><span class="icon">🌊</span>${ofLabel}</span>`;
                            if (of.flow.absorption) {
                                ofTag += `<span class="adv-tag of-tag absorption"><span class="icon">🛡️</span>ABS</span>`;
                            }
                        }
                        
                        let mlTag = '';
                        if (ml && ml.confidence !== 'LOW') {
                            const mlClass = ml.suggestion === 'FAVORABLE' ? 'favorable' : ml.suggestion === 'UNFAVORABLE' ? 'unfavorable' : 'ml-tag';
                            mlTag = `<span class="adv-tag ml-tag ${mlClass}"><span class="icon">🤖</span>${ml.probability}%</span>`;
                        }
                        
                        const confClass = adv.confidence.toLowerCase();
                        const scoreClass = adv.combinedScore >= 65 ? 'high' : adv.combinedScore >= 50 ? 'medium' : 'low';
                        
                        if (!vpTag && !ofTag && !mlTag) return '';
                        
                        return `
                        <div class="signal-advanced">
                            ${vpTag}${ofTag}${mlTag}
                            <span class="conf-badge ${confClass}">${adv.confidence}</span>
                            <div class="adv-score-ring ${scoreClass}">${adv.combinedScore}</div>
                        </div>
                        `;
                    } catch(e) { return ''; }
                })()}
                ${envIconsHtml}
            </div>
        `;
            } catch (cardErr) {
                console.warn('Signal card error:', cardErr.message);
                return '';
            }
        }).filter(html => html !== '').join('');
    } catch (listError) {
        console.error('🛡️ Signal list error:', listError);
        const el = document.getElementById('signalList');
        if (el) {
            el.innerHTML = '<div class="empty"><div style="color:var(--amber)">⚠️ List error - refreshing...</div></div>';
        }
    }
}

function updateCounts() {
    try {
        let filtered = [...safeArr(STATE.signals)];
        
        if (STATE.mode === 'SCALP') {
            filtered = filtered.filter(s => s && ['5m', '15m', '30m', '1H'].includes(s.tf));
        } else if (STATE.mode === 'SWING') {
            filtered = filtered.filter(s => s && ['1H', '4H', '1D'].includes(s.tf));
        }
        
        // Update filter counts (with null checks)
        const elAll = document.getElementById('cAll');
        const elPerfect = document.getElementById('cPerfect');
        const elReady = document.getElementById('cReady');
        const elEarly = document.getElementById('cEarly');
        
        if (elAll) elAll.textContent = filtered.length;
        if (elPerfect) elPerfect.textContent = filtered.filter(s => s && s.grade === 'PERFECT').length;
        if (elReady) elReady.textContent = filtered.filter(s => s && s.status === 'ready').length;
        if (elEarly) elEarly.textContent = filtered.filter(s => s && s.status === 'early').length;
        
        // Update dashboard stats bar (with null checks)
        const elTotal = document.getElementById('statTotal');
        const elCream = document.getElementById('statCream');
        const elStatPerfect = document.getElementById('statPerfect');
        const elStatLong = document.getElementById('statLong');
        const elStatShort = document.getElementById('statShort');
        const elStatAgree = document.getElementById('statFullAgree');
        
        if (elTotal) elTotal.textContent = filtered.length;
        if (elCream) elCream.textContent = filtered.filter(s => s && isCreamSignal(s)).length;
        if (elStatPerfect) elStatPerfect.textContent = filtered.filter(s => s && s.grade === 'PERFECT').length;
        if (elStatLong) elStatLong.textContent = filtered.filter(s => s && s.direction === 'LONG').length;
        if (elStatShort) elStatShort.textContent = filtered.filter(s => s && s.direction === 'SHORT').length;
        if (elStatAgree) elStatAgree.textContent = filtered.filter(s => s && s.agreed === 3).length;
    } catch (countsError) {
        console.warn('Update counts error:', countsError.message);
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// CREAM SIGNAL DETECTION (Ultimate Signal - All conditions perfect)
// ═══════════════════════════════════════════════════════════════════════════════

function isCreamSignal(signal) {
    if (!signal) return false;
    
    const env = STATE.environment || {};
    const dir = signal.direction;
    
    // Criteria 1: Engine Score >= 85
    if (signal.score < 85) return false;
    
    // Criteria 2: Full Agreement (3/3)
    if (signal.agreed !== 3) return false;
    
    // Criteria 3: BTC Trend aligned
    const btcTrend = env.btcTrend?.direction || 'FLAT';
    if (dir === 'LONG' && btcTrend !== 'BULLISH' && btcTrend !== 'FLAT') return false;
    if (dir === 'SHORT' && btcTrend !== 'BEARISH' && btcTrend !== 'FLAT') return false;
    
    // Criteria 4: BTC.D favorable
    const btcDTrend = env.btcDominance?.trend || 'FLAT';
    if (dir === 'LONG' && btcDTrend === 'RISING') return false;  // Bad for alts going long
    if (dir === 'SHORT' && btcDTrend === 'FALLING') return false; // Bad for shorting alts
    
    // Criteria 5: Environment Score >= 80 (GO verdict)
    const envScore = signal.environment?.score || 0;
    if (envScore < 80) return false;
    
    // Criteria 6: HTF Alignment >= 75%
    if (signal.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 0;
        if (htfPct < 75) return false;
    }
    
    // Criteria 7: BTC Structure intact
    const struct = env.btcStructure?.status || 'UNKNOWN';
    if (struct !== 'INTACT') return false;
    
    // Criteria 8: OI confirms direction (NOT a squeeze)
    const oiInterp = STATE.openInterest?.interpretation || 'NEUTRAL';
    if (oiInterp === 'SQUEEZE' || oiInterp === 'LIQUIDATION') return false;
    
    // All criteria passed = CREAM 💎
    return true;
}

function updateMainPanel() {
    // Debug: updateMainPanel
    try {
        const el = document.getElementById('mainPanel');
        if (!el) {
            console.error('❌ mainPanel element not found!');
            return;
        }
        
        if (!STATE.current) {
            // Debug: No signal
            el.innerHTML = `
                <div class="empty">
                    <div class="empty-icon">👈</div>
                    <div>Select a signal to view details</div>
                </div>
            `;
            return;
        }
        
        const sig = STATE.current;
        const ai = STATE.aiResult;
        
        console.log('🟢 Rendering signal:', sig.symbol, sig.direction);
        
        // Safety: Ensure sig has required properties
        if (!sig.symbol || !sig.direction) {
            console.error('❌ Invalid signal data - missing symbol or direction');
            el.innerHTML = '<div class="empty"><div>Invalid signal data</div></div>';
            return;
        }
        
        // FIX: Define sigDirection EARLY to avoid "Cannot access before initialization" error
        const sigDirection = sig.direction || 'LONG';
        
        // FIX: Saved Trade Comparison Banner (when viewing saved trade with fresh rescan)
        let savedComparisonHtml = '';
        if (sig.savedTrade) {
            const st = sig.savedTrade;
            // FIX: Safe division with null check
            const priceDiff = safeFixed(safePct(sig.price - (st.savedEntry || 0), st.savedEntry || 1), 2);
            const priceDirection = sig.price > st.savedEntry ? '📈' : sig.price < st.savedEntry ? '📉' : '➡️';
            const gradeChanged = sig.grade !== st.savedGrade;
            const dirChanged = sig.direction !== st.savedDirection;
            
            savedComparisonHtml = `
                <div style="background:linear-gradient(135deg, var(--purple-dim), var(--cyan-dim));border:2px solid var(--purple);border-radius:10px;padding:12px;margin-bottom:12px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                        <span style="font-size:13px;font-weight:700;color:var(--purple)">📌 SAVED TRADE COMPARISON</span>
                        <span style="font-size:10px;color:var(--text3)">Saved ${new Date(st.savedAt).toLocaleString()}</span>
                    </div>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:10px">
                    <div style="background:var(--bg3);border-radius:6px;padding:8px">
                        <div style="font-size:10px;color:var(--text3);margin-bottom:4px">📸 WHEN SAVED</div>
                        <div style="font-size:12px;color:var(--text)">Entry: $${st.savedEntry?.toFixed(4) || 'N/A'}</div>
                        <div style="font-size:11px;color:var(--text2)">Grade: <span style="color:var(--${st.savedGrade === 'PERFECT' ? 'long' : st.savedGrade === 'STRONG' ? 'cyan' : 'amber'})">${st.savedGrade}</span> (${st.savedScore})</div>
                        <div style="font-size:11px;color:var(--text2)">Dir: ${st.savedDirection}</div>
                    </div>
                    <div style="background:var(--bg3);border-radius:6px;padding:8px">
                        <div style="font-size:10px;color:var(--text3);margin-bottom:4px">📊 NOW (FRESH)</div>
                        <div style="font-size:12px;color:var(--text)">Price: $${sig.price?.toFixed(4) || 'N/A'} ${priceDirection}</div>
                        <div style="font-size:11px;color:var(--text2)">Grade: <span style="color:var(--${sig.grade === 'PERFECT' ? 'long' : sig.grade === 'STRONG' ? 'cyan' : 'amber'})">${sig.grade}</span> (${sig.score}) ${gradeChanged ? '⚠️' : '✅'}</div>
                        <div style="font-size:11px;color:var(--text2)">Dir: ${sig.direction} ${dirChanged ? '🔄 CHANGED!' : '✅'}</div>
                    </div>
                </div>
                
                <div style="display:flex;justify-content:space-between;font-size:11px;padding-top:8px;border-top:1px solid var(--border)">
                    <span style="color:var(--text3)">Price moved: <span style="color:${priceDiff >= 0 ? 'var(--long)' : 'var(--short)'};">${priceDiff >= 0 ? '+' : ''}${priceDiff}%</span></span>
                    ${dirChanged ? '<span style="color:var(--short);font-weight:700">⚠️ DIRECTION CHANGED!</span>' : ''}
                    ${gradeChanged ? '<span style="color:var(--amber)">Grade changed</span>' : '<span style="color:var(--long)">✓ Signal stable</span>'}
                </div>
            </div>
        `;
    }
    
    // HTF Box - with null safety
    const sigHtf = sig.htf || { aligned: 0, total: 0, bias: {} };
    const htfHtml = `
        <div class="htf-box">
            <div class="htf-title">📈 HTF Bias (${sigHtf.aligned || 0}/${sigHtf.total || 0} Aligned)</div>
            <div class="htf-grid">
                ${Object.entries(sigHtf.bias || {}).map(([tf, bias]) => `
                    <div class="htf-item">
                        <div class="htf-label">${tf}</div>
                        <div class="htf-value ${bias === 'BULLISH' ? 'bull' : bias === 'BEARISH' ? 'bear' : 'neutral'}">${bias}</div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    // 🎯 GP/OTE Display - Advanced Fibonacci Zones
    let gpoteHtml = '';
    try {
        if (sig.gpote && sig.gpote.valid) {
            gpoteHtml = generateGPOTEDisplay(sig.gpote, false);
        }
    } catch (gpoteErr) {
        console.warn('GP/OTE display error:', gpoteErr);
        gpoteHtml = '';
    }
    
    // AI Section - Expandable with Comprehensive Independent Analysis
    let aiHtml;
    if (ai) {
        const verdictClass = ai.verdict === 'TAKE' ? 'take' : ai.verdict === 'NO_TRADE' ? 'skip' : ai.verdict === 'SKIP' ? 'skip' : 'wait';
        const barColor = ai.verdict === 'TAKE' ? 'var(--long)' : (ai.verdict === 'SKIP' || ai.verdict === 'NO_TRADE') ? 'var(--short)' : 'var(--amber)';
        const agreementColor = ai.agreesWithScanner ? 'var(--long)' : 'var(--short)';
        const agreementText = ai.agreesWithScanner ? '✓ AGREES' : '✗ DISAGREES';
        const aiDirectionColor = ai.myDirection === 'LONG' ? 'var(--long)' : ai.myDirection === 'SHORT' ? 'var(--short)' : 'var(--text3)';
        const entryTypeColor = ai.entryType === 'ZONE_ENTRY' ? 'var(--gold)' : ai.entryType === 'CONFIRMED' ? 'var(--long)' : 'var(--text3)';
        
        // Helper to format nested objects safely
        const formatObj = (obj, color) => {
            if (!obj) return '';
            if (typeof obj === 'string') return '<div style="font-size:12px;color:var(--text2)">' + obj + '</div>';
            return '<div style="font-size:12px;color:var(--text2)">' + 
                Object.entries(obj).filter(([k,v]) => v && v !== 'N/A').map(([k,v]) => {
                    const label = k.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                    if (Array.isArray(v)) return '<div style="margin-bottom:4px"><b>' + label + ':</b> ' + v.join(', ') + '</div>';
                    return '<div style="margin-bottom:4px"><b>' + label + ':</b> ' + v + '</div>';
                }).join('') + '</div>';
        };
        
        // Get risks array (handles both old and new format)
        const getRisks = () => {
            if (ai.riskAssessment && ai.riskAssessment.risks && ai.riskAssessment.risks.length) return ai.riskAssessment.risks;
            if (ai.riskAssessment && ai.riskAssessment.primaryRisks && ai.riskAssessment.primaryRisks.length) return ai.riskAssessment.primaryRisks;
            if (ai.risks && ai.risks.length) return ai.risks;
            return [];
        };
        
        // Get summary (handles both formats)
        const getSummary = () => ai.executiveSummary || ai.reasoning || '';
        
        // Get leverage info from tradePlan or legacy field
        const getLeverage = () => {
            if (ai.tradePlan && (ai.tradePlan.leverage || ai.tradePlan.positionSize)) {
                return { leverage: ai.tradePlan.leverage, size: ai.tradePlan.positionSize };
            }
            return ai.leverageRecommendation || ai.leverageAdvice || null;
        };
        
        aiHtml = `
            <div class="ai-section">
                <div class="ai-header" onclick="toggleAIExpand()" style="cursor:pointer">
                    <span class="ai-title">🤖 AI Independent Analysis</span>
                    <div style="display:flex;align-items:center;gap:8px">
                        <span class="ai-verdict ${verdictClass}">${ai.verdict}</span>
                        <span style="font-size:14px">${STATE.aiExpanded ? '▼' : '▶'}</span>
                    </div>
                </div>
                
                <div class="ai-bar"><div class="ai-fill" style="width:${ai.confidence}%;background:${barColor}"></div></div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                    <span style="font-size:12px">Confidence: <b>${ai.confidence}%</b></span>
                    <span style="font-size:11px;color:${agreementColor};font-weight:700">${agreementText} with Scanner</span>
                </div>
                
                <div style="display:flex;gap:8px;margin-bottom:10px">
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px">
                        <div style="font-size:11px;color:var(--text3)">Scanner Says</div>
                        <div style="font-size:14px;font-weight:700;color:${sig.direction === 'LONG' ? 'var(--long)' : 'var(--short)'}">${sig.direction}</div>
                    </div>
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px;border:1px solid ${aiDirectionColor}">
                        <div style="font-size:11px;color:var(--text3)">AI Says</div>
                        <div style="font-size:14px;font-weight:700;color:${aiDirectionColor}">${ai.myDirection || 'N/A'}</div>
                    </div>
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px;border:1px solid ${entryTypeColor}">
                        <div style="font-size:11px;color:var(--text3)">Entry Type</div>
                        <div style="font-size:12px;font-weight:700;color:${entryTypeColor}">${ai.entryType === 'ZONE_ENTRY' ? '🎯 ZONE' : ai.entryType === 'CONFIRMED' ? '✅ CONFIRMED' : '❌ NONE'}</div>
                    </div>
                </div>
                
                ${!ai.agreesWithScanner && ai.whyDisagree ? '<div style="background:var(--short-dim);border:1px solid var(--short);border-radius:6px;padding:10px;margin-bottom:10px"><div style="font-size:11px;color:var(--short);font-weight:700;margin-bottom:4px">⚠️ WHY AI DISAGREES:</div><div style="font-size:12px;color:var(--text2)">' + ai.whyDisagree + '</div></div>' : ''}
                
                ${ai.rulesCheck ? '<div style="background:var(--bg4);border-radius:6px;padding:10px;margin-bottom:10px"><div style="font-size:11px;color:var(--cyan);font-weight:700;margin-bottom:6px">📋 RULES CHECK:</div><div style="font-size:11px;color:var(--text2)">' + Object.entries(ai.rulesCheck).map(([rule, result]) => '<div style="margin-bottom:2px"><b>' + rule + ':</b> ' + result + '</div>').join('') + '</div></div>' : ''}
                
                <div class="ai-text" style="background:var(--bg4);padding:10px;border-radius:6px;border-left:3px solid ${barColor}">${getSummary()}</div>
                
                <div id="aiExpandedContent" style="display:${STATE.aiExpanded ? 'block' : 'none'};margin-top:12px;border-top:1px solid var(--border);padding-top:12px">
                    
                    ${STATE.aiDisplayMode === 'detailed' ? `
                    <!-- DETAILED MODE: 13 Sections -->
                    
                    ${ai.confluenceCounter ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--cyan)"><div style="font-size:11px;color:var(--cyan);font-weight:700;margin-bottom:6px">🎯 CONFLUENCE COUNTER</div>' + formatObj(ai.confluenceCounter, 'cyan') + '</div>' : ''}
                    
                    ${ai.trapDetection ? '<div style="margin-bottom:12px;background:' + (ai.trapDetection.isTrap ? 'var(--short-dim)' : 'var(--bg4)') + ';padding:10px;border-radius:6px;border:1px solid ' + (ai.trapDetection.isTrap ? 'var(--short)' : 'var(--long)') + '"><div style="font-size:11px;color:' + (ai.trapDetection.isTrap ? 'var(--short)' : 'var(--long)') + ';font-weight:700;margin-bottom:6px">' + (ai.trapDetection.isTrap ? '⚠️ TRAP DETECTED!' : '✅ NO TRAP DETECTED') + '</div>' + formatObj(ai.trapDetection, ai.trapDetection.isTrap ? 'short' : 'long') + '</div>' : ''}
                    
                    ${ai.entryTiming ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--amber)"><div style="font-size:11px;color:var(--amber);font-weight:700;margin-bottom:6px">⏰ ENTRY TIMING</div>' + formatObj(ai.entryTiming, 'amber') + '</div>' : ''}
                    
                    ${ai.candlePatternAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:6px">🕯️ CANDLE & PATTERNS</div>' + formatObj(ai.candlePatternAnalysis, 'gold') + '</div>' : ''}
                    
                    ${ai.zoneAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:6px">📍 ZONE ANALYSIS</div>' + formatObj(ai.zoneAnalysis, 'gold') + '</div>' : ''}
                    
                    ${ai.smcAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">🎯 SMC ANALYSIS</div>' + formatObj(ai.smcAnalysis, 'purple') + '</div>' : ''}
                    
                    ${ai.momentumAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--blue);font-weight:700;margin-bottom:6px">⚡ MOMENTUM ANALYSIS</div>' + formatObj(ai.momentumAnalysis, 'blue') + '</div>' : ''}
                    
                    ${ai.tradePlan ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">💰 TRADE PLAN</div>' + formatObj(ai.tradePlan, 'long') + '</div>' : ''}
                    
                    ${(ai.riskAssessment || getRisks().length > 0) ? '<div style="margin-bottom:12px;background:var(--short-dim);padding:10px;border-radius:6px;border:1px solid var(--short)"><div style="font-size:11px;color:var(--short);font-weight:700;margin-bottom:6px">⚠️ RISK ASSESSMENT</div>' + (ai.riskAssessment ? formatObj(ai.riskAssessment, 'short') : '<div style="font-size:12px;color:var(--text2)">' + getRisks().map(r => '• ' + r).join('<br>') + '</div>') + '</div>' : ''}
                    
                    ${getLeverage() ? '<div style="margin-bottom:12px;background:var(--amber-dim);border:1px solid var(--amber);border-radius:6px;padding:10px"><div style="font-size:11px;color:var(--amber);font-weight:700;margin-bottom:6px">⚡ LEVERAGE & SIZING</div>' + formatObj(getLeverage(), 'amber') + '</div>' : ''}
                    
                    ${ai.actionPlan ? '<div style="margin-bottom:12px;background:linear-gradient(135deg,var(--long-dim),var(--cyan-dim));padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">🎯 ACTION PLAN</div>' + formatObj(ai.actionPlan, 'long') + '</div>' : ''}
                    
                    ${ai.professionalNotes ? '<div style="background:var(--bg4);padding:10px;border-radius:6px;border-left:3px solid var(--purple)"><div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">📝 PRO NOTES</div><div style="font-size:12px;color:var(--text2);font-style:italic">' + ai.professionalNotes + '</div></div>' : ''}
                    
                    ` : `
                    <!-- COMPACT MODE: 6 Grouped Sections -->
                    
                    <div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--cyan)">
                        <div style="font-size:11px;color:var(--cyan);font-weight:700;margin-bottom:6px">📊 VERDICT & CONFLUENCE</div>
                        ${ai.confluenceCounter ? formatObj(ai.confluenceCounter, 'cyan') : ''}
                        ${ai.entryTiming ? '<div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border)">' + formatObj(ai.entryTiming, 'amber') + '</div>' : ''}
                    </div>
                    
                    ${(ai.trapDetection || ai.riskAssessment || getRisks().length > 0) ? '<div style="margin-bottom:12px;background:var(--short-dim);padding:10px;border-radius:6px;border:1px solid var(--short)"><div style="font-size:11px;color:var(--short);font-weight:700;margin-bottom:6px">⚠️ WARNINGS & RISKS</div>' + (ai.trapDetection ? formatObj(ai.trapDetection, 'short') : '') + (ai.riskAssessment ? '<div style="margin-top:8px">' + formatObj(ai.riskAssessment, 'short') + '</div>' : '') + '</div>' : ''}
                    
                    <div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px">
                        <div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">🔍 TECHNICAL ANALYSIS</div>
                        ${ai.zoneAnalysis ? '<div style="margin-bottom:6px"><b style="color:var(--gold)">Zone:</b> ' + (typeof ai.zoneAnalysis === 'object' ? (ai.zoneAnalysis.zoneQuality || 'N/A') + ' - ' + (ai.zoneAnalysis.pricePosition || 'N/A') : ai.zoneAnalysis) + '</div>' : ''}
                        ${ai.smcAnalysis ? '<div style="margin-bottom:6px"><b style="color:var(--purple)">SMC:</b> ' + (typeof ai.smcAnalysis === 'object' ? (ai.smcAnalysis.structureValidity || 'N/A') + ' - ' + (ai.smcAnalysis.orderBlockQuality || 'N/A') : ai.smcAnalysis) + '</div>' : ''}
                        ${ai.momentumAnalysis ? '<div><b style="color:var(--blue)">Momentum:</b> ' + (typeof ai.momentumAnalysis === 'object' ? (ai.momentumAnalysis.trendStrength || 'N/A') + ' - ' + (ai.momentumAnalysis.entryTiming || 'N/A') : ai.momentumAnalysis) + '</div>' : ''}
                    </div>
                    
                    ${ai.candlePatternAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:6px">🕯️ PRICE ACTION</div>' + formatObj(ai.candlePatternAnalysis, 'gold') + '</div>' : ''}
                    
                    ${(ai.tradePlan || getLeverage()) ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">💰 TRADE SETUP</div>' + (ai.tradePlan ? formatObj(ai.tradePlan, 'long') : '') + (getLeverage() ? '<div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border)">' + formatObj(getLeverage(), 'amber') + '</div>' : '') + '</div>' : ''}
                    
                    ${ai.actionPlan ? '<div style="margin-bottom:12px;background:linear-gradient(135deg,var(--long-dim),var(--cyan-dim));padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">🎯 ACTION PLAN</div>' + formatObj(ai.actionPlan, 'long') + '</div>' : ''}
                    `}
                    
                </div>
                
                <div style="display:flex;gap:8px;margin-top:10px">
                    <button class="btn" onclick="toggleAIExpand()" style="flex:1">${STATE.aiExpanded ? '▲ Collapse' : '▼ Expand Details'}</button>
                    <button class="btn" onclick="askAI()" style="flex:1">🔄 Refresh AI</button>
                </div>
            </div>
        `;
    } else {
        aiHtml = `
            <div class="ai-section" style="text-align:center;padding:20px">
                <div style="font-size:32px;margin-bottom:8px">🧠</div>
                <div style="font-size:13px;font-weight:600;margin-bottom:4px">Independent AI Analysis</div>
                <div style="font-size:12px;color:var(--text2);margin-bottom:12px">AI will analyze raw data and give its own opinion</div>
                <button class="ai-btn" onclick="askAI()">🧠 Ask Multi-AI</button>
            </div>
        `;
    }
    
    // Analysis Grid - with null safety
    const sigZone = safeObj(sig.zone);
    const sigZoneDetails = safeObj(sigZone.details);
    const sigSmc = safeObj(sig.smc);
    const sigSmcDetails = safeObj(sigSmc.details);
    const sigMomentum = safeObj(sig.momentum);
    const sigMomentumDetails = safeObj(sigMomentum.details);
    const sigScoresLocal = safeObj(sig.scores);
    const sigZoneFactors = safeArr(sigZone.factors);
    const sigSmcFactors = safeArr(sigSmc.factors);
    const sigMomentumFactors = safeArr(sigMomentum.factors);
    
    const analysisHtml = `
        <div class="analysis-grid">
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">📍 Zone Analysis</span>
                    <span class="analysis-score" style="background:${scoreColor(sigScoresLocal.zone)}20;color:${scoreColor(sigScoresLocal.zone)}">${safeNum(sigScoresLocal.zone, 0)}</span>
                </div>
                ${sigZoneDetails.nearestSupport ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Support</span>
                        <span class="analysis-value">$${fmtPrice(sigZoneDetails.nearestSupport.price)}</span>
                    </div>
                ` : ''}
                ${sigZoneDetails.nearestResistance ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Resistance</span>
                        <span class="analysis-value">$${fmtPrice(sigZoneDetails.nearestResistance.price)}</span>
                    </div>
                ` : ''}
                <div class="analysis-row">
                    <span class="analysis-label">Status</span>
                    <span class="analysis-value">${sigZone.status || 'N/A'}</span>
                </div>
                <div class="factor-list">
                    ${sigZoneFactors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
            
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">🎯 SMC Analysis</span>
                    <span class="analysis-score" style="background:${scoreColor(sigScoresLocal.smc)}20;color:${scoreColor(sigScoresLocal.smc)}">${safeNum(sigScoresLocal.smc, 0)}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">Structure</span>
                    <span class="analysis-value">${sigSmcDetails.trend || 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">P/D Zone</span>
                    <span class="analysis-value">${sigSmcDetails.pdZone ? sigSmcDetails.pdZone.zone : 'N/A'}</span>
                </div>
                ${sigSmc.trigger ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Trigger</span>
                        <span class="analysis-value" style="color:var(--gold)">${sigSmc.trigger}</span>
                    </div>
                ` : ''}
                <div class="factor-list">
                    ${sigSmcFactors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
            
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">📈 Momentum</span>
                    <span class="analysis-score" style="background:${scoreColor(sigScoresLocal.momentum)}20;color:${scoreColor(sigScoresLocal.momentum)}">${safeNum(sigScoresLocal.momentum, 0)}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">RSI</span>
                    <span class="analysis-value">${sigMomentumDetails.rsi ? safeFixed(sigMomentumDetails.rsi.value, 1) : 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">ADX</span>
                    <span class="analysis-value">${sigMomentumDetails.adx ? safeFixed(sigMomentumDetails.adx.adx, 1) : 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">MACD</span>
                    <span class="analysis-value">${sigMomentumDetails.macd ? sigMomentumDetails.macd.trend : 'N/A'}</span>
                </div>
                <div class="factor-list">
                    ${sigMomentumFactors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
        </div>
    `;
    
    // Warnings - with null safety
    const sigWarnings = safeArr(sig.warnings);
    const warningsHtml = sigWarnings.length > 0 ? `
        <div style="background:var(--amber-dim);border:1px solid var(--amber);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="font-size:11px;color:var(--amber);font-weight:600;margin-bottom:4px">⚠️ Warnings</div>
            <div style="font-size:12px;color:var(--amber)">${sigWarnings.join(' • ')}</div>
        </div>
    ` : '';
    
    // Smart Trade Data - with null safety
    const sigLevelsLocal = safeObj(sig.levels);
    const smart = safeObj(sigLevelsLocal.smart);
    const entryData = safeObj(smart.entry);
    const slData = safeObj(smart.sl);
    const tp1Data = safeObj(smart.tp1);
    const tp2Data = safeObj(smart.tp2);
    const tp3Data = safeObj(smart.tp3);
    const marketGrade = safeObj(safeGet(entryData, 'market.grade', {}));
    const pb1 = entryData.pullback1;
    const pb2 = entryData.pullback2;
    
    // Entry Grade Color
    const gradeColors = {
        'A+': 'var(--long)', 'A': 'var(--long)', 
        'B+': 'var(--cyan)', 'B': 'var(--cyan)',
        'C': 'var(--amber)', 'D': 'var(--short)'
    };
    const gradeColor = gradeColors[marketGrade.grade] || 'var(--text2)';
    
    // Smart Entry Plan HTML
    const smartEntryHtml = `
        <div style="background:var(--bg4);border:1px solid var(--cyan);border-radius:8px;padding:12px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                <span style="font-size:12px;font-weight:700;color:var(--cyan)">🧠 SMART ENTRY PLAN</span>
                <span style="font-size:11px;padding:3px 8px;border-radius:4px;background:${gradeColor};color:var(--bg1);font-weight:700">${marketGrade.grade || 'B'} GRADE</span>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid var(--border);margin-bottom:8px">
                <span style="font-size:11px;color:var(--text3)">Entry Decision:</span>
                <span style="font-size:12px;font-weight:600;color:var(--cyan)">${entryData.decision || 'MARKET'}</span>
            </div>
            <div style="display:grid;grid-template-columns:${pb2 ? 'repeat(3,1fr)' : pb1 ? 'repeat(2,1fr)' : '1fr'};gap:8px">
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--cyan)">
                    <div style="font-size:10px;color:var(--text3)">MARKET (${entryData.market?.size || '25%'})</div>
                    <div style="font-size:13px;font-weight:700;color:var(--cyan)">$${fmtPrice(sigLevelsLocal.entry || sig.price)}</div>
                    <div style="font-size:10px;color:${gradeColor}">Grade: ${marketGrade.grade || 'B'}</div>
                </div>
                ${pb1 ? `
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--purple)">
                    <div style="font-size:10px;color:var(--text3)">PULLBACK 1 (${pb1.size || '50%'})</div>
                    <div style="font-size:13px;font-weight:700;color:var(--purple)">$${fmtPrice(pb1.price)}</div>
                    <div style="font-size:9px;color:var(--purple)">${pb1.reason || 'OB'} • ${sigDirection === 'LONG' ? '-' : '+'}${pb1.distPct || 0}%</div>
                    <div style="font-size:10px;color:${gradeColors[pb1.grade?.grade] || 'var(--text3)'}">Grade: ${pb1.grade?.grade || 'B+'}</div>
                </div>
                ` : ''}
                ${pb2 ? `
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--purple)">
                    <div style="font-size:10px;color:var(--text3)">PULLBACK 2 (${pb2.size || '25%'})</div>
                    <div style="font-size:13px;font-weight:700;color:var(--purple)">$${fmtPrice(pb2.price)}</div>
                    <div style="font-size:9px;color:var(--purple)">${pb2.reason || 'FVG'} • ${sigDirection === 'LONG' ? '-' : '+'}${pb2.distPct || 0}%</div>
                    <div style="font-size:10px;color:${gradeColors[pb2.grade?.grade] || 'var(--text3)'}">Grade: ${pb2.grade?.grade || 'A'}</div>
                </div>
                ` : ''}
            </div>
            ${entryData.avgEntry ? `
            <div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border);display:flex;justify-content:space-between">
                <span style="font-size:10px;color:var(--text3)">Avg Entry (if all fill):</span>
                <span style="font-size:11px;font-weight:600;color:var(--text)">$${fmtPrice(entryData.avgEntry)}</span>
            </div>
            ` : ''}
        </div>
    `;
    
    // Smart SL HTML
    const smartSLHtml = `
        <div style="background:var(--short-dim);border:1px solid var(--short);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                <span style="font-size:11px;font-weight:600;color:var(--short)">🛑 SMART STOP LOSS</span>
                <span style="font-size:12px;font-weight:700;color:var(--short)">$${fmtPrice(sigLevelsLocal.sl || 0)} (${slData.riskPct || sigLevelsLocal.riskPct || '?'}%)</span>
            </div>
            <div style="font-size:10px;color:var(--text2)">${slData.reason || 'Structure-based'}</div>
            ${slData.trapAvoided ? `<div style="font-size:10px;color:var(--long);margin-top:4px">✅ Liquidity trap avoided</div>` : ''}
        </div>
    `;
    
    // Smart TPs HTML - Direction-aware colors
    const tpColor = sigDirection === 'LONG' ? 'var(--long)' : 'var(--short)';
    const tpBgColor = sigDirection === 'LONG' ? 'var(--long-dim)' : 'var(--short-dim)';
    const tpSign = sigDirection === 'LONG' ? '+' : '-';
    
    // Safe calculations for TP distances
    const safeEntry = sigLevelsLocal.entry || sig.price || 1;
    const safeTp1 = sigLevelsLocal.tp1 || safeEntry;
    const safeTp2 = sigLevelsLocal.tp2 || safeEntry;
    const safeTp3 = sigLevelsLocal.tp3 || safeEntry;
    
    const smartTPsHtml = `
        <div style="background:${tpBgColor};border:1px solid ${tpColor};border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="font-size:11px;font-weight:600;color:${tpColor};margin-bottom:8px">🎯 SMART TAKE PROFITS</div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px">
                <div style="background:var(--bg3);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">TP1</div>
                    <div style="font-size:12px;font-weight:700;color:${tpColor}">$${fmtPrice(safeTp1)}</div>
                    <div style="font-size:9px;color:${tpColor}">${tpSign}${tp1Data.distPct || ((Math.abs(safeTp1 - safeEntry) / safeEntry) * 100).toFixed(2)}%</div>
                    <div style="font-size:9px;color:var(--text2)">${tp1Data.probability || 70}% prob</div>
                    <div style="font-size:8px;color:var(--text3)">${tp1Data.reason || 'Liquidity'}</div>
                </div>
                <div style="background:var(--bg3);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">TP2</div>
                    <div style="font-size:12px;font-weight:700;color:${tpColor}">$${fmtPrice(safeTp2)}</div>
                    <div style="font-size:9px;color:${tpColor}">${tpSign}${tp2Data.distPct || ((Math.abs(safeTp2 - safeEntry) / safeEntry) * 100).toFixed(2)}%</div>
                    <div style="font-size:9px;color:var(--text2)">${tp2Data.probability || 55}% prob</div>
                    <div style="font-size:8px;color:var(--text3)">${tp2Data.reason || 'OB Target'}</div>
                </div>
                <div style="background:var(--bg3);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">TP3</div>
                    <div style="font-size:12px;font-weight:700;color:${tpColor}">$${fmtPrice(safeTp3)}</div>
                    <div style="font-size:9px;color:${tpColor}">${tpSign}${tp3Data.distPct || ((Math.abs(safeTp3 - safeEntry) / safeEntry) * 100).toFixed(2)}%</div>
                    <div style="font-size:9px;color:var(--text2)">${tp3Data.probability || 40}% prob</div>
                    <div style="font-size:8px;color:var(--text3)">${tp3Data.reason || 'HTF Level'}</div>
                </div>
            </div>
            <div style="margin-top:8px;display:flex;justify-content:space-between;padding-top:8px;border-top:1px solid var(--border)">
                <span style="font-size:10px;color:var(--text3)">R:R from Avg Entry:</span>
                <span style="font-size:11px;font-weight:700;color:${tpColor}">1:${sigLevelsLocal.rr || '?'}</span>
            </div>
        </div>
    `;
    
    // Leverage & Sizing HTML
    const leverageHtml = `
        <div style="background:var(--bg4);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="font-size:11px;font-weight:600;color:var(--gold);margin-bottom:8px">⚡ LEVERAGE & SIZING</div>
            <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px">
                <div style="text-align:center">
                    <div style="font-size:10px;color:var(--text3)">Safe Leverage</div>
                    <div style="font-size:14px;font-weight:700;color:var(--long)">${marketGrade.leverage?.safe || 5}x</div>
                </div>
                <div style="text-align:center">
                    <div style="font-size:10px;color:var(--text3)">Max Leverage</div>
                    <div style="font-size:14px;font-weight:700;color:var(--amber)">${marketGrade.leverage?.max || 10}x</div>
                </div>
            </div>
            <div style="margin-top:8px;text-align:center">
                <span style="font-size:10px;color:var(--text3)">Confidence: </span>
                <span style="font-size:11px;font-weight:600;color:${gradeColor}">${marketGrade.confidence || 'MEDIUM'}</span>
            </div>
        </div>
    `;
    
    // 🏦 Institutional Data HTML
    const inst = sig.institutional || {};
    const instA = sig.instAnalysis || {};
    const funding = inst.funding || {};
    const oi = inst.openInterest || {};
    const lsRatio = inst.longShortRatio || {};
    const squeeze = inst.squeezeRisk;
    const liqLevels = inst.liquidationLevels || {};
    
    // Institutional bias color
    const instBiasColor = inst.institutionalBias === 'BULLISH' ? 'var(--long)' :
                         inst.institutionalBias === 'BEARISH' ? 'var(--short)' :
                         inst.institutionalBias === 'SLIGHTLY_BULLISH' ? 'var(--cyan)' :
                         inst.institutionalBias === 'SLIGHTLY_BEARISH' ? 'var(--amber)' : 'var(--text2)';
    
    // Recommendation color
    const recColor = instA.recommendation === 'STRONG_CONFIRM' ? 'var(--long)' :
                    instA.recommendation === 'CONFIRM' ? 'var(--cyan)' :
                    instA.recommendation === 'AVOID' ? 'var(--short)' :
                    instA.recommendation === 'CAUTION' ? 'var(--amber)' : 'var(--text2)';
    
    const institutionalHtml = inst.funding ? `
        <div style="background:linear-gradient(135deg, var(--bg4) 0%, rgba(147, 112, 219, 0.1) 100%);border:1px solid var(--purple);border-radius:8px;padding:12px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                <span style="font-size:12px;font-weight:700;color:var(--purple)">🏦 INSTITUTIONAL DATA</span>
                <span style="font-size:11px;padding:3px 8px;border-radius:4px;background:${instBiasColor};color:var(--bg1);font-weight:700">${inst.institutionalBias || 'NEUTRAL'}</span>
            </div>
            
            <!-- Funding Rate -->
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px">
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">FUNDING RATE</div>
                    <div style="font-size:13px;font-weight:700;color:${parseFloat(funding.rate || 0) > 0 ? 'var(--short)' : parseFloat(funding.rate || 0) < 0 ? 'var(--long)' : 'var(--text)'}">${funding.ratePercent || '0.00'}%</div>
                    <div style="font-size:8px;color:var(--text3)">${funding.signal || ''}</div>
                </div>
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">OPEN INTEREST</div>
                    <div style="font-size:13px;font-weight:700;color:${parseFloat(oi.change4h || 0) > 0 ? 'var(--long)' : 'var(--short)'}">${oi.change4h || '0'}%</div>
                    <div style="font-size:8px;color:var(--text3)">${oi.trend || 'STABLE'}</div>
                </div>
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">L/S RATIO</div>
                    <div style="font-size:13px;font-weight:700;color:${parseFloat(lsRatio.buyRatio || 50) > 55 ? 'var(--long)' : parseFloat(lsRatio.sellRatio || 50) > 55 ? 'var(--short)' : 'var(--text)'}">${lsRatio.buyRatio || '50'}%L</div>
                    <div style="font-size:8px;color:var(--text3)">${lsRatio.dominance || 'BALANCED'}</div>
                </div>
            </div>
            
            <!-- Squeeze Alert -->
            ${squeeze ? `
            <div style="background:${squeeze.type === 'LONG_SQUEEZE' ? 'var(--short-dim)' : 'var(--long-dim)'};border:1px solid ${squeeze.type === 'LONG_SQUEEZE' ? 'var(--short)' : 'var(--long)'};border-radius:6px;padding:8px;margin-bottom:10px">
                <div style="display:flex;justify-content:space-between;align-items:center">
                    <span style="font-size:11px;font-weight:700;color:${squeeze.type === 'LONG_SQUEEZE' ? 'var(--short)' : 'var(--long)'}">
                        ${squeeze.type === 'LONG_SQUEEZE' ? '🔻 LONG SQUEEZE RISK' : '🚀 SHORT SQUEEZE RISK'}
                    </span>
                    <span style="font-size:10px;padding:2px 6px;border-radius:3px;background:${squeeze.probability === 'HIGH' ? 'var(--short)' : 'var(--amber)'};color:var(--bg1);font-weight:600">${squeeze.probability}</span>
                </div>
                <div style="font-size:9px;color:var(--text2);margin-top:4px">${squeeze.reason}</div>
                <div style="font-size:9px;color:var(--text3);margin-top:2px">Trigger: $${fmtPrice(squeeze.trigger)}</div>
            </div>
            ` : ''}
            
            <!-- Liquidation Levels -->
            ${liqLevels.magnetLong ? `
            <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:8px">
                <div style="background:var(--short-dim);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--short)">LONG LIQⓁ MAGNET</div>
                    <div style="font-size:11px;font-weight:700;color:var(--short)">$${fmtPrice(liqLevels.magnetLong)}</div>
                    <div style="font-size:8px;color:var(--text3)">20x lev cluster</div>
                </div>
                <div style="background:var(--long-dim);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--long)">SHORT LIQ MAGNET</div>
                    <div style="font-size:11px;font-weight:700;color:var(--long)">$${fmtPrice(liqLevels.magnetShort)}</div>
                    <div style="font-size:8px;color:var(--text3)">20x lev cluster</div>
                </div>
            </div>
            ` : ''}
            
            <!-- Institutional Recommendation -->
            <div style="display:flex;justify-content:space-between;align-items:center;padding-top:8px;border-top:1px solid var(--border)">
                <span style="font-size:10px;color:var(--text3)">Inst. Recommendation:</span>
                <span style="font-size:11px;font-weight:700;color:${recColor}">${instA.recommendation || 'NEUTRAL'} (${instA.score > 0 ? '+' : ''}${instA.score || 0})</span>
            </div>
        </div>
    ` : `
        <div style="background:var(--bg4);border:1px dashed var(--border);border-radius:8px;padding:12px;margin-bottom:12px;text-align:center">
            <span style="font-size:11px;color:var(--text3)">🏦 Institutional data loading...</span>
        </div>
    `;
    
    // Trade Levels (legacy format for compatibility)
    const tradeHtml = `
        <div class="trade-section">
            <div class="trade-title">📊 Trade Levels</div>
            ${smartEntryHtml}
            ${smartSLHtml}
            ${smartTPsHtml}
            ${leverageHtml}
            ${institutionalHtml}
            <div class="trade-meta">
                <span class="rr-tag">Market R:R 1:${sigLevelsLocal.rr || '?'} | Limit R:R 1:${sigLevelsLocal.limitRR || '?'}</span>
                <button class="tv-btn" onclick="openTradingView('${sig.symbol}', '${sig.tfRaw}')">📊 TradingView</button>
                <button class="save-btn" onclick="saveTrade()">💾 Save Trade</button>
            </div>
        </div>
    `;
    
    // Agreement Box
    const zoneAgree = sig.engineDirections.zone === sig.direction;
    const smcAgree = sig.engineDirections.smc === sig.direction;
    const momAgree = sig.engineDirections.momentum === sig.direction;
    // Use direction-appropriate color: GREEN for LONG, RED for SHORT
    const dirColor = sig.direction === 'LONG' ? 'var(--long)' : 'var(--short)';
    const agreementColor = sig.agreed === 3 ? dirColor : 'var(--amber)';
    
    const agreementHtml = `
        <div style="background:var(--bg4);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                <span style="font-size:11px;color:var(--text2)">🎯 Engine Agreement</span>
                <span style="font-size:14px;font-weight:700;color:${agreementColor}">${sig.agreed}/3 Agree</span>
            </div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px">
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${zoneAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">ZONE</div>
                    <div style="font-size:12px;font-weight:700;color:${zoneAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.zone || 'N/A'}</div>
                    <div style="font-size:11px;color:${zoneAgree ? dirColor : 'var(--text3)'}">${zoneAgree ? '✓ Agrees' : '✗ Differs'}</div>
                </div>
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${smcAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">SMC</div>
                    <div style="font-size:12px;font-weight:700;color:${smcAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.smc || 'N/A'}</div>
                    <div style="font-size:11px;color:${smcAgree ? dirColor : 'var(--text3)'}">${smcAgree ? '✓ Agrees' : '✗ Differs'}</div>
                </div>
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${momAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">MOMENTUM</div>
                    <div style="font-size:12px;font-weight:700;color:${momAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.momentum || 'N/A'}</div>
                    <div style="font-size:11px;color:${momAgree ? dirColor : 'var(--text3)'}">${momAgree ? '✓ Agrees' : '✗ Differs'}</div>
                </div>
            </div>
        </div>
    `;
    
    // Environment Panel HTML
    const envPanelHtml = sig.environment ? generateEnvPanelHtml(sig) : '';
    
    // Awareness Panel HTML (Session + News)
    const awarenessHtml = generateAwarenessHtml();
    
    // Safe property access for header (sigDirection already defined above)
    const sigGrade = sig.grade || 'VALID';
    const sigTf = sig.tf || '1H';
    const sigLevels = sig.levels || {};
    
    el.innerHTML = `
        <div class="detail-box">
            <div class="detail-header">
                <div class="detail-title">
                    <span class="detail-pair">${sig.symbol.replace('USDT', '')}</span>
                    <span class="dir-tag ${sigDirection.toLowerCase()}" style="font-size:12px;padding:4px 10px">${sigDirection}</span>
                    <span class="grade ${sigGrade.toLowerCase()}" style="font-size:11px;padding:4px 10px">${sigGrade}</span>
                    <span class="tf-tag" style="font-size:12px">${sigTf}</span>
                </div>
                <div class="detail-price">
                    <div class="detail-price-label">Current Price</div>
                    <div class="detail-price-value">$${fmtPrice(sig.price)}</div>
                </div>
            </div>
            ${savedComparisonHtml}
            ${awarenessHtml}
            ${envPanelHtml}
            ${agreementHtml}
            ${htfHtml}
            ${gpoteHtml}
            ${aiHtml}
            ${warningsHtml}
            ${analysisHtml}
            ${tradeHtml}
        </div>
    `;
    console.log('🟢 Main panel rendered successfully!');
    } catch (panelError) {
        console.error('🛡️ Panel update error:', panelError);
        console.error('Stack:', panelError.stack);
        console.error('Signal data:', STATE.current);
        const el = document.getElementById('mainPanel');
        if (el) {
            el.innerHTML = '<div class="empty"><div style="color:var(--amber)">⚠️ Display error - check console (F12)</div><div style="color:var(--text3);font-size:11px;margin-top:8px">' + panelError.message + '</div></div>';
        }
        toast('Panel display error', 'error');
    }
}

function getFactorClass(factor) {
    const bullish = ['↑', 'Bull', 'Support', 'Discount', 'OS', 'MACD+', 'OBV+', 'Golden', '+'];
    const bearish = ['↓', 'Bear', 'Resist', 'Premium', 'OB', 'MACD-', 'OBV-', 'Death', '-'];
    
    for (const b of bullish) {
        if (factor.includes(b)) return 'bull';
    }
    for (const s of bearish) {
        if (factor.includes(s)) return 'bear';
    }
    return '';
}


// ═══════════════════════════════════════════════════════════════════════════════
// 💾 ENHANCED SAVED TRADES SYSTEM v2.0
// ═══════════════════════════════════════════════════════════════════════════════

// Status constants
const TRADE_STATUS = {
    STRONG_PROFIT: { label: 'STRONG PROFIT', emoji: '🚀', class: 'strong-profit' },
    IN_PROFIT: { label: 'IN PROFIT', emoji: '✅', class: 'in-profit' },
    TP1_HIT: { label: 'TP1 HIT!', emoji: '🎯', class: 'tp-hit' },
    TP2_HIT: { label: 'TP2 HIT!', emoji: '🎯🎯', class: 'tp-hit' },
    TP3_HIT: { label: 'TP3 HIT!', emoji: '🏆', class: 'tp-hit' },
    NEAR_ENTRY: { label: 'NEAR ENTRY', emoji: '⏳', class: 'near-entry' },
    SMALL_LOSS: { label: 'SMALL LOSS', emoji: '⚠️', class: 'small-loss' },
    AT_RISK: { label: 'AT RISK', emoji: '🔴', class: 'at-risk' },
    STOPPED_OUT: { label: 'STOPPED OUT', emoji: '💀', class: 'stopped-out' },
    LOADING: { label: 'LOADING', emoji: '⏳', class: 'loading' }
};

// ═══════════════════════════════════════════════════════════════════════════════
// TRADINGVIEW INTEGRATION - Open chart in TradingView (Basic Plan Compatible)
// ═══════════════════════════════════════════════════════════════════════════════

function openTradingView(symbol, tf) {
    // Convert scanner timeframe to TradingView format
    const tvTimeframes = {
        '1': '1',
        '3': '3',
        '5': '5',
        '15': '15',
        '30': '30',
        '60': '60',
        '120': '120',
        '240': '240',
        'D': 'D',
        '1D': 'D',
        'W': 'W',
        '1W': 'W'
    };
    
    const tvTF = tvTimeframes[tf] || '15';
    
    // Clean symbol (remove USDT suffix variations)
    const cleanSymbol = symbol.replace('USDT', '').replace('PERP', '');
    
    // Build TradingView URL - BYBIT perpetual futures
    // Format: BYBIT:BTCUSDT.P for perpetuals
    const tvSymbol = `BYBIT:${cleanSymbol}USDT.P`;
    
    // TradingView public chart URL (works on Basic/Free plan)
    const url = `https://www.tradingview.com/chart/?symbol=${tvSymbol}&interval=${tvTF}`;
    
    // Open in new tab
    window.open(url, '_blank');
    
    toast(`Opening ${cleanSymbol} ${tvTF} on TradingView...`, 'success');
}

// Save current signal to saved trades - ENHANCED
function saveTrade() {
    try {
    const sig = STATE.current;
    if (!sig) {
        toast('No signal selected!', 'error');
        return;
    }
    
    // Check if already saved
    const exists = STATE.savedTrades.find(t => 
        t.symbol === sig.symbol && t.tf === sig.tf && t.direction === sig.direction
    );
    
    if (exists) {
        toast('Trade already saved!', 'warning');
        return;
    }
    
    // Enhanced saved trade structure
    const savedTrade = {
        id: Date.now(),
        symbol: sig.symbol,
        tf: sig.tf,
        tfRaw: sig.tfRaw,
        direction: sig.direction,
        
        // ORIGINAL DATA (never changes) - with null safety
        original: {
            price: sig.price,
            entry: sig.levels?.entry || sig.price,
            sl: sig.levels?.sl || 0,
            tp1: sig.levels?.tp1 || 0,
            tp2: sig.levels?.tp2 || 0,
            tp3: sig.levels?.tp3 || 0,
            rr: sig.levels?.rr || '?',
            riskPct: sig.levels?.riskPct || '?',
            grade: sig.grade || 'VALID',
            score: sig.score || 0,
            agreed: sig.agreed || 0,
            factors: sig.factors ? sig.factors.slice(0, 5) : [],
            warnings: sig.warnings ? sig.warnings.slice(0, 3) : [],
            smart: sig.levels?.smart || null,
            institutional: sig.institutional,
            instAnalysis: sig.instAnalysis,
            zone: sig.zone,
            smc: sig.smc,
            momentum: sig.momentum,
            candlePatterns: sig.candlePatterns
        },
        
        // LIVE DATA (updates every scan)
        live: {
            currentPrice: sig.price,
            pnlAbsolute: 0,
            pnlPercent: 0,
            distanceToSL: 0,
            distanceToTP1: 0,
            distanceToTP2: 0,
            distanceToTP3: 0,
            progressPercent: 0,
            status: 'NEAR_ENTRY',
            structureValid: true,
            newPatterns: [],
            lastUpdated: Date.now()
        },
        
        // AI INTERPRETATION
        ai: {
            commentary: null,
            recommendation: null,
            moveSlToBE: false,
            warnings: [],
            confidence: 0,
            lastUpdated: null
        },
        
        savedAt: Date.now(),
        savedAtStr: new Date().toLocaleString()
    };
    
    // Calculate initial live data
    updateSavedTradeLiveData(savedTrade, sig.price);
    
    STATE.savedTrades.unshift(savedTrade);
    
    if (STATE.savedTrades.length > 50) {
        STATE.savedTrades = STATE.savedTrades.slice(0, 50);
    }
    
    saveSavedTrades();
    updateSavedTradesListEnhanced();
    
    toast(`💾 Saved ${sig.symbol.replace('USDT', '')} ${sig.direction}!`, 'success');
    } catch (e) {
        console.error('saveTrade error:', e);
        toast('Error saving trade: ' + e.message, 'error');
    }
}

// Update live data for a saved trade
function updateSavedTradeLiveData(trade, currentPrice) {
    const orig = trade.original || trade;
    const isLong = trade.direction === 'LONG';
    
    // Protect against division by zero
    const entryPrice = orig.entry || 1;
    const currentP = currentPrice || entryPrice;
    
    const pnlAbsolute = isLong ? currentP - entryPrice : entryPrice - currentP;
    const pnlPercent = entryPrice > 0 ? (pnlAbsolute / entryPrice) * 100 : 0;
    
    const distanceToSL = currentP > 0 ? Math.abs(currentP - (orig.sl || 0)) / currentP * 100 : 0;
    const distanceToTP1 = currentP > 0 ? Math.abs((orig.tp1 || 0) - currentP) / currentP * 100 : 0;
    const distanceToTP2 = currentP > 0 ? Math.abs((orig.tp2 || 0) - currentP) / currentP * 100 : 0;
    const distanceToTP3 = currentP > 0 ? Math.abs((orig.tp3 || 0) - currentP) / currentP * 100 : 0;
    
    const totalDistance = Math.abs((orig.tp1 || 0) - entryPrice);
    const coveredDistance = isLong 
        ? Math.max(0, currentP - entryPrice)
        : Math.max(0, entryPrice - currentP);
    const progressPercent = totalDistance > 0 ? Math.min(100, (coveredDistance / totalDistance) * 100) : 0;
    
    // Determine status
    let status = 'NEAR_ENTRY';
    
    if (isLong && currentPrice <= orig.sl) status = 'STOPPED_OUT';
    else if (!isLong && currentPrice >= orig.sl) status = 'STOPPED_OUT';
    else if (isLong && currentPrice >= orig.tp3) status = 'TP3_HIT';
    else if (!isLong && currentPrice <= orig.tp3) status = 'TP3_HIT';
    else if (isLong && currentPrice >= orig.tp2) status = 'TP2_HIT';
    else if (!isLong && currentPrice <= orig.tp2) status = 'TP2_HIT';
    else if (isLong && currentPrice >= orig.tp1) status = 'TP1_HIT';
    else if (!isLong && currentPrice <= orig.tp1) status = 'TP1_HIT';
    else if (pnlPercent >= 2) status = 'STRONG_PROFIT';
    else if (pnlPercent > 0.3) status = 'IN_PROFIT';
    else if (pnlPercent >= -0.5) status = 'NEAR_ENTRY';
    else if (pnlPercent >= -1.5) status = 'SMALL_LOSS';
    else status = 'AT_RISK';
    
    // 🧠 PATTERN MEMORY: Record result when trade completes (only once)
    const prevStatus = trade.live?.status;
    const finalStatuses = ['TP1_HIT', 'TP2_HIT', 'TP3_HIT', 'STOPPED_OUT'];
    const isNewFinalStatus = finalStatuses.includes(status) && !finalStatuses.includes(prevStatus);
    
    if (isNewFinalStatus && !trade.resultRecorded) {
        const isWin = status.includes('TP');
        const result = isWin ? 'WIN' : 'LOSS';
        
        // Record to Pattern Memory Brain
        try {
            recordPatternResult({
                symbol: trade.symbol,
                tf: trade.tf,
                direction: trade.direction,
                grade: trade.grade,
                score: trade.score || 0,
                scores: trade.original?.scores || {},
                intent: trade.intent || 'UNKNOWN',
                pnl: pnlPercent
            }, result);
            
            // Record to Drawdown Tracker
            recordTradeResult(isWin, pnlPercent);
            
            console.log(`🧠 Brain learned: ${trade.symbol} ${trade.tf} = ${result} (${pnlPercent.toFixed(2)}%)`);
        } catch (e) {
            console.warn('Pattern recording error:', e);
        }
        
        // Mark as recorded so we don't record again
        trade.resultRecorded = true;
    }
    
    trade.live = {
        currentPrice,
        pnlAbsolute,
        pnlPercent,
        distanceToSL,
        distanceToTP1,
        distanceToTP2,
        distanceToTP3,
        progressPercent,
        status,
        structureValid: trade.live?.structureValid ?? true,
        newPatterns: trade.live?.newPatterns ?? [],
        lastUpdated: Date.now()
    };
    
    return trade;
}

// Fetch current price for saved trade - BINANCE API
async function fetchCurrentPriceForSaved(symbol) {
    try {
        const url = `${CONFIG.BYBIT_V5}/market/tickers?category=linear&symbol=${symbol}`;
        const data = await fetchJSON(url);
        if (data?.price) {
            return parseFloat(data.price);
        }
    } catch (e) {
        console.error(`Failed to fetch price for ${symbol}:`, e);
    }
    return null;
}

// Update all saved trades with live data
async function updateAllSavedTradesLive() {
    if (STATE.savedTrades.length === 0) return;
    
    console.log('📊 Updating saved trades live data...');
    
    for (const trade of STATE.savedTrades) {
        const currentPrice = await fetchCurrentPriceForSaved(trade.symbol);
        if (currentPrice) {
            updateSavedTradeLiveData(trade, currentPrice);
        }
    }
    
    saveSavedTrades();
    updateSavedTradesListEnhanced();
    console.log('✅ Saved trades updated');
}

// Refresh single saved trade
async function refreshSavedTrade(tradeId) {
    const trade = STATE.savedTrades.find(t => t.id === tradeId);
    if (!trade) return;
    
    toast(`🔄 Refreshing ${trade.symbol.replace('USDT', '')}...`, 'info');
    
    const currentPrice = await fetchCurrentPriceForSaved(trade.symbol);
    if (currentPrice) {
        updateSavedTradeLiveData(trade, currentPrice);
        saveSavedTrades();
        updateSavedTradesListEnhanced();
        toast(`✅ ${trade.symbol.replace('USDT', '')} updated!`, 'success');
    } else {
        toast(`❌ Failed to update`, 'error');
    }
}

// Get AI interpretation for saved trade
async function getAITradeInterpretation(tradeId) {
    const trade = STATE.savedTrades.find(t => t.id === tradeId);
    if (!trade) return;
    
    if (!STATE.aiKey) {
        toast('AI not configured. Add API key in settings.', 'warning');
        return;
    }
    
    // SAFETY: Prevent concurrent AI calls
    if (STATE.aiCallInProgress) {
        toast('AI analysis in progress...', 'warning');
        return;
    }
    
    STATE.aiCallInProgress = true;
    toast(`🤖 Getting AI analysis...`, 'info');
    
    try {
    const orig = trade.original || trade;
    const live = trade.live || {};
    const statusInfo = TRADE_STATUS[live.status] || TRADE_STATUS.LOADING;
    const hoursSinceSaved = ((Date.now() - trade.savedAt) / (1000 * 60 * 60)).toFixed(1);
    
    const prompt = `You are monitoring an ACTIVE crypto futures trade. Provide a brief progress update.

TRADE: ${trade.symbol} ${trade.direction} (${trade.tf})
Saved: ${hoursSinceSaved} hours ago

ORIGINAL:
- Entry: $${fmtPrice(orig.entry)} | SL: $${fmtPrice(orig.sl)} (${orig.riskPct}%)
- TP1: $${fmtPrice(orig.tp1)} | TP2: $${fmtPrice(orig.tp2)} | TP3: $${fmtPrice(orig.tp3)}
- Grade: ${orig.grade} (${orig.score}/100) | R:R: 1:${orig.rr}

CURRENT:
- Price: $${fmtPrice(live.currentPrice)} | P&L: ${live.pnlPercent >= 0 ? '+' : ''}${(live.pnlPercent || 0).toFixed(2)}%
- Status: ${statusInfo.label} | Progress to TP1: ${(live.progressPercent || 0).toFixed(0)}%
- Distance to SL: ${(live.distanceToSL || 0).toFixed(2)}% | to TP1: ${(live.distanceToTP1 || 0).toFixed(2)}%

TASK: Provide 2-3 sentence update on progress, concerns, and if SL should move to breakeven.

Respond ONLY with JSON:
{
    "commentary": "Your analysis here",
    "recommendation": "HOLD" or "TAKE_PROFIT" or "MOVE_SL_TO_BE" or "EXIT",
    "moveSlToBE": true/false,
    "warnings": [],
    "confidence": 0-100
}`;

        const response = await callMultiAI(prompt);
        
        if (response) {
            trade.ai = {
                commentary: response.commentary || response.executiveSummary || 'Analysis complete.',
                recommendation: response.recommendation || 'HOLD',
                moveSlToBE: response.moveSlToBE || false,
                warnings: response.warnings || [],
                confidence: response.confidence || 50,
                lastUpdated: Date.now()
            };
            
            saveSavedTrades();
            updateSavedTradesListEnhanced();
            toast(`🤖 AI analysis complete!`, 'success');
        } else {
            toast(`❌ AI analysis failed`, 'error');
        }
    } catch (e) {
        console.error('AI interpretation error:', e);
        toast(`❌ AI analysis failed`, 'error');
    } finally {
        // SAFETY: Always release AI lock
        STATE.aiCallInProgress = false;
    }
}

// Delete saved trade
function deleteSavedTrade(id) {
    STATE.savedTrades = STATE.savedTrades.filter(t => t.id !== id);
    saveSavedTrades();
    updateSavedTradesListEnhanced();
    toast('Trade deleted', 'success');
}

// View saved trade details
async function viewSavedTrade(id) {
    const trade = STATE.savedTrades.find(t => t.id === id);
    if (!trade) {
        toast('Trade not found', 'error');
        return;
    }
    
    // Get original data (handles both old and new format)
    const orig = trade.original || trade;
    
    // First check if signal exists in current scan results
    const matchingSignal = STATE.signals.find(s => 
        s.symbol === trade.symbol && s.tfRaw === trade.tfRaw
    );
    
    if (matchingSignal) {
        // Signal exists in current scan - use it directly
        // Add saved trade comparison data
        matchingSignal.savedTrade = {
            savedAt: trade.savedAt,
            savedEntry: orig.entry,
            savedSL: orig.sl,
            savedTP1: orig.tp1,
            savedTP2: orig.tp2,
            savedTP3: orig.tp3,
            savedDirection: trade.direction,
            savedGrade: orig.grade,
            savedScore: orig.score
        };
        selectSignal(STATE.signals.indexOf(matchingSignal));
        toast(`✅ ${trade.symbol} - Live data loaded`, 'success');
    } else {
        // Signal NOT in current scan - RESCAN to get full analysis
        toast(`🔄 Rescanning ${trade.symbol} ${trade.tf}...`, '');
        
        try {
            // Run full analysis on this specific coin/timeframe
            const freshSignal = await analyzeSignal(trade.symbol, trade.tfRaw);
            
            if (freshSignal) {
                // Add saved trade data for comparison
                freshSignal.savedTrade = {
                    savedAt: trade.savedAt,
                    savedEntry: orig.entry,
                    savedSL: orig.sl,
                    savedTP1: orig.tp1,
                    savedTP2: orig.tp2,
                    savedTP3: orig.tp3,
                    savedDirection: trade.direction,
                    savedGrade: orig.grade,
                    savedScore: orig.score
                };
                
                // Add to signals array temporarily so selectSignal works
                STATE.signals.unshift(freshSignal);
                
                // Limit signals array size (SAFETY)
                if (STATE.signals.length > 500) {
                    STATE.signals = STATE.signals.slice(0, 500);
                }
                
                // Select and display
                STATE.selected = 0;
                STATE.current = freshSignal;
                STATE.aiResult = null;  // Clear old AI result
                updateMainPanel();
                updateSignalList();
                
                // Auto-scroll to main panel on mobile
                const mainPanel = document.getElementById('mainPanel');
                if (mainPanel && window.innerWidth < 900) {
                    setTimeout(() => {
                        mainPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                }
                
                toast(`✅ ${trade.symbol} - Fresh analysis loaded!`, 'success');
            } else {
                // Analysis failed - show saved data as fallback
                displaySavedTradeDetailEnhanced(trade);
                toast(`⚠️ Could not fetch live data - showing saved`, 'warning');
                
                // Auto-scroll to main panel on mobile
                const mainPanel = document.getElementById('mainPanel');
                if (mainPanel && window.innerWidth < 900) {
                    setTimeout(() => {
                        mainPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                }
            }
        } catch (e) {
            console.error('Rescan error:', e);
            displaySavedTradeDetailEnhanced(trade);
            toast(`❌ Rescan failed - showing saved data`, 'error');
        }
    }
}


// ═══════════════════════════════════════════════════════════════════════════════
// TRADE TRACKING
// ═══════════════════════════════════════════════════════════════════════════════

function trackTrade() {
    if (!STATE.current) {
        toast('No signal selected!', 'error');
        return;
    }
    
    const sig = STATE.current;
    
    // Check if already tracking
    const exists = STATE.trades.find(t => t.symbol === sig.symbol && t.tf === sig.tf);
    if (exists) {
        toast('Already tracking this trade!', 'warning');
        return;
    }
    
    const trade = {
        id: Date.now(),
        symbol: sig.symbol,
        tf: sig.tf,
        direction: sig.direction,
        grade: sig.grade || 'VALID',
        entry: sig.levels?.entry || sig.price,
        sl: sig.levels?.sl || 0,
        tp1: sig.levels?.tp1 || 0,
        tp2: sig.levels?.tp2 || 0,
        tp3: sig.levels?.tp3 || 0,
        rr: sig.levels?.rr || '?',
        currentPrice: sig.price,
        tp1Hit: false,
        tp2Hit: false,
        tp3Hit: false,
        slHit: false,
        timestamp: new Date().toISOString()
    };
    
    STATE.trades.push(trade);
    saveTrades();
    updateTradeList();
    
    toast(`📌 Tracking ${sig.symbol.replace('USDT', '')} ${sig.direction}!`, 'success');
}

function closeTrade(id) {
    const trade = STATE.trades.find(t => t.id === id);
    if (trade) {
        // Save to history before removing
        trade.closedAt = Date.now();
        trade.status = 'closed';
        
        // Calculate P&L if we have prices
        if (trade.currentPrice && trade.entry) {
            const pnlPercent = trade.direction === 'LONG' 
                ? ((trade.currentPrice - trade.entry) / trade.entry) * 100
                : ((trade.entry - trade.currentPrice) / trade.entry) * 100;
            trade.pnlPercent = pnlPercent.toFixed(2);
        }
        
        // Add to history
        STATE.tradeHistory = STATE.tradeHistory || [];
        STATE.tradeHistory.unshift(trade);
        
        // Keep only last 100 trades
        if (STATE.tradeHistory.length > 100) {
            STATE.tradeHistory = STATE.tradeHistory.slice(0, 100);
        }
        
        saveTradeHistory();
    }
    
    STATE.trades = STATE.trades.filter(t => t.id !== id);
    saveTrades();
    updateTradeList();
    toast('Trade closed & saved to history', 'success');
}

// Save trade history
function saveTradeHistory() {
    safeStorageSet('bybit_scanner_trade_history', STATE.tradeHistory || []);
}

// Load trade history
function loadTradeHistory() {
    const saved = safeStorageGet('bybit_scanner_trade_history', []);
    STATE.tradeHistory = Array.isArray(saved) ? saved : [];
}

// Get trade stats from history
function getTradeStats() {
    const history = STATE.tradeHistory || [];
    const total = history.length;
    const profitable = history.filter(t => parseFloat(t.pnlPercent || 0) > 0).length;
    const losing = history.filter(t => parseFloat(t.pnlPercent || 0) < 0).length;
    const winRate = total > 0 ? ((profitable / total) * 100).toFixed(1) : 0;
    
    let totalPnL = 0;
    history.forEach(t => {
        if (t.pnlPercent) totalPnL += parseFloat(t.pnlPercent);
    });
    
    return { profitable, losing, total, winRate, totalPnL: totalPnL.toFixed(2) };
}

function saveTrades() {
    safeStorageSet('bybit_scanner_trades', STATE.trades);
}

function loadTrades() {
    const saved = safeStorageGet('bybit_scanner_trades', []);
    STATE.trades = Array.isArray(saved) ? saved : [];
    // Also load history
    loadTradeHistory();
    // Also load saved trades
    loadSavedTrades();
}

// Display saved trade detail - Enhanced with 3 rows
function displaySavedTradeDetailEnhanced(trade) {
    const el = document.getElementById('mainPanel');
    const orig = trade.original || trade;
    const live = trade.live || {};
    const ai = trade.ai || {};
    
    const statusInfo = TRADE_STATUS[live.status] || TRADE_STATUS.LOADING;
    const pnlClass = (live.pnlPercent || 0) >= 0 ? 'profit' : 'loss';
    const statusBg = statusInfo.class.includes('profit') || statusInfo.class.includes('tp') ? 'var(--long-dim)' : 
                     statusInfo.class.includes('risk') || statusInfo.class.includes('stop') ? 'var(--short-dim)' : 'var(--amber-dim)';
    const statusBorder = statusInfo.class.includes('profit') || statusInfo.class.includes('tp') ? 'var(--long)' : 
                        statusInfo.class.includes('risk') || statusInfo.class.includes('stop') ? 'var(--short)' : 'var(--amber)';
    
    el.innerHTML = `
        <div class="detail-box">
            <div class="detail-header">
                <div class="detail-title">
                    <span class="detail-pair">${trade.symbol.replace('USDT', '')}</span>
                    <span class="dir-tag ${trade.direction.toLowerCase()}">${trade.direction}</span>
                    <span class="grade-badge ${(orig.grade || 'valid').toLowerCase()}">${orig.grade || 'VALID'}</span>
                    <span style="font-size:10px;color:var(--amber);margin-left:8px">💾 SAVED</span>
                </div>
                <div class="detail-sub">
                    <span>📊 ${trade.tf}</span>
                    <span>💯 Score: ${(orig.score || 0).toFixed(0)}</span>
                </div>
            </div>
            
            <!-- STATUS BANNER -->
            <div style="background:${statusBg};border:1px solid ${statusBorder};border-radius:6px;padding:12px;margin-bottom:12px;text-align:center">
                <div style="font-size:24px;margin-bottom:4px">${statusInfo.emoji}</div>
                <div style="font-size:14px;font-weight:700;color:${statusBorder}">${statusInfo.label}</div>
                <div style="font-size:20px;font-weight:700;margin-top:4px;color:${pnlClass === 'profit' ? 'var(--long)' : 'var(--short)'}">
                    ${(live.pnlPercent || 0) >= 0 ? '+' : ''}${(live.pnlPercent || 0).toFixed(2)}%
                </div>
                <div style="font-size:11px;color:var(--text3);margin-top:4px">
                    Current: $${fmtPrice(live.currentPrice || orig.entry)} | Saved: ${trade.savedAtStr}
                </div>
            </div>
            
            <!-- PROGRESS BAR -->
            <div style="background:var(--bg3);border-radius:6px;padding:12px;margin-bottom:12px">
                <div style="font-size:11px;color:var(--text3);margin-bottom:8px">📈 Progress to TP1</div>
                <div style="position:relative;height:30px;background:var(--bg4);border-radius:15px;overflow:visible;margin-bottom:8px">
                    <div style="position:absolute;left:0;top:0;height:100%;width:${Math.max(0, Math.min(100, live.progressPercent || 0))}%;
                                background:linear-gradient(90deg, ${pnlClass === 'profit' ? 'var(--long-dim), var(--long)' : 'var(--short), var(--short-dim)'});
                                border-radius:15px;transition:width 0.5s"></div>
                    <div style="position:absolute;left:0%;top:50%;transform:translate(-50%,-50%);background:var(--cyan);color:#000;font-size:9px;font-weight:700;padding:2px 6px;border-radius:3px;z-index:2">Entry</div>
                    <div style="position:absolute;left:100%;top:50%;transform:translate(-50%,-50%);background:var(--long);color:#000;font-size:9px;font-weight:700;padding:2px 6px;border-radius:3px;z-index:2">TP1</div>
                </div>
                <div style="display:flex;justify-content:space-between;font-size:10px;color:var(--text3)">
                    <span>🛑 SL: ${(live.distanceToSL || 0).toFixed(1)}% away</span>
                    <span>${(live.progressPercent || 0).toFixed(0)}% complete</span>
                    <span>🎯 TP1: ${(live.distanceToTP1 || 0).toFixed(1)}% away</span>
                </div>
            </div>
            
            <!-- ORIGINAL LEVELS -->
            <div style="background:var(--bg3);border-radius:6px;padding:12px;margin-bottom:12px">
                <div style="font-size:11px;color:var(--text3);margin-bottom:8px">📸 Original Trade Levels</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px">
                    <div style="background:var(--bg4);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--cyan)">
                        <div style="font-size:10px;color:var(--text3)">ENTRY</div>
                        <div style="font-size:13px;font-weight:700;color:var(--cyan)">$${fmtPrice(orig.entry)}</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--short)">
                        <div style="font-size:10px;color:var(--text3)">STOP LOSS</div>
                        <div style="font-size:13px;font-weight:700;color:var(--short)">$${fmtPrice(orig.sl)}</div>
                        <div style="font-size:9px;color:var(--short)">${orig.riskPct || '?'}%</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--long)">
                        <div style="font-size:10px;color:var(--text3)">R:R</div>
                        <div style="font-size:13px;font-weight:700;color:var(--long)">1:${orig.rr || '?'}</div>
                    </div>
                </div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
                    <div style="background:var(--bg4);border-radius:4px;padding:6px;text-align:center">
                        <div style="font-size:9px;color:var(--text3)">TP1</div>
                        <div style="font-size:11px;font-weight:600;color:var(--long)">$${fmtPrice(orig.tp1)}</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:4px;padding:6px;text-align:center">
                        <div style="font-size:9px;color:var(--text3)">TP2</div>
                        <div style="font-size:11px;font-weight:600;color:var(--long)">$${fmtPrice(orig.tp2)}</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:4px;padding:6px;text-align:center">
                        <div style="font-size:9px;color:var(--text3)">TP3</div>
                        <div style="font-size:11px;font-weight:600;color:var(--long)">$${fmtPrice(orig.tp3)}</div>
                    </div>
                </div>
            </div>
            
            <!-- AI INTERPRETATION -->
            <div style="background:linear-gradient(90deg, rgba(168,85,247,0.1) 0%, var(--bg3) 100%);border-radius:6px;padding:12px;margin-bottom:12px;border-left:3px solid var(--purple)">
                <div style="font-size:11px;color:var(--purple);margin-bottom:8px;font-weight:600">🤖 AI Interpretation</div>
                ${ai.commentary ? `
                    <div style="font-size:12px;color:var(--text);line-height:1.5;margin-bottom:8px">${ai.commentary}</div>
                    ${ai.recommendation ? `<div style="display:inline-block;padding:4px 10px;background:var(--purple-dim);border:1px solid var(--purple);border-radius:4px;font-size:10px;font-weight:600;color:var(--purple)">📋 ${ai.recommendation}</div>` : ''}
                    ${ai.moveSlToBE ? `<div style="margin-top:8px;padding:6px 10px;background:var(--long-dim);border:1px solid var(--long);border-radius:4px;font-size:11px;color:var(--long)">💡 Consider moving SL to breakeven ($${fmtPrice(orig.entry)})</div>` : ''}
                    ${ai.warnings?.length > 0 ? `<div style="margin-top:8px;padding:6px 10px;background:var(--amber-dim);border:1px solid var(--amber);border-radius:4px;font-size:11px;color:var(--amber)">⚠️ ${ai.warnings.join(' • ')}</div>` : ''}
                    <div style="font-size:9px;color:var(--text3);margin-top:8px">Last AI update: ${ai.lastUpdated ? new Date(ai.lastUpdated).toLocaleString() : 'Never'}</div>
                ` : `
                    <div style="text-align:center;padding:10px">
                        <div style="color:var(--text3);font-size:11px;margin-bottom:8px">No AI analysis yet</div>
                        <button onclick="getAITradeInterpretation(${trade.id})" style="padding:8px 16px;background:var(--purple-dim);border:1px solid var(--purple);color:var(--purple);border-radius:4px;font-size:11px;font-weight:600;cursor:pointer">🤖 Get AI Analysis</button>
                    </div>
                `}
            </div>
            
            ${orig.factors?.length > 0 ? `
            <div style="background:var(--bg3);border-radius:6px;padding:10px;margin-bottom:12px">
                <div style="font-size:11px;color:var(--text2);margin-bottom:6px">✅ Original Factors</div>
                <div style="display:flex;flex-wrap:wrap;gap:4px">${orig.factors.map(f => `<span style="font-size:10px;padding:3px 6px;background:var(--long-dim);color:var(--long);border-radius:3px">${f}</span>`).join('')}</div>
            </div>` : ''}
            
            <div style="display:flex;gap:8px;margin-top:12px">
                <button class="btn" onclick="refreshSavedTrade(${trade.id})" style="flex:1;background:var(--cyan-dim);border-color:var(--cyan);color:var(--cyan)">🔄 Refresh</button>
                <button class="btn" onclick="getAITradeInterpretation(${trade.id})" style="flex:1;background:var(--purple-dim);border-color:var(--purple);color:var(--purple)">🤖 AI</button>
            </div>
            <div style="display:flex;gap:8px;margin-top:8px">
                <button class="btn" onclick="rescanSavedTrade('${trade.symbol}', '${trade.tfRaw}')" style="flex:2;background:var(--long-dim);border-color:var(--long);color:var(--long)">📊 Full Rescan</button>
                <button class="btn" onclick="deleteSavedTrade(${trade.id})" style="flex:1;background:var(--short-dim);border-color:var(--short);color:var(--short)">🗑️</button>
            </div>
        </div>`;
    
    // Auto-scroll to main panel on mobile
    if (el && window.innerWidth < 900) {
        setTimeout(() => {
            el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);
    }
}

// Rescan saved trade
async function rescanSavedTrade(symbol, tf) {
    toast(`📊 Scanning ${symbol}...`, 'info');
    try {
        const result = await analyzeSignal(symbol, tf);
        if (result) {
            const existingIdx = STATE.signals.findIndex(s => s.symbol === symbol && s.tf === result.tf);
            if (existingIdx >= 0) STATE.signals[existingIdx] = result;
            else STATE.signals.unshift(result);
            STATE.current = result;
            STATE.aiResult = null; // Clear old AI result
            updateMainPanel();
            updateSignalList();
            toast(`✅ ${symbol} rescanned!`, 'success');
        } else {
            toast(`No signal for ${symbol}`, 'warning');
        }
    } catch (e) {
        console.error('Rescan error:', e);
        toast('Rescan failed', 'error');
    }
}

// Update saved trades list - Enhanced with 3 rows
function updateSavedTradesListEnhanced() {
    const el = document.getElementById('savedList');
    const countEl = document.getElementById('savedCount');
    if (!el || !countEl) return;
    
    countEl.textContent = STATE.savedTrades.length;
    
    if (STATE.savedTrades.length === 0) {
        el.innerHTML = `<div class="saved-empty"><div class="saved-empty-icon">💾</div><div class="saved-empty-text">No saved trades yet</div></div>`;
        return;
    }
    
    el.innerHTML = `<button class="saved-refresh-all" onclick="updateAllSavedTradesLive()">🔄 Refresh All Prices</button>` +
        STATE.savedTrades.map(trade => renderSavedTradeCardEnhanced(trade)).join('');
}

// Render single saved trade card with 3 rows
function renderSavedTradeCardEnhanced(trade) {
    const orig = trade.original || trade;
    const live = trade.live || { currentPrice: orig.price || orig.entry, pnlPercent: 0, progressPercent: 0, status: 'LOADING' };
    const ai = trade.ai || {};
    
    const statusInfo = TRADE_STATUS[live.status] || TRADE_STATUS.LOADING;
    const pnlClass = (live.pnlPercent || 0) >= 0 ? 'profit' : 'loss';
    
    const hoursAgo = Math.floor((Date.now() - trade.savedAt) / (1000 * 60 * 60));
    const timeAgo = hoursAgo < 1 ? 'Just now' : hoursAgo < 24 ? `${hoursAgo}h ago` : `${Math.floor(hoursAgo / 24)}d ago`;
    
    // FIX: Make header clickable to open full analysis
    return `
        <div class="saved-card-enhanced ${trade.direction.toLowerCase()}">
            <div class="saved-card-header" onclick="viewSavedTrade(${trade.id})" style="cursor:pointer" title="Click for full analysis">
                <div class="saved-card-pair">
                    ${trade.symbol.replace('USDT', '')}
                    <span class="saved-card-dir ${trade.direction.toLowerCase()}">${trade.direction}</span>
                    <span style="font-size:10px;color:var(--text3)">${trade.tf}</span>
                    <span style="font-size:9px;color:var(--cyan);margin-left:4px">📊 Tap for details</span>
                </div>
                <div class="saved-status-badge ${statusInfo.class}">${statusInfo.emoji} ${statusInfo.label}</div>
            </div>
            
            <!-- ROW 1: ORIGINAL -->
            <div class="saved-row original">
                <div class="saved-row-label"><span class="emoji">📸</span> SAVED</div>
                <div class="saved-original-grid">
                    <div class="saved-original-item"><div class="label">Entry</div><div class="value entry">$${fmtPrice(orig.entry)}</div></div>
                    <div class="saved-original-item"><div class="label">SL</div><div class="value sl">$${fmtPrice(orig.sl)}</div></div>
                    <div class="saved-original-item"><div class="label">TP1</div><div class="value tp">$${fmtPrice(orig.tp1)}</div></div>
                    <div class="saved-original-item"><div class="label">R:R</div><div class="value rr">1:${orig.rr}</div></div>
                </div>
            </div>
            
            <!-- ROW 2: LIVE -->
            <div class="saved-row live">
                <div class="saved-row-label"><span class="emoji">📊</span> LIVE</div>
                <div class="saved-live-header">
                    <div class="saved-live-price">$${fmtPrice(live.currentPrice)}</div>
                    <div class="saved-live-pnl ${pnlClass}">${(live.pnlPercent || 0) >= 0 ? '+' : ''}${(live.pnlPercent || 0).toFixed(2)}%</div>
                </div>
                <div class="saved-progress-container">
                    <div class="saved-progress-bar">
                        <div class="saved-progress-fill ${pnlClass}" style="width:${Math.max(0, Math.min(100, live.progressPercent || 0))}%"></div>
                    </div>
                    <div class="saved-progress-labels">
                        <span>SL: ${(live.distanceToSL || 0).toFixed(1)}%</span>
                        <span>${(live.progressPercent || 0).toFixed(0)}% to TP1</span>
                        <span>TP1: ${(live.distanceToTP1 || 0).toFixed(1)}%</span>
                    </div>
                </div>
            </div>
            
            <!-- ROW 3: AI -->
            <div class="saved-row ai">
                <div class="saved-row-label"><span class="emoji">🤖</span> AI</div>
                ${ai.commentary ? `
                    <div class="saved-ai-commentary">${ai.commentary}</div>
                    ${ai.moveSlToBE ? '<div class="saved-ai-suggestion">💡 Move SL to BE</div>' : ''}
                ` : `<div class="saved-ai-loading"><button class="saved-ai-btn" onclick="getAITradeInterpretation(${trade.id})">🤖 Get AI</button></div>`}
            </div>
            
            <div class="saved-card-actions">
                <button class="saved-action-btn refresh" onclick="refreshSavedTrade(${trade.id})" title="Refresh live data">🔄</button>
                <button class="saved-action-btn details" onclick="viewSavedTrade(${trade.id})" title="Full analysis">📊</button>
                <button class="saved-action-btn delete" onclick="deleteSavedTrade(${trade.id})" title="Delete">🗑️</button>
            </div>
            <div class="saved-last-updated">Saved ${timeAgo}</div>
        </div>`;
}

function formatTimeAgo(timestamp) {
    const seconds = Math.floor((Date.now() - timestamp) / 1000);
    if (seconds < 60) return 'just now';
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
    return `${Math.floor(seconds / 86400)}d ago`;
}

function saveSavedTrades() {
    try {
        // SAFETY: Limit saved trades before saving
        const maxTrades = CONFIG.SAFETY?.MAX_SAVED_TRADES || 50;
        if (STATE.savedTrades.length > maxTrades) {
            STATE.savedTrades = STATE.savedTrades.slice(0, maxTrades);
        }
        
        const data = JSON.stringify(STATE.savedTrades);
        
        // SAFETY: Check storage size (2MB limit)
        const maxSize = (CONFIG.SAFETY?.MAX_STORAGE_MB || 2) * 1024 * 1024;
        if (data.length > maxSize) {
            console.warn('⚠️ Storage data too large, truncating...');
            // Keep only half the trades
            STATE.savedTrades = STATE.savedTrades.slice(0, Math.floor(maxTrades / 2));
        }
        
        safeStorageSet('bybit_scanner_saved_trades', STATE.savedTrades);
    } catch (e) {
        console.error('Failed to save:', e);
        // SAFETY: If storage full, clear old data
        if (e.name === 'QuotaExceededError') {
            console.warn('⚠️ Storage full, clearing old trades...');
            STATE.savedTrades = STATE.savedTrades.slice(0, 10);
            safeStorageSet('bybit_scanner_saved_trades', STATE.savedTrades);
        }
    }
}

function loadSavedTrades() {
    const saved = safeStorageGet('bybit_scanner_saved_trades', []);
    STATE.savedTrades = Array.isArray(saved) ? saved : [];
    STATE.savedTrades = STATE.savedTrades.map(trade => {
        if (!trade.original) {
            return {
                ...trade,
                original: { price: trade.price, entry: trade.entry, sl: trade.sl, tp1: trade.tp1, tp2: trade.tp2, tp3: trade.tp3, rr: trade.rr, riskPct: trade.riskPct, grade: trade.grade, score: trade.score, agreed: trade.agreed, factors: trade.factors, warnings: trade.warnings },
                live: { currentPrice: trade.price || trade.entry, pnlPercent: 0, progressPercent: 0, status: 'LOADING', lastUpdated: null },
                ai: { commentary: null, lastUpdated: null }
            };
        }
        return trade;
    });
    updateSavedTradesListEnhanced();
}

function toggleSavedTrades() {
    const list = document.getElementById('savedList');
    const toggle = document.getElementById('savedToggle');
    if (list.style.display === 'none') { list.style.display = 'block'; toggle.classList.add('open'); }
    else { list.style.display = 'none'; toggle.classList.remove('open'); }
}

function updateSavedTradesList() { updateSavedTradesListEnhanced(); }

async function updateTradePrices() {
    for (const trade of STATE.trades) {
        try {
            const url = `${CONFIG.BYBIT_V5}/market/tickers?category=linear&symbol=${trade.symbol}`;
            const data = await fetchJSON(url);
            
            if (data && data.price) {
                trade.currentPrice = parseFloat(data.price);
                
                // Check TP/SL hits
                if (trade.direction === 'LONG') {
                    if (trade.currentPrice >= trade.tp1) trade.tp1Hit = true;
                    if (trade.currentPrice >= trade.tp2) trade.tp2Hit = true;
                    if (trade.currentPrice >= trade.tp3) trade.tp3Hit = true;
                    if (trade.currentPrice <= trade.sl) trade.slHit = true;
                } else {
                    if (trade.currentPrice <= trade.tp1) trade.tp1Hit = true;
                    if (trade.currentPrice <= trade.tp2) trade.tp2Hit = true;
                    if (trade.currentPrice <= trade.tp3) trade.tp3Hit = true;
                    if (trade.currentPrice >= trade.sl) trade.slHit = true;
                }
            }
        } catch (e) {
            console.error(`Failed to update price for ${trade.symbol}:`, e);
        }
    }
    
    saveTrades();
    updateTradeList();
}

function updateTradeList() {
    const el = document.getElementById('activeList');
    const countEl = document.getElementById('activeCount');
    
    // Guard against missing elements (if Active Trades section removed)
    if (!el || !countEl) return;
    
    countEl.textContent = STATE.trades.length;
    
    if (STATE.trades.length === 0) {
        el.innerHTML = '<div style="text-align:center;color:var(--text3);font-size:12px;padding:8px">No active trades</div>';
        return;
    }
    
    el.innerHTML = STATE.trades.map(trade => {
        // SAFETY: Guard against undefined values
        const entry = trade.entry || 1;
        const currentPrice = trade.currentPrice || entry;
        const pnl = trade.direction === 'LONG' 
            ? ((currentPrice - entry) / entry) * 100
            : ((entry - currentPrice) / entry) * 100;
        
        const safePnl = isNaN(pnl) ? 0 : pnl;
        const pnlClass = safePnl >= 0 ? 'profit' : 'loss';
        
        return `
            <div class="active-card ${(trade.direction || 'LONG').toLowerCase()}">
                <div class="active-top">
                    <div class="active-pair">
                        ${(trade.symbol || 'UNKNOWN').replace('USDT', '')}
                        <span class="dir-tag ${(trade.direction || 'LONG').toLowerCase()}">${trade.direction || 'LONG'}</span>
                    </div>
                    <span class="active-pnl ${pnlClass}">${safePnl >= 0 ? '+' : ''}${safePnl.toFixed(2)}%</span>
                </div>
                <div class="active-levels">
                    <div class="active-level">
                        <div class="active-level-label">Entry</div>
                        <div class="active-level-value" style="color:var(--cyan)">$${fmtPrice(trade.entry)}</div>
                    </div>
                    <div class="active-level ${trade.slHit ? 'stopped' : ''}">
                        <div class="active-level-label">SL</div>
                        <div class="active-level-value" style="color:var(--short)">$${fmtPrice(trade.sl)}</div>
                    </div>
                    <div class="active-level ${trade.tp1Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP1</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp1)}</div>
                    </div>
                    <div class="active-level ${trade.tp2Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP2</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp2)}</div>
                    </div>
                    <div class="active-level ${trade.tp3Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP3</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp3)}</div>
                    </div>
                </div>
                <div class="active-meta">
                    <span>${trade.grade} • ${trade.tf} • R:R 1:${trade.rr}</span>
                    <button class="close-btn" onclick="closeTrade(${trade.id})">✕ Close</button>
                </div>
            </div>
        `;
    }).join('');
}

// ═══════════════════════════════════════════════════════════════════════════════
// EVENT HANDLERS
// ═══════════════════════════════════════════════════════════════════════════════

function selectSignal(idx) {
    console.log('🔵 selectSignal called with idx:', idx);
    try {
        // Validate index
        if (idx < 0 || idx >= STATE.signals.length) {
            console.warn('Invalid signal index:', idx, 'signals length:', STATE.signals.length);
            toast('Invalid signal index', 'error');
            return;
        }
        
        const signal = STATE.signals[idx];
        if (!signal) {
            console.warn('Signal at index is null/undefined:', idx);
            toast('Signal not found', 'error');
            return;
        }
        
        console.log('🔵 Signal found:', signal.symbol, signal.direction, signal.tf);
        STATE.selected = idx;
        
        // Safe deep copy with fallback
        try {
            STATE.current = JSON.parse(JSON.stringify(signal));
        } catch (copyError) {
            console.warn('Deep copy failed, using shallow copy:', copyError);
            STATE.current = { ...signal };
        }
        
        STATE.aiResult = null;
        
        console.log('🔵 Updating signal list...');
        try {
            updateSignalList();
        } catch (listErr) {
            console.error('Signal list update failed:', listErr);
        }
        
        console.log('🔵 Updating main panel...');
        try {
            updateMainPanel();
        } catch (panelErr) {
            console.error('Main panel update failed:', panelErr);
            toast('Panel render error: ' + panelErr.message, 'error');
        }
        
        console.log('🔵 Selection complete!');
        
        // Auto-scroll to main panel on mobile
        const mainPanel = document.getElementById('mainPanel');
        if (mainPanel && window.innerWidth < 900) {
            setTimeout(() => {
                mainPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
        }
    } catch (selectError) {
        console.error('❌ Select signal error:', selectError);
        console.error('Stack:', selectError.stack);
        STATE.current = null;
        toast('Error: ' + selectError.message, 'error');
    }
}

// NEW: Select signal by symbol and timeframe (more reliable than index)
function selectSignalBySymbol(symbol, tf) {
    console.log('🔵 selectSignalBySymbol called:', symbol, tf);
    try {
        const idx = STATE.signals.findIndex(s => s && s.symbol === symbol && s.tf === tf);
        if (idx === -1) {
            console.warn('Signal not found:', symbol, tf);
            toast('Signal not found', 'error');
            return;
        }
        selectSignal(idx);
    } catch (e) {
        console.error('selectSignalBySymbol error:', e);
        toast('Selection error', 'error');
    }
}

function toggleScan() {
    STATE.scanning = !STATE.scanning;
    
    const btn = document.getElementById('scanBtn');
    const icon = document.getElementById('scanIcon');
    
    if (STATE.scanning) {
        btn.className = 'btn scanning';
        icon.textContent = '◉';
        resetScanProgress(); // Show rainbow progress bar immediately
        runScanner();
    } else {
        btn.className = 'btn';
        icon.textContent = '●';
    }
}

function setMode(mode) {
    STATE.mode = mode;
    STATE.selected = null;
    STATE.current = null;
    STATE.aiResult = null;
    
    document.getElementById('modeAll').className = 'mode-btn' + (mode === 'ALL' ? ' active' : '');
    document.getElementById('modeScalp').className = 'mode-btn' + (mode === 'SCALP' ? ' active' : '');
    document.getElementById('modeSwing').className = 'mode-btn' + (mode === 'SWING' ? ' active' : '');
    
    updateSignalList();
    updateCounts();
    updateMainPanel();
}

function setFilter(filter) {
    STATE.filter = filter;
    
    document.getElementById('filterAll').className = 'filter-btn' + (filter === 'all' ? ' active' : '');
    document.getElementById('filterPerfect').className = 'filter-btn' + (filter === 'perfect' ? ' active' : '');
    document.getElementById('filterReady').className = 'filter-btn' + (filter === 'ready' ? ' active' : '');
    document.getElementById('filterEarly').className = 'filter-btn' + (filter === 'early' ? ' active' : '');
    
    updateSignalList();
}

// AI Display Mode toggle (Detailed vs Compact)
function setAIDisplayMode(mode) {
    STATE.aiDisplayMode = mode;
    
    // Update button styles
    const detailedBtn = document.getElementById('aiModeDetailed');
    const compactBtn = document.getElementById('aiModeCompact');
    
    if (detailedBtn && compactBtn) {
        if (mode === 'detailed') {
            detailedBtn.style.background = 'var(--purple)';
            detailedBtn.style.color = 'white';
            compactBtn.style.background = 'var(--bg4)';
            compactBtn.style.color = 'var(--text2)';
        } else {
            compactBtn.style.background = 'var(--purple)';
            compactBtn.style.color = 'white';
            detailedBtn.style.background = 'var(--bg4)';
            detailedBtn.style.color = 'var(--text2)';
        }
    }
    
    // Re-render main panel if AI result exists
    if (STATE.aiResult) {
        updateMainPanel();
    }
    
    // Save to localStorage
    safeStorageSet('bybit_scanner_ai_display_mode', mode);
    
    toast('AI Display: ' + (mode === 'detailed' ? 'Detailed (13 sections)' : 'Compact (6 sections)'), 'success');
}

async function askAI() {
    console.log('🤖 askAI() called');
    
    if (!STATE.current) {
        console.warn('⚠️ No signal selected');
        toast('Select a signal first!', 'error');
        return;
    }
    
    console.log('📊 Current signal:', STATE.current.symbol, STATE.current.tf);
    
    if (!STATE.aiKey) {
        console.warn('⚠️ No API key configured');
        toast('Configure API key in Settings!', 'warning');
        showSettings();
        return;
    }
    
    console.log('🔑 API Key present:', STATE.aiKey.substring(0, 15) + '...');
    toast('🧠 Multi-AI Analyzing...', 'warning');
    
    try {
        const result = await getAIAnalysis(STATE.current);
        console.log('📦 AI Result:', result);
        
        if (result) {
            STATE.aiResult = result;
            STATE.aiExpanded = false; // Start collapsed
            updateMainPanel();
            
            const aiDot = document.getElementById('aiDot');
            const aiStatus = document.getElementById('aiStatus');
            if (aiDot) aiDot.className = 'ai-dot on';
            if (aiStatus) aiStatus.textContent = 'AI: ' + result.verdict;
            
            toast(`${result.aiProvider || 'AI'}: ${result.verdict} (${result.confidence}%)`, 'success');
        } else {
            console.error('❌ AI result is null');
            toast('AI analysis failed', 'error');
        }
    } catch (error) {
        console.error('❌ askAI error:', error);
        toast('AI error: ' + error.message, 'error');
    }
}

function toggleAIExpand() {
    STATE.aiExpanded = !STATE.aiExpanded;
    const content = document.getElementById('aiExpandedContent');
    if (content) {
        content.style.display = STATE.aiExpanded ? 'block' : 'none';
    }
    updateMainPanel();
}

// ═══════════════════════════════════════════════════════════════════════════════
// SETTINGS
// ═══════════════════════════════════════════════════════════════════════════════

function showSettings() {
    document.getElementById('settingsModal').className = 'modal-bg show';
    
    // Load all 11 API keys into input fields
    document.getElementById('groqKey1').value = GROQ_KEYS[0] || '';
    document.getElementById('groqKey2').value = GROQ_KEYS[1] || '';
    document.getElementById('groqKey3').value = GROQ_KEYS[2] || '';
    document.getElementById('groqKey4').value = GROQ_KEYS[3] || '';
    document.getElementById('groqKey5').value = GROQ_KEYS[4] || '';
    
    // Load Groq ON/OFF toggles
    document.getElementById('groqKey1On').checked = KEY_ENABLED.groq[0];
    document.getElementById('groqKey2On').checked = KEY_ENABLED.groq[1];
    document.getElementById('groqKey3On').checked = KEY_ENABLED.groq[2];
    document.getElementById('groqKey4On').checked = KEY_ENABLED.groq[3];
    document.getElementById('groqKey5On').checked = KEY_ENABLED.groq[4];
    
    document.getElementById('deepseekKey1').value = DEEPSEEK_KEYS[0] || '';
    document.getElementById('deepseekKey1On').checked = KEY_ENABLED.deepseek[0];
    
    document.getElementById('geminiKey1').value = GEMINI_KEYS[0] || '';
    document.getElementById('geminiKey2').value = GEMINI_KEYS[1] || '';
    document.getElementById('geminiKey3').value = GEMINI_KEYS[2] || '';
    document.getElementById('geminiKey4').value = GEMINI_KEYS[3] || '';
    document.getElementById('geminiKey5').value = GEMINI_KEYS[4] || '';
    
    // Load Gemini ON/OFF toggles
    document.getElementById('geminiKey1On').checked = KEY_ENABLED.gemini[0];
    document.getElementById('geminiKey2On').checked = KEY_ENABLED.gemini[1];
    document.getElementById('geminiKey3On').checked = KEY_ENABLED.gemini[2];
    document.getElementById('geminiKey4On').checked = KEY_ENABLED.gemini[3];
    document.getElementById('geminiKey5On').checked = KEY_ENABLED.gemini[4];
    
    // Update key status indicators and grid
    for (let i = 0; i < 5; i++) updateKeyIndicator('groq', i, KEY_STATUS.groq[i]);
    updateKeyIndicator('deepseek', 0, KEY_STATUS.deepseek[0]);
    for (let i = 0; i < 5; i++) updateKeyIndicator('gemini', i, KEY_STATUS.gemini[i]);
    updateKeyStatusGrid();
    
    document.getElementById('aiModelSelect').value = STATE.aiModel;
    
    // Load timeframe toggles
    document.getElementById('tf5m').checked = STATE.tfEnabled['5'];
    document.getElementById('tf15m').checked = STATE.tfEnabled['15'];
    document.getElementById('tf30m').checked = STATE.tfEnabled['30'];
    document.getElementById('tf1h').checked = STATE.tfEnabled['60'];
    document.getElementById('tf4h').checked = STATE.tfEnabled['240'];
    document.getElementById('tf1d').checked = STATE.tfEnabled['D'];
    
    // Load scan interval
    document.getElementById('scanInterval').value = STATE.scanInterval;
    
    // Load alert settings
    document.getElementById('alertSound').checked = STATE.alertSound;
    document.getElementById('alertVibrate').checked = STATE.alertVibrate;
    document.getElementById('alertGrade').value = STATE.alertGrade;
    
    // Load telegram settings
    document.getElementById('telegramEnabled').checked = STATE.telegramEnabled;
    document.getElementById('telegramToken').value = STATE.telegramToken;
    document.getElementById('telegramChatId').value = STATE.telegramChatId;
    
    // Load risk settings
    document.getElementById('riskAccount').value = STATE.riskAccount;
    document.getElementById('riskPercent').value = STATE.riskPercent;
    document.getElementById('riskLeverage').value = STATE.riskLeverage;
    document.getElementById('riskMaxPosition').value = STATE.riskMaxPosition;
    
    // Load weight settings
    document.getElementById('weightZone').value = CONFIG.WEIGHTS.zone * 100;
    document.getElementById('weightSMC').value = CONFIG.WEIGHTS.smc * 100;
    document.getElementById('weightMomentum').value = CONFIG.WEIGHTS.momentum * 100;
    updateWeightDisplay();
    
    // Load theme
    document.getElementById('oledTheme').checked = STATE.oledTheme;
    
    // Load timezone
    const tzSelect = document.getElementById('userTimezone');
    if (tzSelect) {
        tzSelect.value = STATE.awareness?.timezone || 'Australia/Melbourne';
        tzSelect.onchange = updateTimezonePreview;
    }
    updateTimezonePreview();
    
    // Render coin manager
    renderCoinManager();
    
    updateKeyStatus();
}

function hideSettings() {
    document.getElementById('settingsModal').className = 'modal-bg';
}

function updateKeyStatus() {
    const el = document.getElementById('keyStatus');
    const groqCount = GROQ_KEYS.filter(k => k && k.length > 5).length;
    const deepseekCount = DEEPSEEK_KEYS.filter(k => k && k.length > 5).length;
    const geminiCount = GEMINI_KEYS.filter(k => k && k.length > 5).length;
    const total = groqCount + deepseekCount + geminiCount;
    
    if (total > 0) {
        el.className = 'key-status valid';
        el.textContent = `✅ ${total}/11 API Keys configured (Groq: ${groqCount}, DeepSeek: ${deepseekCount}, Gemini: ${geminiCount})`;
    } else {
        el.className = 'key-status invalid';
        el.textContent = '❌ No API Key configured';
    }
}

function toggleKeyVis() {
    // Toggle visibility for all 11 key inputs
    const keyInputs = [
        'groqKey1', 'groqKey2', 'groqKey3', 'groqKey4', 'groqKey5',
        'deepseekKey1',
        'geminiKey1', 'geminiKey2', 'geminiKey3', 'geminiKey4', 'geminiKey5'
    ];
    const firstInput = document.getElementById('groqKey1');
    const newType = firstInput.type === 'password' ? 'text' : 'password';
    keyInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.type = newType;
    });
}

function clearKey() {
    // Clear all 11 key inputs
    const keyInputs = [
        'groqKey1', 'groqKey2', 'groqKey3', 'groqKey4', 'groqKey5',
        'deepseekKey1',
        'geminiKey1', 'geminiKey2', 'geminiKey3', 'geminiKey4', 'geminiKey5'
    ];
    keyInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '';
    });
    
    // Clear arrays
    GROQ_KEYS.fill('');
    DEEPSEEK_KEYS.fill('');
    GEMINI_KEYS.fill('');
    
    STATE.aiKey = '';
    STATE.deepseekKey = '';
    STATE.geminiKey = '';
    
    safeStorageRemove('bybit_scanner_groq_keys');
    safeStorageRemove('bybit_scanner_deepseek_keys');
    safeStorageRemove('bybit_scanner_gemini_keys');
    safeStorageRemove('bybit_scanner_key');
    safeStorageRemove('bybit_scanner_deepseek');
    safeStorageRemove('bybit_scanner_gemini');
    
    updateKeyStatus();
    toast('All API keys cleared', 'warning');
}

async function testKey() {
    await testAllKeys();
}

// Test single Groq key
async function testSingleGroqKey(key) {
    if (!key || key.length < 10) return false;
    try {
        const response = await fetch(CONFIG.GROQ_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
            body: JSON.stringify({ model: 'llama-3.3-70b-versatile', messages: [{ role: 'user', content: 'Hi' }], max_tokens: 5 })
        });
        return response.ok || response.status === 429;
    } catch (e) { return false; }
}

// Test single DeepSeek key
async function testSingleDeepSeekKey(key) {
    if (!key || key.length < 10) return false;
    try {
        const response = await fetch(CONFIG.DEEPSEEK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
            body: JSON.stringify({ model: 'deepseek-chat', messages: [{ role: 'user', content: 'Hi' }], max_tokens: 5 })
        });
        return response.ok || response.status === 429;
    } catch (e) { return false; }
}

// Test single Gemini key
async function testSingleGeminiKey(key) {
    if (!key || key.length < 10) {
        console.log('❌ Gemini key too short or empty');
        return false;
    }
    
    // Gemini keys should start with AIza
    if (!key.startsWith('AIza')) {
        console.log('❌ Gemini key should start with AIza, got:', key.substring(0, 10));
        return false;
    }
    
    // Try primary model first, then fallback
    const models = [
        'gemini-2.0-flash',
        'gemini-1.5-flash',
        'gemini-1.5-flash-latest'
    ];
    
    for (const model of models) {
        try {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;
            console.log(`🔌 Testing Gemini key with ${model}:`, key.substring(0, 15) + '...');
            
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    contents: [{ parts: [{ text: 'Say OK' }] }], 
                    generationConfig: { maxOutputTokens: 5 } 
                })
            });
            
            console.log(`📡 Gemini ${model} response status:`, response.status);
            
            if (response.ok) {
                console.log(`✅ Gemini key WORKS with ${model}!`);
                // Update CONFIG to use working model
                CONFIG.GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
                return true;
            } else if (response.status === 429) {
                console.log(`⚠️ Gemini ${model} rate limited but key is valid`);
                CONFIG.GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
                return true; // Key is valid, just rate limited
            } else if (response.status === 404) {
                console.log(`⚠️ Model ${model} not found, trying next...`);
                continue; // Try next model
            } else {
                const errorData = await response.json().catch(() => ({}));
                console.log(`❌ Gemini ${model} error:`, errorData.error?.message || response.status);
                // If it's an auth error, the key is bad - don't try other models
                if (response.status === 400 || response.status === 401 || response.status === 403) {
                    return false;
                }
                continue; // Try next model for other errors
            }
        } catch (e) { 
            console.error(`❌ Gemini ${model} network error:`, e.message);
            continue; // Try next model on network error
        }
    }
    
    console.log('❌ All Gemini models failed');
    return false;
}

// Update key status indicator
function updateKeyIndicator(provider, index, status) {
    const id = `${provider}Key${index + 1}Status`;
    const el = document.getElementById(id);
    if (el) {
        if (status === true) el.textContent = '✅';
        else if (status === false) el.textContent = '❌';
        else el.textContent = '⚪';
    }
}

// Update key status grid
function updateKeyStatusGrid() {
    const slots = document.querySelectorAll('#keyStatusGrid .key-slot');
    if (slots.length !== 11) return;
    
    // Groq keys (0-4)
    for (let i = 0; i < 5; i++) {
        const hasKey = GROQ_KEYS[i] && GROQ_KEYS[i].length > 5;
        const enabled = KEY_ENABLED.groq[i];
        const status = KEY_STATUS.groq[i];
        let cls = 'key-slot empty';
        let icon = '⚪';
        
        if (hasKey) {
            if (!enabled) { cls = 'key-slot off'; icon = '⏸️'; }
            else if (status === true) { cls = 'key-slot active'; icon = '✅'; }
            else if (status === false) { cls = 'key-slot error'; icon = '❌'; }
            else { cls = 'key-slot empty'; icon = '🟢'; }
        }
        
        slots[i].className = cls;
        slots[i].querySelector('.key-slot-icon').textContent = icon;
    }
    
    // DeepSeek (5)
    {
        const hasKey = DEEPSEEK_KEYS[0] && DEEPSEEK_KEYS[0].length > 5;
        const enabled = KEY_ENABLED.deepseek[0];
        const status = KEY_STATUS.deepseek[0];
        let cls = 'key-slot empty';
        let icon = '⚪';
        
        if (hasKey) {
            if (!enabled) { cls = 'key-slot off'; icon = '⏸️'; }
            else if (status === true) { cls = 'key-slot active'; icon = '✅'; }
            else if (status === false) { cls = 'key-slot error'; icon = '❌'; }
            else { cls = 'key-slot empty'; icon = '🔵'; }
        }
        
        slots[5].className = cls;
        slots[5].querySelector('.key-slot-icon').textContent = icon;
    }
    
    // Gemini keys (6-10)
    for (let i = 0; i < 5; i++) {
        const hasKey = GEMINI_KEYS[i] && GEMINI_KEYS[i].length > 5;
        const enabled = KEY_ENABLED.gemini[i];
        const status = KEY_STATUS.gemini[i];
        let cls = 'key-slot empty';
        let icon = '⚪';
        
        if (hasKey) {
            if (!enabled) { cls = 'key-slot off'; icon = '⏸️'; }
            else if (status === true) { cls = 'key-slot active'; icon = '✅'; }
            else if (status === false) { cls = 'key-slot error'; icon = '❌'; }
            else { cls = 'key-slot empty'; icon = '🟣'; }
        }
        
        slots[6 + i].className = cls;
        slots[6 + i].querySelector('.key-slot-icon').textContent = icon;
    }
}

// Test ALL keys
async function testAllKeys() {
    toast('🔌 Testing all API keys...', 'warning');
    
    let working = 0;
    let tested = 0;
    
    // Test Groq keys
    for (let i = 0; i < 5; i++) {
        const key = document.getElementById(`groqKey${i+1}`).value.trim();
        GROQ_KEYS[i] = key;
        KEY_ENABLED.groq[i] = document.getElementById(`groqKey${i+1}On`).checked;
        
        if (key && key.length > 5 && KEY_ENABLED.groq[i]) {
            updateKeyIndicator('groq', i, null);
            const result = await testSingleGroqKey(key);
            KEY_STATUS.groq[i] = result;
            updateKeyIndicator('groq', i, result);
            if (result) working++;
            tested++;
        }
    }
    
    // Test DeepSeek key
    {
        const key = document.getElementById('deepseekKey1').value.trim();
        DEEPSEEK_KEYS[0] = key;
        KEY_ENABLED.deepseek[0] = document.getElementById('deepseekKey1On').checked;
        
        if (key && key.length > 5 && KEY_ENABLED.deepseek[0]) {
            updateKeyIndicator('deepseek', 0, null);
            const result = await testSingleDeepSeekKey(key);
            KEY_STATUS.deepseek[0] = result;
            updateKeyIndicator('deepseek', 0, result);
            if (result) working++;
            tested++;
        }
    }
    
    // Test Gemini keys
    for (let i = 0; i < 5; i++) {
        const keyInput = document.getElementById(`geminiKey${i+1}`);
        const toggleInput = document.getElementById(`geminiKey${i+1}On`);
        
        if (!keyInput) {
            console.error(`Missing geminiKey${i+1} input`);
            continue;
        }
        
        const key = keyInput.value.trim();
        GEMINI_KEYS[i] = key;
        KEY_ENABLED.gemini[i] = toggleInput ? toggleInput.checked : true;
        
        console.log(`Gemini Key ${i+1}: ${key ? key.substring(0,10) + '...' : 'empty'}, enabled: ${KEY_ENABLED.gemini[i]}`);
        
        if (key && key.length > 5 && KEY_ENABLED.gemini[i]) {
            updateKeyIndicator('gemini', i, null);
            const result = await testSingleGeminiKey(key);
            console.log(`Gemini Key ${i+1} test result: ${result}`);
            KEY_STATUS.gemini[i] = result;
            updateKeyIndicator('gemini', i, result);
            if (result) working++;
            tested++;
        }
    }
    
    updateKeyStatusGrid();
    updateKeyStatus();
    
    const aiDot = document.getElementById('aiDot');
    const aiStatus = document.getElementById('aiStatus');
    
    if (working > 0) {
        toast(`✅ ${working}/${tested} keys working!`, 'success');
        if (aiDot) aiDot.className = 'ai-dot on';
        if (aiStatus) aiStatus.textContent = 'AI: Ready';
    } else if (tested > 0) {
        toast(`❌ 0/${tested} keys working`, 'error');
        if (aiDot) aiDot.className = 'ai-dot error';
        if (aiStatus) aiStatus.textContent = 'AI: Error';
    } else {
        toast('⚠️ No keys to test', 'warning');
    }
}

function saveSettings() {
    console.log('💾 saveSettings() called');
    
    // Save all 11 API keys
    // Groq Keys (5)
    GROQ_KEYS[0] = document.getElementById('groqKey1').value.trim();
    GROQ_KEYS[1] = document.getElementById('groqKey2').value.trim();
    GROQ_KEYS[2] = document.getElementById('groqKey3').value.trim();
    GROQ_KEYS[3] = document.getElementById('groqKey4').value.trim();
    GROQ_KEYS[4] = document.getElementById('groqKey5').value.trim();
    
    // Save Groq ON/OFF toggles
    KEY_ENABLED.groq[0] = document.getElementById('groqKey1On').checked;
    KEY_ENABLED.groq[1] = document.getElementById('groqKey2On').checked;
    KEY_ENABLED.groq[2] = document.getElementById('groqKey3On').checked;
    KEY_ENABLED.groq[3] = document.getElementById('groqKey4On').checked;
    KEY_ENABLED.groq[4] = document.getElementById('groqKey5On').checked;
    
    // DeepSeek Key (1)
    DEEPSEEK_KEYS[0] = document.getElementById('deepseekKey1').value.trim();
    KEY_ENABLED.deepseek[0] = document.getElementById('deepseekKey1On').checked;
    
    // Gemini Keys (5)
    GEMINI_KEYS[0] = document.getElementById('geminiKey1').value.trim();
    GEMINI_KEYS[1] = document.getElementById('geminiKey2').value.trim();
    GEMINI_KEYS[2] = document.getElementById('geminiKey3').value.trim();
    GEMINI_KEYS[3] = document.getElementById('geminiKey4').value.trim();
    GEMINI_KEYS[4] = document.getElementById('geminiKey5').value.trim();
    
    // Save Gemini ON/OFF toggles
    KEY_ENABLED.gemini[0] = document.getElementById('geminiKey1On').checked;
    KEY_ENABLED.gemini[1] = document.getElementById('geminiKey2On').checked;
    KEY_ENABLED.gemini[2] = document.getElementById('geminiKey3On').checked;
    KEY_ENABLED.gemini[3] = document.getElementById('geminiKey4On').checked;
    KEY_ENABLED.gemini[4] = document.getElementById('geminiKey5On').checked;
    
    // Set STATE keys for backward compatibility
    STATE.aiKey = GROQ_KEYS[0];
    STATE.deepseekKey = DEEPSEEK_KEYS[0];
    STATE.geminiKey = GEMINI_KEYS[0];
    STATE.aiModel = document.getElementById('aiModelSelect').value;
    
    // Count only ENABLED keys
    const groqCount = GROQ_KEYS.filter((k, i) => k && KEY_ENABLED.groq[i]).length;
    const geminiCount = GEMINI_KEYS.filter((k, i) => k && KEY_ENABLED.gemini[i]).length;
    const deepseekCount = DEEPSEEK_KEYS.filter((k, i) => k && KEY_ENABLED.deepseek[i]).length;
    
    console.log('💾 Keys captured:', {
        groq: groqCount + ' keys enabled',
        deepseek: deepseekCount + ' keys enabled',
        gemini: geminiCount + ' keys enabled',
        total: groqCount + deepseekCount + geminiCount + ' of 11 enabled'
    });
    
    // Update grid
    updateKeyStatusGrid();
    
    // Save timeframe toggles
    STATE.tfEnabled['5'] = document.getElementById('tf5m').checked;
    STATE.tfEnabled['15'] = document.getElementById('tf15m').checked;
    STATE.tfEnabled['30'] = document.getElementById('tf30m').checked;
    STATE.tfEnabled['60'] = document.getElementById('tf1h').checked;
    STATE.tfEnabled['240'] = document.getElementById('tf4h').checked;
    STATE.tfEnabled['D'] = document.getElementById('tf1d').checked;
    
    // Save scan interval
    STATE.scanInterval = parseInt(document.getElementById('scanInterval').value);
    
    // Save alert settings
    STATE.alertSound = document.getElementById('alertSound').checked;
    STATE.alertVibrate = document.getElementById('alertVibrate').checked;
    STATE.alertGrade = document.getElementById('alertGrade').value;
    
    // Save telegram settings
    STATE.telegramEnabled = document.getElementById('telegramEnabled').checked;
    STATE.telegramToken = document.getElementById('telegramToken').value.trim();
    STATE.telegramChatId = document.getElementById('telegramChatId').value.trim();
    
    // Save risk settings
    STATE.riskAccount = parseFloat(document.getElementById('riskAccount').value) || 1000;
    STATE.riskPercent = parseFloat(document.getElementById('riskPercent').value) || 2;
    STATE.riskLeverage = parseInt(document.getElementById('riskLeverage').value) || 10;
    STATE.riskMaxPosition = parseFloat(document.getElementById('riskMaxPosition').value) || 500;
    
    // Save weights
    CONFIG.WEIGHTS.zone = parseInt(document.getElementById('weightZone').value) / 100;
    CONFIG.WEIGHTS.smc = parseInt(document.getElementById('weightSMC').value) / 100;
    CONFIG.WEIGHTS.momentum = parseInt(document.getElementById('weightMomentum').value) / 100;
    
    // Save theme
    STATE.oledTheme = document.getElementById('oledTheme').checked;
    applyTheme();
    
    // Save timezone
    STATE.awareness.timezone = document.getElementById('userTimezone').value;
    
    // BUG FIX #2: Using safe localStorage functions
    // Save all 11 API keys
    safeStorageSet('bybit_scanner_groq_keys', GROQ_KEYS);
    safeStorageSet('bybit_scanner_deepseek_keys', DEEPSEEK_KEYS);
    safeStorageSet('bybit_scanner_gemini_keys', GEMINI_KEYS);
    
    // Save KEY_ENABLED states
    safeStorageSet('bybit_scanner_key_enabled', KEY_ENABLED);
    
    // Keep old keys for backward compatibility
    safeStorageSet('bybit_scanner_key', STATE.aiKey);
    safeStorageSet('bybit_scanner_model', STATE.aiModel);
    safeStorageSet('bybit_scanner_deepseek', STATE.deepseekKey);
    safeStorageSet('bybit_scanner_gemini', STATE.geminiKey);
    
    safeStorageSet('bybit_scanner_tf', STATE.tfEnabled);
    safeStorageSet('bybit_scanner_interval', STATE.scanInterval);
    safeStorageSet('bybit_scanner_alert_sound', STATE.alertSound);
    safeStorageSet('bybit_scanner_alert_vibrate', STATE.alertVibrate);
    safeStorageSet('bybit_scanner_alert_grade', STATE.alertGrade);
    safeStorageSet('bybit_scanner_telegram_enabled', STATE.telegramEnabled);
    safeStorageSet('bybit_scanner_telegram_token', STATE.telegramToken);
    safeStorageSet('bybit_scanner_telegram_chat', STATE.telegramChatId);
    safeStorageSet('bybit_scanner_risk_account', STATE.riskAccount);
    safeStorageSet('bybit_scanner_risk_percent', STATE.riskPercent);
    safeStorageSet('bybit_scanner_risk_leverage', STATE.riskLeverage);
    safeStorageSet('bybit_scanner_risk_max', STATE.riskMaxPosition);
    safeStorageSet('bybit_scanner_weights', CONFIG.WEIGHTS);
    safeStorageSet('bybit_scanner_oled', STATE.oledTheme);
    safeStorageSet('bybit_scanner_coins', CONFIG.COINS);
    safeStorageSet('bybit_scanner_coin_count', STATE.coinCount);
    safeStorageSet('bybit_scanner_timezone', STATE.awareness.timezone);
    console.log('💾 Settings saved to localStorage successfully!');
    
    const totalKeys = GROQ_KEYS.filter((k, i) => k && KEY_ENABLED.groq[i]).length + 
                     DEEPSEEK_KEYS.filter((k, i) => k && KEY_ENABLED.deepseek[i]).length + 
                     GEMINI_KEYS.filter((k, i) => k && KEY_ENABLED.gemini[i]).length;
    if (totalKeys > 0) {
        const aiDot = document.getElementById('aiDot');
        const aiStatus = document.getElementById('aiStatus');
        if (aiDot) aiDot.className = 'ai-dot on';
        if (aiStatus) aiStatus.textContent = 'AI: ' + totalKeys + '/11 enabled';
    }
    
    updateKeyStatus();
    hideSettings();
    toast('Settings saved! ' + totalKeys + ' API keys configured.', 'success');
}

function loadSettings() {
    // BUG FIX #2: Using safe localStorage functions
    // Load all 11 API keys
    const savedGroqKeys = safeStorageGet('bybit_scanner_groq_keys', null);
    const savedDeepseekKeys = safeStorageGet('bybit_scanner_deepseek_keys', null);
    const savedGeminiKeys = safeStorageGet('bybit_scanner_gemini_keys', null);
    
    if (savedGroqKeys && Array.isArray(savedGroqKeys)) {
        savedGroqKeys.forEach((k, i) => { if (i < 5) GROQ_KEYS[i] = k || ''; });
    }
    if (savedDeepseekKeys && Array.isArray(savedDeepseekKeys)) {
        savedDeepseekKeys.forEach((k, i) => { if (i < 1) DEEPSEEK_KEYS[i] = k || ''; });
    }
    if (savedGeminiKeys && Array.isArray(savedGeminiKeys)) {
        savedGeminiKeys.forEach((k, i) => { if (i < 5) GEMINI_KEYS[i] = k || ''; });
    }
    
    // Load KEY_ENABLED states
    const savedKeyEnabled = safeStorageGet('bybit_scanner_key_enabled', null);
    if (savedKeyEnabled) {
        if (savedKeyEnabled.groq) KEY_ENABLED.groq = savedKeyEnabled.groq;
        if (savedKeyEnabled.deepseek) KEY_ENABLED.deepseek = savedKeyEnabled.deepseek;
        if (savedKeyEnabled.gemini) KEY_ENABLED.gemini = savedKeyEnabled.gemini;
    }
    
    // Backward compatibility - load old single keys if no array saved
    if (!savedGroqKeys) {
        const oldKey = safeStorageGet('bybit_scanner_key', '');
        if (oldKey) GROQ_KEYS[0] = oldKey;
    }
    if (!savedDeepseekKeys) {
        const oldKey = safeStorageGet('bybit_scanner_deepseek', '');
        if (oldKey) DEEPSEEK_KEYS[0] = oldKey;
    }
    if (!savedGeminiKeys) {
        const oldKey = safeStorageGet('bybit_scanner_gemini', '');
        if (oldKey) GEMINI_KEYS[0] = oldKey;
    }
    
    // Set STATE for backward compatibility
    STATE.aiKey = GROQ_KEYS[0] || DEFAULT_KEY;
    STATE.deepseekKey = DEEPSEEK_KEYS[0] || '';
    STATE.geminiKey = GEMINI_KEYS[0] || '';
    STATE.aiModel = safeStorageGet('bybit_scanner_model', 'llama-3.3-70b-versatile');
    
    // Load AI Display Mode
    STATE.aiDisplayMode = safeStorageGet('bybit_scanner_ai_display_mode', 'detailed');
    
    const groqCount = GROQ_KEYS.filter((k, i) => k && KEY_ENABLED.groq[i]).length;
    const geminiCount = GEMINI_KEYS.filter((k, i) => k && KEY_ENABLED.gemini[i]).length;
    const deepseekCount = DEEPSEEK_KEYS.filter((k, i) => k && KEY_ENABLED.deepseek[i]).length;
    
    console.log('🔑 Keys loaded:', {
        groq: groqCount + ' keys enabled',
        deepseek: deepseekCount + ' keys enabled',
        gemini: geminiCount + ' keys enabled',
        total: groqCount + deepseekCount + geminiCount + ' of 11 enabled'
    });
    
    // Load timeframe toggles
    const savedTf = safeStorageGet('bybit_scanner_tf', null);
    if (savedTf) {
        STATE.tfEnabled = savedTf;
    }
    
    // Load scan interval
    const savedInterval = safeStorageGet('bybit_scanner_interval', null);
    if (savedInterval) STATE.scanInterval = parseInt(savedInterval);
    
    // Load alert settings
    const savedSound = safeStorageGet('bybit_scanner_alert_sound', null);
    const savedVibrate = safeStorageGet('bybit_scanner_alert_vibrate', null);
    const savedGrade = safeStorageGet('bybit_scanner_alert_grade', null);
    
    if (savedSound !== null) STATE.alertSound = savedSound === true || savedSound === 'true';
    if (savedVibrate !== null) STATE.alertVibrate = savedVibrate === true || savedVibrate === 'true';
    if (savedGrade) STATE.alertGrade = savedGrade;
    
    // Load telegram settings
    const telegramEnabledVal = safeStorageGet('bybit_scanner_telegram_enabled', false);
    STATE.telegramEnabled = telegramEnabledVal === true || telegramEnabledVal === 'true';
    STATE.telegramToken = safeStorageGet('bybit_scanner_telegram_token', '');
    STATE.telegramChatId = safeStorageGet('bybit_scanner_telegram_chat', '');
    
    // Load risk settings
    STATE.riskAccount = parseFloat(safeStorageGet('bybit_scanner_risk_account', 1000)) || 1000;
    STATE.riskPercent = parseFloat(safeStorageGet('bybit_scanner_risk_percent', 2)) || 2;
    STATE.riskLeverage = parseInt(safeStorageGet('bybit_scanner_risk_leverage', 10)) || 10;
    STATE.riskMaxPosition = parseFloat(safeStorageGet('bybit_scanner_risk_max', 500)) || 500;
    
    // Load weights
    const savedWeights = safeStorageGet('bybit_scanner_weights', null);
    if (savedWeights) {
        CONFIG.WEIGHTS = savedWeights;
    }
    
    // Load theme
    const oledVal = safeStorageGet('bybit_scanner_oled', false);
    STATE.oledTheme = oledVal === true || oledVal === 'true';
    applyTheme();
    
    // Load coins
    const savedCoins = safeStorageGet('bybit_scanner_coins', null);
    const savedCoinCount = safeStorageGet('bybit_scanner_coin_count', null);
    if (savedCoins && Array.isArray(savedCoins)) {
        CONFIG.COINS = savedCoins;
    } else {
        CONFIG.COINS = CONFIG.ALL_COINS.slice(0, 50);
    }
    if (savedCoinCount) STATE.coinCount = parseInt(savedCoinCount);
    
    // Load timezone
    if (!STATE.awareness) STATE.awareness = { timezone: 'auto', news: [] };
    STATE.awareness.timezone = safeStorageGet('bybit_scanner_timezone', 'Australia/Melbourne');
    
    if (STATE.aiKey || STATE.deepseekKey || STATE.geminiKey) {
        const aiDot = document.getElementById('aiDot');
        const aiStatus = document.getElementById('aiStatus');
        if (aiDot) aiDot.className = 'ai-dot on';
        if (aiStatus) aiStatus.textContent = 'AI: Ready';
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ALERT FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function triggerAlert(signal) {
    console.log('🔔 triggerAlert called for:', signal.symbol, signal.direction, signal.grade);
    
    // Play sound
    if (STATE.alertSound) {
        playAlertSound();
    }
    
    // Vibrate
    if (STATE.alertVibrate && navigator.vibrate) {
        navigator.vibrate([200, 100, 200, 100, 200]);
    }
    
    // Send Telegram alert
    if (STATE.telegramEnabled) {
        console.log('🔔 Telegram enabled, sending alert...');
        sendTelegramAlert(signal);
    } else {
        console.log('🔔 Telegram disabled, skipping telegram alert');
    }
    
    // Show notification toast
    toast(`🔔 ${signal.grade}: ${signal.symbol.replace('USDT', '')} ${signal.direction} on ${signal.tf}`, 'success');
}

function playAlertSound() {
    try {
        // Create audio context for alert beep
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        oscillator.frequency.value = 880; // A5 note
        oscillator.type = 'sine';
        gainNode.gain.value = 0.3;
        
        oscillator.start();
        
        // Beep pattern: beep-beep-beep
        setTimeout(() => { gainNode.gain.value = 0; }, 100);
        setTimeout(() => { gainNode.gain.value = 0.3; }, 150);
        setTimeout(() => { gainNode.gain.value = 0; }, 250);
        setTimeout(() => { gainNode.gain.value = 0.3; }, 300);
        setTimeout(() => { gainNode.gain.value = 0; }, 400);
        setTimeout(() => { oscillator.stop(); }, 450);
    } catch (e) {
        console.log('Audio not supported');
    }
}

function testAlert() {
    // FIX: Complete test signal with all required properties
    const testSignal = {
        symbol: 'BTCUSDT',
        direction: 'LONG',
        grade: 'PERFECT',
        tf: '1H',
        score: 95,
        agreed: 3,
        levels: {
            entry: 100000.00,
            sl: 98500.00,
            tp1: 101500.00,
            tp2: 103000.00,
            tp3: 105000.00,
            rr: '3.0'
        }
    };
    triggerAlert(testSignal);
}

// ═══════════════════════════════════════════════════════════════════════════════
// COIN MANAGER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function setCoinCount(count) {
    STATE.coinCount = count;
    CONFIG.COINS = CONFIG.ALL_COINS.slice(0, count);
    renderCoinManager();
    toast(`Set to Top ${count} coins`, 'success');
}

function addCoin() {
    const input = document.getElementById('addCoinInput');
    let coin = input.value.trim().toUpperCase();
    if (!coin) return;
    
    if (!coin.endsWith('USDT')) {
        coin = coin + 'USDT';
    }
    
    if (CONFIG.COINS.includes(coin)) {
        toast('Coin already in list!', 'warning');
        return;
    }
    
    CONFIG.COINS.push(coin);
    input.value = '';
    renderCoinManager();
    toast(`Added ${coin}`, 'success');
}

function removeCoin(coin) {
    CONFIG.COINS = CONFIG.COINS.filter(c => c !== coin);
    renderCoinManager();
}

function renderCoinManager() {
    const el = document.getElementById('coinManager');
    document.getElementById('coinCountDisplay').textContent = CONFIG.COINS.length;
    
    el.innerHTML = `<div class="coin-grid">${CONFIG.COINS.map(coin => `
        <div class="coin-chip">
            <span>${coin.replace('USDT', '')}</span>
            <span class="remove-coin" onclick="removeCoin('${coin}')">×</span>
        </div>
    `).join('')}</div>`;
}

// ═══════════════════════════════════════════════════════════════════════════════
// WEIGHT & THEME FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function updateWeightDisplay() {
    const zone = parseInt(document.getElementById('weightZone').value);
    const smc = parseInt(document.getElementById('weightSMC').value);
    const momentum = parseInt(document.getElementById('weightMomentum').value);
    
    document.getElementById('weightZoneVal').textContent = zone + '%';
    document.getElementById('weightSMCVal').textContent = smc + '%';
    document.getElementById('weightMomentumVal').textContent = momentum + '%';
    
    const total = zone + smc + momentum;
    const totalEl = document.getElementById('weightTotal');
    totalEl.textContent = total + '%';
    totalEl.style.color = total === 100 ? 'var(--long)' : 'var(--short)';
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENGINE LOCK SYSTEM - Prevents accidental changes when scrolling
// ═══════════════════════════════════════════════════════════════════════════════

const ENGINE_LOCKS = {
    zone: false,
    smc: false,
    momentum: false
};

function toggleEngineLock(engine) {
    ENGINE_LOCKS[engine] = !ENGINE_LOCKS[engine];
    updateLockUI(engine);
    saveLockState();
}

function updateLockUI(engine) {
    // Handle case sensitivity: 'smc' -> 'SMC', 'zone' -> 'Zone', 'momentum' -> 'Momentum'
    let idSuffix;
    if (engine === 'smc') {
        idSuffix = 'SMC';
    } else if (engine === 'zone') {
        idSuffix = 'Zone';
    } else if (engine === 'momentum') {
        idSuffix = 'Momentum';
    } else {
        idSuffix = engine.charAt(0).toUpperCase() + engine.slice(1);
    }
    
    const btn = document.getElementById('lock' + idSuffix);
    const slider = document.getElementById('weight' + idSuffix);
    const container = document.getElementById('slider' + idSuffix);
    
    if (ENGINE_LOCKS[engine]) {
        if (btn) {
            btn.textContent = '🔒';
            btn.classList.add('locked');
        }
        if (slider) slider.disabled = true;
        if (container) container.classList.add('locked');
    } else {
        if (btn) {
            btn.textContent = '🔓';
            btn.classList.remove('locked');
        }
        if (slider) slider.disabled = false;
        if (container) container.classList.remove('locked');
    }
}

function lockAllEngines() {
    ENGINE_LOCKS.zone = true;
    ENGINE_LOCKS.smc = true;
    ENGINE_LOCKS.momentum = true;
    updateLockUI('zone');
    updateLockUI('smc');
    updateLockUI('momentum');
    saveLockState();
    toast('🔒 All engines locked', 'success');
}

function unlockAllEngines() {
    ENGINE_LOCKS.zone = false;
    ENGINE_LOCKS.smc = false;
    ENGINE_LOCKS.momentum = false;
    updateLockUI('zone');
    updateLockUI('smc');
    updateLockUI('momentum');
    saveLockState();
    toast('🔓 All engines unlocked', 'success');
}

function saveLockState() {
    try {
        localStorage.setItem('bybit_scanner_engine_locks', JSON.stringify(ENGINE_LOCKS));
    } catch (e) {
        console.error('Failed to save lock state:', e);
    }
}

function loadLockState() {
    try {
        const saved = localStorage.getItem('bybit_scanner_engine_locks');
        if (saved) {
            const locks = JSON.parse(saved);
            ENGINE_LOCKS.zone = locks.zone || false;
            ENGINE_LOCKS.smc = locks.smc || false;
            ENGINE_LOCKS.momentum = locks.momentum || false;
        }
        updateLockUI('zone');
        updateLockUI('smc');
        updateLockUI('momentum');
    } catch (e) {
        console.error('Failed to load lock state:', e);
    }
}

function applyTheme() {
    if (STATE.oledTheme) {
        document.body.classList.add('oled');
    } else {
        document.body.classList.remove('oled');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// TELEGRAM FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

async function sendTelegramAlert(signal) {
    // FIX: Early validation with logging
    if (!STATE.telegramEnabled) {
        console.log('📱 Telegram: Disabled');
        return;
    }
    if (!STATE.telegramToken) {
        console.log('📱 Telegram: No token configured');
        return;
    }
    if (!STATE.telegramChatId) {
        console.log('📱 Telegram: No chat ID configured');
        return;
    }
    
    // FIX: Null check for signal properties
    if (!signal || !signal.symbol || !signal.direction) {
        console.error('📱 Telegram: Invalid signal object');
        return;
    }
    
    // FIX: Safe access to levels with fallbacks
    const levels = signal.levels || {};
    const entry = levels.entry ? levels.entry.toFixed(4) : 'N/A';
    const sl = levels.sl ? levels.sl.toFixed(4) : 'N/A';
    const tp1 = levels.tp1 ? levels.tp1.toFixed(4) : 'N/A';
    const tp2 = levels.tp2 ? levels.tp2.toFixed(4) : 'N/A';
    const tp3 = levels.tp3 ? levels.tp3.toFixed(4) : 'N/A';
    const rr = levels.rr || 'N/A';
    
    // Environment data
    const env = signal.environment || {};
    const envScore = env.score || 'N/A';
    const envVerdict = env.verdict || 'N/A';
    const btcTrend = STATE.environment?.btcTrend?.direction || '--';
    const btcD = STATE.environment?.btcDominance?.trend === 'FALLING' ? 'ALTS' : 
                 STATE.environment?.btcDominance?.trend === 'RISING' ? 'BTC' : '--';
    
    const envEmoji = envVerdict === 'GO' ? '🟢' : envVerdict === 'CAUTION' ? '🟡' : envVerdict === 'RISKY' ? '🟠' : '🔴';
    
    // Safe symbol name (remove any markdown-breaking characters)
    const safeSymbol = (signal.symbol || '').replace('USDT', '').replace(/[_*`]/g, '');
    
    const message = `🚨 *${signal.grade || 'SIGNAL'} SIGNAL*

📊 *${safeSymbol}/USDT* - ${signal.direction}
⏱️ Timeframe: ${signal.tf || 'N/A'}
📈 Score: ${signal.score || 0}/100
🎯 Agreement: ${signal.agreed || 0}/3

📊 *Environment:* ${envEmoji} ${envVerdict} (${envScore}/100)
• BTC: ${btcTrend} | Season: ${btcD}

💰 *Trade Levels:*
• Entry: $${entry}
• Stop Loss: $${sl}
• TP1: $${tp1}
• TP2: $${tp2}
• TP3: $${tp3}

⚖️ Risk:Reward = 1:${rr}

_BS Scanner V1 ULTIMATE_`;

    try {
        console.log('📱 Telegram: Sending alert for', signal.symbol);
        
        const url = `https://api.telegram.org/bot${STATE.telegramToken}/sendMessage`;
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: STATE.telegramChatId,
                text: message,
                parse_mode: 'Markdown'
            })
        });
        
        // FIX: Check response status
        if (response.ok) {
            const data = await response.json();
            if (data.ok) {
                console.log('📱 Telegram: ✅ Alert sent successfully!');
            } else {
                console.error('📱 Telegram: ❌ API Error:', data.description);
            }
        } else {
            const errorData = await response.json().catch(() => ({}));
            console.error('📱 Telegram: ❌ HTTP Error:', response.status, errorData.description || response.statusText);
            
            // Common error hints
            if (response.status === 401) {
                console.error('📱 Telegram: Invalid bot token! Check your token.');
            } else if (response.status === 400) {
                console.error('📱 Telegram: Bad request - check chat ID or message format.');
            }
        }
    } catch (e) {
        console.error('📱 Telegram: ❌ Network/Connection error:', e.message);
    }
}

async function testTelegram() {
    if (!document.getElementById('telegramToken').value || !document.getElementById('telegramChatId').value) {
        toast('Enter Bot Token and Chat ID first!', 'error');
        return;
    }
    
    const token = document.getElementById('telegramToken').value.trim();
    const chatId = document.getElementById('telegramChatId').value.trim();
    
    // Validate token format
    if (!token.includes(':')) {
        toast('❌ Invalid token format! Should be like: 123456789:ABCdefGHI...', 'error');
        return;
    }
    
    // BUG FIX #5: Save settings before testing so saved values match tested values
    STATE.telegramToken = token;
    STATE.telegramChatId = chatId;
    STATE.telegramEnabled = document.getElementById('telegramEnabled').checked;
    safeStorageSet('bybit_scanner_telegram_token', token);
    safeStorageSet('bybit_scanner_telegram_chat', chatId);
    safeStorageSet('bybit_scanner_telegram_enabled', STATE.telegramEnabled);
    
    toast('📱 Testing Telegram connection...', '');
    
    try {
        const url = `https://api.telegram.org/bot${token}/sendMessage`;
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: chatId,
                text: '✅ *BS Scanner V1 ULTIMATE Connected!*\n\n🚀 You will receive trading signals here.\n\n_Test successful!_',
                parse_mode: 'Markdown'
            })
        });
        
        const data = await response.json();
        
        if (response.ok && data.ok) {
            toast('✅ Telegram test sent & settings saved!', 'success');
            console.log('📱 Telegram test successful:', data);
        } else {
            // Detailed error messages
            const errorMsg = data.description || 'Unknown error';
            console.error('📱 Telegram test failed:', errorMsg);
            
            if (errorMsg.includes('chat not found')) {
                toast('❌ Chat ID not found! Make sure you started the bot first.', 'error');
            } else if (errorMsg.includes('bot was blocked')) {
                toast('❌ Bot was blocked! Unblock the bot and try again.', 'error');
            } else if (errorMsg.includes('Unauthorized')) {
                toast('❌ Invalid Bot Token! Check your token.', 'error');
            } else {
                toast(`❌ Telegram error: ${errorMsg}`, 'error');
            }
        }
    } catch (e) {
        console.error('📱 Telegram connection error:', e);
        toast('❌ Network error! Check your internet connection.', 'error');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// VIEW TOGGLE & HEAT MAP
// ═══════════════════════════════════════════════════════════════════════════════

function setView(view) {
    STATE.view = view;
    document.getElementById('viewList').className = 'view-btn' + (view === 'list' ? ' active' : '');
    document.getElementById('viewHeatmap').className = 'view-btn' + (view === 'heatmap' ? ' active' : '');
    
    if (view === 'list') {
        updateSignalList();
    } else {
        renderHeatMap();
    }
}

function renderHeatMap() {
    const el = document.getElementById('signalList');
    const coins = [...new Set(STATE.signals.map(s => s.symbol))].slice(0, 30);
    const tfs = ['5m', '15m', '30m', '1H', '4H', '1D'];
    
    if (coins.length === 0) {
        el.innerHTML = `<div class="empty"><div class="empty-icon">🌡️</div><div>No signals for heat map</div></div>`;
        return;
    }
    
    let html = `<div class="heat-map-container"><table class="heat-map-table">
        <thead><tr><th>Coin</th>${tfs.map(tf => `<th>${tf}</th>`).join('')}</tr></thead>
        <tbody>`;
    
    for (const coin of coins) {
        html += `<tr><td class="coin-name">${coin.replace('USDT', '')}</td>`;
        
        for (const tf of tfs) {
            const sig = STATE.signals.find(s => s.symbol === coin && s.tf === tf);
            if (sig) {
                const cellClass = sig.direction.toLowerCase() + (sig.grade === 'PERFECT' ? ' perfect' : '');
                html += `<td onclick="selectSignalByKey('${coin}','${tf}')">
                    <div class="heat-cell ${cellClass}">${sig.score}</div>
                </td>`;
            } else {
                html += `<td><div class="heat-cell none">-</div></td>`;
            }
        }
        html += '</tr>';
    }
    
    html += '</tbody></table></div>';
    el.innerHTML = html;
}

function selectSignalByKey(symbol, tf) {
    const idx = STATE.signals.findIndex(s => s.symbol === symbol && s.tf === tf);
    if (idx >= 0) {
        selectSignal(idx);
        setView('list');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// RISK CALCULATOR
// ═══════════════════════════════════════════════════════════════════════════════

function calculatePositionSize(signal) {
    if (!signal) return null;
    
    const account = STATE.riskAccount;
    const riskPct = STATE.riskPercent / 100;
    const leverage = STATE.riskLeverage;
    const maxPos = STATE.riskMaxPosition;
    
    const riskAmount = account * riskPct;
    const slDistance = Math.abs(signal.levels.entry - signal.levels.sl) / signal.levels.entry;
    
    let positionSize = riskAmount / slDistance;
    positionSize = Math.min(positionSize, maxPos);
    
    const margin = positionSize / leverage;
    
    return {
        positionSize: positionSize.toFixed(2),
        margin: margin.toFixed(2),
        riskAmount: riskAmount.toFixed(2),
        leverage: leverage
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// INITIALIZATION
// ═══════════════════════════════════════════════════════════════════════════════

async function init() {
    console.log('🚀 Bybit Scanner v9.5 Starting...');
    
    // Load saved data
    loadSettings();
    loadTrades();
    loadLockState();
    updateTradeList();
    
    // Restore panel states
    restoreBacktestState();
    restoreFlowState();
    
    // Fetch BTC price and all market data
    await fetchBTC();
    await fetchAllMarketData();
    
    // Fetch Open Interest data
    await fetchBTCOpenInterest();
    
    // Initialize environment system
    await updateEnvironment();
    
    // Fetch crypto news for awareness
    await fetchCryptoNews();
    
    // BUG FIX #4: Track intervals for cleanup
    if (!window.scannerIntervals) {
        window.scannerIntervals = [];
    }
    
    // Clear any existing intervals (prevents stacking on hot reload)
    window.scannerIntervals.forEach(id => clearInterval(id));
    window.scannerIntervals = [];
    
    // Start auto-refresh with tracked intervals
    window.scannerIntervals.push(setInterval(fetchBTC, 30000));
    window.scannerIntervals.push(setInterval(fetchAllMarketData, 60000));  // Update market badges every minute
    window.scannerIntervals.push(setInterval(updateTradePrices, 30000));
    window.scannerIntervals.push(setInterval(updateEnvironment, 60000));  // Update environment every minute
    window.scannerIntervals.push(setInterval(fetchBTCOpenInterest, 60000));  // Update OI every minute
    window.scannerIntervals.push(setInterval(fetchLiquidations, 120000)); // Update liquidations every 2 min
    window.scannerIntervals.push(setInterval(fetchCryptoNews, 3600000));  // Update news every hour
    
    // Start scanning
    STATE.scanning = true;
    document.getElementById('scanBtn').className = 'btn scanning';
    document.getElementById('scanIcon').textContent = '◉';
    
    // 🧠 Initialize Intelligent Brains
    initIntelligentBrains();
    
    // 🔥 Initialize Phase 1 Live Data System
    initPhase1LiveData();
    
    runScanner();
    
    console.log('🧠 BS Scanner V10.1 - Coin Personality + Adaptive Learning! Each coin is unique! 🔥');
}

// BUG FIX #4: Cleanup intervals on page unload
window.addEventListener('beforeunload', () => {
    if (window.scannerIntervals) {
        window.scannerIntervals.forEach(id => clearInterval(id));
    }
});

// Start when DOM is ready
document.addEventListener('DOMContentLoaded', init);

// ═══════════════════════════════════════════════════════════════════════════════
// PWA SERVICE WORKER (Offline Support + Install as App)
// ═══════════════════════════════════════════════════════════════════════════════

// Register Service Worker for PWA
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        // Create inline service worker
        const swCode = `
            const CACHE_NAME = 'bs-scanner-v1';
            const urlsToCache = ['/'];
            
            self.addEventListener('install', e => {
                e.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache)));
                self.skipWaiting();
            });
            
            self.addEventListener('fetch', e => {
                e.respondWith(
                    fetch(e.request).catch(() => caches.match(e.request))
                );
            });
            
            self.addEventListener('activate', e => {
                e.waitUntil(clients.claim());
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl).then(reg => {
            console.log('✅ PWA Service Worker registered');
        }).catch(err => {
            console.log('PWA registration skipped (local file)');
        });
    });
}

// PWA Install Prompt
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    console.log('📱 App can be installed! Use browser menu > Add to Home Screen');
});

// ═══════════════════════════════════════════════════════════════════════════════
// TRADE HISTORY FEATURE
// ═══════════════════════════════════════════════════════════════════════════════

function showTradeHistory() {
    const history = STATE.tradeHistory || [];
    const stats = getTradeStats();
    
    let historyItems = '';
    if (history.length === 0) {
        historyItems = '<div style="text-align:center;color:var(--text3);padding:20px">No trade history yet</div>';
    } else {
        history.forEach(t => {
            const pnl = parseFloat(t.pnlPercent || 0);
            const resultClass = pnl > 0 ? 'long' : pnl < 0 ? 'short' : 'text3';
            const resultIcon = pnl > 0 ? '✅' : pnl < 0 ? '❌' : '⏹️';
            const date = new Date(t.closedAt || t.timestamp).toLocaleDateString();
            const pnlStr = t.pnlPercent ? (pnl >= 0 ? '+' : '') + t.pnlPercent + '%' : '--';
            const dirClass = t.direction === 'LONG' ? 'long' : 'short';
            
            historyItems += '<div style="display:flex;align-items:center;gap:8px;padding:8px;background:var(--bg3);border-radius:6px;margin-bottom:6px;border-left:3px solid var(--' + resultClass + ')">' +
                '<span style="font-size:16px">' + resultIcon + '</span>' +
                '<div style="flex:1">' +
                    '<div style="font-weight:600;font-size:13px">' + t.symbol.replace('USDT', '') + ' <span style="color:var(--' + dirClass + ');font-size:11px">' + t.direction + '</span></div>' +
                    '<div style="font-size:10px;color:var(--text3)">' + t.tf + ' • ' + t.grade + ' • ' + date + '</div>' +
                '</div>' +
                '<div style="text-align:right">' +
                    '<div style="font-weight:700;color:var(--' + (pnl >= 0 ? 'long' : 'short') + ')">' + pnlStr + '</div>' +
                    '<div style="font-size:10px;color:var(--text3)">P&L</div>' +
                '</div>' +
            '</div>';
        });
    }
    
    const pnlColor = parseFloat(stats.totalPnL) >= 0 ? 'var(--long)' : 'var(--short)';
    const pnlSign = parseFloat(stats.totalPnL) >= 0 ? '+' : '';
    
    const modalHtml = '<div class="modal-bg show" id="historyModal" onclick="if(event.target.id===\'historyModal\')closeHistoryModal()">' +
        '<div class="modal" style="max-width:500px;max-height:80vh;overflow:hidden;display:flex;flex-direction:column">' +
            '<div class="modal-head">' +
                '<div class="modal-title">📊 Trade History</div>' +
                '<button class="modal-close" onclick="closeHistoryModal()">✕</button>' +
            '</div>' +
            '<div style="padding:12px;border-bottom:1px solid var(--border)">' +
                '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;text-align:center">' +
                    '<div style="background:var(--bg3);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:var(--gold)">' + stats.total + '</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Total</div>' +
                    '</div>' +
                    '<div style="background:var(--long-dim);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:var(--long)">' + stats.profitable + '</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Profit</div>' +
                    '</div>' +
                    '<div style="background:var(--short-dim);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:var(--short)">' + stats.losing + '</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Loss</div>' +
                    '</div>' +
                    '<div style="background:var(--bg3);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:' + pnlColor + '">' + pnlSign + stats.totalPnL + '%</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Total P&L</div>' +
                    '</div>' +
                '</div>' +
            '</div>' +
            '<div style="flex:1;overflow-y:auto;padding:12px">' + historyItems + '</div>' +
            '<div class="modal-foot">' +
                '<button class="btn" onclick="clearTradeHistory()">🗑️ Clear</button>' +
                '<button class="btn primary" onclick="closeHistoryModal()">Close</button>' +
            '</div>' +
        '</div>' +
    '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeHistoryModal() {
    const modal = document.getElementById('historyModal');
    if (modal) modal.remove();
}

function clearTradeHistory() {
    if (confirm('Are you sure you want to clear all trade history?')) {
        STATE.tradeHistory = [];
        saveTradeHistory();
        closeHistoryModal();
        showTradeHistory();
        toast('Trade history cleared', 'success');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════════════════════════
// ██████╗ ███████╗    ███████╗ ██████╗ █████╗ ███╗   ██╗███╗   ██╗███████╗██████╗     ██╗   ██╗ ██╗ ██╗
// ██╔══██╗██╔════╝    ██╔════╝██╔════╝██╔══██╗████╗  ██║████╗  ██║██╔════╝██╔══██╗    ██║   ██║███║███║
// ██████╔╝███████╗    ███████╗██║     ███████║██╔██╗ ██║██╔██╗ ██║█████╗  ██████╔╝    ██║   ██║╚██║╚██║
// ██╔══██╗╚════██║    ╚════██║██║     ██╔══██║██║╚██╗██║██║╚██╗██║██╔══╝  ██╔══██╗    ╚██╗ ██╔╝ ██║ ██║
// ██████╔╝███████║    ███████║╚██████╗██║  ██║██║ ╚████║██║ ╚████║███████╗██║  ██║     ╚████╔╝  ██║ ██║
// ╚═════╝ ╚══════╝    ╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝      ╚═══╝   ╚═╝ ╚═╝
// ULTIMATE BACKTEST ENGINE V11 - COMPLETE REWRITE
// ═══════════════════════════════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════════
// MASTER CONFIG - ALL COINS & TIMEFRAMES
// ═══════════════════════════════════════════════════════════════════════════════
const UB_CONFIG = {
    // ═══════════════════════════════════════════════════════════════════════════
    // 150 MOST LIQUID BYBIT PERPETUAL COINS
    // ═══════════════════════════════════════════════════════════════════════════
    ALL_COINS: [
        // TIER 1 - Ultra Liquid (10)
        'BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'BNBUSDT', 'XRPUSDT', 'DOGEUSDT', 'ADAUSDT', 'AVAXUSDT', 'DOTUSDT', 'LINKUSDT',
        // TIER 2 - Major Alts (20)
        'MATICUSDT', 'LTCUSDT', 'ATOMUSDT', 'NEARUSDT', 'APTUSDT', 'ARBUSDT', 'OPUSDT', 'INJUSDT', 'SUIUSDT', 'SEIUSDT',
        'TIAUSDT', 'RUNEUSDT', 'FTMUSDT', 'SANDUSDT', 'MANAUSDT', 'GALAUSDT', 'AXSUSDT', 'ETCUSDT', 'FILUSDT', 'ICPUSDT',
        // TIER 3 - Mid Caps (30)
        'XLMUSDT', 'TRXUSDT', 'XMRUSDT', 'AABORUSDT', 'UNIUSDT', 'MKRUSDT', 'SNXUSDT', 'COMPUSDT', 'CRVUSDT', 'LDOUSDT',
        'FETUSDT', 'AGIXUSDT', 'RNDRUSDT', 'BLURUSDT', 'CFXUSDT', 'STXUSDT', 'EGLDUSDT', 'KASUSDT', 'WLDUSDT', 'JUPUSDT',
        'PYTHUSDT', 'ONDOUSDT', 'ENAUSDT', 'PENDLEUSDT', 'STRKUSDT', 'ZKUSDT', 'WUSDT', 'ZETAUSDT', 'EIGENUSDT', 'MOVEUSDT',
        // TIER 4 - Memes & Gaming (20)
        'PEPEUSDT', 'SHIBUSDT', 'WIFUSDT', 'FLOKIUSDT', 'BONKUSDT', 'ORDIUSDT', 'MEMEUSDT', 'BOMEUSDT', 'NEIROUSDT', 'TURBOUSDT',
        'IMXUSDT', 'FLOWUSDT', 'ENJUSDT', 'CHZUSDT', 'APEUSDT', 'GMTUSDT', 'YGGUSDT', 'PIXELUSDT', 'PORTALUSDT', 'XAIUSDT',
        // TIER 5 - DeFi & Infrastructure (30)
        'AABOROUSDT', 'SUSHIUSDT', '1INCHUSDT', 'DYDXUSDT', 'GMXUSDT', 'PERPUSDT', 'RADUSDT', 'UMAUSDT', 'BALUSDT', 'YFIUSDT',
        'KNCUSDT', 'ZRXUSDT', 'OGNUSDT', 'CELOUSDT', 'KSMUSDT', 'MINAUSDT', 'ROSEUSD', 'QNTUSDT', 'OCEANUSDT', 'GRTUSDT',
        'ILVUSDT', 'API3USDT', 'BANDUSDT', 'STORJUSDT', 'SCUSDT', 'ARUSDT', 'HNTUSDT', 'IOTAUSDT', 'ZILUSDT', 'VETUSDT',
        // TIER 6 - Layer 2 & Scaling (20)
        'METISUSDT', 'MANTAUSDT', 'ALTUSDT', 'BLASTUSDT', 'MODEUSDT', 'SCROLLUSDT', 'LINEAUSDT', 'TAIKOUSDT', 'ZKSYNUSDT', 'BASUSDT',
        'CELRUSDT', 'CTSIUSDT', 'SKLUSDT', 'BOAUSDT', 'GLMUSDT', 'RLCUSDT', 'ANKRUSDT', 'POWRUSDT', 'NMRUSDT', 'REQUSDT',
        // TIER 7 - AI & New Narratives (20)
        'TAOUSDT', 'ARKMUSDT', 'VIRTUSDT', 'AI16ZUSDT', 'GRIFFAINUSDT', 'FABORICUSDT', 'ACUSDT', 'NFPUSDT', 'AIUSDT', 'PHAUSDT',
        'RSRUSDT', 'TABOROUSDT', 'ACEUSDT', 'DYMUSDT', 'MABORVUSDT', 'NTRNUSDT', 'ASTRUSDT', 'AABORUUSDT', 'SAGAUSDT', 'VANRYUSDT'
    ],
    ALL_TFS: ['5', '15', '30', '60', '240', 'D'],
    ULTRA_TFS: ['5', '15', '30', '60', '240'], // 5m to 4H (no Daily for speed)
    TF_LABELS: { '5': '5m', '15': '15m', '30': '30m', '60': '1H', '240': '4H', 'D': '1D' },
    
    // DEFAULT SETTINGS (user can change)
    settings: {
        ultraCoins: 150,
        ultraTFs: ['5', '15', '30', '60', '240'],
        fastCoins: 20,
        fastTFs: ['60', '240'],
        deepCoins: 10,
        deepTFs: ['15', '60', '240'],
        minScore: 60,
        minTrades: 3,
        chopFilter: true,
        slippagePct: 0.1,
        paranoidMode: true
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 1: COST MODEL
// ═══════════════════════════════════════════════════════════════════════════════
const CostModel = {
    config: { makerFee: 0.0002, takerFee: 0.00055, baseSlippage: 0.0001 },
    getSpreadByTier(symbol) {
        const tier1 = ['BTCUSDT', 'ETHUSDT'];
        const tier2 = ['SOLUSDT', 'BNBUSDT', 'XRPUSDT', 'DOGEUSDT'];
        if (tier1.includes(symbol)) return 0.00005;
        if (tier2.includes(symbol)) return 0.0001;
        return 0.0002;
    },
    calculateTotalCosts(entryPrice, exitPrice, size, symbol, isLimit = false) {
        const entryFee = entryPrice * size * (isLimit ? this.config.makerFee : this.config.takerFee);
        const exitFee = exitPrice * size * this.config.takerFee;
        return entryFee + exitFee;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 2: BACKTEST STATISTICS ENGINE
// ═══════════════════════════════════════════════════════════════════════════════
const BacktestStatistics = {
    calculate(trades, initialCapital = 10000) {
        if (!trades || trades.length === 0) return this.emptyStats();
        
        // Normalize trades - handle both netPnl and pnl formats
        const normalizedTrades = trades.map(t => ({
            ...t,
            netPnl: t.netPnl !== undefined ? t.netPnl : (t.pnl !== undefined ? t.pnl - 0.2 : 0)
        }));
        
        const wins = normalizedTrades.filter(t => t.netPnl > 0);
        const losses = normalizedTrades.filter(t => t.netPnl <= 0);
        const totalPnl = normalizedTrades.reduce((sum, t) => sum + t.netPnl, 0);
        const grossProfit = wins.reduce((sum, t) => sum + t.netPnl, 0);
        const grossLoss = Math.abs(losses.reduce((sum, t) => sum + t.netPnl, 0));
        
        let equity = initialCapital, peak = equity, maxDrawdown = 0, maxDrawdownPct = 0;
        const equityCurve = [{ equity, drawdown: 0 }];
        
        for (const trade of normalizedTrades) {
            equity += trade.netPnl;
            peak = Math.max(peak, equity);
            const dd = peak - equity;
            const ddPct = peak > 0 ? (dd / peak) * 100 : 0;
            maxDrawdown = Math.max(maxDrawdown, dd);
            maxDrawdownPct = Math.max(maxDrawdownPct, ddPct);
            equityCurve.push({ equity, drawdown: ddPct });
        }
        
        const returns = normalizedTrades.map(t => t.netPnl / initialCapital);
        const avgReturn = returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0;
        const stdDev = returns.length > 0 ? Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length) : 0;
        const riskFreeRate = 0.02 / 252;
        const sharpeRatio = stdDev > 0 ? ((avgReturn - riskFreeRate) / stdDev) * Math.sqrt(252) : 0;
        
        const negReturns = returns.filter(r => r < 0);
        const downsideDev = negReturns.length > 0 ? Math.sqrt(negReturns.reduce((sum, r) => sum + r * r, 0) / negReturns.length) : 0.001;
        const sortinoRatio = downsideDev > 0 ? ((avgReturn - riskFreeRate) / downsideDev) * Math.sqrt(252) : 0;
        const calmarRatio = maxDrawdownPct > 0 ? (totalPnl / initialCapital * 100) / maxDrawdownPct : 0;
        const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? 999 : 0;
        
        let maxConsecWins = 0, maxConsecLosses = 0, consecWins = 0, consecLosses = 0;
        for (const t of normalizedTrades) {
            if (t.netPnl > 0) { consecWins++; consecLosses = 0; maxConsecWins = Math.max(maxConsecWins, consecWins); }
            else { consecLosses++; consecWins = 0; maxConsecLosses = Math.max(maxConsecLosses, consecLosses); }
        }
        
        const avgWin = wins.length > 0 ? grossProfit / wins.length : 0;
        const avgLoss = losses.length > 0 ? grossLoss / losses.length : 0;
        const avgRR = avgLoss > 0 ? avgWin / avgLoss : 0;
        const winRate = normalizedTrades.length > 0 ? (wins.length / normalizedTrades.length) * 100 : 0;
        const expectancy = (winRate / 100 * avgWin) - ((100 - winRate) / 100 * avgLoss);
        
        return {
            totalTrades: normalizedTrades.length, wins: wins.length, losses: losses.length,
            winRate: winRate.toFixed(1), totalPnl: totalPnl.toFixed(2),
            totalPnlPct: ((totalPnl / initialCapital) * 100).toFixed(2),
            grossProfit: grossProfit.toFixed(2), grossLoss: grossLoss.toFixed(2),
            profitFactor: profitFactor.toFixed(2), maxDrawdown: maxDrawdown.toFixed(2),
            maxDrawdownPct: maxDrawdownPct.toFixed(2), sharpeRatio: sharpeRatio.toFixed(2),
            sortinoRatio: sortinoRatio.toFixed(2), calmarRatio: calmarRatio.toFixed(2),
            avgWin: avgWin.toFixed(2), avgLoss: avgLoss.toFixed(2), avgRR: avgRR.toFixed(2),
            expectancy: expectancy.toFixed(2), maxConsecWins, maxConsecLosses,
            equityCurve, finalEquity: equity.toFixed(2)
        };
    },
    emptyStats() {
        return { totalTrades: 0, wins: 0, losses: 0, winRate: '0', totalPnl: '0', totalPnlPct: '0',
            grossProfit: '0', grossLoss: '0', profitFactor: '0', maxDrawdown: '0', maxDrawdownPct: '0',
            sharpeRatio: '0', sortinoRatio: '0', calmarRatio: '0', avgWin: '0', avgLoss: '0',
            avgRR: '0', expectancy: '0', maxConsecWins: 0, maxConsecLosses: 0, equityCurve: [], finalEquity: '10000' };
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 3: K-FOLD CROSS VALIDATION
// ═══════════════════════════════════════════════════════════════════════════════
const KFoldCV = {
    async run(symbol, timeframe, candles, settings, k = 5) {
        if (!candles || candles.length < k * 100) return { error: 'Insufficient data for K-Fold', folds: k };
        
        const foldSize = Math.floor(candles.length / k);
        const foldResults = [];
        
        for (let i = 0; i < k; i++) {
            const testStart = i * foldSize;
            const testEnd = (i + 1) * foldSize;
            const testCandles = candles.slice(testStart, testEnd);
            
            const trades = [];
            for (let j = 100; j < testCandles.length - 20; j += 3) {
                const slice = testCandles.slice(Math.max(0, j - 100), j + 1);
                if (slice.length < 50) continue;
                
                try {
                    const signal = quickSignalCheck(slice, symbol, timeframe);
                    if (!signal || signal.score < (settings?.minScore || 60)) continue;
                    
                    const futureSlice = testCandles.slice(j + 1, j + 21);
                    if (futureSlice.length < 5) continue;
                    
                    const outcome = simulateTradeOutcome(signal, futureSlice);
                    if (outcome) trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won });
                } catch (e) { /* skip bad signals */ }
            }
            
            const stats = BacktestStatistics.calculate(trades, 10000);
            foldResults.push({ fold: i + 1, trades: trades.length, winRate: parseFloat(stats.winRate) || 0, pnl: parseFloat(stats.totalPnl) || 0, sharpe: parseFloat(stats.sharpeRatio) || 0 });
        }
        
        const winRates = foldResults.map(f => f.winRate);
        const avgWinRate = winRates.length > 0 ? winRates.reduce((a, b) => a + b, 0) / k : 0;
        const winRateStdDev = winRates.length > 0 ? Math.sqrt(winRates.reduce((sum, w) => sum + Math.pow(w - avgWinRate, 2), 0) / k) : 0;
        const pnls = foldResults.map(f => f.pnl);
        const avgPnl = pnls.length > 0 ? pnls.reduce((a, b) => a + b, 0) / k : 0;
        const positiveCount = pnls.filter(p => p > 0).length;
        
        return {
            folds: foldResults,
            summary: {
                avgWinRate: avgWinRate.toFixed(1), winRateStdDev: winRateStdDev.toFixed(1),
                avgPnl: avgPnl.toFixed(2), positiveCount,
                isConsistent: winRateStdDev < 10 && positiveCount >= Math.ceil(k * 0.6),
                consistency: ((1 - Math.min(winRateStdDev, 100) / 100) * (positiveCount / k) * 100).toFixed(0)
            }
        };
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 4: WALK-FORWARD ANALYSIS
// ═══════════════════════════════════════════════════════════════════════════════
const WalkForwardAnalysis = {
    async run(symbol, timeframe, candles, optimizeWindow = 0.7, testWindow = 0.3, windows = 4) {
        if (!candles || candles.length < 400) return { error: 'Insufficient data', windows: [], efficiency: '0', rating: 'POOR' };
        
        const windowSize = Math.floor(candles.length / windows);
        const optimizeSize = Math.floor(windowSize * optimizeWindow);
        const testSize = Math.floor(windowSize * testWindow);
        
        const results = [];
        let totalInSample = 0, totalOutOfSample = 0;
        
        for (let w = 0; w < windows; w++) {
            const start = w * windowSize;
            const optimizeCandles = candles.slice(start, start + optimizeSize);
            const testCandles = candles.slice(start + optimizeSize, start + optimizeSize + testSize);
            
            if (optimizeCandles.length < 100 || testCandles.length < 50) continue;
            
            const inSampleTrades = await this.runSimpleBacktest(optimizeCandles, symbol, timeframe);
            const inSampleStats = BacktestStatistics.calculate(inSampleTrades, 10000);
            
            const outOfSampleTrades = await this.runSimpleBacktest(testCandles, symbol, timeframe);
            const outOfSampleStats = BacktestStatistics.calculate(outOfSampleTrades, 10000);
            
            totalInSample += parseFloat(inSampleStats.totalPnl) || 0;
            totalOutOfSample += parseFloat(outOfSampleStats.totalPnl) || 0;
            
            results.push({
                window: w + 1,
                inSample: { trades: inSampleTrades.length, pnl: inSampleStats.totalPnl, winRate: inSampleStats.winRate },
                outOfSample: { trades: outOfSampleTrades.length, pnl: outOfSampleStats.totalPnl, winRate: outOfSampleStats.winRate }
            });
        }
        
        const efficiency = totalInSample > 0 ? totalOutOfSample / totalInSample : 0;
        
        return {
            windows: results, totalInSample: totalInSample.toFixed(2), totalOutOfSample: totalOutOfSample.toFixed(2),
            efficiency: efficiency.toFixed(2), isRobust: efficiency >= 0.5 && totalOutOfSample > 0,
            rating: efficiency >= 0.7 ? 'EXCELLENT' : efficiency >= 0.5 ? 'GOOD' : efficiency >= 0.3 ? 'MODERATE' : 'POOR'
        };
    },
    async runSimpleBacktest(candles, symbol, timeframe) {
        const trades = [];
        let skippedChop = 0;
        
        for (let i = 100; i < candles.length - 20; i += 3) {
            const slice = candles.slice(Math.max(0, i - 100), i);
            if (slice.length < 50) continue;
            
            // PARANOID FIX: Skip signals in choppy conditions
            if (isChoppy(slice, 20)) {
                skippedChop++;
                continue;
            }
            
            try {
                const signal = quickSignalCheck(slice, symbol, timeframe);
                if (!signal || signal.score < 60) continue;
                
                const future = candles.slice(i + 1, i + 21);
                if (future.length < 5) continue;
                
                const outcome = simulateTradeOutcome(signal, future);
                if (outcome) trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won, reason: outcome.reason });
            } catch (e) { /* skip */ }
        }
        return trades;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 5: MONTE CARLO SIMULATION
// ═══════════════════════════════════════════════════════════════════════════════
const MonteCarloSimulator = {
    run(trades, simulations = 1000, initialCapital = 10000) {
        if (!trades || trades.length < 10) return { error: 'Need at least 10 trades for Monte Carlo', profitProbability: '0', ruinProbability: '100' };
        
        // Normalize trades
        const tradeReturns = trades.map(t => {
            if (t.netPnl !== undefined) return t.netPnl;
            if (t.pnl !== undefined) return t.pnl - 0.2;
            return 0;
        }).filter(r => !isNaN(r));
        
        if (tradeReturns.length < 10) return { error: 'Not enough valid trades', profitProbability: '0', ruinProbability: '100' };
        
        const results = [];
        
        for (let sim = 0; sim < simulations; sim++) {
            const shuffled = [...tradeReturns].sort(() => Math.random() - 0.5);
            let equity = initialCapital, peak = equity, maxDD = 0;
            
            for (const ret of shuffled) {
                equity += ret;
                peak = Math.max(peak, equity);
                const dd = peak > 0 ? (peak - equity) / peak : 0;
                maxDD = Math.max(maxDD, dd);
            }
            
            results.push({ finalEquity: equity, totalReturn: ((equity - initialCapital) / initialCapital) * 100, maxDrawdown: maxDD * 100 });
        }
        
        results.sort((a, b) => a.finalEquity - b.finalEquity);
        const getPercentile = (arr, p) => arr[Math.floor(arr.length * p / 100)] || arr[0];
        
        const finalEquities = results.map(r => r.finalEquity);
        const totalReturns = results.map(r => r.totalReturn);
        const maxDDs = results.map(r => r.maxDrawdown);
        
        return {
            simulations, tradeCount: trades.length,
            percentile5: { finalEquity: getPercentile(finalEquities, 5).toFixed(2), totalReturn: getPercentile(totalReturns, 5).toFixed(2), maxDrawdown: getPercentile(maxDDs, 95).toFixed(2) },
            percentile25: { finalEquity: getPercentile(finalEquities, 25).toFixed(2), totalReturn: getPercentile(totalReturns, 25).toFixed(2) },
            median: { finalEquity: getPercentile(finalEquities, 50).toFixed(2), totalReturn: getPercentile(totalReturns, 50).toFixed(2), maxDrawdown: getPercentile(maxDDs, 50).toFixed(2) },
            percentile75: { finalEquity: getPercentile(finalEquities, 75).toFixed(2), totalReturn: getPercentile(totalReturns, 75).toFixed(2) },
            percentile95: { finalEquity: getPercentile(finalEquities, 95).toFixed(2), totalReturn: getPercentile(totalReturns, 95).toFixed(2), maxDrawdown: getPercentile(maxDDs, 5).toFixed(2) },
            profitProbability: ((results.filter(r => r.totalReturn > 0).length / simulations) * 100).toFixed(1),
            ruinProbability: ((results.filter(r => r.finalEquity < initialCapital * 0.5).length / simulations) * 100).toFixed(1)
        };
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 6: GENETIC OPTIMIZER (SIMPLIFIED FOR SPEED)
// ═══════════════════════════════════════════════════════════════════════════════
const GeneticOptimizer = {
    config: { populationSize: 20, generations: 10, mutationRate: 0.2, eliteCount: 2 },
    paramBounds: {
        minScore: { min: 50, max: 80, step: 10 },
        riskPerTrade: { min: 0.5, max: 2, step: 0.5 }
    },
    
    async run(symbol, timeframe, candles, progressCallback = null) {
        if (!candles || candles.length < 300) return { error: 'Insufficient data', bestParams: { minScore: 60, riskPerTrade: 1 }, bestFitness: 0 };
        
        let population = [];
        for (let i = 0; i < this.config.populationSize; i++) {
            population.push({ params: this.randomParams(), fitness: -Infinity });
        }
        
        let bestEver = { fitness: -Infinity, params: { minScore: 60, riskPerTrade: 1 } };
        const history = [];
        
        for (let gen = 0; gen < this.config.generations; gen++) {
            // Evaluate
            for (let i = 0; i < population.length; i++) {
                if (population[i].fitness === -Infinity) {
                    population[i].fitness = this.evaluateFitness(population[i].params, candles, symbol, timeframe);
                }
            }
            
            population.sort((a, b) => b.fitness - a.fitness);
            if (population[0].fitness > bestEver.fitness) bestEver = { ...population[0] };
            
            history.push({ generation: gen + 1, bestFitness: population[0].fitness.toFixed(2), avgFitness: (population.reduce((s, p) => s + p.fitness, 0) / population.length).toFixed(2), bestParams: { ...population[0].params } });
            
            if (progressCallback) progressCallback({ generation: gen + 1, total: this.config.generations, best: population[0].fitness.toFixed(2), params: population[0].params });
            
            // Next generation
            const nextGen = population.slice(0, this.config.eliteCount).map(p => ({ ...p, fitness: -Infinity }));
            while (nextGen.length < this.config.populationSize) {
                const parent = population[Math.floor(Math.random() * 5)]; // Top 5
                const child = { params: { ...parent.params }, fitness: -Infinity };
                if (Math.random() < this.config.mutationRate) this.mutate(child);
                nextGen.push(child);
            }
            population = nextGen;
        }
        
        return { bestParams: bestEver.params, bestFitness: bestEver.fitness, history, generations: this.config.generations };
    },
    
    randomParams() {
        const params = {};
        for (const [key, bounds] of Object.entries(this.paramBounds)) {
            const steps = Math.floor((bounds.max - bounds.min) / bounds.step);
            params[key] = bounds.min + Math.floor(Math.random() * (steps + 1)) * bounds.step;
        }
        return params;
    },
    
    evaluateFitness(params, candles, symbol, timeframe) {
        const trades = [];
        for (let i = 100; i < candles.length - 20; i += 8) { // Larger step for speed
            const slice = candles.slice(Math.max(0, i - 100), i);
            if (slice.length < 50) continue;
            
            try {
                const signal = quickSignalCheck(slice, symbol, timeframe);
                if (!signal || signal.score < params.minScore) continue;
                
                const future = candles.slice(i + 1, i + 21);
                if (future.length < 5) continue;
                
                const outcome = simulateTradeOutcome(signal, future);
                if (outcome) {
                    const netPnl = (outcome.pnl - 0.2) * (params.riskPerTrade || 1);
                    trades.push({ netPnl, won: outcome.won });
                }
            } catch (e) { /* skip */ }
        }
        
        if (trades.length < 5) return -100;
        const stats = BacktestStatistics.calculate(trades, 10000);
        const sharpe = parseFloat(stats.sharpeRatio) || 0;
        const pf = parseFloat(stats.profitFactor) || 0;
        const dd = parseFloat(stats.maxDrawdownPct) || 100;
        return sharpe * 10 + pf * 5 + Math.sqrt(trades.length) - dd * 0.3;
    },
    
    mutate(individual) {
        const keys = Object.keys(this.paramBounds);
        const key = keys[Math.floor(Math.random() * keys.length)];
        const bounds = this.paramBounds[key];
        const delta = (Math.random() < 0.5 ? -1 : 1) * bounds.step;
        individual.params[key] = Math.max(bounds.min, Math.min(bounds.max, individual.params[key] + delta));
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 7: AUTOPILOT SYSTEM - FIXED VERSION
// ═══════════════════════════════════════════════════════════════════════════════
const AutoPilot = {
    config: { 
        enabled: false, 
        symbols: UB_CONFIG.ALL_COINS.slice(0, 20), // Top 20 coins
        timeframes: ['60', '240'],
        lastFastRun: 0, 
        lastDeepRun: 0 
    },
    results: { fast: [], deep: [] },
    isRunning: false,
    
    start() { 
        this.config.enabled = true; 
        this.saveConfig(); 
        this.updateUI('🟢 ENABLED'); 
        toast('AutoPilot enabled', 'success');
    },
    
    stop() { 
        this.config.enabled = false; 
        this.saveConfig(); 
        this.updateUI('🔴 DISABLED'); 
        toast('AutoPilot disabled', '');
    },
    
    async runFast() {
        if (this.isRunning) { toast('Already running!', 'error'); return; }
        this.isRunning = true;
        
        console.log('🤖 AutoPilot FAST starting...');
        this.updateUI('🟡 FAST RUNNING...');
        
        const resultsDiv = document.getElementById('ubAPResults');
        if (resultsDiv) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:20px;">
                <div style="font-size:30px;animation:spin 1s linear infinite;">⚡</div>
                <div style="margin-top:10px;font-weight:700;">FAST SCAN RUNNING</div>
                <div id="apProgress" style="font-size:12px;color:var(--text3);margin-top:8px;">Initializing...</div>
                <div style="margin-top:10px;background:var(--bg4);border-radius:4px;height:6px;overflow:hidden;">
                    <div id="apProgressBar" style="width:0%;height:100%;background:var(--cyan);transition:width 0.3s;"></div>
                </div>
            </div>`;
        }
        
        const results = [];
        const coins = this.config.symbols;
        const tfs = this.config.timeframes;
        const totalScans = coins.length * tfs.length;
        let scanCount = 0;
        let errors = 0;
        let totalSkippedChop = 0;
        
        for (const symbol of coins) {
            for (const tf of tfs) {
                scanCount++;
                const pct = Math.round((scanCount / totalScans) * 100);
                
                const progEl = document.getElementById('apProgress');
                const barEl = document.getElementById('apProgressBar');
                if (progEl) progEl.textContent = `${symbol.replace('USDT','')} ${UB_CONFIG.TF_LABELS[tf] || tf} (${scanCount}/${totalScans})`;
                if (barEl) barEl.style.width = pct + '%';
                
                try {
                    const candles = await fetchKlines(symbol, tf, 500);
                    if (!candles || candles.length < 150) { errors++; continue; }
                    
                    const trades = [];
                    let skippedChop = 0;
                    
                    for (let i = 100; i < candles.length - 20; i += 5) {
                        const slice = candles.slice(Math.max(0, i - 100), i);
                        if (slice.length < 50) continue;
                        
                        // PARANOID: Skip choppy conditions
                        if (typeof isChoppy === 'function' && isChoppy(slice, 20)) {
                            skippedChop++;
                            continue;
                        }
                        
                        try {
                            const signal = quickSignalCheck(slice, symbol, tf);
                            if (!signal || signal.score < 60) continue;
                            
                            const future = candles.slice(i + 1, i + 21);
                            if (future.length < 5) continue;
                            
                            const outcome = simulateTradeOutcome(signal, future);
                            if (outcome) trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won, pnl: outcome.pnl, reason: outcome.reason });
                        } catch (e) { /* skip */ }
                    }
                    
                    totalSkippedChop += skippedChop;
                    
                    if (trades.length >= 3) {
                        const stats = BacktestStatistics.calculate(trades, 10000);
                        const streakAnalysis = typeof analyzeLosingStreaks === 'function' ? analyzeLosingStreaks(trades) : { maxStreak: 0, survives: true };
                        
                        results.push({ 
                            symbol, 
                            timeframe: tf, 
                            tfLabel: UB_CONFIG.TF_LABELS[tf] || tf,
                            trades: trades.length, 
                            winRate: stats.winRate, 
                            pnl: stats.totalPnl, 
                            sharpe: stats.sharpeRatio,
                            profitFactor: stats.profitFactor,
                            maxStreak: streakAnalysis.maxStreak,
                            survives: streakAnalysis.survives,
                            skippedChop
                        });
                    }
                } catch (e) { 
                    console.warn(`FAST error ${symbol} ${tf}:`, e); 
                    errors++; 
                }
                
                await new Promise(r => setTimeout(r, 30));
            }
        }
        
        this.results.fast = results;
        this.config.lastFastRun = Date.now();
        this.saveConfig();
        this.displayFastResults(results, errors);
        this.updateUI('🟢 ENABLED');
        this.isRunning = false;
        
        console.log('🤖 AutoPilot FAST complete:', results.length, 'results,', errors, 'errors, skipped chop:', totalSkippedChop);
        return results;
    },
    
    displayFastResults(results, errors = 0) {
        const resultsDiv = document.getElementById('ubAPResults');
        if (!resultsDiv) return;
        
        if (results.length === 0) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--amber);">
                <div style="font-size:40px;margin-bottom:10px;">⚠️</div>
                <div>No valid results found</div>
                <div style="font-size:11px;margin-top:5px;">${errors} pairs failed</div>
            </div>`;
            return;
        }
        
        results.sort((a, b) => parseFloat(b.pnl) - parseFloat(a.pnl));
        
        const avgWR = (results.reduce((s, r) => s + parseFloat(r.winRate), 0) / results.length).toFixed(1);
        const profitable = results.filter(r => parseFloat(r.pnl) > 0).length;
        const totalTrades = results.reduce((s, r) => s + r.trades, 0);
        const survivingPairs = results.filter(r => r.survives !== false).length;
        const totalSkipped = results.reduce((s, r) => s + (r.skippedChop || 0), 0);
        
        let rowsHTML = results.slice(0, 40).map(r => {
            const pnl = parseFloat(r.pnl);
            const wr = parseFloat(r.winRate);
            const pnlColor = pnl >= 0 ? 'var(--long)' : 'var(--short)';
            const wrColor = wr >= 55 ? 'var(--long)' : wr >= 45 ? 'var(--amber)' : 'var(--short)';
            const surviveIcon = r.survives !== false ? '✓' : '✗';
            const surviveColor = r.survives !== false ? 'var(--long)' : 'var(--short)';
            return `<div style="display:grid;grid-template-columns:1.2fr 0.5fr 0.4fr 0.6fr 0.7fr 0.5fr 0.3fr;padding:6px 8px;background:var(--bg4);border-radius:4px;margin-bottom:3px;font-size:10px;align-items:center;">
                <div style="font-weight:700;">${r.symbol.replace('USDT','')}</div>
                <div>${r.tfLabel}</div>
                <div>${r.trades}</div>
                <div style="color:${wrColor};font-weight:700;">${r.winRate}%</div>
                <div style="color:${pnlColor};font-weight:700;">${pnl >= 0 ? '+' : ''}${r.pnl}%</div>
                <div>${r.sharpe}</div>
                <div style="color:${surviveColor};font-weight:700;" title="Max losing streak: ${r.maxStreak || 0}">${surviveIcon}</div>
            </div>`;
        }).join('');
        
        resultsDiv.innerHTML = `<div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                <div style="font-size:14px;font-weight:700;">⚡ FAST SCAN RESULTS</div>
                <div style="background:linear-gradient(135deg,#ff6b35,#f7931a);color:#000;padding:3px 8px;border-radius:4px;font-size:9px;font-weight:700;">🛡️ PARANOID MODE</div>
            </div>
            <div style="font-size:9px;color:var(--text3);margin-bottom:10px;">Entry: Next Open +0.1% slip | TP/SL: Heuristic | Chop: Filtered (${totalSkipped} skipped)</div>
            <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:5px;margin-bottom:12px;">
                <div style="background:var(--bg3);padding:6px;border-radius:6px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">PAIRS</div>
                    <div style="font-size:14px;font-weight:700;">${results.length}</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:6px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">TRADES</div>
                    <div style="font-size:14px;font-weight:700;">${totalTrades}</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:6px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">AVG WIN%</div>
                    <div style="font-size:14px;font-weight:700;color:${parseFloat(avgWR) >= 50 ? 'var(--long)' : 'var(--short)'}">${avgWR}%</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:6px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">PROFIT</div>
                    <div style="font-size:14px;font-weight:700;color:var(--long)">${profitable}/${results.length}</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:6px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">SURVIVE</div>
                    <div style="font-size:14px;font-weight:700;color:${survivingPairs === results.length ? 'var(--long)' : 'var(--amber)'}">${survivingPairs}/${results.length}</div>
                </div>
            </div>
            <div style="display:grid;grid-template-columns:1.2fr 0.5fr 0.4fr 0.6fr 0.7fr 0.5fr 0.3fr;padding:6px 8px;background:var(--bg3);border-radius:4px;margin-bottom:4px;font-size:8px;font-weight:700;">
                <div>COIN</div><div>TF</div><div>#</div><div>WIN%</div><div>PNL</div><div>SHRP</div><div>💀</div>
            </div>
            <div style="max-height:280px;overflow-y:auto;">${rowsHTML}</div>
            ${results.length > 40 ? `<div style="text-align:center;font-size:10px;color:var(--text3);margin-top:8px;">Showing top 40 of ${results.length}</div>` : ''}
        </div>`;
    },
    
    async runDeep() {
        if (this.isRunning) { toast('Already running!', 'error'); return; }
        this.isRunning = true;
        
        console.log('🤖 AutoPilot DEEP starting...');
        this.updateUI('🟠 DEEP RUNNING...');
        
        const resultsDiv = document.getElementById('ubAPResults');
        if (resultsDiv) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:20px;">
                <div style="font-size:30px;animation:spin 1s linear infinite;">🔬</div>
                <div style="margin-top:10px;font-weight:700;">DEEP ANALYSIS RUNNING</div>
                <div id="apDeepProgress" style="font-size:12px;color:var(--text3);margin-top:8px;">Initializing...</div>
                <div style="font-size:10px;color:var(--amber);margin-top:5px;">Takes 2-5 minutes</div>
                <div style="margin-top:10px;background:var(--bg4);border-radius:4px;height:6px;overflow:hidden;">
                    <div id="apDeepBar" style="width:0%;height:100%;background:var(--purple);transition:width 0.3s;"></div>
                </div>
            </div>`;
        }
        
        const results = [];
        const coins = this.config.symbols.slice(0, 10);
        const tfs = ['15', '60', '240'];
        const totalScans = coins.length * tfs.length;
        let scanCount = 0;
        
        for (const symbol of coins) {
            for (const tf of tfs) {
                scanCount++;
                const pct = Math.round((scanCount / totalScans) * 100);
                
                const progEl = document.getElementById('apDeepProgress');
                const barEl = document.getElementById('apDeepBar');
                if (progEl) progEl.textContent = `${symbol.replace('USDT','')} ${UB_CONFIG.TF_LABELS[tf] || tf} (${scanCount}/${totalScans})`;
                if (barEl) barEl.style.width = pct + '%';
                
                try {
                    const candles = await fetchKlines(symbol, tf, 1000);
                    if (!candles || candles.length < 300) continue;
                    
                    const trades = [];
                    let skippedChop = 0;
                    
                    for (let i = 100; i < candles.length - 20; i += 3) {
                        const slice = candles.slice(Math.max(0, i - 100), i);
                        if (slice.length < 50) continue;
                        
                        // PARANOID: Skip choppy conditions
                        if (typeof isChoppy === 'function' && isChoppy(slice, 20)) {
                            skippedChop++;
                            continue;
                        }
                        
                        try {
                            const signal = quickSignalCheck(slice, symbol, tf);
                            if (!signal || signal.score < 60) continue;
                            
                            const future = candles.slice(i + 1, i + 21);
                            if (future.length < 5) continue;
                            
                            const outcome = simulateTradeOutcome(signal, future);
                            if (outcome) trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won, pnl: outcome.pnl, reason: outcome.reason });
                        } catch (e) { /* skip */ }
                    }
                    
                    if (trades.length >= 10) {
                        const stats = BacktestStatistics.calculate(trades, 10000);
                        const mc = MonteCarloSimulator.run(trades, 500);
                        const streakAnalysis = typeof analyzeLosingStreaks === 'function' ? analyzeLosingStreaks(trades) : { maxStreak: 0, survives: true };
                        
                        results.push({
                            symbol,
                            timeframe: tf,
                            tfLabel: UB_CONFIG.TF_LABELS[tf] || tf,
                            trades: trades.length,
                            winRate: stats.winRate,
                            pnl: stats.totalPnl,
                            sharpe: stats.sharpeRatio,
                            profitFactor: stats.profitFactor,
                            maxDD: stats.maxDrawdownPct,
                            profitProb: mc.profitProbability || '0',
                            maxStreak: streakAnalysis.maxStreak,
                            survives: streakAnalysis.survives,
                            skippedChop,
                            rating: parseFloat(stats.sharpeRatio) >= 1 && parseFloat(mc.profitProbability || 0) >= 70 && streakAnalysis.survives ? 'A' :
                                    parseFloat(stats.sharpeRatio) >= 0.5 && parseFloat(mc.profitProbability || 0) >= 55 ? 'B' : 'C'
                        });
                    }
                } catch (e) {
                    console.warn(`DEEP error ${symbol} ${tf}:`, e);
                }
                
                await new Promise(r => setTimeout(r, 50));
            }
        }
        
        this.results.deep = results;
        this.config.lastDeepRun = Date.now();
        this.saveConfig();
        this.displayDeepResults(results);
        this.updateUI('🟢 ENABLED');
        this.isRunning = false;
        
        console.log('🤖 AutoPilot DEEP complete:', results.length, 'results');
        return results;
    },
    
    displayDeepResults(results) {
        const resultsDiv = document.getElementById('ubAPResults');
        if (!resultsDiv) return;
        
        if (results.length === 0) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--amber);"><div style="font-size:40px;margin-bottom:10px;">⚠️</div><div>No valid results</div></div>`;
            return;
        }
        
        results.sort((a, b) => {
            if (a.rating !== b.rating) return a.rating.localeCompare(b.rating);
            return parseFloat(b.profitProb) - parseFloat(a.profitProb);
        });
        
        const aRated = results.filter(r => r.rating === 'A').length;
        const bRated = results.filter(r => r.rating === 'B').length;
        
        let rowsHTML = results.map(r => {
            const pnl = parseFloat(r.pnl);
            const wr = parseFloat(r.winRate);
            const pp = parseFloat(r.profitProb);
            const ratingColor = r.rating === 'A' ? 'var(--long)' : r.rating === 'B' ? 'var(--amber)' : 'var(--text3)';
            return `<div style="display:grid;grid-template-columns:1fr 0.5fr 0.4fr 0.6fr 0.7fr 0.6fr 0.5fr;padding:6px 8px;background:var(--bg4);border-radius:4px;margin-bottom:3px;font-size:10px;align-items:center;border-left:3px solid ${ratingColor};">
                <div style="font-weight:700;">${r.symbol.replace('USDT','')}</div>
                <div>${r.tfLabel}</div>
                <div>${r.trades}</div>
                <div style="color:${wr >= 55 ? 'var(--long)' : wr >= 45 ? 'var(--amber)' : 'var(--short)'}">${r.winRate}%</div>
                <div style="color:${pnl >= 0 ? 'var(--long)' : 'var(--short)'}">${pnl >= 0 ? '+' : ''}${r.pnl}%</div>
                <div style="color:${pp >= 70 ? 'var(--long)' : pp >= 55 ? 'var(--amber)' : 'var(--short)'}">${r.profitProb}%</div>
                <div style="font-weight:700;color:${ratingColor};">${r.rating}</div>
            </div>`;
        }).join('');
        
        resultsDiv.innerHTML = `<div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                <div style="font-size:14px;font-weight:700;">🔬 DEEP ANALYSIS RESULTS</div>
                <div style="font-size:9px;color:var(--text3);">${new Date().toLocaleTimeString()}</div>
            </div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-bottom:12px;">
                <div style="background:var(--long-dim);padding:10px;border-radius:6px;text-align:center;border:1px solid var(--long);">
                    <div style="font-size:9px;color:var(--text3);">A RATED</div>
                    <div style="font-size:20px;font-weight:700;color:var(--long);">${aRated}</div>
                </div>
                <div style="background:var(--amber-dim);padding:10px;border-radius:6px;text-align:center;border:1px solid var(--amber);">
                    <div style="font-size:9px;color:var(--text3);">B RATED</div>
                    <div style="font-size:20px;font-weight:700;color:var(--amber);">${bRated}</div>
                </div>
                <div style="background:var(--bg3);padding:10px;border-radius:6px;text-align:center;">
                    <div style="font-size:9px;color:var(--text3);">TOTAL</div>
                    <div style="font-size:20px;font-weight:700;">${results.length}</div>
                </div>
            </div>
            <div style="display:grid;grid-template-columns:1fr 0.5fr 0.4fr 0.6fr 0.7fr 0.6fr 0.5fr;padding:6px 8px;background:var(--bg3);border-radius:4px;margin-bottom:4px;font-size:9px;font-weight:700;">
                <div>COIN</div><div>TF</div><div>#</div><div>WIN%</div><div>PNL</div><div>MC%</div><div>RATE</div>
            </div>
            <div style="max-height:280px;overflow-y:auto;">${rowsHTML}</div>
            <div style="margin-top:10px;padding:8px;background:var(--bg3);border-radius:4px;font-size:10px;">
                <div style="font-weight:700;margin-bottom:4px;">📊 Rating:</div>
                <div><span style="color:var(--long);font-weight:700;">A</span> = Sharpe ≥1 & MC ≥70%</div>
                <div><span style="color:var(--amber);font-weight:700;">B</span> = Sharpe ≥0.5 & MC ≥55%</div>
            </div>
        </div>`;
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ULTRA MODE - 150 COINS × 5 TIMEFRAMES = 750 SCANS
    // ═══════════════════════════════════════════════════════════════════════════
    async runUltra() {
        if (this.isRunning) { toast('Already running!', 'error'); return; }
        this.isRunning = true;
        
        const settings = UB_CONFIG.settings;
        const coins = UB_CONFIG.ALL_COINS.slice(0, settings.ultraCoins);
        const tfs = settings.ultraTFs;
        const totalScans = coins.length * tfs.length;
        
        console.log(`🚀 AutoPilot ULTRA starting - ${coins.length} coins × ${tfs.length} TFs = ${totalScans} scans...`);
        this.updateUI('🔴 ULTRA RUNNING...');
        
        const resultsDiv = document.getElementById('ubAPResults');
        if (resultsDiv) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:20px;">
                <div style="font-size:40px;animation:spin 1s linear infinite;">🚀</div>
                <div style="margin-top:10px;font-weight:700;color:#f7931a;">ULTRA SCAN RUNNING</div>
                <div style="font-size:11px;color:var(--text3);margin-top:5px;">${coins.length} coins × ${tfs.length} TFs = ${totalScans} scans</div>
                <div id="apUltraProgress" style="font-size:12px;color:var(--cyan);margin-top:10px;">Initializing...</div>
                <div style="margin-top:10px;background:var(--bg4);border-radius:4px;height:8px;overflow:hidden;">
                    <div id="apUltraBar" style="width:0%;height:100%;background:linear-gradient(90deg,var(--cyan),#f7931a,var(--short));transition:width 0.3s;"></div>
                </div>
                <div id="apUltraStats" style="margin-top:8px;font-size:10px;color:var(--text3);"></div>
                <div style="font-size:10px;color:var(--amber);margin-top:10px;">⏱️ Estimated: ${Math.ceil(totalScans * 0.12)} - ${Math.ceil(totalScans * 0.18)} minutes</div>
            </div>`;
        }
        
        const results = [];
        let scanCount = 0;
        let errors = 0;
        let totalSkippedChop = 0;
        let totalTrades = 0;
        const startTime = Date.now();
        
        for (const symbol of coins) {
            for (const tf of tfs) {
                scanCount++;
                const pct = Math.round((scanCount / totalScans) * 100);
                const elapsed = ((Date.now() - startTime) / 1000 / 60).toFixed(1);
                const eta = scanCount > 10 ? (((Date.now() - startTime) / scanCount) * (totalScans - scanCount) / 1000 / 60).toFixed(1) : '...';
                
                const progEl = document.getElementById('apUltraProgress');
                const barEl = document.getElementById('apUltraBar');
                const statsEl = document.getElementById('apUltraStats');
                if (progEl) progEl.textContent = `${symbol.replace('USDT','')} ${UB_CONFIG.TF_LABELS[tf]} (${scanCount}/${totalScans}) - ${pct}%`;
                if (barEl) barEl.style.width = pct + '%';
                if (statsEl) statsEl.textContent = `✓ ${results.length} valid | 📊 ${totalTrades} trades | ❌ ${errors} errors | ⏱️ ${elapsed}m / ETA ${eta}m`;
                
                try {
                    const candles = await fetchKlines(symbol, tf, 500);
                    if (!candles || candles.length < 150) { errors++; continue; }
                    
                    const trades = [];
                    let skippedChop = 0;
                    
                    for (let i = 100; i < candles.length - 20; i += 5) {
                        const slice = candles.slice(Math.max(0, i - 100), i);
                        if (slice.length < 50) continue;
                        
                        // Chop filter if enabled
                        if (settings.chopFilter && typeof isChoppy === 'function' && isChoppy(slice, 20)) {
                            skippedChop++;
                            continue;
                        }
                        
                        try {
                            const signal = quickSignalCheck(slice, symbol, tf);
                            if (!signal || signal.score < settings.minScore) continue;
                            
                            const future = candles.slice(i + 1, i + 21);
                            if (future.length < 5) continue;
                            
                            const outcome = simulateTradeOutcome(signal, future);
                            if (outcome) trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won });
                        } catch (e) { /* skip */ }
                    }
                    
                    totalSkippedChop += skippedChop;
                    totalTrades += trades.length;
                    
                    if (trades.length >= settings.minTrades) {
                        const stats = BacktestStatistics.calculate(trades, 10000);
                        const streakAnalysis = typeof analyzeLosingStreaks === 'function' ? analyzeLosingStreaks(trades) : { maxStreak: 0, survives: true };
                        
                        results.push({ 
                            symbol, 
                            timeframe: tf, 
                            tfLabel: UB_CONFIG.TF_LABELS[tf],
                            trades: trades.length, 
                            winRate: stats.winRate, 
                            pnl: stats.totalPnl, 
                            sharpe: stats.sharpeRatio,
                            profitFactor: stats.profitFactor,
                            maxDD: stats.maxDrawdownPct,
                            maxStreak: streakAnalysis.maxStreak,
                            survives: streakAnalysis.survives
                        });
                    }
                } catch (e) { 
                    errors++; 
                }
                
                await new Promise(r => setTimeout(r, 15)); // Fast for ULTRA
            }
        }
        
        const totalTime = ((Date.now() - startTime) / 1000 / 60).toFixed(1);
        this.results.ultra = results;
        this.saveConfig();
        this.displayUltraResults(results, errors, totalSkippedChop, totalTrades, totalTime);
        this.updateUI('🟢 ENABLED');
        this.isRunning = false;
        
        console.log(`🚀 AutoPilot ULTRA complete: ${results.length} results from ${totalScans} scans in ${totalTime} minutes`);
        return results;
    },
    
    displayUltraResults(results, errors = 0, skippedChop = 0, totalTrades = 0, totalTime = '0') {
        const resultsDiv = document.getElementById('ubAPResults');
        if (!resultsDiv) return;
        
        if (results.length === 0) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--amber);"><div style="font-size:40px;margin-bottom:10px;">⚠️</div><div>No valid results</div><div style="font-size:11px;margin-top:5px;">${errors} errors</div></div>`;
            return;
        }
        
        // Sort by Sharpe (best risk-adjusted return)
        results.sort((a, b) => parseFloat(b.sharpe) - parseFloat(a.sharpe));
        
        const avgWR = (results.reduce((s, r) => s + parseFloat(r.winRate), 0) / results.length).toFixed(1);
        const profitable = results.filter(r => parseFloat(r.pnl) > 0).length;
        const survivingPairs = results.filter(r => r.survives !== false).length;
        const aGrade = results.filter(r => parseFloat(r.sharpe) >= 1 && parseFloat(r.winRate) >= 55 && r.survives).length;
        const bGrade = results.filter(r => parseFloat(r.sharpe) >= 0.5 && parseFloat(r.sharpe) < 1 && parseFloat(r.winRate) >= 50).length;
        
        // Top 60 results
        let rowsHTML = results.slice(0, 60).map((r, idx) => {
            const pnl = parseFloat(r.pnl);
            const wr = parseFloat(r.winRate);
            const shrp = parseFloat(r.sharpe);
            const isTop = idx < 10;
            const bgColor = isTop ? 'var(--long-dim)' : 'var(--bg4)';
            return `<div style="display:grid;grid-template-columns:0.3fr 1fr 0.5fr 0.4fr 0.6fr 0.6fr 0.5fr;padding:5px 8px;background:${bgColor};border-radius:4px;margin-bottom:2px;font-size:9px;align-items:center;">
                <div style="color:${isTop ? 'var(--gold)' : 'var(--text3)'};font-weight:700;">#${idx+1}</div>
                <div style="font-weight:700;">${r.symbol.replace('USDT','')}</div>
                <div>${r.tfLabel}</div>
                <div>${r.trades}</div>
                <div style="color:${wr >= 55 ? 'var(--long)' : wr >= 45 ? 'var(--amber)' : 'var(--short)'};">${r.winRate}%</div>
                <div style="color:${pnl >= 0 ? 'var(--long)' : 'var(--short)'};">${pnl >= 0 ? '+' : ''}${r.pnl}%</div>
                <div style="color:${shrp >= 1 ? 'var(--long)' : shrp >= 0.5 ? 'var(--amber)' : 'var(--short)'};">${r.sharpe}</div>
            </div>`;
        }).join('');
        
        resultsDiv.innerHTML = `<div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                <div style="font-size:14px;font-weight:700;color:#f7931a;">🚀 ULTRA SCAN COMPLETE</div>
                <div style="background:linear-gradient(135deg,#ff6b35,#f7931a);color:#000;padding:3px 8px;border-radius:4px;font-size:9px;font-weight:700;">🛡️ PARANOID</div>
            </div>
            <div style="font-size:9px;color:var(--text3);margin-bottom:10px;">⏱️ ${totalTime} min | ${skippedChop} chop filtered | ${errors} errors</div>
            
            <div style="display:grid;grid-template-columns:repeat(6,1fr);gap:4px;margin-bottom:10px;">
                <div style="background:var(--bg3);padding:6px;border-radius:4px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">SCANNED</div>
                    <div style="font-size:12px;font-weight:700;">${results.length}</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:4px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">TRADES</div>
                    <div style="font-size:12px;font-weight:700;">${totalTrades}</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:4px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">AVG WIN</div>
                    <div style="font-size:12px;font-weight:700;color:${parseFloat(avgWR) >= 50 ? 'var(--long)' : 'var(--short)'}">${avgWR}%</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:4px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">PROFIT</div>
                    <div style="font-size:12px;font-weight:700;color:var(--long)">${profitable}</div>
                </div>
                <div style="background:var(--long-dim);padding:6px;border-radius:4px;text-align:center;border:1px solid var(--long);">
                    <div style="font-size:7px;color:var(--text3);">A GRADE</div>
                    <div style="font-size:12px;font-weight:700;color:var(--long);">${aGrade}</div>
                </div>
                <div style="background:var(--amber-dim);padding:6px;border-radius:4px;text-align:center;border:1px solid var(--amber);">
                    <div style="font-size:7px;color:var(--text3);">B GRADE</div>
                    <div style="font-size:12px;font-weight:700;color:var(--amber);">${bGrade}</div>
                </div>
            </div>
            
            <div style="display:grid;grid-template-columns:0.3fr 1fr 0.5fr 0.4fr 0.6fr 0.6fr 0.5fr;padding:5px 8px;background:var(--bg3);border-radius:4px;margin-bottom:4px;font-size:8px;font-weight:700;">
                <div>#</div><div>COIN</div><div>TF</div><div>TR</div><div>WIN%</div><div>PNL</div><div>SHRP</div>
            </div>
            <div style="max-height:350px;overflow-y:auto;">${rowsHTML}</div>
            ${results.length > 60 ? `<div style="text-align:center;font-size:9px;color:var(--text3);margin-top:6px;">Showing top 60 of ${results.length} | Sorted by Sharpe</div>` : ''}
            
            <div style="margin-top:10px;padding:8px;background:var(--bg3);border-radius:4px;font-size:9px;">
                <div style="font-weight:700;margin-bottom:4px;">📊 Grading:</div>
                <div><span style="color:var(--long);font-weight:700;">A</span> = Sharpe ≥1 & Win% ≥55% & Survives streak</div>
                <div><span style="color:var(--amber);font-weight:700;">B</span> = Sharpe ≥0.5 & Win% ≥50%</div>
            </div>
        </div>`;
    },
    
    saveConfig() { try { localStorage.setItem('autoPilotConfig', JSON.stringify(this.config)); localStorage.setItem('autoPilotResults', JSON.stringify(this.results)); } catch (e) {} },
    loadConfig() { 
        try { 
            const cfg = localStorage.getItem('autoPilotConfig'); 
            const res = localStorage.getItem('autoPilotResults'); 
            if (cfg) this.config = { ...this.config, ...JSON.parse(cfg) }; 
            if (res) this.results = { ...this.results, ...JSON.parse(res) };
            // Show most recent results
            if (this.results.ultra?.length > 0) setTimeout(() => this.displayUltraResults(this.results.ultra), 500);
            else if (this.results.fast?.length > 0) setTimeout(() => this.displayFastResults(this.results.fast), 500);
            else if (this.results.deep?.length > 0) setTimeout(() => this.displayDeepResults(this.results.deep), 500);
        } catch (e) {} 
    },
    updateUI(status) { const el = document.getElementById('autopilotStatusText'); if (el) el.textContent = status; }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 8: ULTIMATE BACKTEST UI
// ═══════════════════════════════════════════════════════════════════════════════
let lastBacktestTrades = [];

function createUltimateBacktestUI() {
    const existingPanel = document.getElementById('ultimateBacktestPanel');
    if (existingPanel) return;
    
    const panelHTML = `
    <div id="ultimateBacktestPanel" class="ultimate-bt-panel" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.95);z-index:9999;overflow-y:auto;padding:10px;">
        <div style="max-width:800px;margin:0 auto;">
            <div style="display:flex;justify-content:space-between;align-items:center;padding:15px;background:var(--bg2);border-radius:8px;margin-bottom:10px;">
                <div style="display:flex;align-items:center;gap:10px;">
                    <span style="font-size:24px;">🚀</span>
                    <div><div style="font-size:16px;font-weight:700;color:var(--gold);">BS SCANNER V11</div><div style="font-size:11px;color:var(--text3);">ULTIMATE BACKTEST ENGINE</div></div>
                </div>
                <button onclick="hideUltimateBacktest()" style="background:var(--short);color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-weight:700;">✕ CLOSE</button>
            </div>
            
            <div style="display:flex;gap:5px;margin-bottom:10px;flex-wrap:wrap;">
                <button onclick="switchUBTab('backtest')" id="ubTabBacktest" class="ub-tab" style="flex:1;padding:10px;background:var(--cyan);color:#000;border:none;border-radius:6px;font-weight:700;cursor:pointer;min-width:80px;">📊 BACKTEST</button>
                <button onclick="switchUBTab('optimizer')" id="ubTabOptimizer" class="ub-tab" style="flex:1;padding:10px;background:var(--bg3);color:var(--text);border:1px solid var(--border);border-radius:6px;font-weight:700;cursor:pointer;min-width:80px;">🧬 OPTIMIZE</button>
                <button onclick="switchUBTab('montecarlo')" id="ubTabMC" class="ub-tab" style="flex:1;padding:10px;background:var(--bg3);color:var(--text);border:1px solid var(--border);border-radius:6px;font-weight:700;cursor:pointer;min-width:80px;">🎲 MONTE CARLO</button>
                <button onclick="switchUBTab('autopilot')" id="ubTabAP" class="ub-tab" style="flex:1;padding:10px;background:var(--bg3);color:var(--text);border:1px solid var(--border);border-radius:6px;font-weight:700;cursor:pointer;min-width:80px;">🤖 AUTOPILOT</button>
            </div>
            
            <div id="ubContentBacktest" class="ub-content">
                <div style="background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px;">
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">SYMBOL</label>
                            <select id="ubSymbol" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                                <option value="BTCUSDT">BTC</option><option value="ETHUSDT">ETH</option><option value="SOLUSDT">SOL</option><option value="BNBUSDT">BNB</option><option value="XRPUSDT">XRP</option><option value="DOGEUSDT">DOGE</option><option value="ADAUSDT">ADA</option><option value="AVAXUSDT">AVAX</option><option value="DOTUSDT">DOT</option><option value="LINKUSDT">LINK</option>
                            </select></div>
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">TIMEFRAME</label>
                            <select id="ubTimeframe" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                                <option value="15">15m</option><option value="30">30m</option><option value="60" selected>1H</option><option value="240">4H</option><option value="D">1D</option>
                            </select></div>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px;">
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">MIN SCORE</label>
                            <select id="ubMinScore" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                                <option value="50">50+ (All Valid)</option><option value="60" selected>60+ (Strong)</option><option value="70">70+ (Perfect)</option><option value="80">80+ (Cream)</option>
                            </select></div>
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">CAPITAL ($)</label>
                            <input type="number" id="ubCapital" value="10000" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;"></div>
                    </div>
                    <div style="display:flex;gap:10px;">
                        <button onclick="runUltimateBacktest()" id="ubRunBtn" style="flex:1;padding:12px;background:linear-gradient(135deg,var(--cyan),var(--blue));color:#fff;border:none;border-radius:6px;font-weight:700;cursor:pointer;font-size:14px;">▶ RUN BACKTEST</button>
                        <button onclick="runFullValidation()" id="ubValidateBtn" style="flex:1;padding:12px;background:linear-gradient(135deg,var(--purple),var(--amber));color:#fff;border:none;border-radius:6px;font-weight:700;cursor:pointer;font-size:14px;">🔬 FULL VALIDATION</button>
                    </div>
                </div>
                <div id="ubBacktestResults" style="background:var(--bg2);border-radius:8px;padding:15px;">
                    <div style="text-align:center;color:var(--text3);padding:40px;"><div style="font-size:40px;margin-bottom:10px;">📊</div><div>Select parameters and click RUN BACKTEST</div></div>
                </div>
            </div>
            
            <div id="ubContentOptimizer" class="ub-content" style="display:none;">
                <div style="background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="margin-bottom:10px;"><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">OPTIMIZATION MODE</label>
                        <select id="ubOptMode" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                            <option value="genetic">🧬 Genetic Algorithm (Recommended)</option><option value="grid">📊 Grid Search (Exhaustive)</option>
                        </select></div>
                    <button onclick="runOptimization()" id="ubOptBtn" style="width:100%;padding:12px;background:linear-gradient(135deg,var(--long),var(--cyan));color:#fff;border:none;border-radius:6px;font-weight:700;cursor:pointer;font-size:14px;">🧬 START OPTIMIZATION</button>
                </div>
                <div id="ubOptResults" style="background:var(--bg2);border-radius:8px;padding:15px;"><div style="text-align:center;color:var(--text3);padding:40px;"><div style="font-size:40px;margin-bottom:10px;">🧬</div><div>Genetic Algorithm will find optimal parameters</div></div></div>
            </div>
            
            <div id="ubContentMC" class="ub-content" style="display:none;">
                <div style="background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="margin-bottom:10px;"><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">SIMULATIONS</label>
                        <select id="ubMCSimulations" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                            <option value="500">500 (Fast)</option><option value="1000" selected>1,000 (Standard)</option><option value="5000">5,000 (Thorough)</option>
                        </select></div>
                    <button onclick="runMonteCarlo()" id="ubMCBtn" style="width:100%;padding:12px;background:linear-gradient(135deg,var(--amber),var(--short));color:#fff;border:none;border-radius:6px;font-weight:700;cursor:pointer;font-size:14px;">🎲 RUN MONTE CARLO</button>
                </div>
                <div id="ubMCResults" style="background:var(--bg2);border-radius:8px;padding:15px;"><div style="text-align:center;color:var(--text3);padding:40px;"><div style="font-size:40px;margin-bottom:10px;">🎲</div><div>Run backtest first, then Monte Carlo</div></div></div>
            </div>
            
            <div id="ubContentAP" class="ub-content" style="display:none;">
                <div style="background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
                        <div><div style="font-size:14px;font-weight:700;">🤖 AutoPilot Status</div><div id="autopilotStatusText" style="font-size:12px;color:var(--text3);">🔴 DISABLED</div></div>
                        <div style="display:flex;gap:8px;">
                            <button onclick="AutoPilot.start()" style="padding:8px 16px;background:var(--long);color:#fff;border:none;border-radius:4px;font-weight:700;cursor:pointer;">ENABLE</button>
                            <button onclick="AutoPilot.stop()" style="padding:8px 16px;background:var(--short);color:#fff;border:none;border-radius:4px;font-weight:700;cursor:pointer;">DISABLE</button>
                        </div>
                    </div>
                    
                    <!-- SCAN BUTTONS -->
                    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;margin-bottom:15px;">
                        <button onclick="AutoPilot.runFast()" style="padding:12px;background:var(--cyan-dim);border:1px solid var(--cyan);color:var(--cyan);border-radius:6px;font-weight:700;cursor:pointer;">
                            <div style="font-size:16px;">⚡</div>
                            <div style="font-size:11px;">FAST</div>
                            <div style="font-size:9px;opacity:0.7;">20 coins × 2 TF</div>
                        </button>
                        <button onclick="AutoPilot.runDeep()" style="padding:12px;background:var(--purple-dim);border:1px solid var(--purple);color:var(--purple);border-radius:6px;font-weight:700;cursor:pointer;">
                            <div style="font-size:16px;">🔬</div>
                            <div style="font-size:11px;">DEEP</div>
                            <div style="font-size:9px;opacity:0.7;">10 coins × 3 TF</div>
                        </button>
                        <button onclick="AutoPilot.runUltra()" style="padding:12px;background:linear-gradient(135deg,rgba(255,107,53,0.2),rgba(247,147,26,0.2));border:1px solid #f7931a;color:#f7931a;border-radius:6px;font-weight:700;cursor:pointer;">
                            <div style="font-size:16px;">🚀</div>
                            <div style="font-size:11px;">ULTRA</div>
                            <div style="font-size:9px;opacity:0.7;">150 coins × 5 TF</div>
                        </button>
                    </div>
                    
                    <!-- SETTINGS PANEL -->
                    <details style="background:var(--bg3);border-radius:6px;padding:10px;margin-bottom:10px;">
                        <summary style="cursor:pointer;font-weight:700;font-size:12px;color:var(--text);">⚙️ SCAN SETTINGS</summary>
                        <div style="margin-top:12px;display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                            <div>
                                <label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">ULTRA Coins</label>
                                <select id="ubSettingsUltraCoins" onchange="UB_CONFIG.settings.ultraCoins=parseInt(this.value)" style="width:100%;padding:6px;background:var(--bg4);color:var(--text);border:1px solid var(--border);border-radius:4px;">
                                    <option value="50">50 coins</option>
                                    <option value="100">100 coins</option>
                                    <option value="150" selected>150 coins</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">Min Score</label>
                                <select id="ubSettingsMinScore" onchange="UB_CONFIG.settings.minScore=parseInt(this.value)" style="width:100%;padding:6px;background:var(--bg4);color:var(--text);border:1px solid var(--border);border-radius:4px;">
                                    <option value="50">50+</option>
                                    <option value="60" selected>60+</option>
                                    <option value="70">70+</option>
                                    <option value="80">80+</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">Timeframes</label>
                                <select id="ubSettingsTFs" onchange="updateTFSettings(this.value)" style="width:100%;padding:6px;background:var(--bg4);color:var(--text);border:1px solid var(--border);border-radius:4px;">
                                    <option value="5m-4h" selected>5m → 4H (5 TFs)</option>
                                    <option value="15m-4h">15m → 4H (4 TFs)</option>
                                    <option value="1h-4h">1H → 4H (2 TFs)</option>
                                    <option value="all">All TFs (6 TFs)</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">Slippage %</label>
                                <select id="ubSettingsSlippage" onchange="UB_CONFIG.settings.slippagePct=parseFloat(this.value)" style="width:100%;padding:6px;background:var(--bg4);color:var(--text);border:1px solid var(--border);border-radius:4px;">
                                    <option value="0.05">0.05%</option>
                                    <option value="0.1" selected>0.1%</option>
                                    <option value="0.15">0.15%</option>
                                    <option value="0.2">0.2%</option>
                                </select>
                            </div>
                            <div style="grid-column:span 2;display:flex;gap:15px;margin-top:5px;">
                                <label style="font-size:11px;display:flex;align-items:center;gap:5px;cursor:pointer;">
                                    <input type="checkbox" id="ubSettingsChop" checked onchange="UB_CONFIG.settings.chopFilter=this.checked" style="width:16px;height:16px;">
                                    <span>Chop Filter</span>
                                </label>
                                <label style="font-size:11px;display:flex;align-items:center;gap:5px;cursor:pointer;">
                                    <input type="checkbox" id="ubSettingsParanoid" checked onchange="UB_CONFIG.settings.paranoidMode=this.checked" style="width:16px;height:16px;">
                                    <span>Paranoid Mode</span>
                                </label>
                            </div>
                        </div>
                    </details>
                    
                    <!-- SCAN INFO -->
                    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:10px;">
                        <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;">
                            <div style="color:var(--cyan);font-weight:700;">FAST</div>
                            <div style="color:var(--text3);">~2 min</div>
                        </div>
                        <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;">
                            <div style="color:var(--purple);font-weight:700;">DEEP</div>
                            <div style="color:var(--text3);">~5 min</div>
                        </div>
                        <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;">
                            <div style="color:#f7931a;font-weight:700;">ULTRA</div>
                            <div style="color:var(--text3);">~15-25 min</div>
                        </div>
                    </div>
                </div>
                <div id="ubAPResults" style="background:var(--bg2);border-radius:8px;padding:15px;"><div style="text-align:center;color:var(--text3);padding:40px;"><div style="font-size:40px;margin-bottom:10px;">🤖</div><div>Select FAST, DEEP, or ULTRA scan</div><div style="font-size:11px;margin-top:5px;color:var(--amber);">🛡️ Paranoid Mode: Real slippage + Chop filter</div></div></div>
            </div>
        </div>
    </div>`;
    
    document.body.insertAdjacentHTML('beforeend', panelHTML);
}

function updateTFSettings(value) {
    switch(value) {
        case '5m-4h': UB_CONFIG.settings.ultraTFs = ['5', '15', '30', '60', '240']; break;
        case '15m-4h': UB_CONFIG.settings.ultraTFs = ['15', '30', '60', '240']; break;
        case '1h-4h': UB_CONFIG.settings.ultraTFs = ['60', '240']; break;
        case 'all': UB_CONFIG.settings.ultraTFs = ['5', '15', '30', '60', '240', 'D']; break;
    }
}

function switchUBTab(tab) {
    const tabs = { backtest: 'Backtest', optimizer: 'Optimizer', montecarlo: 'MC', autopilot: 'AP' };
    for (const [t, id] of Object.entries(tabs)) {
        const tabEl = document.getElementById(`ubTab${id}`);
        const contentEl = document.getElementById(`ubContent${id}`);
        if (t === tab) { tabEl.style.background = 'var(--cyan)'; tabEl.style.color = '#000'; tabEl.style.border = 'none'; contentEl.style.display = 'block'; }
        else { tabEl.style.background = 'var(--bg3)'; tabEl.style.color = 'var(--text)'; tabEl.style.border = '1px solid var(--border)'; contentEl.style.display = 'none'; }
    }
}

function showUltimateBacktest() { createUltimateBacktestUI(); document.getElementById('ultimateBacktestPanel').style.display = 'block'; AutoPilot.loadConfig(); }
function hideUltimateBacktest() { document.getElementById('ultimateBacktestPanel').style.display = 'none'; }

async function runUltimateBacktest() {
    const btn = document.getElementById('ubRunBtn');
    const resultsDiv = document.getElementById('ubBacktestResults');
    const symbol = document.getElementById('ubSymbol').value;
    const timeframe = document.getElementById('ubTimeframe').value;
    const minScore = parseInt(document.getElementById('ubMinScore').value);
    const capital = parseFloat(document.getElementById('ubCapital').value) || 10000;
    
    btn.disabled = true; btn.textContent = '⏳ RUNNING...';
    resultsDiv.innerHTML = '<div style="text-align:center;padding:40px;"><div style="font-size:40px;animation:spin 1s linear infinite;">⏳</div><div style="margin-top:10px;">Fetching historical data...</div><div id="ubProgress" style="font-size:11px;color:var(--text3);margin-top:5px;">0%</div></div>';
    
    try {
        const candles = await fetchKlines(symbol, timeframe, 1500);
        if (!candles || candles.length < 200) throw new Error('Insufficient data: ' + (candles?.length || 0) + ' candles');
        
        document.getElementById('ubProgress').textContent = 'Analyzing signals...';
        const trades = [];
        const totalSteps = candles.length - 120;
        
        for (let i = 100; i < candles.length - 20; i += 2) {
            if (i % 50 === 0) { document.getElementById('ubProgress').textContent = `${Math.round((i - 100) / totalSteps * 100)}%`; await new Promise(r => setTimeout(r, 1)); }
            
            const slice = candles.slice(i - 100, i);
            const signal = quickSignalCheck(slice, symbol, timeframe);
            if (!signal || signal.score < minScore) continue;
            
            const future = candles.slice(i + 1, i + 21);
            if (future.length < 5) continue;
            
            const outcome = simulateTradeOutcome(signal, future);
            const riskAmount = capital * 0.01;
            const netPnl = (outcome.pnl / 100) * riskAmount - (riskAmount * 0.002);
            
            trades.push({ symbol, timeframe, direction: signal.direction, grade: signal.grade, score: signal.score, entry: signal.entry, sl: signal.sl, tp: signal.tp1 || signal.tp, entryTime: candles[i].time || candles[i].timestamp, outcome: outcome.won ? 'WIN' : 'LOSS', pnl: outcome.pnl, netPnl, rr: outcome.rr, exitReason: outcome.exitReason });
        }
        
        lastBacktestTrades = trades;
        const stats = BacktestStatistics.calculate(trades, capital);
        displayUltimateResults(symbol, timeframe, candles.length, trades, stats, capital);
    } catch (error) {
        resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--short);"><div style="font-size:40px;margin-bottom:10px;">❌</div><div>Backtest failed: ${error.message}</div></div>`;
    }
    
    btn.disabled = false; btn.textContent = '▶ RUN BACKTEST';
}

function displayUltimateResults(symbol, timeframe, candleCount, trades, stats, capital) {
    const resultsDiv = document.getElementById('ubBacktestResults');
    const winRate = parseFloat(stats.winRate) || 0;
    const pnlPct = parseFloat(stats.totalPnlPct) || 0;
    const sharpe = parseFloat(stats.sharpeRatio) || 0;
    const maxDD = parseFloat(stats.maxDrawdownPct) || 0;
    const pf = parseFloat(stats.profitFactor) || 0;
    
    const wrColor = winRate >= 55 ? 'var(--long)' : winRate >= 45 ? 'var(--amber)' : 'var(--short)';
    const pnlColor = pnlPct > 0 ? 'var(--long)' : 'var(--short)';
    const sharpeColor = sharpe >= 1.5 ? 'var(--long)' : sharpe >= 0.5 ? 'var(--amber)' : 'var(--short)';
    const ddColor = maxDD <= 15 ? 'var(--long)' : maxDD <= 25 ? 'var(--amber)' : 'var(--short)';
    const pfColor = pf >= 1.5 ? 'var(--long)' : pf >= 1 ? 'var(--amber)' : 'var(--short)';
    
    const byGrade = {};
    trades.forEach(t => { const g = t.grade || 'VALID'; if (!byGrade[g]) byGrade[g] = { trades: 0, wins: 0, pnl: 0 }; byGrade[g].trades++; if (t.outcome === 'WIN') byGrade[g].wins++; byGrade[g].pnl += t.pnl || 0; });
    
    let gradeHTML = '';
    for (const [grade, data] of Object.entries(byGrade)) {
        const wr = data.trades > 0 ? ((data.wins / data.trades) * 100).toFixed(0) : 0;
        const pnl = data.pnl.toFixed(1);
        gradeHTML += `<div style="display:flex;justify-content:space-between;padding:6px 8px;background:var(--bg4);border-radius:4px;margin-bottom:4px;font-size:11px;"><span style="font-weight:700;">${grade}</span><span>${data.trades} trades</span><span style="color:${parseFloat(wr) >= 50 ? 'var(--long)' : 'var(--short)'}">${wr}% WR</span><span style="color:${parseFloat(pnl) >= 0 ? 'var(--long)' : 'var(--short)'}">${pnl}%</span></div>`;
    }
    
    resultsDiv.innerHTML = `<div style="margin-bottom:15px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;"><div style="font-size:14px;font-weight:700;">${symbol} ${CONFIG.TF_LABELS?.[timeframe] || timeframe}</div><div style="font-size:11px;color:var(--text3);">${candleCount} candles | ${trades.length} trades</div></div>
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:15px;">
            <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;"><div style="font-size:10px;color:var(--text3);margin-bottom:4px;">WIN RATE</div><div style="font-size:20px;font-weight:700;color:${wrColor}">${stats.winRate}%</div></div>
            <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;"><div style="font-size:10px;color:var(--text3);margin-bottom:4px;">TOTAL PNL</div><div style="font-size:20px;font-weight:700;color:${pnlColor}">${pnlPct >= 0 ? '+' : ''}${stats.totalPnlPct}%</div></div>
            <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;"><div style="font-size:10px;color:var(--text3);margin-bottom:4px;">SHARPE</div><div style="font-size:20px;font-weight:700;color:${sharpeColor}">${stats.sharpeRatio}</div></div>
        </div>
        <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:15px;">
            <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;"><div style="font-size:9px;color:var(--text3);">MAX DD</div><div style="font-size:14px;font-weight:700;color:${ddColor}">${stats.maxDrawdownPct}%</div></div>
            <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;"><div style="font-size:9px;color:var(--text3);">PROFIT F.</div><div style="font-size:14px;font-weight:700;color:${pfColor}">${stats.profitFactor}</div></div>
            <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;"><div style="font-size:9px;color:var(--text3);">AVG RR</div><div style="font-size:14px;font-weight:700;">${stats.avgRR}</div></div>
            <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;"><div style="font-size:9px;color:var(--text3);">EXPECTANCY</div><div style="font-size:14px;font-weight:700;color:${parseFloat(stats.expectancy) >= 0 ? 'var(--long)' : 'var(--short)'}">${stats.expectancy}</div></div>
        </div>
        <div style="background:linear-gradient(135deg,var(--bg4),var(--bg3));padding:12px;border-radius:6px;text-align:center;margin-bottom:15px;border:1px solid ${pnlColor};"><div style="font-size:10px;color:var(--text3);margin-bottom:4px;">FINAL EQUITY</div><div style="font-size:24px;font-weight:700;color:${pnlColor}">$${stats.finalEquity}</div><div style="font-size:11px;color:var(--text3);">from $${capital.toLocaleString()}</div></div>
        <div style="margin-bottom:15px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">📊 BY GRADE</div>${gradeHTML}</div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;"><div style="background:var(--long-dim);padding:8px;border-radius:4px;text-align:center;border:1px solid var(--long);"><div style="font-size:9px;color:var(--text3);">MAX WIN STREAK</div><div style="font-size:16px;font-weight:700;color:var(--long);">${stats.maxConsecWins}</div></div><div style="background:var(--short-dim);padding:8px;border-radius:4px;text-align:center;border:1px solid var(--short);"><div style="font-size:9px;color:var(--text3);">MAX LOSS STREAK</div><div style="font-size:16px;font-weight:700;color:var(--short);">${stats.maxConsecLosses}</div></div></div>
    </div>`;
}

async function runFullValidation() {
    const btn = document.getElementById('ubValidateBtn');
    const resultsDiv = document.getElementById('ubBacktestResults');
    const symbol = document.getElementById('ubSymbol').value;
    const timeframe = document.getElementById('ubTimeframe').value;
    const minScore = parseInt(document.getElementById('ubMinScore').value);
    
    btn.disabled = true; btn.textContent = '⏳ VALIDATING...';
    resultsDiv.innerHTML = '<div style="text-align:center;padding:40px;"><div style="font-size:40px;animation:spin 1s linear infinite;">🔬</div><div style="margin-top:10px;">Running full validation...</div><div id="ubProgress" style="font-size:11px;color:var(--text3);margin-top:5px;">Step 1/4: Fetching data...</div></div>';
    
    try {
        const candles = await fetchKlines(symbol, timeframe, 1500);
        if (!candles || candles.length < 500) throw new Error('Need at least 500 candles for full validation');
        
        document.getElementById('ubProgress').textContent = 'Step 1/4: Running backtest...';
        const trades = [];
        for (let i = 100; i < candles.length - 20; i += 3) {
            const slice = candles.slice(i - 100, i);
            const signal = quickSignalCheck(slice, symbol, timeframe);
            if (!signal || signal.score < minScore) continue;
            const future = candles.slice(i + 1, i + 21);
            if (future.length < 5) continue;
            const outcome = simulateTradeOutcome(signal, future);
            trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won, pnl: outcome.pnl });
        }
        if (trades.length < 20) throw new Error('Insufficient trades for validation: ' + trades.length);
        
        lastBacktestTrades = trades;
        const btStats = BacktestStatistics.calculate(trades, 10000);
        
        document.getElementById('ubProgress').textContent = 'Step 2/4: K-Fold validation...';
        await new Promise(r => setTimeout(r, 100));
        const kfold = await KFoldCV.run(symbol, timeframe, candles, { minScore }, 5);
        
        document.getElementById('ubProgress').textContent = 'Step 3/4: Walk-Forward analysis...';
        await new Promise(r => setTimeout(r, 100));
        const wf = await WalkForwardAnalysis.run(symbol, timeframe, candles);
        
        document.getElementById('ubProgress').textContent = 'Step 4/4: Monte Carlo simulation...';
        await new Promise(r => setTimeout(r, 100));
        const mc = MonteCarloSimulator.run(trades, 1000);
        
        let confidence = 0;
        const checks = [];
        
        const wr = parseFloat(btStats.winRate);
        if (wr >= 55) { confidence += 15; checks.push({ name: 'Win Rate', status: '✅', value: wr + '%' }); }
        else if (wr >= 45) { confidence += 10; checks.push({ name: 'Win Rate', status: '⚠️', value: wr + '%' }); }
        else { checks.push({ name: 'Win Rate', status: '❌', value: wr + '%' }); }
        
        const pf = parseFloat(btStats.profitFactor);
        if (pf >= 1.5) { confidence += 15; checks.push({ name: 'Profit Factor', status: '✅', value: pf }); }
        else if (pf >= 1.0) { confidence += 10; checks.push({ name: 'Profit Factor', status: '⚠️', value: pf }); }
        else { checks.push({ name: 'Profit Factor', status: '❌', value: pf }); }
        
        if (kfold?.summary?.isConsistent) { confidence += 20; checks.push({ name: 'K-Fold Consistent', status: '✅', value: 'Yes' }); }
        else { checks.push({ name: 'K-Fold Consistent', status: '❌', value: 'No' }); }
        
        const wfEff = parseFloat(wf?.efficiency) || 0;
        if (wfEff >= 0.7) { confidence += 20; checks.push({ name: 'Walk-Forward', status: '✅', value: (wfEff * 100).toFixed(0) + '%' }); }
        else if (wfEff >= 0.5) { confidence += 10; checks.push({ name: 'Walk-Forward', status: '⚠️', value: (wfEff * 100).toFixed(0) + '%' }); }
        else { checks.push({ name: 'Walk-Forward', status: '❌', value: (wfEff * 100).toFixed(0) + '%' }); }
        
        const mcProfit = parseFloat(mc?.profitProbability) || 0;
        if (mcProfit >= 80) { confidence += 20; checks.push({ name: 'MC Profit Prob', status: '✅', value: mcProfit + '%' }); }
        else if (mcProfit >= 60) { confidence += 10; checks.push({ name: 'MC Profit Prob', status: '⚠️', value: mcProfit + '%' }); }
        else { checks.push({ name: 'MC Profit Prob', status: '❌', value: mcProfit + '%' }); }
        
        const dd = parseFloat(btStats.maxDrawdownPct);
        if (dd <= 15) { confidence += 10; checks.push({ name: 'Max Drawdown', status: '✅', value: dd + '%' }); }
        else if (dd <= 25) { confidence += 5; checks.push({ name: 'Max Drawdown', status: '⚠️', value: dd + '%' }); }
        else { checks.push({ name: 'Max Drawdown', status: '❌', value: dd + '%' }); }
        
        const rating = confidence >= 80 ? 'EXCELLENT' : confidence >= 60 ? 'GOOD' : confidence >= 40 ? 'MODERATE' : 'POOR';
        const ratingColor = confidence >= 80 ? 'var(--long)' : confidence >= 60 ? 'var(--cyan)' : confidence >= 40 ? 'var(--amber)' : 'var(--short)';
        
        let checksHTML = checks.map(c => `<div style="display:flex;justify-content:space-between;padding:8px;background:var(--bg4);border-radius:4px;margin-bottom:4px;"><span>${c.status} ${c.name}</span><span style="font-weight:700;">${c.value}</span></div>`).join('');
        
        resultsDiv.innerHTML = `<div style="margin-bottom:15px;">
            <div style="text-align:center;margin-bottom:20px;"><div style="font-size:14px;color:var(--text3);margin-bottom:5px;">STRATEGY CONFIDENCE</div><div style="font-size:48px;font-weight:700;color:${ratingColor}">${confidence}%</div><div style="font-size:18px;font-weight:700;color:${ratingColor};margin-top:5px;">${rating}</div></div>
            <div style="margin-bottom:15px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">🔬 VALIDATION CHECKS</div>${checksHTML}</div>
            <div style="background:linear-gradient(135deg,var(--bg4),var(--bg3));padding:12px;border-radius:6px;margin-bottom:15px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">🎲 MONTE CARLO (1000 sims)</div><div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;"><div style="text-align:center;"><div style="font-size:9px;color:var(--text3);">WORST 5%</div><div style="font-size:14px;font-weight:700;color:${parseFloat(mc.percentile5.totalReturn) >= 0 ? 'var(--long)' : 'var(--short)'}">${mc.percentile5.totalReturn}%</div></div><div style="text-align:center;"><div style="font-size:9px;color:var(--text3);">MEDIAN</div><div style="font-size:14px;font-weight:700;color:${parseFloat(mc.median.totalReturn) >= 0 ? 'var(--long)' : 'var(--short)'}">${mc.median.totalReturn}%</div></div><div style="text-align:center;"><div style="font-size:9px;color:var(--text3);">BEST 5%</div><div style="font-size:14px;font-weight:700;color:var(--long)">${mc.percentile95.totalReturn}%</div></div></div></div>
            <div style="background:var(--bg4);padding:12px;border-radius:6px;margin-bottom:15px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">📊 K-FOLD (5 folds)</div><div style="display:flex;justify-content:space-between;font-size:11px;"><span>Avg Win Rate: <b>${kfold?.summary?.avgWinRate || 0}%</b></span><span>Std Dev: <b>${kfold?.summary?.winRateStdDev || 0}%</b></span><span>Consistency: <b style="color:${kfold?.summary?.isConsistent ? 'var(--long)' : 'var(--short)'}">${kfold?.summary?.consistency || 0}%</b></span></div></div>
            <div style="background:var(--bg4);padding:12px;border-radius:6px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">📈 WALK-FORWARD (4 windows)</div><div style="display:flex;justify-content:space-between;font-size:11px;"><span>In-Sample: <b style="color:${parseFloat(wf.totalInSample) >= 0 ? 'var(--long)' : 'var(--short)'}">${wf.totalInSample}%</b></span><span>Out-Sample: <b style="color:${parseFloat(wf.totalOutOfSample) >= 0 ? 'var(--long)' : 'var(--short)'}">${wf.totalOutOfSample}%</b></span><span>Efficiency: <b style="color:${ratingColor}">${wf.rating}</b></span></div></div>
        </div>`;
    } catch (error) {
        resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--short);"><div style="font-size:40px;margin-bottom:10px;">❌</div><div>Validation failed: ${error.message}</div></div>`;
    }
    
    btn.disabled = false; btn.textContent = '🔬 FULL VALIDATION';
}

async function runMonteCarlo() {
    const btn = document.getElementById('ubMCBtn');
    const resultsDiv = document.getElementById('ubMCResults');
    const simulations = parseInt(document.getElementById('ubMCSimulations').value);
    
    if (!lastBacktestTrades || lastBacktestTrades.length < 10) {
        resultsDiv.innerHTML = '<div style="text-align:center;padding:40px;color:var(--amber);"><div style="font-size:40px;margin-bottom:10px;">⚠️</div><div>Run backtest first!</div></div>';
        return;
    }
    
    btn.disabled = true; btn.textContent = '⏳ SIMULATING...';
    resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;"><div style="font-size:40px;animation:spin 1s linear infinite;">🎲</div><div style="margin-top:10px;">Running ${simulations.toLocaleString()} simulations...</div></div>`;
    
    await new Promise(r => setTimeout(r, 100));
    const mc = MonteCarloSimulator.run(lastBacktestTrades, simulations);
    
    const profitProb = parseFloat(mc.profitProbability);
    const probColor = profitProb >= 80 ? 'var(--long)' : profitProb >= 60 ? 'var(--amber)' : 'var(--short)';
    
    resultsDiv.innerHTML = `<div style="margin-bottom:15px;">
        <div style="text-align:center;margin-bottom:20px;"><div style="font-size:14px;color:var(--text3);margin-bottom:5px;">PROFIT PROBABILITY</div><div style="font-size:48px;font-weight:700;color:${probColor}">${mc.profitProbability}%</div><div style="font-size:11px;color:var(--text3);margin-top:5px;">${simulations.toLocaleString()} simulations | ${mc.tradeCount} trades</div></div>
        <div style="background:var(--bg4);border-radius:6px;overflow:hidden;margin-bottom:15px;">
            <div style="display:grid;grid-template-columns:1fr 1fr 1fr;background:var(--bg3);padding:8px;font-size:10px;font-weight:700;"><div>PERCENTILE</div><div style="text-align:center;">RETURN</div><div style="text-align:right;">EQUITY</div></div>
            <div style="display:grid;grid-template-columns:1fr 1fr 1fr;padding:8px;font-size:11px;border-bottom:1px solid var(--border);"><div>5% (Worst)</div><div style="text-align:center;color:${parseFloat(mc.percentile5.totalReturn) >= 0 ? 'var(--long)' : 'var(--short)'}">${mc.percentile5.totalReturn}%</div><div style="text-align:right;">$${mc.percentile5.finalEquity}</div></div>
            <div style="display:grid;grid-template-columns:1fr 1fr 1fr;padding:8px;font-size:11px;border-bottom:1px solid var(--border);background:var(--bg3);"><div style="font-weight:700;">50% (Median)</div><div style="text-align:center;font-weight:700;color:${parseFloat(mc.median.totalReturn) >= 0 ? 'var(--long)' : 'var(--short)'}">${mc.median.totalReturn}%</div><div style="text-align:right;font-weight:700;">$${mc.median.finalEquity}</div></div>
            <div style="display:grid;grid-template-columns:1fr 1fr 1fr;padding:8px;font-size:11px;"><div>95% (Best)</div><div style="text-align:center;color:var(--long)">${mc.percentile95.totalReturn}%</div><div style="text-align:right;">$${mc.percentile95.finalEquity}</div></div>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;"><div style="background:var(--short-dim);padding:12px;border-radius:6px;text-align:center;border:1px solid var(--short);"><div style="font-size:10px;color:var(--text3);">RUIN PROBABILITY</div><div style="font-size:20px;font-weight:700;color:var(--short);">${mc.ruinProbability}%</div></div><div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;"><div style="font-size:10px;color:var(--text3);">WORST DRAWDOWN</div><div style="font-size:20px;font-weight:700;color:var(--amber);">${mc.percentile5.maxDrawdown}%</div></div></div>
    </div>`;
    
    btn.disabled = false; btn.textContent = '🎲 RUN MONTE CARLO';
}

async function runOptimization() {
    const btn = document.getElementById('ubOptBtn');
    const resultsDiv = document.getElementById('ubOptResults');
    const symbol = document.getElementById('ubSymbol').value;
    const timeframe = document.getElementById('ubTimeframe').value;
    
    btn.disabled = true; btn.textContent = '⏳ OPTIMIZING...';
    resultsDiv.innerHTML = '<div style="text-align:center;padding:40px;"><div style="font-size:40px;animation:spin 1s linear infinite;">🧬</div><div style="margin-top:10px;">Fetching data...</div><div id="optProgress" style="font-size:11px;color:var(--text3);margin-top:5px;">Generation 0/20</div></div>';
    
    try {
        const candles = await fetchKlines(symbol, timeframe, 1000);
        if (!candles || candles.length < 500) throw new Error('Need at least 500 candles for optimization');
        
        const result = await GeneticOptimizer.run(symbol, timeframe, candles, (progress) => {
            document.getElementById('optProgress').textContent = `Generation ${progress.generation}/${progress.total} | Best: ${progress.best}`;
        });
        
        let historyHTML = result.history.slice(-5).map(h => `<div style="display:flex;justify-content:space-between;padding:6px 8px;background:var(--bg4);border-radius:4px;margin-bottom:4px;font-size:10px;"><span>Gen ${h.generation}</span><span>Best: ${h.bestFitness}</span><span>Avg: ${h.avgFitness}</span></div>`).join('');
        
        resultsDiv.innerHTML = `<div style="margin-bottom:15px;">
            <div style="text-align:center;margin-bottom:20px;"><div style="font-size:14px;color:var(--text3);margin-bottom:5px;">BEST FITNESS SCORE</div><div style="font-size:48px;font-weight:700;color:var(--long)">${result.bestFitness.toFixed(1)}</div></div>
            <div style="background:linear-gradient(135deg,var(--bg4),var(--bg3));padding:15px;border-radius:6px;margin-bottom:15px;border:1px solid var(--long);"><div style="font-size:12px;font-weight:700;margin-bottom:10px;">🏆 OPTIMAL PARAMETERS</div><div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;"><div style="font-size:11px;">Min Score: <b style="color:var(--cyan)">${result.bestParams.minScore}</b></div><div style="font-size:11px;">Zone Weight: <b style="color:var(--cyan)">${result.bestParams.zoneWeight}%</b></div><div style="font-size:11px;">SMC Weight: <b style="color:var(--purple)">${result.bestParams.smcWeight}%</b></div><div style="font-size:11px;">Momentum Weight: <b style="color:var(--amber)">${result.bestParams.momentumWeight}%</b></div><div style="font-size:11px;">Risk/Trade: <b style="color:var(--long)">${result.bestParams.riskPerTrade}%</b></div></div></div>
            <div style="background:var(--bg4);padding:12px;border-radius:6px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">📈 EVOLUTION (Last 5 Generations)</div>${historyHTML}</div>
        </div>`;
    } catch (error) {
        resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--short);"><div style="font-size:40px;margin-bottom:10px;">❌</div><div>Optimization failed: ${error.message}</div></div>`;
    }
    
    btn.disabled = false; btn.textContent = '🧬 START OPTIMIZATION';
}

function addUltimateBacktestButton() {
    const headerBtns = document.querySelector('.header-btns');
    if (headerBtns && !document.getElementById('ubOpenBtn')) {
        const btn = document.createElement('button');
        btn.id = 'ubOpenBtn'; btn.className = 'btn'; btn.innerHTML = '🚀'; btn.title = 'Ultimate Backtest';
        btn.onclick = showUltimateBacktest;
        btn.style.background = 'linear-gradient(135deg, var(--cyan), var(--purple))';
        btn.style.border = 'none'; btn.style.color = '#fff';
        headerBtns.insertBefore(btn, headerBtns.firstChild);
    }
}

if (!document.getElementById('ubStyles')) {
    const style = document.createElement('style');
    style.id = 'ubStyles';
    style.textContent = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } .ub-tab:hover { opacity: 0.8; }';
    document.head.appendChild(style);
}

setTimeout(() => { addUltimateBacktestButton(); AutoPilot.loadConfig(); }, 1000);
console.log('🚀 BS SCANNER V11 - ULTIMATE BACKTEST ENGINE LOADED');

</script>
</body>
</html>
