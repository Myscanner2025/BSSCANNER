<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta name="theme-color" content="#0a0a0f">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="BS SCANNER">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQlMgU2Nhbm5lciBWMSIsInNob3J0X25hbWUiOiJCUyBWMSIsImRlc2NyaXB0aW9uIjoiQnliaXQgQ3J5cHRvIFNpZ25hbCBTY2FubmVyIHdpdGggTXVsdGktQUkiLCJzdGFydF91cmwiOiIuIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzBhMGEwZiIsInRoZW1lX2NvbG9yIjoiIzBhMGEwZiIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAxMDAgMTAwJz48cmVjdCB3aWR0aD0nMTAwJyBoZWlnaHQ9JzEwMCcgZmlsbD0nJTIzMGEwYTBmJy8+PHRleHQgeD0nNTAnIHk9JzYwJyBmb250LXNpemU9JzQwJyB0ZXh0LWFuY2hvcj0nbWlkZGxlJyBmaWxsPSclMjNmZmQ3MDAnPuKaoTwvdGV4dD48L3N2Zz4iLCJzaXplcyI6IjE5MngxOTIiLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCJ9XX0=">
<title>BS Scanner V19 ULTRA - Liquidity-First + V18 Engines + Capped Scoring</title>
<style>
:root{
--bg1:#0a0a0f;--bg2:#12121a;--bg3:#1a1a25;--bg4:#22222f;
--border:#2a2a3a;--text:#ffffff;--text2:#ffffff;--text3:#ffffff;
--long:#00d9a0;--long-dim:rgba(0,217,160,0.15);
--short:#ff4757;--short-dim:rgba(255,71,87,0.15);
--purple:#a855f7;--purple-dim:rgba(168,85,247,0.15);
--blue:#3b82f6;--blue-dim:rgba(59,130,246,0.15);
--amber:#f59e0b;--amber-dim:rgba(245,158,11,0.15);
--cyan:#06b6d4;--cyan-dim:rgba(6,182,212,0.15);
--gold:#ffd700;--gold-dim:rgba(255,215,0,0.15)
}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,-apple-system,sans-serif;background:var(--bg1);color:var(--text);min-height:100vh;overflow-x:hidden}
.app{display:flex;flex-direction:column;min-height:100vh}

/* V11-CLEAN: TIGHT SPACING FOR ALL ROWS */
.header{padding:4px 8px !important;gap:3px !important}
.header-row1{padding:3px 8px !important;gap:4px !important}
.env-bar{padding:3px 8px !important;gap:4px !important}
.structure-bar{padding:3px 8px !important;gap:4px !important}
.live-data-bar{padding:3px 8px !important;gap:4px !important}
.stats-bar{padding:3px 8px !important;gap:2px !important}
.direction-tabs{margin-bottom:3px !important;gap:4px !important}
.saved-dropdown{margin-bottom:3px !important}
.sidebar-top{gap:3px !important;padding:4px !important}
.signal-list{padding:4px !important}
.signal-card{padding:8px !important;margin-bottom:6px !important}

/* HEADER - 2 ROW LAYOUT */
.header{display:flex;flex-direction:column;padding:8px 10px;background:var(--bg2);border-bottom:1px solid var(--border);gap:6px}
.header-row1{display:flex;align-items:center;gap:6px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch;scrollbar-width:none;-ms-overflow-style:none;padding:6px 10px;background:var(--bg2);border-bottom:1px solid var(--border)}
.header-row1::-webkit-scrollbar{display:none}
/* Market Info Badge - Redesigned to match ENV bar */
.info-badge{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg3);border-radius:4px;font-size:11px;border:1px solid var(--border);flex-shrink:0;white-space:nowrap}
.info-badge .icon{font-size:12px}
.info-badge .label{color:var(--text3);margin-right:2px}
.info-badge .value{font-weight:700;color:var(--text)}
.info-badge.go{border-color:var(--long);background:var(--long-dim)}
.info-badge.go .value{color:var(--long)}
.info-badge.caution{border-color:var(--amber);background:var(--amber-dim)}
.info-badge.caution .value{color:var(--amber)}
.info-badge.nogo{border-color:var(--short);background:var(--short-dim)}
.info-badge.nogo .value{color:var(--short)}
/* Old m-badge kept for compatibility but hidden */
.m-badge{display:none}
.header-row2{display:flex;align-items:center;gap:8px}
.header-btns{display:flex;gap:4px;margin-left:auto;align-items:center}
.ai-dot{width:8px;height:8px;border-radius:50%;background:var(--text3);margin-right:4px}
.ai-dot.on{background:var(--long);box-shadow:0 0 8px var(--long)}
.ai-dot.error{background:var(--short);box-shadow:0 0 8px var(--short)}
.btn{padding:4px 8px;border-radius:4px;border:1px solid var(--border);background:var(--bg3);color:var(--text);font-size:10px;cursor:pointer;transition:all 0.2s}
.btn:hover{background:var(--bg4)}
.btn.active{background:var(--long-dim);border-color:var(--long);color:var(--long)}
.btn.scanning{background:linear-gradient(90deg,rgba(255,100,100,0.9),rgba(255,180,100,0.9),rgba(255,255,100,0.9),rgba(100,255,100,0.9),rgba(100,255,255,0.9),rgba(100,180,255,0.9),rgba(180,100,255,0.9),rgba(255,100,255,0.9),rgba(255,100,180,0.9),rgba(255,100,100,0.9));background-size:200% 100%;animation:rainbowFlow 2s linear infinite;border:none;color:#fff;font-weight:700;text-shadow:0 0 5px rgba(0,0,0,0.5);box-shadow:0 0 10px rgba(200,200,255,0.4),0 0 20px rgba(100,200,255,0.2)}
.btn.scan-done{background:linear-gradient(90deg,var(--long),rgba(0,255,170,0.8),var(--cyan),rgba(0,255,170,0.8),var(--long));background-size:200% 100%;animation:completePulse 3s ease-in-out infinite;border:none;color:#fff;font-weight:700;text-shadow:0 0 5px rgba(0,0,0,0.5);box-shadow:0 0 10px var(--long),0 0 20px rgba(0,255,170,0.3)}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.6}}

/* MARKET BADGES - WIDER & SCROLLABLE */
.m-badge{display:flex;align-items:center;gap:4px;padding:6px 10px;background:var(--bg3);border-radius:6px;border:1px solid var(--border);font-size:12px;min-width:85px;flex-shrink:0}
.m-badge-icon{font-size:14px}
.m-badge-value{font-weight:700;color:var(--text);font-size:12px;white-space:nowrap}
.m-badge.bull .m-badge-value{color:var(--long)}
.m-badge.bear .m-badge-value{color:var(--short)}
.m-badge.neutral .m-badge-value{color:var(--text)}
/* Season flash animations */
.m-badge.flash-bright-green{animation:flashBrightGreen 0.5s ease-in-out infinite}
.m-badge.flash-dim-green{animation:flashDimGreen 2s ease-in-out infinite}
.m-badge.flash-bright-red{animation:flashBrightRed 0.5s ease-in-out infinite}
.m-badge.flash-dim-red{animation:flashDimRed 2s ease-in-out infinite}
.m-badge.flash-bright-green .m-badge-value{color:#00ff88;text-shadow:0 0 8px #00ff88}
.m-badge.flash-dim-green .m-badge-value{color:#00d980;text-shadow:0 0 4px #00d980}
.m-badge.flash-bright-red .m-badge-value{color:#ff4757;text-shadow:0 0 8px #ff4757}
.m-badge.flash-dim-red .m-badge-value{color:#ff6b6b;text-shadow:0 0 4px #ff6b6b}
@keyframes flashBrightGreen{0%,100%{opacity:1}50%{opacity:0.3}}
@keyframes flashDimGreen{0%,100%{opacity:1}50%{opacity:0.6}}
@keyframes flashBrightRed{0%,100%{opacity:1}50%{opacity:0.3}}
@keyframes flashDimRed{0%,100%{opacity:1}50%{opacity:0.6}}

/* ENVIRONMENT BAR */
.env-bar{display:flex;align-items:center;gap:6px;padding:6px 10px;background:var(--bg2);border-bottom:1px solid var(--border);overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch;scrollbar-width:none;-ms-overflow-style:none}
.env-bar::-webkit-scrollbar{display:none}
.env-status{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg3);border-radius:4px;font-size:11px;flex-shrink:0;white-space:nowrap}
.env-status .icon{font-size:12px}
.env-status .label{color:var(--text3);margin-right:2px}
.env-status .value{font-weight:700}
.env-status.go{border:1px solid var(--long);background:var(--long-dim)}
.env-status.go .value{color:var(--long)}
.env-status.caution{border:1px solid var(--amber);background:var(--amber-dim)}
.env-status.caution .value{color:var(--amber)}
.env-status.risky{border:1px solid #ff8c00;background:rgba(255,140,0,0.15)}
.env-status.risky .value{color:#ff8c00}
.env-status.nogo{border:1px solid var(--short);background:var(--short-dim)}
.env-status.nogo .value{color:var(--short)}
.env-verdict{margin-left:auto;display:flex;align-items:center;gap:6px;padding:4px 10px;border-radius:4px;font-size:11px;font-weight:700}
.env-verdict.go{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}
.env-verdict.caution{background:var(--amber-dim);color:var(--amber);border:1px solid var(--amber)}
.env-verdict.risky{background:rgba(255,140,0,0.15);color:#ff8c00;border:1px solid #ff8c00}
.env-verdict.nogo{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.env-score{font-size:13px;font-weight:700}

/* V10.3 STRUCTURE BAR */
.structure-bar{display:flex;align-items:center;gap:6px;padding:5px 10px;background:linear-gradient(90deg,var(--bg2),rgba(0,229,255,0.05));border-bottom:1px solid rgba(0,229,255,0.3);overflow-x:auto;scrollbar-width:none}
.structure-bar::-webkit-scrollbar{display:none}
.str-status{display:flex;align-items:center;gap:4px;padding:3px 7px;background:var(--bg3);border-radius:4px;font-size:10px;flex-shrink:0;border:1px solid var(--border)}
.str-status .icon{font-size:11px}
.str-status .label{color:var(--text3);font-size:9px}
.str-status .value{font-weight:700;font-size:10px}
.str-status.valid{border-color:#00e5ff;background:rgba(0,229,255,0.1)}
.str-status.valid .value{color:#00e5ff}
.str-status.invalid{border-color:var(--short);background:var(--short-dim)}
.str-status.invalid .value{color:var(--short)}
.str-status.neutral{border-color:var(--amber);background:var(--amber-dim)}
.str-status.neutral .value{color:var(--amber)}
.str-verdict{margin-left:auto;display:flex;align-items:center;gap:6px;padding:4px 10px;border-radius:4px;font-size:10px;font-weight:700}
.str-verdict.valid{background:#00e5ff;color:#000}
.str-verdict.invalid{background:var(--short);color:#fff}
.str-verdict.neutral{background:var(--amber);color:#000}
.str-score{font-size:12px;font-weight:700}

/* SIGNAL CARD ENV ICONS */
.signal-env{display:flex;gap:2px;margin-top:4px;flex-wrap:wrap}
.signal-env .env-icon{font-size:10px;padding:1px 3px;border-radius:2px;background:var(--bg4)}
.signal-env .env-icon.ok{color:var(--long)}
.signal-env .env-icon.warn{color:var(--amber)}
.signal-env .env-icon.bad{color:var(--short)}

/* SIGNAL CARD STRUCTURE INFO */
.signal-structure{display:flex;gap:4px;margin-top:4px;flex-wrap:wrap;padding:4px 6px;background:var(--bg4);border-radius:4px}
.signal-structure .str-tag{font-size:8px;padding:2px 5px;border-radius:3px;display:flex;align-items:center;gap:2px}
.signal-structure .str-tag .icon{font-size:9px}
.signal-structure .str-tag.channel{background:rgba(0,229,255,0.1);color:#00e5ff}
.signal-structure .str-tag.trendline{background:rgba(168,85,247,0.1);color:#a855f7}
.signal-structure .str-tag.compression{background:var(--long-dim);color:var(--long)}
.signal-structure .str-tag.bias{background:var(--blue-dim);color:var(--blue)}
.signal-structure .str-tag.gate-pass{background:var(--long-dim);color:var(--long)}
.signal-structure .str-tag.gate-fail{background:var(--short-dim);color:var(--short)}

/* SMART MATRIX DISPLAY */
.smart-matrix{display:flex;align-items:center;gap:6px;padding:6px 8px;background:var(--bg4);border-radius:6px;margin-top:6px;flex-wrap:wrap}
.smart-matrix .regime-badge{font-size:9px;padding:2px 6px;border-radius:4px;font-weight:700;text-transform:uppercase}
.smart-matrix .regime-badge.uptrend{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}
.smart-matrix .regime-badge.downtrend{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.smart-matrix .regime-badge.ranging{background:var(--amber-dim);color:var(--amber);border:1px solid var(--amber)}
.smart-matrix .regime-badge.choppy{background:var(--purple-dim);color:var(--purple);border:1px solid var(--purple)}
.smart-matrix .regime-badge.transitional{background:var(--bg3);color:var(--text3);border:1px solid var(--border)}
.smart-matrix .weights{font-size:10px;color:var(--text2);font-family:monospace}
.smart-matrix .weights .w-zone{color:var(--cyan)}
.smart-matrix .weights .w-smc{color:var(--purple)}
.smart-matrix .weights .w-mom{color:var(--amber)}
.smart-matrix .dominant{font-size:9px;padding:2px 5px;border-radius:3px;background:var(--bg3);color:var(--text3)}
.smart-matrix .dominant.zone-lead{color:var(--cyan);border:1px solid var(--cyan)}
.smart-matrix .dominant.smc-lead{color:var(--purple);border:1px solid var(--purple)}
.smart-matrix .dominant.momentum-lead{color:var(--amber);border:1px solid var(--amber)}
.smart-matrix .dominant.balanced{color:var(--long);border:1px solid var(--long)}
.smart-matrix .agreement{font-size:9px;padding:2px 5px;border-radius:3px}
.smart-matrix .agreement.full{background:var(--long-dim);color:var(--long)}
.smart-matrix .agreement.majority{background:var(--cyan-dim);color:var(--cyan)}
.smart-matrix .agreement.conflict{background:var(--short-dim);color:var(--short)}

/* ═══════════════════════════════════════════════════════════════════════════════
   PHASE 1: TOP TIER REAL-TIME DATA STYLES
   ═══════════════════════════════════════════════════════════════════════════════ */

/* LIVE DATA BAR */
.live-data-bar{display:flex;align-items:center;gap:6px;padding:6px 10px;background:linear-gradient(180deg,var(--bg2) 0%,var(--bg3) 100%);border-bottom:1px solid var(--border);overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none}
.live-data-bar::-webkit-scrollbar{display:none}
.live-badge{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg4);border-radius:6px;font-size:10px;border:1px solid var(--border);flex-shrink:0;transition:all 0.3s}
.live-badge .icon{font-size:12px}
.live-badge .label{color:var(--text3);font-size:9px}
.live-badge .value{font-weight:700;font-family:monospace}
.live-badge.bullish{border-color:var(--long);background:var(--long-dim)}
.live-badge.bullish .value{color:var(--long)}
.live-badge.bearish{border-color:var(--short);background:var(--short-dim)}
.live-badge.bearish .value{color:var(--short)}
.live-badge.neutral{border-color:var(--amber);background:var(--amber-dim)}
.live-badge.neutral .value{color:var(--amber)}
.live-badge.flash{animation:liveFlash 0.5s ease-out}
@keyframes liveFlash{0%{transform:scale(1.1);box-shadow:0 0 15px var(--gold)}100%{transform:scale(1);box-shadow:none}}

/* LIQUIDATION SPECIFIC */
.liq-badge{position:relative;overflow:hidden}
.liq-badge::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.1),transparent);animation:liqShimmer 2s infinite}
@keyframes liqShimmer{0%{left:-100%}100%{left:100%}}
.liq-badge .liq-long{color:var(--long);font-weight:700}
.liq-badge .liq-short{color:var(--short);font-weight:700}
.liq-cascade{animation:cascadePulse 1s ease-in-out infinite}
@keyframes cascadePulse{0%,100%{box-shadow:0 0 5px var(--short)}50%{box-shadow:0 0 20px var(--short)}}

/* OI DELTA SPECIFIC */
.oi-badge .oi-up{color:var(--long)}
.oi-badge .oi-down{color:var(--short)}
.oi-badge .oi-bar{width:40px;height:4px;background:var(--bg2);border-radius:2px;overflow:hidden;margin-left:4px}
.oi-badge .oi-bar-fill{height:100%;border-radius:2px;transition:width 0.5s ease}
.oi-badge .oi-bar-fill.positive{background:linear-gradient(90deg,var(--long),#00ffaa)}
.oi-badge .oi-bar-fill.negative{background:linear-gradient(90deg,var(--short),#ff8888)}

/* WHALE ALERT SPECIFIC */
.whale-badge{position:relative}
.whale-badge.active{border-color:var(--gold);background:var(--gold-dim);animation:whaleGlow 1.5s ease-in-out infinite}
@keyframes whaleGlow{0%,100%{box-shadow:0 0 5px var(--gold)}50%{box-shadow:0 0 15px var(--gold)}}
.whale-alert-popup{position:fixed;top:80px;right:10px;background:var(--bg2);border:2px solid var(--gold);border-radius:8px;padding:10px 15px;z-index:1000;animation:whaleSlideIn 0.3s ease-out;box-shadow:0 4px 20px rgba(255,215,0,0.3)}
@keyframes whaleSlideIn{0%{transform:translateX(100%);opacity:0}100%{transform:translateX(0);opacity:1}}
.whale-alert-popup .whale-icon{font-size:20px;margin-right:8px}
.whale-alert-popup .whale-info{display:flex;flex-direction:column;gap:2px}
.whale-alert-popup .whale-coin{font-weight:700;font-size:12px}
.whale-alert-popup .whale-details{font-size:10px;color:var(--text3)}
.whale-alert-popup .whale-amount{font-size:14px;font-weight:700}
.whale-alert-popup .whale-amount.buy{color:var(--long)}
.whale-alert-popup .whale-amount.sell{color:var(--short)}

/* FUNDING RATE SPECIFIC */
.funding-badge .countdown{font-family:monospace;font-size:9px;color:var(--text3);margin-left:4px}
.funding-badge.positive .value{color:var(--long)}
.funding-badge.negative .value{color:var(--short)}
.funding-badge .funding-bar{width:50px;height:4px;background:var(--bg2);border-radius:2px;position:relative;margin-left:4px}
.funding-badge .funding-bar::before{content:'';position:absolute;left:50%;top:0;width:1px;height:100%;background:var(--text3)}
.funding-badge .funding-indicator{position:absolute;top:-1px;width:6px;height:6px;border-radius:50%;transition:left 0.3s}
.funding-badge .funding-indicator.positive{background:var(--long);left:75%}
.funding-badge .funding-indicator.negative{background:var(--short);left:25%}
.funding-badge .funding-indicator.neutral{background:var(--amber);left:50%}

/* SIGNAL CARD LIVE DATA */
.signal-live-data{display:flex;gap:4px;margin-top:4px;flex-wrap:wrap}
.signal-live-data .live-tag{font-size:8px;padding:2px 4px;border-radius:3px;background:var(--bg4)}
.signal-live-data .live-tag.liq-bullish{color:var(--long);border:1px solid var(--long)}
.signal-live-data .live-tag.liq-bearish{color:var(--short);border:1px solid var(--short)}
.signal-live-data .live-tag.oi-rising{color:var(--long);border:1px solid var(--long)}
.signal-live-data .live-tag.oi-falling{color:var(--short);border:1px solid var(--short)}
.signal-live-data .live-tag.whale-buy{color:var(--gold);border:1px solid var(--gold)}
.signal-live-data .live-tag.whale-sell{color:var(--purple);border:1px solid var(--purple)}
.signal-live-data .live-tag.funding-pos{color:var(--long)}
.signal-live-data .live-tag.funding-neg{color:var(--short)}

/* LIVE INDICATOR DOT */
.live-dot{width:6px;height:6px;border-radius:50%;background:var(--long);animation:livePulse 1.5s ease-in-out infinite;margin-right:4px}
@keyframes livePulse{0%,100%{opacity:1;transform:scale(1)}50%{opacity:0.5;transform:scale(0.8)}}
.live-dot.disconnected{background:var(--short);animation:none}
.live-dot.connecting{background:var(--amber);animation:livePulse 0.5s ease-in-out infinite}

/* ═══════════════════════════════════════════════════════════════════════════════
   PHASE 2-4: ADVANCED ANALYSIS STYLES
   ═══════════════════════════════════════════════════════════════════════════════ */

/* ADVANCED ANALYSIS BAR */
.signal-advanced{display:flex;gap:4px;margin-top:4px;flex-wrap:wrap;padding:4px 6px;background:var(--bg4);border-radius:4px}
.signal-advanced .adv-tag{font-size:8px;padding:2px 5px;border-radius:3px;display:flex;align-items:center;gap:2px}
.signal-advanced .adv-tag .icon{font-size:10px}

/* Volume Profile Tags */
.signal-advanced .vp-tag{background:rgba(59,130,246,0.15);color:var(--blue);border:1px solid var(--blue)}
.signal-advanced .vp-tag.at-poc{background:rgba(255,215,0,0.2);color:var(--gold);border:1px solid var(--gold)}
.signal-advanced .vp-tag.at-vah{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.signal-advanced .vp-tag.at-val{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}

/* Order Flow Tags */
.signal-advanced .of-tag{background:rgba(168,85,247,0.15);color:var(--purple);border:1px solid var(--purple)}
.signal-advanced .of-tag.buy-aggro{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}
.signal-advanced .of-tag.sell-aggro{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.signal-advanced .of-tag.absorption{background:rgba(6,182,212,0.15);color:var(--cyan);border:1px solid var(--cyan)}

/* ML Prediction Tags */
.signal-advanced .ml-tag{background:rgba(245,158,11,0.15);color:var(--amber);border:1px solid var(--amber)}
.signal-advanced .ml-tag.favorable{background:var(--long-dim);color:var(--long);border:1px solid var(--long);animation:mlGlow 2s ease-in-out infinite}
.signal-advanced .ml-tag.unfavorable{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
@keyframes mlGlow{0%,100%{box-shadow:0 0 3px var(--long)}50%{box-shadow:0 0 8px var(--long)}}

/* Confidence Badge */
.signal-advanced .conf-badge{font-size:7px;padding:1px 4px;border-radius:2px;font-weight:700}
.signal-advanced .conf-badge.high{background:var(--long);color:var(--bg)}
.signal-advanced .conf-badge.medium{background:var(--amber);color:var(--bg)}
.signal-advanced .conf-badge.low{background:var(--bg3);color:var(--text3)}

/* Combined Score Ring */
.adv-score-ring{width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:9px;font-weight:700;position:relative;margin-left:auto}
.adv-score-ring::before{content:'';position:absolute;inset:-2px;border-radius:50%;border:2px solid var(--border);border-top-color:var(--long)}
.adv-score-ring.high{color:var(--long)}
.adv-score-ring.high::before{border-color:var(--long)}
.adv-score-ring.medium{color:var(--amber)}
.adv-score-ring.medium::before{border-color:var(--amber)}
.adv-score-ring.low{color:var(--text3)}

/* FILTERED SIGNALS SECTION */
.filtered-section{padding:8px 10px;background:var(--bg3);border-top:1px solid var(--border);cursor:pointer}
.filtered-section:hover{background:var(--bg4)}
.filtered-header{display:flex;align-items:center;justify-content:space-between;font-size:11px;color:var(--text3)}
.filtered-count{color:var(--short);font-weight:700}
.filtered-list{display:none;margin-top:8px;padding-top:8px;border-top:1px solid var(--border)}
.filtered-list.show{display:block}
.filtered-item{font-size:10px;padding:4px 6px;background:var(--short-dim);border-radius:4px;margin-bottom:4px;color:var(--short)}

/* ENV PANEL SECTION */
.env-panel{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px}
.env-panel-title{font-size:12px;font-weight:700;color:var(--cyan);margin-bottom:10px;padding-bottom:6px;border-bottom:1px solid var(--border)}
.env-row{display:flex;justify-content:space-between;align-items:center;padding:4px 0;font-size:11px}
.env-row .label{color:var(--text3)}

/* BACKTEST PANEL - COLLAPSIBLE */
/* COMBINED PANELS ROW - SIDE BY SIDE 50/50 */
.panels-row{display:flex;flex-direction:row;gap:4px;padding:4px;background:var(--bg2);border-bottom:1px solid var(--border);flex-wrap:nowrap}
.panels-row .panel-half{flex:1 1 50%;min-width:0;max-width:50%;background:var(--bg3);border-radius:6px;border:1px solid var(--border);overflow:hidden}
.panel-half .panel-header{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;cursor:pointer;user-select:none;background:var(--bg3)}
.panel-half .panel-header:active{background:var(--bg4)}
.panel-half .panel-title{display:flex;align-items:center;gap:4px;font-size:11px;font-weight:700}
.panel-half .panel-title.flow-color{color:var(--amber)}
.panel-half .panel-title.backtest-color{color:var(--cyan)}
.panel-half .panel-toggle{font-size:14px;color:var(--text3);transition:transform 0.3s}
.panel-half .panel-toggle.expanded{transform:rotate(180deg)}
.panel-half .panel-content{max-height:0;overflow:hidden;transition:max-height 0.3s ease-out}
.panel-half .panel-content.expanded{max-height:400px;overflow-y:auto}

/* FLOW PANEL - COMPACT */
.flow-grid-compact{display:grid;grid-template-columns:1fr 1fr;gap:3px;padding:6px}
.flow-item-compact{text-align:center;padding:5px 3px;background:var(--bg4);border-radius:4px}
.flow-item-compact .flow-label{font-size:7px;color:var(--text3);margin-bottom:1px;text-transform:uppercase;white-space:nowrap}
.flow-item-compact .flow-value{font-size:10px;font-weight:700;color:var(--text);white-space:nowrap}
.flow-item-compact .flow-change{font-size:8px;margin-top:1px;white-space:nowrap}
.flow-item-compact .flow-change.up{color:var(--long)}
.flow-item-compact .flow-change.down{color:var(--short)}
.flow-verdict-compact{display:flex;align-items:center;justify-content:center;gap:4px;padding:5px;background:var(--bg4);border-top:1px solid var(--border)}
.flow-verdict-compact .label{font-size:8px;color:var(--text3)}
.flow-verdict-compact .value{font-size:9px;font-weight:700;padding:2px 6px;border-radius:3px}
.flow-verdict-compact .value.bullish{background:var(--long-dim);color:var(--long)}
.flow-verdict-compact .value.bearish{background:var(--short-dim);color:var(--short)}
.flow-verdict-compact .value.squeeze{background:var(--amber-dim);color:var(--amber)}
.flow-verdict-compact .value.neutral{background:var(--bg3);color:var(--text2)}

/* BACKTEST PANEL - COMPACT */
.backtest-controls-compact{display:flex;flex-direction:column;gap:3px;padding:5px}
.backtest-controls-row{display:flex;gap:3px}
.backtest-select-compact{flex:1;background:var(--bg4);border:1px solid var(--border);color:var(--text);padding:4px 4px;border-radius:3px;font-size:9px;min-width:0}
.backtest-run-compact{background:var(--cyan);color:var(--bg);border:none;padding:4px 8px;border-radius:3px;font-size:9px;font-weight:700;cursor:pointer;white-space:nowrap}
.backtest-run-compact:hover{background:var(--long)}
.backtest-run-compact:disabled{background:var(--bg4);color:var(--text3);cursor:not-allowed}
.backtest-results-compact{padding:5px;font-size:9px}
.backtest-results-compact .backtest-summary{display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-bottom:5px}
.backtest-results-compact .backtest-stat{background:var(--bg4);padding:5px;border-radius:4px}
.backtest-results-compact .backtest-stat-label{font-size:7px;color:var(--text3);margin-bottom:1px}
.backtest-results-compact .backtest-stat-value{font-size:11px;font-weight:700}
.backtest-results-compact .backtest-stat-value.positive{color:var(--long)}
.backtest-results-compact .backtest-stat-value.negative{color:var(--short)}
.backtest-results-compact .backtest-grade-row{display:flex;align-items:center;justify-content:space-between;padding:3px 5px;background:var(--bg4);border-radius:3px;margin-bottom:2px;font-size:8px}
.backtest-results-compact .grade-name{font-weight:700}
.backtest-results-compact .win-rate{color:var(--long);font-weight:600}
.backtest-results-compact .pnl.positive{color:var(--long)}
.backtest-results-compact .pnl.negative{color:var(--short)}
.backtest-empty{text-align:center;padding:10px;color:var(--text3);font-size:8px}
.backtest-empty .icon{font-size:14px;margin-bottom:3px}

/* Hide old panels - kept for backwards compatibility */
.backtest-panel{display:none}
.flow-panel{display:none}

/* Legacy support classes */
.backtest-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;cursor:pointer;user-select:none}
.backtest-header:hover{background:var(--bg3)}
.backtest-title{display:flex;align-items:center;gap:8px;font-size:12px;font-weight:700;color:var(--cyan)}
.backtest-toggle{font-size:14px;color:var(--text3);transition:transform 0.3s}
.backtest-toggle.expanded{transform:rotate(180deg)}
.backtest-content{max-height:0;overflow:hidden;transition:max-height 0.3s ease-out}
.backtest-content.expanded{max-height:600px;overflow-y:auto}
.backtest-controls{display:flex;flex-wrap:wrap;gap:8px;padding:10px 12px;background:var(--bg3);border-top:1px solid var(--border)}
.backtest-select{background:var(--bg4);border:1px solid var(--border);color:var(--text);padding:6px 10px;border-radius:4px;font-size:11px}
.backtest-run{background:var(--cyan);color:var(--bg);border:none;padding:6px 16px;border-radius:4px;font-size:11px;font-weight:700;cursor:pointer}
.backtest-run:hover{background:var(--long)}
.backtest-run:disabled{background:var(--bg4);color:var(--text3);cursor:not-allowed}
.backtest-results{padding:10px 12px}
.backtest-summary{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px}
.backtest-stat{background:var(--bg3);padding:10px;border-radius:6px;border:1px solid var(--border)}
.backtest-stat-label{font-size:10px;color:var(--text3);margin-bottom:4px}
.backtest-stat-value{font-size:16px;font-weight:700}
.backtest-stat-value.positive{color:var(--long)}
.backtest-stat-value.negative{color:var(--short)}
.backtest-stat-value.neutral{color:var(--text)}
.backtest-grades{margin-bottom:12px}
.backtest-grade-row{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:var(--bg3);border-radius:4px;margin-bottom:6px;font-size:11px}
.backtest-grade-row .grade-name{font-weight:700}
.backtest-grade-row .grade-stats{display:flex;gap:12px;color:var(--text2)}
.backtest-grade-row .win-rate{color:var(--long);font-weight:700}
.backtest-grade-row .pnl.positive{color:var(--long)}
.backtest-grade-row .pnl.negative{color:var(--short)}
.backtest-insights{background:var(--bg3);padding:10px;border-radius:6px;border:1px solid var(--border)}
.backtest-insight{display:flex;align-items:center;gap:8px;font-size:11px;padding:4px 0;color:var(--text2)}
.backtest-insight .icon{font-size:14px}
.backtest-insight .highlight{color:var(--long);font-weight:700}
.backtest-insight .lowlight{color:var(--short);font-weight:700}
.backtest-loading{text-align:center;padding:30px;color:var(--text3)}
.backtest-loading .spinner{font-size:24px;animation:spin 1s linear infinite}
@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}

/* Legacy flow panel CSS - hidden but kept for compatibility */
.flow-panel{display:none;background:var(--bg2);border-bottom:1px solid var(--border)}
.flow-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;cursor:pointer;user-select:none}
.flow-header:hover{background:var(--bg3)}
.flow-title{display:flex;align-items:center;gap:8px;font-size:12px;font-weight:700;color:var(--amber)}
.flow-status{font-size:10px;font-weight:400;padding:2px 6px;border-radius:3px;margin-left:8px}
.flow-status.bullish{background:var(--long-dim);color:var(--long)}
.flow-status.bearish{background:var(--short-dim);color:var(--short)}
.flow-status.neutral{background:var(--amber-dim);color:var(--amber)}
.flow-toggle{font-size:14px;color:var(--text3);transition:transform 0.3s}
.flow-toggle.expanded{transform:rotate(180deg)}
.flow-content{max-height:0;overflow:hidden;transition:max-height 0.3s ease-out}
.flow-content.expanded{max-height:200px}
.flow-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;padding:10px 12px;background:var(--bg3)}
.flow-item{text-align:center;padding:8px 4px;background:var(--bg4);border-radius:6px;border:1px solid var(--border)}
.flow-label{font-size:9px;color:var(--text3);margin-bottom:4px;text-transform:uppercase}
.flow-value{font-size:13px;font-weight:700;color:var(--text)}
.flow-change{font-size:10px;margin-top:2px}
.flow-change.up{color:var(--long)}
.flow-change.down{color:var(--short)}
.flow-change.neutral{color:var(--text3)}
.flow-verdict{display:flex;align-items:center;justify-content:center;gap:8px;padding:8px 12px;background:var(--bg4);border-top:1px solid var(--border)}
.flow-verdict-label{font-size:10px;color:var(--text3);text-transform:uppercase}
.flow-verdict-value{font-size:12px;font-weight:700;padding:4px 12px;border-radius:4px}
.flow-verdict-value.bullish{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}
.flow-verdict-value.bearish{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.flow-verdict-value.squeeze{background:var(--amber-dim);color:var(--amber);border:1px solid var(--amber)}
.flow-verdict-value.neutral{background:var(--bg3);color:var(--text2);border:1px solid var(--border)}

.env-row .value{font-weight:600}
.env-row .value.ok{color:var(--long)}
.env-row .value.warn{color:var(--amber)}
.env-row .value.bad{color:var(--short)}
.env-row .points{font-size:10px;color:var(--text3);margin-left:6px}
.env-divider{height:1px;background:var(--border);margin:8px 0}
.env-total{display:flex;justify-content:space-between;align-items:center;padding:8px 0;font-size:13px;font-weight:700}
.env-total .score{font-size:16px}
.env-total .score.go{color:var(--long)}
.env-total .score.caution{color:var(--amber)}
.env-total .score.risky{color:#ff8c00}
.env-total .score.nogo{color:var(--short)}

/* AI ENV VERDICT */
.ai-env-verdict{padding:8px;background:var(--bg4);border-radius:6px;margin-top:8px;font-size:11px}
.ai-env-verdict.agree{border-left:3px solid var(--long)}
.ai-env-verdict.warn{border-left:3px solid var(--amber)}
.ai-env-verdict.disagree{border-left:3px solid var(--short)}

/* SCAN PROGRESS BAR - LONGER & GLOWING */
.scan-progress-bar{display:none;flex:1;align-items:center;gap:6px}
.scan-progress-bar.active{display:flex}
.scan-progress-track{flex:1;height:6px;background:var(--bg4);border-radius:3px;overflow:hidden;box-shadow:inset 0 0 3px rgba(0,0,0,0.3)}
.scan-progress-fill{height:100%;border-radius:3px;transition:width 0.3s;background:var(--amber)}
.scan-progress-fill.scanning{background:linear-gradient(90deg,rgba(255,100,100,0.9),rgba(255,180,100,0.9),rgba(255,255,100,0.9),rgba(100,255,100,0.9),rgba(100,255,255,0.9),rgba(100,180,255,0.9),rgba(180,100,255,0.9),rgba(255,100,255,0.9),rgba(255,100,180,0.9),rgba(255,100,100,0.9));background-size:200% 100%;animation:rainbowFlow 2s linear infinite;box-shadow:0 0 8px rgba(200,200,255,0.3),0 0 15px rgba(100,200,255,0.2)}
.scan-progress-fill.done{background:linear-gradient(90deg,var(--long),rgba(0,255,170,0.8),var(--cyan),rgba(0,255,170,0.8),var(--long));background-size:200% 100%;animation:completePulse 3s ease-in-out infinite;box-shadow:0 0 10px var(--long),0 0 20px rgba(0,255,170,0.3)}
.scan-progress-fill.error{background:linear-gradient(90deg,var(--short),rgba(255,107,107,0.8),rgba(255,71,87,0.8),rgba(255,107,107,0.8),var(--short));background-size:200% 100%;animation:errorPulse 1.5s ease-in-out infinite;box-shadow:0 0 10px var(--short),0 0 20px rgba(255,71,87,0.3)}
@keyframes errorPulse{0%,100%{background-position:0% 50%;box-shadow:0 0 8px var(--short)}50%{background-position:100% 50%;box-shadow:0 0 15px var(--short)}}
.scan-progress-text.error{color:var(--short)}
.scan-progress-pct.error{color:var(--short)}
@keyframes rainbowFlow{0%{background-position:0% 50%}100%{background-position:200% 50%}}
@keyframes completePulse{0%,100%{background-position:0% 50%;box-shadow:0 0 10px var(--long)}50%{background-position:100% 50%;box-shadow:0 0 20px var(--long),0 0 30px var(--cyan)}}
.scan-progress-text{font-size:10px;color:var(--amber);white-space:nowrap}
.scan-progress-text.done{color:var(--long)}
@keyframes scanGlow{0%,100%{box-shadow:0 0 5px var(--amber),0 0 10px rgba(247,166,0,0.4)}50%{box-shadow:0 0 8px var(--amber),0 0 15px rgba(247,166,0,0.5)}}

/* GLOW RADAR ICON */
.glow-radar{color:var(--gold);text-shadow:0 0 10px var(--gold),0 0 20px var(--gold),0 0 30px rgba(255,215,0,0.5);animation:radarPulse 2s ease-in-out infinite}
@keyframes radarPulse{0%,100%{transform:scale(1);opacity:1}50%{transform:scale(1.1);opacity:0.8}}

/* RAINBOW CIRCLE SPINNER WITH TEXT INSIDE */
.rainbow-circle-container{
    width:120px;
    height:120px;
    position:relative;
    margin:0 auto 10px;
}
.rainbow-circle-ring{
    position:absolute;
    top:0;left:0;right:0;bottom:0;
    border-radius:50%;
    border:4px solid transparent;
    background:linear-gradient(var(--bg2),var(--bg2)) padding-box,
               conic-gradient(from 0deg,
                   rgba(255,100,100,0.8),
                   rgba(255,180,100,0.8),
                   rgba(255,255,100,0.8),
                   rgba(100,255,100,0.8),
                   rgba(100,255,255,0.8),
                   rgba(100,180,255,0.8),
                   rgba(180,100,255,0.8),
                   rgba(255,100,255,0.8),
                   rgba(255,100,180,0.8),
                   rgba(255,100,100,0.8)
               ) border-box;
    animation:rainbowSpin 2s linear infinite, gentleFlash 1s ease-in-out infinite;
    box-shadow:0 0 15px rgba(100,200,255,0.3),0 0 30px rgba(255,100,200,0.2);
}
.rainbow-circle-inner{
    position:absolute;
    top:8px;left:8px;right:8px;bottom:8px;
    border-radius:50%;
    background:var(--bg2);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    padding:8px;
}
.rainbow-circle-coin{
    font-size:14px;
    font-weight:700;
    color:var(--cyan);
    text-shadow:0 0 5px rgba(0,200,255,0.5);
}
.rainbow-circle-tf{
    font-size:11px;
    font-weight:600;
    color:var(--amber);
}
.rainbow-circle-count{
    font-size:10px;
    color:var(--text2);
    margin-top:2px;
}
.rainbow-circle-pct{
    font-size:16px;
    font-weight:700;
    color:var(--gold);
    text-shadow:0 0 5px rgba(255,200,0,0.4);
}
@keyframes rainbowSpin{
    0%{transform:rotate(0deg)}
    100%{transform:rotate(360deg)}
}
@keyframes gentleFlash{
    0%,100%{opacity:1}
    50%{opacity:0.7}
}

/* SIMPLE SCANNING TEXT */
.scan-text-glow{
    color:var(--cyan);
    text-shadow:0 0 5px rgba(0,200,255,0.5);
    font-weight:600;
}
.scan-text-amber{
    color:var(--amber);
    text-shadow:0 0 5px rgba(255,180,0,0.4);
    font-weight:600;
}

/* CONTENT LAYOUT */
.content{display:flex;flex-direction:column;flex:1}
@media(min-width:900px){.content{flex-direction:row}.sidebar{width:380px;border-right:1px solid var(--border)}.main{flex:1}}
.sidebar{background:var(--bg2);display:flex;flex-direction:column;max-height:55vh}
@media(min-width:900px){.sidebar{max-height:none;height:calc(100vh - 52px)}}

/* SIDEBAR TOP */
.sidebar-top{padding:10px;border-bottom:1px solid var(--border)}
.mode-row{display:flex;gap:4px;margin-bottom:8px}
.mode-btn{flex:1;padding:8px 4px;border:1px solid var(--border);border-radius:5px;background:transparent;color:var(--text2);font-size:11px;font-weight:600;cursor:pointer;transition:all 0.2s}
.mode-btn.active{background:var(--purple);border-color:var(--purple);color:white}
.mode-btn:hover:not(.active){background:var(--bg4)}

/* V11-CLEAN: DIRECTION TABS - COMPACT SIZE */
.direction-tabs{display:flex;gap:4px;margin-bottom:3px}
.dir-tab{flex:1;background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:6px 8px;cursor:pointer;transition:all 0.3s}
.dir-tab.long{border-color:rgba(0,217,160,0.3)}
.dir-tab.long.active{border-color:var(--long);background:var(--long-dim);box-shadow:0 0 10px rgba(0,217,160,0.2)}
.dir-tab.short{border-color:rgba(255,71,87,0.3)}
.dir-tab.short.active{border-color:var(--short);background:var(--short-dim);box-shadow:0 0 10px rgba(255,71,87,0.2)}
.dir-tab-header{display:flex;align-items:center;gap:4px;justify-content:center;flex-wrap:nowrap}
.dir-tab-icon{font-size:12px}
.dir-tab-label{font-weight:700;font-size:11px}
.dir-tab.long .dir-tab-label{color:var(--long)}
.dir-tab.short .dir-tab-label{color:var(--short)}
.dir-tab-count{background:var(--bg4);padding:1px 6px;border-radius:8px;font-size:10px;font-weight:700}
.dir-tab.long.active .dir-tab-count{background:var(--long);color:#000}
.dir-tab.short.active .dir-tab-count{background:var(--short);color:#fff}
.dir-tab-saved{font-size:9px;color:var(--cyan);padding:1px 4px;background:var(--cyan-dim);border-radius:3px}
.dir-tab-arrow{font-size:8px;color:var(--text3);transition:transform 0.3s;margin-left:2px}
.dir-tab-arrow.open{transform:rotate(180deg)}

/* SAVED DROPDOWN */
.saved-dropdown{background:var(--bg2);border:1px solid var(--border);border-radius:8px;margin-bottom:8px;overflow:hidden;animation:slideDown 0.3s ease}
@keyframes slideDown{from{opacity:0;max-height:0}to{opacity:1;max-height:300px}}
.saved-dropdown-header{padding:8px 12px;background:var(--bg3);font-size:11px;font-weight:700;color:var(--cyan);border-bottom:1px solid var(--border)}
.saved-dropdown-list{max-height:200px;overflow-y:auto;padding:8px}
.saved-dropdown .saved-empty{text-align:center;color:var(--text3);font-size:11px;padding:12px}

/* SAVED TRADE MINI CARD */
.saved-mini-card{display:flex;align-items:center;gap:8px;padding:8px 10px;background:var(--bg3);border-radius:6px;margin-bottom:6px;border-left:3px solid var(--border);cursor:pointer;transition:all 0.2s}
.saved-mini-card:hover{background:var(--bg4);transform:translateX(2px)}
.saved-mini-card.long{border-left-color:var(--long)}
.saved-mini-card.short{border-left-color:var(--short)}
.saved-mini-card .smc-pair{font-weight:700;font-size:12px;min-width:60px}
.saved-mini-card .smc-entry{font-size:10px;color:var(--text3);font-family:monospace}
.saved-mini-card .smc-pnl{font-size:11px;font-weight:700;padding:2px 6px;border-radius:4px;margin-left:auto}
.saved-mini-card .smc-pnl.profit{background:var(--long-dim);color:var(--long)}
.saved-mini-card .smc-pnl.loss{background:var(--short-dim);color:var(--short)}
.saved-mini-card .smc-status{font-size:10px}
.saved-mini-card .smc-actions{display:flex;gap:4px}
.saved-mini-card .smc-btn{padding:4px 8px;border-radius:4px;font-size:9px;border:1px solid var(--border);background:var(--bg4);color:var(--text2);cursor:pointer}
.saved-mini-card .smc-btn:hover{background:var(--bg3)}
.saved-mini-card .smc-btn.delete{border-color:var(--short);color:var(--short)}
.saved-mini-card .smc-btn.delete:hover{background:var(--short);color:#fff}

.filter-row{display:flex;gap:4px}
.filter-btn{flex:1;padding:6px 4px;border:1px solid var(--border);border-radius:4px;background:transparent;color:var(--text3);font-size:12px;cursor:pointer;transition:all 0.2s}
.filter-btn.active{background:var(--bg4);color:var(--text);border-color:var(--text3)}
.filter-btn .count{margin-left:3px;color:var(--cyan)}

/* SIGNAL LIST */
.signal-list{flex:1;overflow-y:auto;padding:8px}
.signal-card{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:8px;cursor:pointer;transition:all 0.3s}
.signal-card:hover{transform:translateX(2px)}
.signal-card.active{border-color:var(--gold);background:var(--gold-dim)}

/* GLOWING EFFECTS - LONG/SHORT */
.signal-card.long{border-left:3px solid var(--long);box-shadow:0 0 12px rgba(0,217,160,0.2),inset 0 0 20px rgba(0,217,160,0.05)}
.signal-card.long:hover{box-shadow:0 0 20px rgba(0,217,160,0.4),inset 0 0 30px rgba(0,217,160,0.1)}
.signal-card.short{border-left:3px solid var(--short);box-shadow:0 0 12px rgba(255,71,87,0.2),inset 0 0 20px rgba(255,71,87,0.05)}
.signal-card.short:hover{box-shadow:0 0 20px rgba(255,71,87,0.4),inset 0 0 30px rgba(255,71,87,0.1)}

/* GLOWING GRADE BADGES */
.signal-card.long.grade-perfect{box-shadow:0 0 15px rgba(0,217,160,0.3),0 0 25px rgba(255,215,0,0.3)}
.signal-card.short.grade-perfect{box-shadow:0 0 15px rgba(255,71,87,0.3),0 0 25px rgba(255,215,0,0.3)}
.signal-card.long.grade-strong{box-shadow:0 0 15px rgba(0,217,160,0.35)}
.signal-card.short.grade-strong{box-shadow:0 0 15px rgba(255,71,87,0.35)}
.signal-card.long.grade-valid{box-shadow:0 0 12px rgba(0,217,160,0.25),0 0 20px rgba(59,130,246,0.2)}
.signal-card.short.grade-valid{box-shadow:0 0 12px rgba(255,71,87,0.25),0 0 20px rgba(59,130,246,0.2)}
.signal-card.long.grade-heating{box-shadow:0 0 10px rgba(0,217,160,0.2),0 0 15px rgba(245,158,11,0.2)}
.signal-card.short.grade-heating{box-shadow:0 0 10px rgba(255,71,87,0.2),0 0 15px rgba(245,158,11,0.2)}
.signal-card.grade-brewing{box-shadow:0 0 8px rgba(168,85,247,0.15)}

/* 3/3 AGREEMENT EXTRA GLOW */
.signal-card.full-agree{animation:pulseGlow 2s ease-in-out infinite}
@keyframes pulseGlow{0%,100%{filter:brightness(1)}50%{filter:brightness(1.1)}}

.signal-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.signal-pair{font-weight:700;font-size:14px;display:flex;align-items:center;gap:5px}
.dir-tag{font-size:12px;font-weight:700;padding:2px 6px;border-radius:3px}
.dir-tag.long{background:var(--long-dim);color:var(--long);box-shadow:0 0 8px rgba(0,217,160,0.3)}
.dir-tag.short{background:var(--short-dim);color:var(--short);box-shadow:0 0 8px rgba(255,71,87,0.3)}
.tf-tag{font-size:12px;padding:2px 6px;border-radius:3px;background:var(--bg4);border:1px solid var(--cyan);color:var(--cyan)}

/* GLOWING GRADE BADGES */
.grade{font-size:12px;font-weight:700;padding:4px 8px;border-radius:4px}
.grade.perfect{background:linear-gradient(135deg,var(--gold),#ffaa00);color:#000;box-shadow:0 0 15px rgba(255,215,0,0.5);animation:goldPulse 1.5s ease-in-out infinite}
@keyframes goldPulse{0%,100%{box-shadow:0 0 15px rgba(255,215,0,0.5)}50%{box-shadow:0 0 25px rgba(255,215,0,0.8)}}
.grade.strong{background:var(--long);color:#000;box-shadow:0 0 12px rgba(0,217,160,0.4)}
.grade.valid{background:var(--blue);color:white;box-shadow:0 0 10px rgba(59,130,246,0.4)}
.grade.heating{background:var(--amber);color:#000;box-shadow:0 0 10px rgba(245,158,11,0.4)}
.grade.brewing{background:var(--purple-dim);color:var(--purple);border:1px solid var(--purple);box-shadow:0 0 8px rgba(168,85,247,0.3)}
.signal-meta{display:flex;gap:6px;font-size:12px;color:var(--text2);margin-bottom:5px}
.signal-scores{display:flex;gap:3px;flex-wrap:wrap}
.score-tag{font-size:12px;padding:2px 5px;border-radius:3px;background:var(--bg4);color:var(--text2);font-family:monospace}
.score-tag.good{color:var(--long);text-shadow:0 0 5px rgba(0,217,160,0.5)}
.score-tag.mid{color:var(--amber);text-shadow:0 0 5px rgba(245,158,11,0.5)}
.score-tag.low{color:var(--short);text-shadow:0 0 5px rgba(255,71,87,0.5)}

/* STATUS BADGES */
.status-badge{font-size:11px;font-weight:700;padding:2px 5px;border-radius:3px;margin-left:4px}
.status-badge.new{background:var(--cyan-dim);color:var(--cyan);box-shadow:0 0 8px rgba(6,182,212,0.4)}
.status-badge.up{background:var(--long-dim);color:var(--long)}
.status-badge.down{background:var(--short-dim);color:var(--short)}
.status-badge.gone{background:var(--bg4);color:var(--text3);text-decoration:line-through}

/* MAIN PANEL */
.main{padding:12px;overflow-y:auto;background:var(--bg1)}
@media(min-width:900px){.main{height:calc(100vh - 52px)}}
.detail-box{background:var(--bg2);border:1px solid var(--border);border-radius:10px;padding:14px}
.detail-header{display:flex;justify-content:space-between;align-items:center;padding-bottom:12px;border-bottom:1px solid var(--border);margin-bottom:12px;flex-wrap:wrap;gap:8px}
.detail-title{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.detail-pair{font-size:22px;font-weight:700}
.detail-price{text-align:right}
.detail-price-label{font-size:12px;color:var(--text2)}
.detail-price-value{font-size:18px;font-weight:700;font-family:monospace}

/* HTF BOX */
.htf-box{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:12px}
.htf-title{font-size:11px;color:var(--text2);margin-bottom:8px;display:flex;align-items:center;gap:6px}
.htf-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:6px}
.htf-item{text-align:center;padding:6px 4px;background:var(--bg4);border-radius:5px}
.htf-label{font-size:12px;color:var(--text3)}
.htf-value{font-size:11px;font-weight:700}
.htf-value.bull{color:var(--long)}
.htf-value.bear{color:var(--short)}
.htf-value.neutral{color:var(--text3)}

/* AI SECTION */
.ai-section{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:14px;margin-bottom:12px}
.ai-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
.ai-title{font-size:13px;font-weight:700;display:flex;align-items:center;gap:6px}
.ai-verdict{font-size:11px;font-weight:700;padding:4px 12px;border-radius:4px}
.ai-verdict.take{background:var(--long-dim);color:var(--long)}
.ai-verdict.skip{background:var(--short-dim);color:var(--short)}
.ai-verdict.wait{background:var(--amber-dim);color:var(--amber)}
.ai-bar{height:8px;background:var(--bg2);border-radius:4px;overflow:hidden;margin-bottom:8px}
.ai-fill{height:100%;border-radius:4px;transition:width 0.3s}
.ai-text{font-size:11px;color:var(--text2);line-height:1.5;margin-bottom:8px}
.ai-risks{font-size:12px;color:var(--amber);margin-bottom:8px}
.ai-btn{width:100%;padding:10px;background:linear-gradient(135deg,#f55036,#ff6b4a);border:none;color:white;border-radius:6px;font-size:12px;font-weight:700;cursor:pointer}
.ai-btn:hover{opacity:0.9}

/* ANALYSIS GRID */
.analysis-grid{display:grid;grid-template-columns:1fr;gap:10px;margin-bottom:12px}
@media(min-width:600px){.analysis-grid{grid-template-columns:repeat(3,1fr)}}
.analysis-card{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px}
.analysis-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.analysis-title{font-size:11px;color:var(--text2)}
.analysis-score{font-family:monospace;font-weight:700;padding:3px 8px;border-radius:4px;font-size:12px}
.analysis-row{display:flex;justify-content:space-between;font-size:12px;padding:3px 0;border-bottom:1px solid var(--border)}
.analysis-row:last-child{border-bottom:none}
.analysis-label{color:var(--text2)}
.analysis-value{font-family:monospace;font-weight:600}
.factor-list{display:flex;flex-wrap:wrap;gap:3px;margin-top:8px}
.factor{font-size:12px;padding:2px 5px;border-radius:3px;background:var(--bg4);color:var(--text2)}
.factor.bull{background:var(--long-dim);color:var(--long)}
.factor.bear{background:var(--short-dim);color:var(--short)}
.factor.warn{background:var(--amber-dim);color:var(--amber)}

/* TRADE SECTION */
.trade-section{margin-bottom:12px}
.trade-title{font-size:12px;font-weight:600;margin-bottom:10px;color:var(--text2)}
.trade-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:6px}
@media(max-width:600px){.trade-grid{grid-template-columns:repeat(3,1fr)}}
@media(max-width:400px){.trade-grid{grid-template-columns:repeat(2,1fr)}}
.trade-box{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:8px 4px;text-align:center}
.trade-box-label{font-size:12px;color:var(--text3);margin-bottom:2px}
.trade-box-value{font-family:monospace;font-size:12px;font-weight:600;word-break:break-all}
.trade-box.entry{border-color:var(--cyan)}.trade-box.entry .trade-box-value{color:var(--cyan)}
.trade-box.limit{border-color:var(--purple);background:var(--purple-dim)}.trade-box.limit .trade-box-value{color:var(--purple)}
.trade-box.limit .limit-type{font-size:9px;color:var(--purple);font-weight:700;margin-top:2px}
.trade-box.sl{border-color:var(--short)}.trade-box.sl .trade-box-value{color:var(--short)}
.trade-box.tp{border-color:var(--long)}.trade-box.tp .trade-box-value{color:var(--long)}
.trade-meta{display:flex;justify-content:space-between;align-items:center;margin-top:10px}
.rr-tag{background:var(--purple-dim);color:var(--purple);padding:5px 12px;border-radius:5px;font-size:11px;font-weight:600}
.track-btn{padding:10px 20px;background:var(--amber-dim);border:1px solid var(--amber);color:var(--amber);border-radius:6px;font-size:12px;font-weight:600;cursor:pointer}
.track-btn:hover{background:var(--amber);color:#000}

/* ACTIVE TRADES */
.active-section{border-top:1px solid var(--border);padding:10px;background:var(--bg1)}
.active-title{font-size:11px;font-weight:700;margin-bottom:8px;display:flex;align-items:center;gap:6px}
.active-count{background:var(--purple);color:white;font-size:12px;padding:2px 6px;border-radius:8px}
.active-list{max-height:150px;overflow-y:auto}
.active-card{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:6px}
.active-card.long{border-left:3px solid var(--long)}
.active-card.short{border-left:3px solid var(--short)}
.active-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
.active-pair{font-weight:700;font-size:12px;display:flex;align-items:center;gap:5px}
.active-pnl{font-family:monospace;font-size:11px;font-weight:700;padding:2px 6px;border-radius:4px}
.active-pnl.profit{background:var(--long-dim);color:var(--long)}
.active-pnl.loss{background:var(--short-dim);color:var(--short)}
.active-levels{display:grid;grid-template-columns:repeat(5,1fr);gap:3px;margin-bottom:4px}
.active-level{text-align:center;padding:3px;background:var(--bg4);border-radius:3px}
.active-level-label{font-size:11px;color:var(--text3)}
.active-level-value{font-family:monospace;font-size:12px}
.active-level.hit{background:var(--long-dim);border:1px solid var(--long)}
.active-level.stopped{background:var(--short-dim);border:1px solid var(--short)}
.active-meta{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--text3)}
.close-btn{padding:3px 8px;background:var(--bg4);border:1px solid var(--border);color:var(--text2);border-radius:3px;font-size:12px;cursor:pointer}
.close-btn:hover{background:var(--short-dim);border-color:var(--short);color:var(--short)}
.btn-history{padding:2px 6px;background:var(--purple-dim);border:1px solid var(--purple);color:var(--purple);border-radius:3px;font-size:10px;cursor:pointer;margin-left:auto}
.btn-history:hover{background:var(--purple);color:#fff}

/* SAVED TRADES */
.saved-section{border-top:1px solid var(--border);padding:10px;background:linear-gradient(135deg, var(--bg1) 0%, rgba(0,200,255,0.05) 100%)}
.saved-title{font-size:11px;font-weight:700;display:flex;justify-content:space-between;align-items:center;cursor:pointer;padding:4px 0;color:var(--cyan)}
.saved-title:hover{color:var(--gold)}
.saved-count{background:var(--cyan);color:var(--bg1);font-size:10px;padding:2px 6px;border-radius:8px;font-weight:700}
.saved-toggle{font-size:10px;transition:transform 0.2s}
.saved-toggle.open{transform:rotate(180deg)}
.saved-list{max-height:200px;overflow-y:auto;margin-top:8px}
.saved-card{background:var(--bg3);border:1px solid var(--cyan);border-radius:6px;padding:10px;margin-bottom:8px;position:relative}
.saved-card.long{border-left:3px solid var(--long)}
.saved-card.short{border-left:3px solid var(--short)}
.saved-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.saved-pair{font-weight:700;font-size:13px;color:var(--text)}
.saved-dir{font-size:10px;padding:2px 6px;border-radius:3px;font-weight:700}
.saved-dir.long{background:var(--long);color:#000}
.saved-dir.short{background:var(--short);color:#fff}
.saved-grade{font-size:10px;padding:2px 6px;border-radius:3px;font-weight:700;background:var(--gold);color:#000}
.saved-info{display:grid;grid-template-columns:repeat(4,1fr);gap:4px;margin-bottom:8px}
.saved-info-item{text-align:center;background:var(--bg4);border-radius:4px;padding:4px}
.saved-info-label{font-size:9px;color:var(--text3)}
.saved-info-value{font-size:11px;font-weight:600;font-family:monospace}
.saved-meta{display:flex;justify-content:space-between;align-items:center;font-size:10px;color:var(--text3)}
.saved-time{font-style:italic}
.saved-actions{display:flex;gap:6px}
.saved-btn{padding:4px 10px;border-radius:4px;font-size:10px;font-weight:600;cursor:pointer;border:1px solid}
.saved-btn.view{background:var(--cyan-dim);border-color:var(--cyan);color:var(--cyan)}
.saved-btn.view:hover{background:var(--cyan);color:#000}
.saved-btn.delete{background:var(--short-dim);border-color:var(--short);color:var(--short)}
.saved-btn.delete:hover{background:var(--short);color:#fff}
.save-btn{padding:10px 20px;background:var(--cyan-dim);border:1px solid var(--cyan);color:var(--cyan);border-radius:6px;font-size:12px;font-weight:600;cursor:pointer;margin-left:8px}
.save-btn:hover{background:var(--cyan);color:#000}
.tv-btn{padding:10px 20px;background:rgba(33,150,243,0.15);border:1px solid #2196F3;color:#2196F3;border-radius:6px;font-size:12px;font-weight:600;cursor:pointer;margin-left:8px;transition:all 0.2s}
.tv-btn:hover{background:#2196F3;color:#fff}


/* ═══════════════════════════════════════════════════════════════════════════════
   ENHANCED SAVED TRADES STYLES v2.0
   ═══════════════════════════════════════════════════════════════════════════════ */

/* Saved Trade Card - Enhanced */
.saved-card-enhanced {
    background: var(--bg3);
    border: 1px solid var(--border);
    border-radius: 8px;
    margin-bottom: 10px;
    overflow: hidden;
    transition: all 0.3s ease;
}
.saved-card-enhanced.long { border-left: 4px solid var(--long); }
.saved-card-enhanced.short { border-left: 4px solid var(--short); }
.saved-card-enhanced:hover { border-color: var(--cyan); }

/* Card Header */
.saved-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 12px;
    background: var(--bg4);
    border-bottom: 1px solid var(--border);
}
.saved-card-pair {
    font-weight: 700;
    font-size: 14px;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 8px;
}
.saved-card-dir {
    font-size: 10px;
    padding: 3px 8px;
    border-radius: 4px;
    font-weight: 700;
}
.saved-card-dir.long { background: var(--long); color: #000; }
.saved-card-dir.short { background: var(--short); color: #fff; }

/* Status Badge */
.saved-status-badge {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: 700;
}
.saved-status-badge.strong-profit { background: var(--long-dim); color: var(--long); }
.saved-status-badge.in-profit { background: var(--long-dim); color: var(--long); }
.saved-status-badge.tp-hit { background: var(--gold-dim); color: var(--gold); animation: pulse 1s infinite; }
.saved-status-badge.near-entry { background: var(--amber-dim); color: var(--amber); }
.saved-status-badge.small-loss { background: var(--amber-dim); color: var(--amber); }
.saved-status-badge.at-risk { background: var(--short-dim); color: var(--short); animation: pulse 0.5s infinite; }
.saved-status-badge.stopped-out { background: var(--short); color: #fff; }
.saved-status-badge.loading { background: var(--bg4); color: var(--text3); }

/* Row Container */
.saved-row {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
}
.saved-row:last-child { border-bottom: none; }

/* Row Label */
.saved-row-label {
    font-size: 10px;
    font-weight: 700;
    color: var(--text3);
    margin-bottom: 6px;
    display: flex;
    align-items: center;
    gap: 6px;
}
.saved-row-label .emoji { font-size: 12px; }

/* ROW 1: Original Data */
.saved-row.original {
    background: linear-gradient(90deg, rgba(59,130,246,0.05) 0%, transparent 100%);
}
.saved-original-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
}
.saved-original-item {
    background: var(--bg4);
    border-radius: 4px;
    padding: 6px;
    text-align: center;
}
.saved-original-item .label {
    font-size: 9px;
    color: var(--text3);
    margin-bottom: 2px;
}
.saved-original-item .value {
    font-size: 11px;
    font-weight: 600;
    font-family: 'Courier New', monospace;
}
.saved-original-item .value.entry { color: var(--cyan); }
.saved-original-item .value.sl { color: var(--short); }
.saved-original-item .value.tp { color: var(--long); }
.saved-original-item .value.rr { color: var(--purple); }

/* ROW 2: Live Progress */
.saved-row.live {
    background: linear-gradient(90deg, rgba(0,217,160,0.05) 0%, transparent 100%);
}
.saved-live-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}
.saved-live-price {
    font-size: 16px;
    font-weight: 700;
    font-family: 'Courier New', monospace;
}
.saved-live-pnl {
    font-size: 14px;
    font-weight: 700;
    padding: 4px 10px;
    border-radius: 4px;
}
.saved-live-pnl.profit { background: var(--long-dim); color: var(--long); }
.saved-live-pnl.loss { background: var(--short-dim); color: var(--short); }

/* Progress Bar */
.saved-progress-container {
    margin-top: 8px;
}
.saved-progress-bar {
    position: relative;
    height: 24px;
    background: var(--bg4);
    border-radius: 12px;
    overflow: visible;
    margin-bottom: 4px;
}
.saved-progress-fill {
    height: 100%;
    border-radius: 12px;
    transition: width 0.5s ease;
}
.saved-progress-fill.profit {
    background: linear-gradient(90deg, var(--long-dim), var(--long));
}
.saved-progress-fill.loss {
    background: linear-gradient(90deg, var(--short), var(--short-dim));
}
.saved-progress-fill.neutral {
    background: linear-gradient(90deg, var(--amber-dim), var(--amber));
}

/* Progress Markers */
.saved-progress-marker {
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 10px;
    font-weight: 700;
    padding: 2px 4px;
    border-radius: 3px;
    white-space: nowrap;
    z-index: 2;
}
.saved-progress-marker.current {
    background: transparent;
    color: var(--cyan);
    font-size: 14px;
    padding: 0;
    box-shadow: none;
    z-index: 3;
}

/* Progress Labels */
.saved-progress-labels {
    display: flex;
    justify-content: space-between;
    font-size: 9px;
    color: var(--text3);
    padding: 0 4px;
}

/* ROW 3: AI Interpretation */
.saved-row.ai {
    background: linear-gradient(90deg, rgba(168,85,247,0.05) 0%, transparent 100%);
}
.saved-ai-commentary {
    font-size: 12px;
    color: var(--text);
    line-height: 1.5;
    padding: 8px 10px;
    background: var(--bg4);
    border-radius: 6px;
    border-left: 3px solid var(--purple);
}
.saved-ai-suggestion {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-top: 8px;
    padding: 6px 10px;
    background: var(--long-dim);
    border: 1px solid var(--long);
    border-radius: 4px;
    font-size: 11px;
    color: var(--long);
}
.saved-ai-warning {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-top: 8px;
    padding: 6px 10px;
    background: var(--amber-dim);
    border: 1px solid var(--amber);
    border-radius: 4px;
    font-size: 11px;
    color: var(--amber);
}
.saved-ai-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px;
    color: var(--text3);
    font-size: 11px;
}
.saved-ai-btn {
    padding: 6px 12px;
    background: var(--purple-dim);
    border: 1px solid var(--purple);
    color: var(--purple);
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}
.saved-ai-btn:hover {
    background: var(--purple);
    color: #fff;
}

/* Card Actions */
.saved-card-actions {
    display: flex;
    gap: 6px;
    padding: 10px 12px;
    background: var(--bg4);
    border-top: 1px solid var(--border);
}
.saved-action-btn {
    flex: 1;
    padding: 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    border: 1px solid;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
}
.saved-action-btn.refresh {
    background: var(--cyan-dim);
    border-color: var(--cyan);
    color: var(--cyan);
}
.saved-action-btn.refresh:hover {
    background: var(--cyan);
    color: #000;
}
.saved-action-btn.details {
    background: var(--purple-dim);
    border-color: var(--purple);
    color: var(--purple);
}
.saved-action-btn.details:hover {
    background: var(--purple);
    color: #fff;
}
.saved-action-btn.delete {
    background: var(--short-dim);
    border-color: var(--short);
    color: var(--short);
    flex: 0.5;
}
.saved-action-btn.delete:hover {
    background: var(--short);
    color: #fff;
}

/* Last Updated */
.saved-last-updated {
    font-size: 9px;
    color: var(--text3);
    text-align: right;
    padding: 4px 12px;
    background: var(--bg4);
}

/* Enhanced saved list */
.saved-list-enhanced {
    max-height: 400px;
    overflow-y: auto;
    padding: 8px;
}

/* Empty state */
.saved-empty {
    text-align: center;
    padding: 20px;
    color: var(--text3);
}
.saved-empty-icon {
    font-size: 32px;
    margin-bottom: 8px;
}
.saved-empty-text {
    font-size: 12px;
}

/* Refresh All Button */
.saved-refresh-all {
    width: 100%;
    padding: 8px;
    background: var(--bg4);
    border: 1px dashed var(--border);
    border-radius: 6px;
    color: var(--text3);
    font-size: 11px;
    cursor: pointer;
    margin-bottom: 10px;
    transition: all 0.2s;
}
.saved-refresh-all:hover {
    background: var(--cyan-dim);
    border-color: var(--cyan);
    color: var(--cyan);
}
/* EMPTY & LOADING */
.empty{text-align:center;padding:40px 20px;color:var(--text2)}
.empty-icon{font-size:36px;margin-bottom:10px}
.spinner{width:24px;height:24px;border:3px solid var(--bg4);border-top-color:var(--gold);border-radius:50%;animation:spin 0.8s linear infinite;margin:0 auto 10px}
@keyframes spin{to{transform:rotate(360deg)}}
.scan-status{font-size:12px;color:var(--text3);margin-top:6px}

/* MODAL */
.modal-bg{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;z-index:1000;padding:10px}
.modal-bg.show{display:flex}
.modal{background:var(--bg2);border:1px solid var(--border);border-radius:12px;width:100%;max-width:500px;max-height:90vh;overflow:hidden}
.modal-head{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border-bottom:1px solid var(--border)}
.modal-title{font-size:14px;font-weight:700}
.modal-close{background:none;border:none;color:var(--text2);font-size:22px;cursor:pointer}
.modal-body{padding:14px;overflow-y:auto;max-height:60vh}
.form-group{margin-bottom:12px}
.form-label{font-size:12px;color:var(--text2);margin-bottom:4px;display:block}
.form-input,.form-select{width:100%;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px}
.form-row{display:flex;gap:8px;margin-top:6px}
.form-row .btn{flex:1}
.key-status{font-size:12px;padding:6px 10px;border-radius:5px;margin-bottom:12px}
.key-status.valid{background:var(--long-dim);color:var(--long)}
.key-status.invalid{background:var(--short-dim);color:var(--short)}

/* Key Status Grid */
.key-grid{display:grid;grid-template-columns:repeat(11,1fr);gap:4px;margin:10px 0;padding:8px;background:var(--bg4);border-radius:6px}
.key-slot{display:flex;flex-direction:column;align-items:center;padding:4px 2px;border-radius:4px;font-size:9px;background:var(--bg3)}
.key-slot.active{background:var(--long-dim);border:1px solid var(--long)}
.key-slot.error{background:var(--short-dim);border:1px solid var(--short)}
.key-slot.off{background:var(--bg4);opacity:0.4}
.key-slot.empty{background:var(--bg3);border:1px dashed var(--border)}
.key-slot-icon{font-size:12px}
.key-slot-label{color:var(--text3);font-size:8px}

/* Key Row with Toggle */
.key-row{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.key-row .form-input{flex:1}

/* Toggle Switch */
.toggle-switch{position:relative;width:32px;height:18px;flex-shrink:0}
.toggle-switch input{opacity:0;width:0;height:0}
.toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:var(--bg4);border-radius:18px;transition:0.3s}
.toggle-slider:before{position:absolute;content:"";height:12px;width:12px;left:3px;bottom:3px;background:var(--text3);border-radius:50%;transition:0.3s}
.toggle-switch input:checked+.toggle-slider{background:var(--long)}
.toggle-switch input:checked+.toggle-slider:before{transform:translateX(14px)}

/* Key Status Indicator */
.key-indicator{font-size:14px;width:20px;text-align:center;flex-shrink:0}

.modal-foot{padding:12px 14px;border-top:1px solid var(--border);display:flex;justify-content:flex-end;gap:8px}
.groq-info{background:var(--cyan-dim);border:1px solid var(--cyan);border-radius:6px;padding:10px;font-size:11px;color:var(--cyan);margin-bottom:12px}
.groq-info a{color:var(--cyan)}

/* TIMEFRAME & ALERT TOGGLES */
.tf-toggle{display:flex;align-items:center;justify-content:center;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;cursor:pointer;transition:all 0.2s}
.tf-toggle:has(input:checked){background:var(--long-dim);border-color:var(--long)}
.tf-toggle input{display:none}
.tf-toggle-label{font-size:13px;font-weight:700;color:var(--text)}
.tf-toggle:has(input:checked) .tf-toggle-label{color:var(--long)}
.alert-toggle{display:flex;align-items:center;gap:10px;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;cursor:pointer;margin-bottom:8px}
.alert-toggle:has(input:checked){background:var(--amber-dim);border-color:var(--amber)}
.alert-toggle input{width:18px;height:18px;accent-color:var(--amber)}
.alert-toggle-label{font-size:12px;color:var(--text)}

/* TOAST */
.toast-box{position:fixed;bottom:12px;right:12px;z-index:1100}
.toast{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:10px 14px;margin-top:6px;font-size:12px;animation:slideIn 0.3s}
.toast.success{border-color:var(--long);background:var(--long-dim)}
.toast.error{border-color:var(--short);background:var(--short-dim)}
.toast.warning{border-color:var(--amber);background:var(--amber-dim)}
@keyframes slideIn{from{opacity:0;transform:translateX(30px)}to{opacity:1;transform:translateX(0)}}

/* DASHBOARD STATS BAR */
.stats-bar{display:grid;grid-template-columns:repeat(6,1fr);gap:4px;padding:8px 6px;background:var(--bg2);border-bottom:1px solid var(--border)}
.stat-box{text-align:center;padding:6px 3px;background:var(--bg3);border-radius:6px;border:1px solid var(--border);transition:all 0.2s}
.stat-box:hover{background:var(--bg4);transform:scale(1.02)}
.stat-box:active{transform:scale(0.98)}
.stat-value{font-size:15px;font-weight:700;font-family:monospace}
.stat-value.long{color:var(--long);text-shadow:0 0 8px rgba(0,217,160,0.4)}
.stat-value.short{color:var(--short);text-shadow:0 0 8px rgba(255,71,87,0.4)}
.stat-value.gold{color:var(--gold);text-shadow:0 0 8px rgba(255,215,0,0.4)}
.stat-label{font-size:9px;color:var(--text3);margin-top:2px;font-weight:600;letter-spacing:0.5px}
/* Individual stat box styles */
.stat-box:nth-child(1){border-color:var(--cyan);border-width:1px 1px 2px 1px}
.stat-box:nth-child(1) .stat-value{color:var(--cyan)}
.stat-box:nth-child(2){border-color:#00ffcc;border-width:1px 1px 2px 1px;background:linear-gradient(180deg,var(--bg3) 0%,rgba(0,255,204,0.1) 100%)}
.stat-box:nth-child(2) .stat-label{color:#00ffcc}
.stat-box:nth-child(3){border-color:var(--gold);border-width:1px 1px 2px 1px;background:linear-gradient(180deg,var(--bg3) 0%,rgba(255,215,0,0.1) 100%)}
.stat-box:nth-child(3) .stat-label{color:var(--gold)}
.stat-box:nth-child(4){border-color:var(--long);border-width:1px 1px 2px 1px}
.stat-box:nth-child(4) .stat-label{color:var(--long)}
.stat-box:nth-child(5){border-color:var(--short);border-width:1px 1px 2px 1px}
.stat-box:nth-child(5) .stat-label{color:var(--short)}
.stat-box:nth-child(6){border-color:var(--amber);border-width:1px 1px 2px 1px}
.stat-box:nth-child(6) .stat-value{color:var(--amber)}
.stat-box:nth-child(6) .stat-label{color:var(--amber)}

/* COIN MANAGER */
.coin-manager{max-height:200px;overflow-y:auto;border:1px solid var(--border);border-radius:6px;padding:8px;background:var(--bg4)}
.coin-grid{display:flex;flex-wrap:wrap;gap:4px}
.coin-chip{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg3);border:1px solid var(--border);border-radius:4px;font-size:11px;font-weight:600}
.coin-chip .remove-coin{cursor:pointer;color:var(--short);font-weight:700}
.coin-chip .remove-coin:hover{color:#ff0000}
.add-coin-row{display:flex;gap:6px;margin-bottom:8px}
.add-coin-row input{flex:1;padding:8px;background:var(--bg4);border:1px solid var(--border);border-radius:4px;color:var(--text);font-size:12px;text-transform:uppercase}

/* HEAT MAP */
/* HEATMAP REMOVED IN V11-CLEAN */
.heat-cell{border-radius:4px;padding:4px 2px;font-weight:700;font-size:10px}
.heat-cell.long{background:var(--long-dim);color:var(--long);box-shadow:inset 0 0 10px rgba(0,217,160,0.3)}
.heat-cell.short{background:var(--short-dim);color:var(--short);box-shadow:inset 0 0 10px rgba(255,71,87,0.3)}
.heat-cell.none{background:var(--bg4);color:var(--text3)}
.heat-cell.perfect{box-shadow:0 0 8px rgba(255,215,0,0.5)}

/* RISK CALCULATOR */
.risk-calc{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px}
.risk-row{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
.risk-input{padding:8px;background:var(--bg4);border:1px solid var(--border);border-radius:4px;color:var(--text);font-size:12px;width:100%}
.risk-result{background:var(--long-dim);border:1px solid var(--long);border-radius:6px;padding:10px;text-align:center}
.risk-result-value{font-size:18px;font-weight:700;color:var(--long)}
.risk-result-label{font-size:11px;color:var(--text2)}

/* SIGNAL HISTORY */
.history-list{max-height:200px;overflow-y:auto}
.history-item{display:flex;justify-content:space-between;align-items:center;padding:8px;background:var(--bg3);border-radius:6px;margin-bottom:6px;border-left:3px solid var(--border)}
.history-item.win{border-left-color:var(--long);background:var(--long-dim)}
.history-item.loss{border-left-color:var(--short);background:var(--short-dim)}
.history-item.pending{border-left-color:var(--amber)}
.history-pnl{font-weight:700;font-family:monospace}
.history-pnl.profit{color:var(--long)}
.history-pnl.loss{color:var(--short)}

/* WEIGHT SLIDERS */
.weight-slider{margin-bottom:12px}
.weight-slider-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
.weight-slider-label{font-size:12px;color:var(--text2);flex:1}
.weight-slider-value{font-size:12px;font-weight:700;color:var(--cyan)}
.weight-slider input[type="range"]{width:100%;height:6px;background:var(--bg4);border-radius:3px;outline:none;-webkit-appearance:none}
.weight-slider input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;background:var(--cyan);border-radius:50%;cursor:pointer;box-shadow:0 0 8px rgba(6,182,212,0.5)}
.weight-slider input[type="range"]:disabled{opacity:0.5;cursor:not-allowed}
.weight-slider.locked{opacity:0.7;background:var(--bg4);border-radius:6px;padding:4px}

/* LOCK BUTTONS */
.lock-btn{background:transparent;border:1px solid var(--border);border-radius:4px;padding:2px 6px;font-size:12px;cursor:pointer;margin:0 8px;transition:all 0.2s}
.lock-btn:hover{background:var(--bg4)}
.lock-btn.locked{background:var(--amber-dim);border-color:var(--amber);color:var(--amber)}

/* VIEW TOGGLE */
.view-toggle{display:flex;gap:4px;margin-bottom:8px}
.view-btn{flex:1;padding:8px;border:1px solid var(--border);border-radius:4px;background:var(--bg4);color:var(--text3);font-size:12px;cursor:pointer;transition:all 0.2s}
.view-btn.active{background:var(--cyan-dim);border-color:var(--cyan);color:var(--cyan)}

/* OLED THEME */
body.oled{--bg1:#000000;--bg2:#050505;--bg3:#0a0a0a;--bg4:#111111;--border:#1a1a1a}
</style>
</head>
<body>
<div class="app">
<header class="header">
<!-- ROW 1: Market Info (Scrollable, matching ENV bar style) -->
<div class="header-row1">
<div class="info-badge" id="badgeBTC" title="BTC Price"><span class="icon">₿</span><span class="label">BTC:</span><span class="value" id="badgeBTCVal">---</span></div>
<div class="info-badge" id="badgeFG" title="Fear & Greed"><span class="icon">😱</span><span class="label">F&G:</span><span class="value" id="badgeFGVal">--</span></div>
<div class="info-badge" id="badgeDom" title="BTC Dominance"><span class="icon">📊</span><span class="label">DOM:</span><span class="value" id="badgeDomVal">--</span></div>
<div class="info-badge" id="badgeSeason" title="Alt/BTC Season"><span class="icon">🌙</span><span class="label">SZN:</span><span class="value" id="badgeSeasonVal">--</span></div>
<div class="info-badge" id="badgeSession" title="Trading Session"><span class="icon">🌍</span><span class="label">SESSION:</span><span class="value" id="badgeSessionVal">---</span></div>
<div class="info-badge" id="badgeAlts" title="Alts Condition"><span class="icon">🪙</span><span class="label">ALTS:</span><span class="value" id="badgeAltsVal">--</span></div>
</div>
<!-- ROW 2: Scan Progress Bar + Buttons -->
<div class="header-row2">
<div class="scan-progress-bar active" id="scanProgressBar">
    <span class="scan-progress-text" id="scanProgressText">Ready</span>
    <div class="scan-progress-track"><div class="scan-progress-fill" id="scanProgressFill" style="width:0%"></div></div>
    <span class="scan-progress-text" id="scanProgressPct">0%</span>
</div>
<div class="header-btns">
<button class="btn active" id="scanBtn" onclick="toggleScan()"><span id="scanIcon">●</span> Scan</button>
<button class="btn" onclick="showSettings()">⚙</button>
</div>
</div>
</header>

<!-- ENVIRONMENT BAR -->
<div class="env-bar" id="envBar">
<div class="env-status" id="envBTC" title="BTC Trend"><span class="icon">₿</span><span class="label">BTC:</span><span class="value" id="envBTCVal">--</span></div>
<div class="env-status" id="envBTCD" title="BTC Dominance Trend"><span class="icon">📊</span><span class="label">BTC.D:</span><span class="value" id="envBTCDVal">--</span></div>
<div class="env-status" id="envDXY" title="DXY Trend"><span class="icon">💵</span><span class="label">DXY:</span><span class="value" id="envDXYVal">--</span></div>
<div class="env-status" id="envStruct" title="BTC Structure"><span class="icon">🏗️</span><span class="label">STRUCT:</span><span class="value" id="envStructVal">--</span></div>
<div class="env-status" id="envRSI" title="BTC RSI"><span class="icon">📈</span><span class="label">RSI:</span><span class="value" id="envRSIVal">--</span></div>
<div class="env-status" id="envFund" title="Funding Rate"><span class="icon">💰</span><span class="label">FUND:</span><span class="value" id="envFundVal">--</span></div>
<div class="env-status" id="envOI" title="BTC Open Interest"><span class="icon">📊</span><span class="label">OI:</span><span class="value" id="envOIVal">--</span></div>
<div class="env-verdict" id="envVerdict"><span class="env-score" id="envScore">--</span><span id="envVerdictText">LOADING</span></div>
</div>

<!-- V10.3 STRUCTURE BAR -->
<div class="structure-bar" id="structureBar">
<div class="str-status" id="strChannel" title="Liquidity Channel"><span class="icon">📊</span><span class="label">CH:</span><span class="value" id="strChannelVal">--</span></div>
<div class="str-status" id="strTrendline" title="Trendlines"><span class="icon">📐</span><span class="label">TL:</span><span class="value" id="strTrendlineVal">--</span></div>
<div class="str-status" id="strCompression" title="Compression"><span class="icon">🔄</span><span class="label">COMP:</span><span class="value" id="strCompressionVal">--</span></div>
<div class="str-status" id="strBias" title="Channel Bias"><span class="icon">🎯</span><span class="label">BIAS:</span><span class="value" id="strBiasVal">--</span></div>
<div class="str-verdict" id="strVerdict"><span class="str-score" id="strScore">--</span><span id="strVerdictText">STRUCTURE</span></div>
</div>

<!-- 🔥 PHASE 1: LIVE DATA BAR -->
<div class="live-data-bar" id="liveDataBar">
    <div class="live-dot connecting"></div>
    <div class="live-badge liq-badge neutral">
        <span class="icon">💀</span>
        <span class="label">LIQS</span>
        <span class="value">Loading...</span>
    </div>
    <div class="live-badge oi-badge neutral">
        <span class="icon">📊</span>
        <span class="label">OI</span>
        <span class="value">--</span>
    </div>
    <div class="live-badge whale-badge neutral">
        <span class="icon">🐋</span>
        <span class="label">WHALE</span>
        <span class="value">--</span>
    </div>
    <div class="live-badge funding-badge neutral">
        <span class="icon">💰</span>
        <span class="label">FUND</span>
        <span class="value">--</span>
    </div>
</div>

<!-- DASHBOARD STATS BAR -->
<div class="stats-bar">
    <div class="stat-box" onclick="filterByStats('all')" style="cursor:pointer"><div class="stat-value" id="statTotal">0</div><div class="stat-label">ALL</div></div>
    <div class="stat-box" onclick="filterByStats('cream')" style="cursor:pointer"><div class="stat-value" id="statCream" style="color:#00ffcc;text-shadow:0 0 8px #00ffcc">0</div><div class="stat-label">💎</div></div>
    <div class="stat-box" onclick="filterByStats('perfect')" style="cursor:pointer"><div class="stat-value gold" id="statPerfect">0</div><div class="stat-label">🥇</div></div>
    <div class="stat-box" onclick="filterByStats('long')" style="cursor:pointer"><div class="stat-value long" id="statLong">0</div><div class="stat-label">LONG</div></div>
    <div class="stat-box" onclick="filterByStats('short')" style="cursor:pointer"><div class="stat-value short" id="statShort">0</div><div class="stat-label">SHORT</div></div>
    <div class="stat-box" onclick="filterByStats('agree3')" style="cursor:pointer"><div class="stat-value" id="statFullAgree">0</div><div class="stat-label">3/3</div></div>
</div>

<div class="content">
<aside class="sidebar">
<div class="sidebar-top">
<!-- V11-CLEAN: DIRECTION TABS WITH INTEGRATED SAVED TRADES -->
<div class="direction-tabs">
    <div class="dir-tab long active" id="dirTabLong" onclick="setDirectionTab('LONG')">
        <div class="dir-tab-header">
            <span class="dir-tab-icon">📈</span>
            <span class="dir-tab-label">LONG</span>
            <span class="dir-tab-count" id="dirLongCount">0</span>
            <span class="dir-tab-saved" id="dirLongSaved" title="Saved LONG trades">💾0</span>
            <span class="dir-tab-arrow" id="dirLongArrow">▼</span>
        </div>
    </div>
    <div class="dir-tab short" id="dirTabShort" onclick="setDirectionTab('SHORT')">
        <div class="dir-tab-header">
            <span class="dir-tab-icon">📉</span>
            <span class="dir-tab-label">SHORT</span>
            <span class="dir-tab-count" id="dirShortCount">0</span>
            <span class="dir-tab-saved" id="dirShortSaved" title="Saved SHORT trades">💾0</span>
            <span class="dir-tab-arrow" id="dirShortArrow">▼</span>
        </div>
    </div>
</div>
<!-- SAVED TRADES DROPDOWN (appears when arrow clicked) -->
<div class="saved-dropdown" id="savedDropdownLong" style="display:none">
    <div class="saved-dropdown-header">💾 ACTIVE LONG TRADES</div>
    <div class="saved-dropdown-list" id="savedLongList">
        <div class="saved-empty">No saved LONG trades</div>
    </div>
</div>
<div class="saved-dropdown" id="savedDropdownShort" style="display:none">
    <div class="saved-dropdown-header">💾 ACTIVE SHORT TRADES</div>
    <div class="saved-dropdown-list" id="savedShortList">
        <div class="saved-empty">No saved SHORT trades</div>
    </div>
</div>
<!-- V11-CLEAN: Filter row removed (ALL/PERFECT/READY/EARLY) - use stats bar instead -->
</div>
<div class="signal-list" id="signalList"><div class="empty"><div class="rainbow-circle-container"><div class="rainbow-circle-ring"></div><div class="rainbow-circle-inner"><div class="rainbow-circle-coin">Ready</div><div class="rainbow-circle-tf">to scan</div><div class="rainbow-circle-pct">0%</div><div class="rainbow-circle-count">0/0</div></div></div></div></div>


<!-- HIDDEN LEGACY ELEMENTS (for backward compatibility) -->
<div id="activeList" style="display:none"></div>
<div id="activeCount" style="display:none">0</div>
<div id="aiDot" class="ai-dot" style="display:none"></div>
<div id="aiStatus" style="display:none"></div>

<!-- V11-CLEAN: Saved trades moved to direction tabs dropdown -->

</aside>
<main class="main" id="mainPanel"><div class="empty"><div class="empty-icon" style="font-size:48px;color:var(--cyan);text-shadow:0 0 15px rgba(0,200,255,0.5)">📊</div>Select a signal to view details</div></main>
</div>
</div>

<!-- SETTINGS MODAL -->
<div class="modal-bg" id="settingsModal">
<div class="modal" style="max-height:90vh;overflow-y:auto">
<div class="modal-head"><span class="modal-title">⚙️ Settings</span><button class="modal-close" onclick="hideSettings()">×</button></div>
<div class="modal-body">

<!-- AI SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin-bottom:10px;border-bottom:1px solid var(--border);padding-bottom:6px">🤖 AI Configuration (v13 Multi-AI - 11 Keys)</div>
<div id="keyStatus" class="key-status valid">✅ Multi-AI System Ready</div>
<div class="groq-info">🧠 v13 uses 3 AI providers with auto-failover & key rotation: Groq → DeepSeek → Gemini</div>

<!-- Key Status Grid -->
<div class="key-grid" id="keyStatusGrid">
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G1</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G2</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G3</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G4</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G5</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">DS</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm1</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm2</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm3</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm4</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm5</span></div>
</div>

<!-- Groq Keys (5 slots) -->
<div style="font-size:12px;font-weight:600;color:var(--long);margin:12px 0 8px 0">🟢 Groq API Keys (5 slots - FREE)</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey1On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey1" placeholder="Groq Key 1: gsk_...">
    <span class="key-indicator" id="groqKey1Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey2On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey2" placeholder="Groq Key 2: gsk_...">
    <span class="key-indicator" id="groqKey2Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey3On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey3" placeholder="Groq Key 3: gsk_...">
    <span class="key-indicator" id="groqKey3Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey4On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey4" placeholder="Groq Key 4: gsk_...">
    <span class="key-indicator" id="groqKey4Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey5On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey5" placeholder="Groq Key 5: gsk_...">
    <span class="key-indicator" id="groqKey5Status">⚪</span>
</div>
<div style="font-size:10px;color:var(--text3);margin-bottom:12px">Get free keys: <a href="https://console.groq.com/keys" target="_blank" style="color:var(--cyan)">console.groq.com/keys</a></div>

<!-- DeepSeek Key (1 slot) -->
<div style="font-size:12px;font-weight:600;color:var(--blue);margin:12px 0 8px 0">🔵 DeepSeek API Key (1 slot - Paid)</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="deepseekKey1On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="deepseekKey1" placeholder="DeepSeek Key: sk-...">
    <span class="key-indicator" id="deepseekKey1Status">⚪</span>
</div>
<div style="font-size:10px;color:var(--text3);margin-bottom:12px">Best value: <a href="https://platform.deepseek.com" target="_blank" style="color:var(--cyan)">platform.deepseek.com</a> (~$0.14/1M tokens)</div>

<!-- Gemini Keys (5 slots) -->
<div style="font-size:12px;font-weight:600;color:var(--purple);margin:12px 0 8px 0">🟣 Gemini API Keys (5 slots - FREE)</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey1On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey1" placeholder="Gemini Key 1: AIza...">
    <span class="key-indicator" id="geminiKey1Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey2On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey2" placeholder="Gemini Key 2: AIza...">
    <span class="key-indicator" id="geminiKey2Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey3On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey3" placeholder="Gemini Key 3: AIza...">
    <span class="key-indicator" id="geminiKey3Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey4On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey4" placeholder="Gemini Key 4: AIza...">
    <span class="key-indicator" id="geminiKey4Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey5On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey5" placeholder="Gemini Key 5: AIza...">
    <span class="key-indicator" id="geminiKey5Status">⚪</span>
</div>
<div style="font-size:10px;color:var(--text3);margin-bottom:12px">Free backup: <a href="https://aistudio.google.com/apikey" target="_blank" style="color:var(--cyan)">aistudio.google.com/apikey</a></div>

<div class="form-row">
<button class="btn" onclick="toggleKeyVis()">👁️ Show</button>
<button class="btn" onclick="clearKey()">🗑️ Clear All</button>
<button class="btn primary" onclick="testAllKeys()">🔌 Test All Keys</button>
</div>

<div class="form-group">
<label class="form-label">AI Model (Groq)</label>
<select class="form-select" id="aiModelSelect">
<option value="llama-3.3-70b-versatile">Llama 3.3 70B (Best)</option>
<option value="llama-3.1-8b-instant">Llama 3.1 8B (Fast)</option>
<option value="mixtral-8x7b-32768">Mixtral 8x7B</option>
<option value="gemma2-9b-it">Gemma 2 9B</option>
</select>
</div>

<!-- AI DISPLAY MODE SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--purple);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🤖 AI Display Mode</div>
<div style="display:flex;gap:8px;margin-bottom:10px">
<button class="btn" id="aiModeDetailed" onclick="setAIDisplayMode('detailed')" style="flex:1">📊 Detailed (13)</button>
<button class="btn" id="aiModeCompact" onclick="setAIDisplayMode('compact')" style="flex:1">📱 Compact (6)</button>
</div>
<div style="font-size:11px;color:var(--text3);margin-bottom:10px">
<b>Detailed:</b> All 13 sections expanded separately<br>
<b>Compact:</b> 6 grouped sections for mobile/quick view
</div>

<!-- COIN SELECTION SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🪙 Coin Selection</div>
<div style="display:flex;gap:6px;margin-bottom:10px">
<button class="btn" onclick="setCoinCount(50)">Top 50</button>
<button class="btn" onclick="setCoinCount(100)">Top 100</button>
<button class="btn" onclick="setCoinCount(150)">Top 150</button>
<button class="btn" onclick="setCoinCount(200)">Top 200</button>
</div>
<div class="add-coin-row">
<input type="text" id="addCoinInput" placeholder="Add coin (e.g. TRUMP)" maxlength="15">
<button class="btn" onclick="addCoin()">➕ Add</button>
</div>
<div style="font-size:11px;color:var(--text3);margin-bottom:6px">Selected: <span id="coinCountDisplay">50</span> coins (Click × to remove)</div>
<div class="coin-manager" id="coinManager"></div>

<!-- WEIGHT SLIDERS SECTION WITH LOCK -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">⚖️ Engine Weights <button class="btn" onclick="lockAllEngines()" style="font-size:10px;padding:2px 6px;margin-left:10px">🔒 Lock All</button> <button class="btn" onclick="unlockAllEngines()" style="font-size:10px;padding:2px 6px">🔓 Unlock All</button></div>
<div class="weight-slider" id="sliderZone">
<div class="weight-slider-header"><span class="weight-slider-label">🎯 Zone Analysis</span><button class="lock-btn" id="lockZone" onclick="toggleEngineLock('zone')">🔓</button><span class="weight-slider-value" id="weightZoneVal">35%</span></div>
<input type="range" min="10" max="60" value="35" id="weightZone" oninput="updateWeightDisplay()">
</div>
<div class="weight-slider" id="sliderSMC">
<div class="weight-slider-header"><span class="weight-slider-label">📐 SMC Analysis</span><button class="lock-btn" id="lockSMC" onclick="toggleEngineLock('smc')">🔓</button><span class="weight-slider-value" id="weightSMCVal">35%</span></div>
<input type="range" min="10" max="60" value="35" id="weightSMC" oninput="updateWeightDisplay()">
</div>
<div class="weight-slider" id="sliderMomentum">
<div class="weight-slider-header"><span class="weight-slider-label">📊 Momentum Analysis</span><button class="lock-btn" id="lockMomentum" onclick="toggleEngineLock('momentum')">🔓</button><span class="weight-slider-value" id="weightMomentumVal">30%</span></div>
<input type="range" min="10" max="60" value="30" id="weightMomentum" oninput="updateWeightDisplay()">
</div>
<div style="font-size:10px;color:var(--amber);text-align:center;margin-top:4px">🔒 = Locked (won't change when scrolling)</div>
<div style="font-size:11px;color:var(--text3);text-align:center;margin-top:4px">Total: <span id="weightTotal">100%</span></div>

<!-- RISK CALCULATOR SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">💰 Risk Management</div>
<div class="risk-row">
<div class="form-group" style="margin:0">
<label class="form-label">Account Size ($)</label>
<input type="number" class="risk-input" id="riskAccount" value="1000" placeholder="1000">
</div>
<div class="form-group" style="margin:0">
<label class="form-label">Risk Per Trade (%)</label>
<input type="number" class="risk-input" id="riskPercent" value="2" min="0.5" max="10" step="0.5" placeholder="2">
</div>
</div>
<div class="risk-row">
<div class="form-group" style="margin:0">
<label class="form-label">Default Leverage</label>
<select class="form-select" id="riskLeverage">
<option value="3">3x</option>
<option value="5">5x</option>
<option value="10" selected>10x</option>
<option value="20">20x</option>
</select>
</div>
<div class="form-group" style="margin:0">
<label class="form-label">Max Position ($)</label>
<input type="number" class="risk-input" id="riskMaxPosition" value="500" placeholder="500">
</div>
</div>

<!-- TIMEFRAME SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">⏱️ Timeframes to Scan</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<label class="tf-toggle"><input type="checkbox" id="tf5m" checked><span class="tf-toggle-label">5m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf15m" checked><span class="tf-toggle-label">15m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf30m" checked><span class="tf-toggle-label">30m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf1h" checked><span class="tf-toggle-label">1H</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf4h" checked><span class="tf-toggle-label">4H</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf1d" checked><span class="tf-toggle-label">1D</span></label>
</div>

<!-- AUTO-SCAN INTERVAL -->
<div class="form-group">
<label class="form-label">🔄 Auto-Scan Interval</label>
<select class="form-select" id="scanInterval">
<option value="60000">1 Minute</option>
<option value="180000">3 Minutes</option>
<option value="300000" selected>5 Minutes</option>
<option value="600000">10 Minutes</option>
</select>
</div>

<!-- ALERTS SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🔔 Alert Settings</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="alertSound" checked><span class="alert-toggle-label">🔊 Sound Alert on New Signal</span></label>
</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="alertVibrate"><span class="alert-toggle-label">📳 Vibrate on New Signal</span></label>
</div>
<div class="form-group">
<label class="form-label">Alert for Grade</label>
<select class="form-select" id="alertGrade">
<option value="PERFECT">PERFECT only</option>
<option value="STRONG">STRONG and above</option>
<option value="VALID">VALID and above</option>
<option value="HEATING">HEATING and above</option>
<option value="BREWING" selected>All signals (BREWING+)</option>
</select>
</div>
<button class="btn" onclick="testAlert()" style="width:100%;margin-top:8px">🔔 Test Alert</button>

<!-- TELEGRAM SECTION - ADVANCED -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">📱 Telegram Alerts (Advanced)</div>

<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="telegramEnabled"><span class="alert-toggle-label">Enable Telegram Alerts</span></label>
</div>

<div class="form-group">
<label class="form-label">Bot Token</label>
<input type="text" class="form-input" id="telegramToken" placeholder="123456789:ABCdefGHI...">
</div>

<div class="form-group">
<label class="form-label">Chat ID</label>
<input type="text" class="form-input" id="telegramChatId" placeholder="Your chat ID">
</div>

<button class="btn" onclick="testTelegramAdvanced()" style="width:100%;margin-top:8px">📱 Test Connection</button>

<div style="font-size:12px;font-weight:600;color:var(--text2);margin:12px 0 8px 0">🎯 Alert Filters</div>

<div class="form-group">
<label class="form-label">Minimum Grade</label>
<select class="form-select" id="telegramMinGrade">
<option value="HEATING">HEATING (40+)</option>
<option value="VALID">VALID (60+)</option>
<option value="STRONG" selected>STRONG (75+)</option>
<option value="PERFECT">PERFECT (90+)</option>
</select>
</div>

<div class="form-group">
<label class="form-label">Cooldown (minutes)</label>
<input type="number" class="form-input" id="telegramCooldown" value="5" min="1" max="60">
</div>

<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="telegramDetailed" checked><span class="alert-toggle-label">📝 Detailed Alerts</span></label>
</div>

<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="telegramCream" checked><span class="alert-toggle-label">💎 CREAM/VIP for PERFECT</span></label>
</div>

<div style="font-size:12px;font-weight:600;color:var(--text2);margin:12px 0 8px 0">🔔 Notifications</div>

<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="telegramTPAlerts" checked><span class="alert-toggle-label">🎯 TP Hit Alerts</span></label>
</div>

<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="telegramSLAlerts" checked><span class="alert-toggle-label">🛑 SL Hit Alerts</span></label>
</div>

<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="telegramDailySummary"><span class="alert-toggle-label">📊 Daily Summary</span></label>
</div>

<div style="font-size:12px;font-weight:600;color:var(--text2);margin:12px 0 8px 0">🌙 Quiet Hours (No Alerts)</div>

<div style="display:flex;gap:10px">
<div class="form-group" style="flex:1">
<label class="form-label">Start Hour</label>
<input type="number" class="form-input" id="telegramQuietStart" placeholder="23" min="0" max="23">
</div>
<div class="form-group" style="flex:1">
<label class="form-label">End Hour</label>
<input type="number" class="form-input" id="telegramQuietEnd" placeholder="7" min="0" max="23">
</div>
</div>

<div style="display:flex;justify-content:space-around;padding:10px;background:var(--bg4);border-radius:6px;margin-top:10px">
<div style="text-align:center"><span id="tgStatSent" style="font-size:18px;font-weight:700;color:var(--long)">0</span><br><span style="font-size:10px;color:var(--text3)">Sent</span></div>
<div style="text-align:center"><span id="tgStatSkipped" style="font-size:18px;font-weight:700;color:var(--text3)">0</span><br><span style="font-size:10px;color:var(--text3)">Skipped</span></div>
<div style="text-align:center"><span id="tgStatErrors" style="font-size:18px;font-weight:700;color:var(--short)">0</span><br><span style="font-size:10px;color:var(--text3)">Errors</span></div>
</div>

<!-- THEME SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🎨 Theme</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="oledTheme"><span class="alert-toggle-label">🌙 OLED Black Theme (Battery Saver)</span></label>
</div>

<!-- TIMEZONE SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🕐 Timezone & Session</div>
<div class="form-group">
<label class="form-label">Your City</label>
<select class="form-select" id="userTimezone">
<option value="auto">🌐 Auto-Detect</option>
<option value="Australia/Melbourne">🇦🇺 Melbourne (UTC+11)</option>
<option value="Australia/Sydney">🇦🇺 Sydney (UTC+11)</option>
<option value="Australia/Perth">🇦🇺 Perth (UTC+8)</option>
<option value="Asia/Singapore">🇸🇬 Singapore (UTC+8)</option>
<option value="Asia/Hong_Kong">🇭🇰 Hong Kong (UTC+8)</option>
<option value="Asia/Tokyo">🇯🇵 Tokyo (UTC+9)</option>
<option value="Asia/Dubai">🇦🇪 Dubai (UTC+4)</option>
<option value="Europe/London">🇬🇧 London (UTC+0)</option>
<option value="Europe/Paris">🇫🇷 Paris (UTC+1)</option>
<option value="America/New_York">🇺🇸 New York (UTC-5)</option>
<option value="America/Chicago">🇺🇸 Chicago (UTC-6)</option>
<option value="America/Los_Angeles">🇺🇸 Los Angeles (UTC-8)</option>
</select>
</div>
<div id="timezonePreview" style="font-size:11px;color:var(--text3);padding:8px;background:var(--bg4);border-radius:4px;margin-top:8px">
🕐 Current: -- | Session: --
</div>

</div>
<div class="modal-foot">
<button class="btn" onclick="hideSettings()">Cancel</button>
<button class="btn active" onclick="saveSettings()">Save</button>
</div>
</div>
</div>
<div class="toast-box" id="toastBox"></div>

<script>
// ═══════════════════════════════════════════════════════════════════════════════
// GLOBAL ERROR HANDLERS - CRASH PREVENTION
// ═══════════════════════════════════════════════════════════════════════════════

// Catch all uncaught errors
window.onerror = function(msg, url, line, col, error) {
    // Ignore network/browser-specific noise
    const msgStr = String(msg || '');
    if (msgStr.includes('AbortSignal') || 
        msgStr.includes('postMessage') || 
        msgStr.includes('Failed to fetch') ||
        msgStr.includes('NetworkError') ||
        msgStr.includes('Timeout') ||
        msgStr.includes('cloned')) {
        return true;
    }
    console.error('🛑 Global Error:', msg, 'at line', line);
    // Show user-friendly toast if available
    if (typeof toast === 'function') {
        toast('An error occurred - check console', 'error');
    }
    return true;  // Prevents default error handling (crash)
};

// Catch unhandled promise rejections
window.onunhandledrejection = function(event) {
    // Ignore network/browser noise
    const reason = event.reason ? String(event.reason) : '';
    if (reason.includes('AbortSignal') || 
        reason.includes('postMessage') || 
        reason.includes('abort') || 
        reason.includes('Failed to fetch') ||
        reason.includes('Timeout') ||
        reason.includes('cloned') ||
        reason.includes('NetworkError')) {
        event.preventDefault();
        return;
    }
    console.error('🛑 Unhandled Promise Rejection:', event.reason);
    if (typeof toast === 'function') {
        toast('Network/API error - retrying...', 'warning');
    }
    event.preventDefault();  // Prevents crash
};

// ═══════════════════════════════════════════════════════════════════════════════
// 🛡️ CRASH-PROOF WRAPPER SYSTEM - SOLID PROTECTION
// ═══════════════════════════════════════════════════════════════════════════════

// Safe wrapper for synchronous functions
function safeCall(fn, fallback, context = 'Unknown') {
    try {
        const result = fn();
        return result;
    } catch (e) {
        console.error(`🛡️ SafeCall Error [${context}]:`, e.message);
        return fallback;
    }
}

// Safe wrapper for async functions
async function safeAsync(fn, fallback, context = 'Unknown') {
    try {
        const result = await fn();
        return result;
    } catch (e) {
        console.error(`🛡️ SafeAsync Error [${context}]:`, e.message);
        return fallback;
    }
}

// Safe property access - prevents "Cannot read property of undefined"
function safeGet(obj, path, fallback = null) {
    try {
        const keys = path.split('.');
        let result = obj;
        for (const key of keys) {
            if (result === null || result === undefined) return fallback;
            result = result[key];
        }
        return result !== undefined ? result : fallback;
    } catch (e) {
        return fallback;
    }
}

// Safe number - ensures value is a valid number
function safeNum(val, fallback = 0) {
    const num = Number(val);
    return isNaN(num) || !isFinite(num) ? fallback : num;
}

// Safe array - ensures value is an array
function safeArr(val) {
    return Array.isArray(val) ? val : [];
}

// Safe object - ensures value is an object
function safeObj(val) {
    return val && typeof val === 'object' && !Array.isArray(val) ? val : {};
}

// Safe division - prevents divide by zero
function safeDiv(a, b, fallback = 0) {
    if (b === 0 || isNaN(b) || !isFinite(b)) return fallback;
    const result = a / b;
    return isNaN(result) || !isFinite(result) ? fallback : result;
}

// Safe percentage calculation
function safePct(value, total, decimals = 2) {
    if (!total || total === 0) return 0;
    const pct = (value / total) * 100;
    return isNaN(pct) || !isFinite(pct) ? 0 : Number(pct.toFixed(decimals));
}

// Safe array reduce
function safeReduce(arr, fn, initial) {
    if (!Array.isArray(arr) || arr.length === 0) return initial;
    try {
        return arr.reduce(fn, initial);
    } catch (e) {
        return initial;
    }
}

// Safe array map
function safeMap(arr, fn) {
    if (!Array.isArray(arr)) return [];
    try {
        return arr.map(fn).filter(x => x !== undefined && x !== null);
    } catch (e) {
        return [];
    }
}

// Safe array filter
function safeFilter(arr, fn) {
    if (!Array.isArray(arr)) return [];
    try {
        return arr.filter(fn);
    } catch (e) {
        return [];
    }
}

// Safe JSON parse
function safeJSON(str, fallback = null) {
    try {
        return JSON.parse(str);
    } catch (e) {
        return fallback;
    }
}

// Safe toFixed
function safeFixed(num, decimals = 2) {
    const n = safeNum(num, 0);
    try {
        return n.toFixed(decimals);
    } catch (e) {
        return '0';
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// END CRASH-PROOF WRAPPER SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Console log limiter
let consoleLogCount = 0;
const originalConsoleLog = console.log;
console.log = function(...args) {
    consoleLogCount++;
    if (consoleLogCount > 1000) {
        if (consoleLogCount === 1001) {
            originalConsoleLog('⚠️ Console log limit reached - throttling');
        }
        if (consoleLogCount % 100 === 0) {
            originalConsoleLog(...args);  // Log every 100th
        }
        return;
    }
    originalConsoleLog(...args);
};

// ═══════════════════════════════════════════════════════════════════════════════
// Bybit Scanner - CONFIGURATION
// ═══════════════════════════════════════════════════════════════════════════════

const CONFIG = {
    // ═══════════════════════════════════════════════════════════════════════════
    // V19 ULTRA RED DNA - LIQUIDITY HUNTING CORE
    // ═══════════════════════════════════════════════════════════════════════════
    LIQUIDITY: {
        enabled: true,
        
        // Pool Detection Settings (from Ultra Red)
        pool: {
            swingLen: 5,              // Swing detection lookback
            minTouches: 2,            // Minimum touches for valid pool
            equalRange: 0.003,        // 0.3% for equal highs/lows
            clusterRange: 0.008,      // 0.8% for clustering nearby levels
            maxPools: 5               // Max pools to track per direction
        },
        
        // Sweep Detection Settings (from Ultra Red)
        sweep: {
            wickRatio: 0.4,           // Min 40% rejection wick
            volumeSpike: 1.5,         // 1.5x avg volume confirms sweep
            lookback: 10,             // Candles to check for sweep
            requireRejection: true,   // Must have rejection wick
            requireVolume: false      // Volume preferred but not required
        },
        
        // Distance Settings
        limits: {
            maxDistance: 0.025,       // Max 2.5% away for limit setup
            atLevelDist: 0.003        // 0.3% = at level
        },
        
        // Master Gate - THIS IS THE KEY
        masterGate: {
            enabled: true,            // If true, NO SWEEP = NO SIGNAL
            requirePool: true,        // Must have liquidity pool
            requireSweep: true,       // Must have sweep for CONFIRMED
            allowLimitWithoutSweep: true  // Allow LIMIT mode without sweep
        }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // V19 REGIME FILTER (from Ultra Red)
    // ═══════════════════════════════════════════════════════════════════════════
    REGIME: {
        enabled: true,
        blockChop: true,              // Block signals in CHOP regime
        dxThreshold: 25,              // ADX-like threshold for TREND
        efficiencyThreshold: 0.4,     // Price efficiency for TREND
        chopVolatility: 0.3           // Volatility consistency below this = CHOP
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // V19 SIGNAL MODES (from Ultra Red)
    // ═══════════════════════════════════════════════════════════════════════════
    SIGNAL_MODES: {
        CONFIRMED: { minScore: 75, requireSweep: true, requireVolume: true },
        LIMIT: { minScore: 55, requireSweep: false, requirePool: true },
        CAUTION: { minScore: 40, requirePool: true, hasWarning: true },
        WATCH: { minScore: 0, requirePool: true }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // V19 SCORING - CAPPED BONUSES + SUBTRACTIVE PENALTIES
    // ═══════════════════════════════════════════════════════════════════════════
    SCORING_V19: {
        // Base score from liquidity (if sweep detected)
        baseScore: 50,
        
        // Support engine bonuses (CAPPED)
        bonuses: {
            smcConfirms: 20,          // SMC (BOS/ChoCH/OB) confirms
            zoneConfirms: 15,         // Zone confluence
            momentumAligned: 10,      // Momentum aligned (NOT opposing)
            htfAligned: 10,           // HTF trend aligned
            multiTfStack: 5,          // Per additional TF with pool (max 3)
            volumeSpike: 10           // Volume > 1.5x on sweep
        },
        
        // HARD CAP on total bonuses
        maxTotalBonus: 15,
        
        // Penalties (SUBTRACTIVE)
        penalties: {
            htfOpposes: -15,          // HTF against direction
            momentumOpposes: -15,     // Strong momentum against
            htfWeak: -10,             // HTF 40-60% alignment
            noVolume: -10,            // No volume confirmation
            lowTouches: -5            // Only 2 touches (weak pool)
        }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // V10.3 STRUCTURE ENGINE CONFIG (FROM QUANTUM CHART)
    // ═══════════════════════════════════════════════════════════════════════════
    STRUCTURE: {
        enabled: true,
        
        // Channel validation
        channel: {
            enabled: true,
            minWidth: 0.02,         // 2% minimum channel width
            maxWidth: 0.08,         // 8% maximum channel width
            boundaryTypes: ['ob', 'zone', 'swing'],  // Priority order
            boundaryScores: { ob: 25, zone: 15, swing: 5 }
        },
        
        // Trendline validation
        trendlines: {
            enabled: true,
            swingPeriods: [3, 5, 8],     // Multi-TF swing detection
            minTouches: 2,
            maxLines: 3
        },
        
        // Compression detection
        compression: {
            enabled: true,
            atrPeriod: 14,
            compressionThreshold: 0.8,    // ATR < 80% of average = compressed
            expansionThreshold: 1.2       // ATR > 120% = expansion
        },
        
        // Bias calculation
        bias: {
            premiumZone: 0.75,            // Top 25% of channel
            discountZone: 0.25,           // Bottom 25% of channel
            equilibriumTolerance: 0.1     // 10% around midline
        },
        
        // Gate requirements
        gate: {
            enabled: true,
            requireChannel: true,
            requireTrendlineOrZone: true,
            requireBiasAlignment: true,
            blockOnFail: false            // Set to true to hard-block signals
        }
    },
    
    // FULL 200 COINS LIST - Bybit USDT perpetuals (NO MEME COINS)
    ALL_COINS: [
        // Tier 1: Blue Chips (1-20) - Highest Liquidity
        'BTCUSDT','ETHUSDT','BNBUSDT','SOLUSDT','XRPUSDT','ADAUSDT','AVAXUSDT',
        'DOTUSDT','LINKUSDT','MATICUSDT','LTCUSDT','BCHUSDT','ATOMUSDT','ETCUSDT','XLMUSDT',
        'NEARUSDT','ICPUSDT','APTUSDT','FILUSDT',
        // Tier 2: Large Caps (21-50) - Strong Volume
        'UNIUSDT','AAVEUSDT','LDOUSDT','ARBUSDT','OPUSDT','INJUSDT','SUIUSDT','SEIUSDT',
        'TIAUSDT','STXUSDT','IMXUSDT','RUNEUSDT','MKRUSDT','GRTUSDT','FETUSDT','RNDRUSDT',
        'THETAUSDT','HBARUSDT','ALGOUSDT','VETUSDT','FTMUSDT','EGLDUSDT','FLOWUSDT','SANDUSDT',
        'AXSUSDT','MANAUSDT','ENJUSDT','CHZUSDT','GALAUSDT','QNTUSDT',
        // Tier 3: Mid Caps DeFi (51-80) - Solid Projects
        'SNXUSDT','COMPUSDT','CRVUSDT','SUSHIUSDT','1INCHUSDT','DYDXUSDT','GMXUSDT','PERPUSDT',
        'ZRXUSDT','LRCUSDT','BALUSDT','YFIUSDT','PENDLEUSDT','ENAUSDT','JUPUSDT','PYTHUSDT',
        'WLDUSDT','TAOUSDT','AGIXUSDT','OCEANUSDT','MINAUSDT','KAVAUSDT','ROSAUSDT','NEOUSDT',
        'XTZUSDT','EOSUSDT','IOTAUSDT','DASHUSDT','ZECUSDT','XMRUSDT',
        // Tier 4: Infrastructure & L2 (81-110) - Tech Focused
        'STRKUSDT','MANTAUSDT','ZKUSDT','SCROLLUSDT','ZETAUSDT','CELOUSDT','KSMUSDT','ARUSDT',
        'STORJUSDT','ANKRUSDT','SKLUSDT','CTSIUSDT','BANDUSDT','API3USDT','LPTUSDT','RENDERUSDT',
        'ILVUSDT','CFXUSDT','KASUSDT','EIGENUSDT','RONINUSDT','OMUSDT','DYMUSDT','MOVRUSDT',
        'GLMRUSDT','RADUSDT','LQTYUSDT','TRUUSDT','POLYXUSDT','SYNUSDT',
        // Tier 5: Gaming & NFT (111-140) - Growing Sectors  
        'GMTUSDT','APEUSDT','MAGICUSDT','YGGUSDT','PORTALUSDT','PIXELUSDT','XAIUSDT','ACEUSDT',
        'ALTUSDT','BEAMUSDT','PRIMESDT','GABORUSDT','MBOXUSDT','RAREUSDT','AUDIOUSDT','HIGHUSDT',
        'BICOUSDT','BLURUSDT','MASKUSDT','RDNTUSDT','HOOKUSDT','IDUSDT','EDUUSDT','MAVUSDT',
        'CYBERUSDT','ARKMUSDT','FRONTUSDT','AGLDUSDT','SUPERUSDT','SAFEUSDT',
        // Tier 6: Established Alts (141-170) - Proven Track Record
        'WAVESUSDT','RENUSDT','ONTUSDT','ZENUSDT','DCRUSDT','RLCUSDT','NMRUSDT','LSKUSDT',
        'XVSUSDT','ALPACAUSDT','DARUSDT','JTOUSDT','SAGAUSDT','TNSRUSDT','AEVOUSDT','REZUSDT',
        'IOUSDT','LISTAUSDT','DRIFTUSDT','MORPHOUSDT','GRASSUSDT','MOVEUSDT','VANAUSDT',
        'SCRUSDT','ATHUSDT','MEUSDT','BBUSDT','MDTUSDT','AMBUSDT',
        // Tier 7: Additional Quality (171-200) - Diversification
        'COTIUSDT','OGNUSDT','REQUSDT','PUNDIXUSDT','PHAUSDT','FORTHUSDT','BONDUSDT','MLNUSDT',
        'BADGERUSDT','RARIUSDT','ALCXUSDT','FXSUSDT','CVXUSDT','SDUSDT','PRIMEUSDT','XVGUSDT',
        'STEEMUSDT','SNTUSDT','FUNUSDT','NKNUSDT','POWRUSDT','CVCUSDT','DATAUSDT','GTCUSDT',
        'TORNUSDT','ELFUSDT','CTKUSDT','WINGUSDT'
    ],
    
    // Active coins list (can be modified by user)
    COINS: [],
    
    // Timeframes for scanning - V5.3 UPDATED
    TF_SCALP: ['15','30'],                 // V9.1: Only 15m and 30m (best performers)
    TF_SWING: ['60'],                       // V9.1: 1H as swing (not 4H)
    TF_ALL: ['5','15','30','240'],         // All: No 1H (confirmation only), No 1D (poor performance)
    TF_LABELS: {'5':'5m','15':'15m','30':'30m','60':'1H','240':'4H','D':'1D','W':'1W'},
    
    // HTF mapping for each entry TF - V5.3: 1H is confirmation TF
    HTF_MAP: {
        '5': ['15','60'],              // 5m entry → check 15m, 1H
        '15': ['60','240'],            // 15m entry → check 1H, 4H
        '30': ['60','240'],            // 30m entry → check 1H, 4H
        '240': ['D'],                  // 4H entry → check 1D
        'D': ['W']                     // 1D entry → check 1W (not used)
    },
    
    // V5.3 MODE-SPECIFIC SETTINGS
    MODE_SETTINGS: {
        SCALP: {
            tfs: ['5','15','30'],
            boss: 'MOMENTUM',          // RSI/Volume is king for scalp
            slMultiplier: 1.0,         // Tight SL
            tpMultiplier: 1.5,         // Quick TP (1:1.5)
            rsiOversold: 35,
            rsiOverbought: 65,
            volumeThreshold: 1.3,      // 1.3x average volume
            useHTF: true,              // Use 1H as confirmation
            confirmTF: '60'            // 1H confirms scalp direction
        },
        SWING: {
            tfs: ['240'],
            boss: 'HTF',               // HTF trend is king for swing
            slMultiplier: 1.5,         // Normal SL
            tpMultiplier: 2.5,         // Standard TP (1:1.67)
            useHTF: true,
            confirmTF: 'D'             // 1D confirms swing direction
        }
    },
    
    // Zone Analysis TFs for multi-TF confluence
    ZONE_TFS: ['15','30','60','240'],
    
    // Scoring weights (can be modified by user)
    WEIGHTS: { zone: 0.35, smc: 0.35, momentum: 0.30 },
    
    // Grade thresholds (V1 ULTIMATE - Updated)
    GRADES: {
        PERFECT: 90,
        STRONG: 75,
        VALID: 60,
        HEATING: 45
    },
    
    // Conflict penalties
    PENALTIES: {
        ZONE_SMC_CONFLICT: -20,
        HTF_CONFLICT: -10,
        EXHAUSTION: -10,
        DIVERGENCE_AGAINST: -15
    },
    
    // V5.1 SELF-LEARNING CONFIG
    LEARNING: {
        ENABLED: true,
        HISTORY_DAYS: 180,          // 6 months backtest
        MIN_PATTERNS: 15,           // Min patterns before adjusting
        CONFIDENCE_BOOST: 10,       // Points added for high confidence
        CONFIDENCE_PENALTY: 15,     // Points subtracted for low confidence
        HIGH_WIN_RATE: 0.65,        // 65%+ = high confidence
        LOW_WIN_RATE: 0.45,         // Below 45% = low confidence
        OPTIMAL_SETTINGS: {
            '5':   { zone: 60, smc: 30, momentum: 40, sl: 1.5, tp: 2.0 },
            '15':  { zone: 65, smc: 35, momentum: 45, sl: 2.0, tp: 2.5 },
            '30':  { zone: 70, smc: 40, momentum: 50, sl: 2.0, tp: 2.5 },
            '60':  { zone: 75, smc: 45, momentum: 55, sl: 2.5, tp: 3.0 },
            '240': { zone: 80, smc: 50, momentum: 55, sl: 2.5, tp: 3.5 },
            'D':   { zone: 80, smc: 50, momentum: 55, sl: 3.0, tp: 4.0 }
        }
    },
    
    // API
    BYBIT_BASE: 'https://api.bybit.com',
    BYBIT_V5: 'https://api.bybit.com/v5',
    GROQ_URL: 'https://api.groq.com/openai/v1/chat/completions',
    DEEPSEEK_URL: 'https://api.deepseek.com/v1/chat/completions',
    GEMINI_URL: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent',
    
    // Scan intervals
    SCAN_DELAY: 150,        // ms between API calls (SAFETY: prevent rate limit)
    AUTO_SCAN_INTERVAL: 60000  // 1 minute
};

// ═══════════════════════════════════════════════════════════════════════════════
// 🎭 COIN PERSONALITY SYSTEM - DISABLED (All coins use same neutral settings)
// ═══════════════════════════════════════════════════════════════════════════════
const COIN_PERSONALITY = {
    // Single neutral tier for ALL coins - no restrictions
    NEUTRAL: {
        coins: [], // Matches everything
        name: 'NEUTRAL',
        volatilityMult: 1.0,        // Standard
        zoneThreshold: 0.015,       // 1.5% zone distance
        minRejectionMult: 1.2,      // Easy rejection requirement
        volumeRequired: 0.8,        // Standard volume
        positionFilterLong: 80,     // Can LONG up to 80% (very lenient)
        positionFilterShort: 20,    // Can SHORT down to 20% (very lenient)
        trendStrict: false,         // Don't require trend
        htfReliable: true,          // Trust HTF
        requireSweep: false,        // Never require sweep
        slMultiplier: 1.0,          // Standard SL
        tpMultiplier: 1.0,          // Standard TP
        description: 'Neutral - same rules for all coins'
    }
};

// Helper function - always returns NEUTRAL (no personality restrictions)
function getCoinPersonality(symbol) {
    return COIN_PERSONALITY.NEUTRAL;
}

// ═══════════════════════════════════════════════════════════════════════════════
// EXTENDED CONFIG - SAFETY LIMITS & BRAIN SYSTEMS
// ═══════════════════════════════════════════════════════════════════════════════
const CONFIG_EXTENDED = {
    // ═══════════════════════════════════════════════════════════════════════════════
    // SAFETY LIMITS - CRASH PREVENTION
    // ═══════════════════════════════════════════════════════════════════════════════
    SAFETY: {
        // Array limits
        MAX_SIGNALS: 500,
        MAX_SAVED_TRADES: 50,
        MAX_HISTORY: 100,
        MAX_CONSOLE_LOGS: 1000,
        
        // API limits
        API_TIMEOUT_MS: 10000,      // 10 second timeout
        MAX_RETRIES: 3,             // Max retry attempts
        SCAN_DELAY_MS: 150,         // Delay between API calls
        AI_DELAY_MS: 500,           // Delay between AI calls
        
        // Interval limits
        MIN_SCAN_INTERVAL_MS: 30000, // Min 30 seconds
        PRICE_REFRESH_MS: 5000,      // 5 second price refresh
        
        // Storage limits
        MAX_STORAGE_MB: 2,           // Max localStorage usage
        MAX_STORAGE_ITEMS: 50,       // Max items per storage key
        
        // Loop limits
        MAX_ITERATIONS: 10000,       // Max loop iterations
        MAX_RECURSION: 100,          // Max recursion depth
        MAX_COINS_PER_SCAN: 300,     // Max coins per scan (increased from 100)
        
        // Concurrent limits
        MAX_CONCURRENT_SCANS: 1,     // Only 1 scan at a time
        MAX_CONCURRENT_AI: 1         // Only 1 AI call at a time
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 1: AUTO POSITION SIZING BY VOLATILITY
    // ═══════════════════════════════════════════════════════════════════════════════
    VOLATILITY_SIZING: {
        baseRiskPercent: 1.0,           // Base risk 1% of account
        maxRiskPercent: 2.0,            // Maximum risk per trade
        minRiskPercent: 0.25,           // Minimum risk per trade
        
        // ATR thresholds (as % of price)
        atrLow: 0.5,                    // Below 0.5% = low volatility
        atrNormal: 1.5,                 // 0.5% - 1.5% = normal
        atrHigh: 3.0,                   // 1.5% - 3% = high volatility
        atrExtreme: 5.0,                // Above 3% = extreme
        
        // Size multipliers by volatility
        multipliers: {
            LOW: 1.5,                   // Calm market - can size up
            NORMAL: 1.0,                // Normal size
            HIGH: 0.6,                  // Volatile - reduce size
            EXTREME: 0.3                // Extreme - minimal size
        },
        
        // Grade multipliers
        gradeMultipliers: {
            PERFECT: 1.25,
            STRONG: 1.0,
            VALID: 0.75,
            HEATING: 0.5,
            BREWING: 0.25
        },
        
        // Intent multipliers (from J's Bot)
        intentMultipliers: {
            STOP_HUNT: 1.0,             // Normal size for stop hunts
            BREAKOUT: 0.8,              // Slightly smaller for breakouts (can add)
            ABSORPTION: 0.0             // No trade for absorption
        }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 2: CORRELATION FILTER (OVEREXPOSURE PROTECTION)
    // ═══════════════════════════════════════════════════════════════════════════════
    CORRELATION: {
        enabled: true,
        maxSimilarSignals: 3,           // Max signals from same group
        
        // Correlation groups (coins that move together)
        groups: {
            BTC_CORRELATED: ['BTCUSDT'],
            ETH_ECOSYSTEM: ['ETHUSDT', 'OPUSDT', 'ARBUSDT', 'MATICUSDT', 'STXUSDT', 'LDOUSDT'],
            SOL_ECOSYSTEM: ['SOLUSDT', 'JUPUSDT', 'RNDRUSDT', 'PYTHUSDT'],
            LAYER1: ['AVAXUSDT', 'DOTUSDT', 'ATOMUSDT', 'NEARUSDT', 'APTUSDT', 'SUIUSDT', 'SEIUSDT', 'INJUSDT'],
            DEFI: ['UNIUSDT', 'AAVEUSDT', 'MKRUSDT', 'SNXUSDT', 'COMPUSDT', 'CRVUSDT', 'SUSHIUSDT', 'DYDXUSDT'],
            AI_TOKENS: ['FETUSDT', 'AGIXUSDT', 'RNDRUSDT', 'WLDUSDT', 'TAOUSDT'],
            // MEME: REMOVED - No meme coins
            GAMING: ['AXSUSDT', 'SANDUSDT', 'MANAUSDT', 'GALAUSDT', 'ENJUSDT', 'ILVUSDT', 'IMXUSDT'],
            OLD_ALTS: ['LTCUSDT', 'BCHUSDT', 'ETCUSDT', 'XLMUSDT', 'XRPUSDT', 'ADAUSDT', 'TRXUSDT'],
            STORAGE: ['FILUSDT', 'ARUSDT', 'STORJUSDT'],
            ORACLES: ['LINKUSDT', 'BANDUSDT', 'API3USDT']
        },
        
        // Alert thresholds
        warningThreshold: 2,            // Warn at 2 similar signals
        blockThreshold: 4               // Block at 4 similar signals
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 3: DRAWDOWN PROTECTION (LOSS STREAK MANAGEMENT)
    // ═══════════════════════════════════════════════════════════════════════════════
    DRAWDOWN: {
        enabled: true,
        
        // Loss streak thresholds
        warningStreak: 2,               // Warn after 2 consecutive losses
        reduceStreak: 3,                // Reduce size after 3 losses
        pauseStreak: 5,                 // Pause trading after 5 losses
        
        // Size reduction multipliers
        reductions: {
            streak3: 0.5,               // 50% size after 3 losses
            streak4: 0.25,              // 25% size after 4 losses
            streak5: 0.0                // Pause (0%) after 5 losses
        },
        
        // Recovery
        recoveryWins: 2,                // Wins needed to reset
        
        // Daily limits
        maxDailyLosses: 5,              // Max losses per day
        maxDailyLossPercent: 5.0,       // Max 5% account loss per day
        
        // Cooldown
        cooldownMinutes: 30,            // Cooldown after hitting limits
        
        // Grade restrictions during drawdown
        minGradeDuringDrawdown: 'STRONG' // Only STRONG+ during drawdown
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 4: INTENT CLASSIFICATION (FROM J's BOT)
    // ═══════════════════════════════════════════════════════════════════════════════
    INTENT: {
        enabled: true,
        
        // SL multipliers by intent
        slMultipliers: {
            STOP_HUNT: 2.2,             // Wider SL - expects wick
            BREAKOUT: 1.8,              // Tighter SL - momentum
            ABSORPTION: null            // No trade
        },
        
        // TP multipliers by intent
        tpMultipliers: {
            STOP_HUNT: 3.5,             // Fade back target
            BREAKOUT: 4.0,              // Ride trend target
            ABSORPTION: null            // No trade
        },
        
        // TP modes
        tpModes: {
            STOP_HUNT: 'LIQUIDITY_TARGET',  // Target opposite liquidity
            BREAKOUT: 'TRAILING',            // Trail with trend
            ABSORPTION: 'NONE'               // No trade
        },
        
        // Entry modes
        entryModes: {
            STOP_HUNT: 'CONFIRMATION',      // Wait for confirmation
            BREAKOUT: 'MOMENTUM',           // Enter on momentum
            ABSORPTION: 'NONE'              // No trade
        }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 5: PATTERN MEMORY (FROM J's BOT)
    // ═══════════════════════════════════════════════════════════════════════════════
    PATTERN_MEMORY: {
        enabled: true,
        minOccurrences: 5,              // Min patterns before using
        minConfidence: 0.6,             // Min 60% success rate to boost
        maxConfidence: 0.9,             // Max 90% confidence boost
        decayDays: 30,                  // Patterns decay after 30 days
        
        // Confidence adjustments
        boostMultiplier: 1.15,          // +15% confidence for good patterns
        penaltyMultiplier: 0.85         // -15% confidence for bad patterns
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 6: COIN PERSONALITY - DISABLED (All coins use same neutral settings)
    // ═══════════════════════════════════════════════════════════════════════════════
    COIN_PERSONALITY: {
        enabled: false, // DISABLED - No coin personality restrictions
        profiles: {},   // Empty - no individual profiles
        default: {
            type: 'NEUTRAL',
            volatility: 'MEDIUM',
            respects_zones: 0.70,
            trend_strength: 0.70,
            fake_breakouts: 0.40,
            best_tf: ['5', '15', '30', '60', '240'],
            avoid_tf: [],
            sl_multiplier: 1.0,
            tp_multiplier: 1.0,
            min_score: 50,
            notes: 'Neutral - same rules for all coins'
        }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 BRAIN 7: ADAPTIVE LEARNING - Learn from your actual trades!
    // ═══════════════════════════════════════════════════════════════════════════════
    ADAPTIVE_LEARNING: {
        enabled: true,
        
        // How many trades before we start adjusting
        minTrades: 10,
        
        // Learning rate (how fast to adjust)
        learningRate: 0.1,
        
        // What we learn per coin
        trackPerCoin: true,
        
        // What we learn per timeframe
        trackPerTF: true,
        
        // What we learn per direction
        trackPerDirection: true,
        
        // Decay old data (days)
        decayDays: 60,
        
        // Auto-adjust thresholds
        autoAdjust: {
            // If win rate < 40% for coin/tf combo, increase min_score
            lowWinRateThreshold: 0.40,
            lowWinRatePenalty: 5,           // Add +5 to min score
            
            // If win rate > 70% for coin/tf combo, decrease min_score
            highWinRateThreshold: 0.70,
            highWinRateBonus: -3,            // Reduce min score by 3
            
            // If avg loss > avg win, widen SL
            lossRatioThreshold: 1.2,
            slAdjustment: 0.1               // Add 10% to SL multiplier
        }
    }
};

// MERGE CONFIG_EXTENDED into CONFIG for backwards compatibility
Object.assign(CONFIG, CONFIG_EXTENDED);

// ═══════════════════════════════════════════════════════════════════════════════
// 🧠 INTELLIGENT BRAIN STATE
// ═══════════════════════════════════════════════════════════════════════════════

const BRAIN_STATE = {
    // Drawdown tracking
    drawdown: {
        consecutiveLosses: 0,
        consecutiveWins: 0,
        dailyLosses: 0,
        dailyLossPercent: 0,
        lastLossTime: null,
        isPaused: false,
        pausedUntil: null,
        lastResetDate: null
    },
    
    // Pattern memory database
    patternDB: [],
    
    // Correlation tracking
    activeSignals: [],
    groupCounts: {},
    
    // Trade history for learning
    tradeHistory: []
};

// ═══════════════════════════════════════════════════════════════════════════════
// V5.1 SELF-LEARNING ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

const LEARNING_STATE = {
    patternMemory: {},      // Pattern key -> {wins, losses, total}
    optimalSettings: null,  // Optimized settings per TF
    lastOptimized: null,    // Timestamp
    backtestResults: {}     // Cache
};

const SelfLearning = {
    // Initialize from localStorage
    init() {
        try {
            const saved = localStorage.getItem('bsv5_learning');
            if (saved) {
                const data = JSON.parse(saved);
                LEARNING_STATE.patternMemory = data.patternMemory || {};
                LEARNING_STATE.optimalSettings = data.optimalSettings || null;
                LEARNING_STATE.lastOptimized = data.lastOptimized || null;
            }
            console.log('🧠 Self-Learning initialized:', Object.keys(LEARNING_STATE.patternMemory).length, 'patterns');
        } catch (e) {
            // Silent: Learning init
        }
    },
    
    // Save to localStorage
    save() {
        try {
            localStorage.setItem('bsv5_learning', JSON.stringify(LEARNING_STATE));
        } catch (e) { /* Silent */ }
    },
    
    // Create pattern key from signal
    createPatternKey(signal) {
        const tf = signal.tfRaw || signal.tf;
        const dir = signal.direction;
        const zBucket = Math.floor((signal.scores?.zone || 0) / 20) * 20;
        const sBucket = Math.floor((signal.scores?.smc || 0) / 20) * 20;
        return `${tf}_${dir}_Z${zBucket}_S${sBucket}`;
    },
    
    // Get adjustment for signal BEFORE firing
    getAdjustment(signal) {
        if (!CONFIG.LEARNING.ENABLED) return { adj: 0, confidence: 'N/A', winRate: 0, total: 0 };
        
        const key = this.createPatternKey(signal);
        const pattern = LEARNING_STATE.patternMemory[key];
        
        if (!pattern || pattern.total < CONFIG.LEARNING.MIN_PATTERNS) {
            return { adj: 0, confidence: 'LOW', winRate: 0, total: pattern?.total || 0 };
        }
        
        const winRate = pattern.wins / pattern.total;
        let adj = 0, confidence = 'MEDIUM';
        
        if (winRate >= CONFIG.LEARNING.HIGH_WIN_RATE && pattern.total >= 25) {
            adj = CONFIG.LEARNING.CONFIDENCE_BOOST;
            confidence = 'HIGH';
        } else if (winRate >= 0.55) {
            adj = 5;
            confidence = 'MEDIUM';
        } else if (winRate < CONFIG.LEARNING.LOW_WIN_RATE) {
            adj = -CONFIG.LEARNING.CONFIDENCE_PENALTY;
            confidence = 'LOW';
        }
        
        return { 
            adj, 
            confidence, 
            winRate: Math.round(winRate * 100), 
            total: pattern.total,
            key
        };
    },
    
    // Record trade outcome
    recordOutcome(signal, isWin) {
        const key = this.createPatternKey(signal);
        if (!LEARNING_STATE.patternMemory[key]) {
            LEARNING_STATE.patternMemory[key] = { wins: 0, losses: 0, total: 0 };
        }
        
        LEARNING_STATE.patternMemory[key].total++;
        if (isWin) LEARNING_STATE.patternMemory[key].wins++;
        else LEARNING_STATE.patternMemory[key].losses++;
        
        this.save();
        console.log(`🧠 Pattern recorded: ${key} = ${isWin ? 'WIN' : 'LOSS'}`);
    },
    
    // Get stats for display
    getStats() {
        const patterns = Object.keys(LEARNING_STATE.patternMemory).length;
        const totalTrades = Object.values(LEARNING_STATE.patternMemory)
            .reduce((sum, p) => sum + p.total, 0);
        const totalWins = Object.values(LEARNING_STATE.patternMemory)
            .reduce((sum, p) => sum + p.wins, 0);
        const avgWinRate = totalTrades > 0 ? Math.round((totalWins / totalTrades) * 100) : 0;
        
        return { patterns, totalTrades, totalWins, avgWinRate };
    },
    
    // Apply learning adjustment to score
    applyToScore(signal) {
        if (!CONFIG.LEARNING.ENABLED) return signal.score;
        
        const learning = this.getAdjustment(signal);
        signal.learning = learning;
        
        let adjustedScore = signal.score + learning.adj;
        adjustedScore = Math.max(0, Math.min(100, adjustedScore));
        
        return adjustedScore;
    }
};

// Initialize learning on load
setTimeout(() => SelfLearning.init(), 100);

// ═══════════════════════════════════════════════════════════════════════════════
// STATE MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════════
// MULTI-AI PROVIDER SYSTEM (v13 UPGRADE)
// ═══════════════════════════════════════════════════════════════════════════════

// Groq API Keys (5 keys for rotation) - Add your keys in Settings
const GROQ_KEYS = [
    '', // Add your Groq key in Settings
    '',
    '',
    '',
    ''
];

// DeepSeek API Keys (paid - best value)
const DEEPSEEK_KEYS = [
    '', // Add your DeepSeek key in Settings
];

// Gemini API Keys (free backup)
const GEMINI_KEYS = [
    '', // Add your Gemini key in Settings
    '',
    '',
    '',
    ''
];

// KEY ENABLED STATE (ON/OFF toggles)
const KEY_ENABLED = {
    groq: [true, true, true, true, true],
    deepseek: [true],
    gemini: [true, true, true, true, true]
};

// KEY STATUS (null=untested, true=working, false=failed)
const KEY_STATUS = {
    groq: [null, null, null, null, null],
    deepseek: [null],
    gemini: [null, null, null, null, null]
};

let currentGroqKeyIndex = 0;
let currentDeepSeekKeyIndex = 0;
let currentGeminiKeyIndex = 0;

// Get next API key with rotation (respects ON/OFF toggles)
function getNextGroqKey() {
    const validKeys = GROQ_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.groq[item.index]);
    if (validKeys.length === 0) return null;
    const item = validKeys[currentGroqKeyIndex % validKeys.length];
    console.log(`🔑 Using Groq Key #${item.index + 1} (${currentGroqKeyIndex % validKeys.length + 1}/${validKeys.length})`);
    currentGroqKeyIndex++;
    return item.key;
}

function getNextDeepSeekKey() {
    const validKeys = DEEPSEEK_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.deepseek[item.index]);
    if (validKeys.length === 0) return null;
    const item = validKeys[currentDeepSeekKeyIndex % validKeys.length];
    console.log(`🔑 Using DeepSeek Key #${item.index + 1}`);
    currentDeepSeekKeyIndex++;
    return item.key;
}

function getNextGeminiKey() {
    const validKeys = GEMINI_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.gemini[item.index]);
    if (validKeys.length === 0) return null;
    const item = validKeys[currentGeminiKeyIndex % validKeys.length];
    console.log(`🔑 Using Gemini Key #${item.index + 1} (${currentGeminiKeyIndex % validKeys.length + 1}/${validKeys.length})`);
    currentGeminiKeyIndex++;
    return item.key;
}

// Legacy support
const API_KEYS = GROQ_KEYS;
let currentKeyIndex = 0;

// Get next API key (round-robin rotation) - Legacy support
function getNextAPIKey() {
    return getNextGroqKey() || API_KEYS[0];
}

const DEFAULT_KEY = '';

const STATE = {
    mode: 'ALL',
    filter: 'all',
    statsFilter: 'all',  // Stats bar filter: 'all', 'perfect', 'long', 'short', 'agree3'
    view: 'list',  // V11-CLEAN: Always list (heatmap removed)
    directionTab: 'LONG',  // V11-CLEAN: Direction tab filter
    directionDropdownOpen: { LONG: false, SHORT: false },  // V11-CLEAN: Dropdown state
    scanning: false,
    scanInProgress: false,  // SAFETY: Lock to prevent concurrent scans
    aiCallInProgress: false,  // SAFETY: Lock to prevent concurrent AI calls
    signals: [],
    previousSignals: [],  // For tracking changes (⬆️⬇️🆕💀)
    selected: null,
    current: null,
    aiResult: null,
    trades: [],
    savedTrades: [],  // 💾 Saved trades for later reference
    signalHistory: [],  // Track TP/SL hits
    btc: { price: 0, change: 0 },
    // Market data for badges
    fearGreed: null,
    dxy: null,
    funding: null,
    btcDominance: null,
    btcDomTrend: 'flat',
    altSeasonScore: 50,
    aiKey: DEFAULT_KEY,
    aiModel: 'llama-3.3-70b-versatile',
    // v13 Multi-AI Keys
    deepseekKey: '',
    geminiKey: '',
    scanProgress: { current: 0, total: 0, coin: '', tf: '' },
    // Timeframe toggles
    tfEnabled: {
        '5': true,
        '15': true,
        '30': true,
        '60': true,
        '240': true,
        'D': true
    },
    // Alert settings
    alertSound: true,
    alertVibrate: false,
    alertGrade: 'BREWING',
    // Telegram settings - ADVANCED
    telegramEnabled: false,
    telegramToken: '',
    telegramChatId: '',
    telegramMinGrade: 'STRONG',
    telegramCooldown: 5,
    telegramDetailed: true,
    telegramCream: true,
    telegramTPAlerts: true,
    telegramSLAlerts: true,
    telegramDailySummary: false,
    telegramQuietStart: null,
    telegramQuietEnd: null,
    telegramStats: { sent: 0, skipped: 0, errors: 0 },
    telegramCooldowns: new Map(),
    // Scan interval (ms)
    scanInterval: 300000,  // 5 minutes default
    // AI expanded state
    aiExpanded: false,
    // AI Display Mode: 'detailed' (13 sections) or 'compact' (6 sections)
    aiDisplayMode: 'detailed',
    // Risk management
    riskAccount: 1000,
    riskPercent: 2,
    riskLeverage: 10,
    riskMaxPosition: 500,
    // Theme
    oledTheme: false,
    // Custom coins (if modified)
    customCoins: null,
    coinCount: 50,
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🛡️ PROFESSIONAL HARDENING - 5 Critical Fixes
    // ═══════════════════════════════════════════════════════════════════════════════
    hardening: {
        // FIX 1: LIVE SIGNAL LOGGING - Track every signal outcome
        signalLog: [],                    // Array of { signal, outcome, timestamp }
        signalLogMax: 500,                // Keep last 500 signals
        
        // FIX 2: REGIME COOLDOWN - Prevent whipsaw
        regime: {
            current: 'UNKNOWN',           // TRENDING, RANGING, VOLATILE, UNKNOWN
            lastChange: 0,                // Timestamp of last regime change
            cooldownCandles: 5,           // Don't flip for N candles
            candlesSinceChange: 0,        // Counter
            locked: false                 // True if in cooldown
        },
        
        // FIX 3: MEMORY CLEANUP - Prevent memory bloat
        cleanup: {
            lastCleanup: Date.now(),
            cleanupInterval: 300000,      // Clean every 5 minutes
            maxSignals: 200,              // Max signals in memory
            maxTrades: 100                // Max trades in memory
        },
        
        // FIX 4: ERROR RETRY LIMIT - Pause on repeated failures
        errors: {
            consecutive: 0,               // Consecutive API failures
            maxConsecutive: 5,            // Pause after 5 failures
            paused: false,                // True if scanning paused
            pausedAt: 0,                  // When paused
            pauseDuration: 60000,         // Pause for 1 minute
            totalErrors: 0,               // Total errors this session
            lastError: null               // Last error message
        },
        
        // FIX 5: ASYNC MUTEX - Proper scan locking
        mutex: {
            scanLock: false,              // Hard lock for scanning
            scanLockTime: 0,              // When lock was acquired
            scanLockTimeout: 120000,      // Force unlock after 2 minutes
            queuedScans: 0,               // Scans waiting
            lastScanComplete: 0           // When last scan finished
        }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // ENVIRONMENT SYSTEM STATE
    // ═══════════════════════════════════════════════════════════════════════════════
    environment: {
        // Layer 1: Macro
        dxy: { value: 0, trend: 'FLAT', favorable: null },       // null = unknown
        btcTrend: { direction: 'FLAT', strength: 0 },
        btcDominance: { value: 0, trend: 'FLAT' },
        
        // Layer 2: BTC Health
        btcStructure: { status: 'UNKNOWN', score: 0 },          // INTACT, BROKEN, UNKNOWN
        btcRSI: { value: 50, status: 'HEALTHY' },               // HEALTHY, OVERBOUGHT, OVERSOLD
        
        // Layer 3: Leverage
        funding: { rate: 0, status: 'NORMAL' },                 // NORMAL, ELEVATED, EXTREME
        
        // Layer 4: Verdict
        score: 50,
        verdict: 'UNKNOWN',                                      // GO, CAUTION, RISKY, NO-GO
        favoredDirection: null,                                  // LONG, SHORT, or null
        
        // Timestamps
        lastUpdate: null,
        isStale: false
    },
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🔥 PHASE 1: TOP TIER LIVE DATA STATE
    // ═══════════════════════════════════════════════════════════════════════════════
    liveData: {
        // WebSocket connection status
        wsConnected: false,
        wsReconnectAttempts: 0,
        wsLastHeartbeat: null,
        
        // Liquidation tracking
        liquidations: {
            recent: [],              // Last 100 liquidations
            longTotal5m: 0,          // Long liqs in last 5 min
            shortTotal5m: 0,         // Short liqs in last 5 min
            longTotal15m: 0,         // Long liqs in last 15 min
            shortTotal15m: 0,        // Short liqs in last 15 min
            bias: 'NEUTRAL',         // BULLISH (shorts rekt), BEARISH (longs rekt), NEUTRAL
            biasStrength: 0,         // 0-100
            cascadeDetected: false,  // True if big cascade happening
            lastBigLiq: null,        // Last liquidation > $500K
            byCoin: {}               // Per-coin liquidation data
        },
        
        // Open Interest tracking
        openInterest: {
            btc: { current: 0, change5m: 0, change1h: 0, trend: 'FLAT' },
            eth: { current: 0, change5m: 0, change1h: 0, trend: 'FLAT' },
            total: { current: 0, change5m: 0, change1h: 0, trend: 'FLAT' },
            byCoin: {},
            lastUpdate: null
        },
        
        // Whale/Large trade tracking
        whales: {
            recent: [],              // Last 50 whale trades
            buyVolume5m: 0,          // Buy volume in last 5 min
            sellVolume5m: 0,         // Sell volume in last 5 min
            bias: 'NEUTRAL',         // BUYING, SELLING, NEUTRAL
            lastWhale: null,         // Last whale trade
            alertQueue: [],          // Pending whale alerts
            threshold: 100000        // $100K minimum for whale
        },
        
        // Funding rate tracking
        funding: {
            btc: { rate: 0, predicted: 0, countdown: '', nextTime: null },
            eth: { rate: 0, predicted: 0, countdown: '', nextTime: null },
            average: 0,              // Average funding across top coins
            extremeCoins: [],        // Coins with extreme funding
            byCoin: {},
            lastUpdate: null
        }
    },
    
    // Filtered signals count
    filteredSignals: [],
    filteredCount: 0,
    showFiltered: false,
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🧠 INTELLIGENT BRAIN STATE (v3 - 100% Intelligence)
    // ═══════════════════════════════════════════════════════════════════════════════
    brain: {
        // Drawdown tracking
        consecutiveLosses: 0,
        consecutiveWins: 0,
        dailyLosses: 0,
        dailyLossPercent: 0,
        lastLossTime: null,
        isPaused: false,
        pausedUntil: null,
        lastResetDate: new Date().toDateString(),
        
        // Active correlation tracking
        activeSignalGroups: {},
        
        // Pattern memory (persisted to localStorage)
        patternDB: [],
        
        // Trade history for learning
        tradeResults: []
    },
    
    // Trade history for P&L tracking
    tradeHistory: []
};

// ═══════════════════════════════════════════════════════════════════════════════
// UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

// BUG FIX #1: Safe DOM element text setter - prevents crash if element doesn't exist
function safeSetText(id, text) {
    const el = document.getElementById(id);
    if (el) el.textContent = text;
}

// BUG FIX #1: Safe DOM element HTML setter
function safeSetHTML(id, html) {
    const el = document.getElementById(id);
    if (el) el.innerHTML = html;
}

// BUG FIX #1: Safe DOM class operations
function safeAddClass(id, className) {
    const el = document.getElementById(id);
    if (el) el.classList.add(className);
}

function safeRemoveClass(id, className) {
    const el = document.getElementById(id);
    if (el) el.classList.remove(className);
}

function safeSetStyle(id, prop, value) {
    const el = document.getElementById(id);
    if (el) el.style[prop] = value;
}

// BUG FIX #2: Safe localStorage operations - prevents crash in private mode or when full
function safeStorageSet(key, value) {
    try {
        localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));
        return true;
    } catch (e) {
        console.warn('⚠️ localStorage.setItem failed:', key, e.message);
        return false;
    }
}

function safeStorageGet(key, defaultValue = null) {
    try {
        const item = localStorage.getItem(key);
        if (item === null) return defaultValue;
        try {
            return JSON.parse(item);
        } catch {
            return item; // Return as string if not JSON
        }
    } catch (e) {
        console.warn('⚠️ localStorage.getItem failed:', key, e.message);
        return defaultValue;
    }
}

function safeStorageRemove(key) {
    try {
        localStorage.removeItem(key);
        return true;
    } catch (e) {
        console.warn('⚠️ localStorage.removeItem failed:', key, e.message);
        return false;
    }
}

function toast(msg, type = '') {
    const box = document.getElementById('toastBox');
    if (!box) return; // BUG FIX #1: Null check
    const t = document.createElement('div');
    t.className = 'toast ' + type;
    t.textContent = msg;
    box.appendChild(t);
    setTimeout(() => t.remove(), 3500);
}

function fmtPrice(p) {
    if (!p || isNaN(p)) return '0';
    if (p >= 1000) return p.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    if (p >= 1) return p.toFixed(4);
    if (p >= 0.001) return p.toFixed(6);
    return p.toFixed(8);
}

function fmtPct(p) {
    // FIX: Add null/undefined check
    if (p === null || p === undefined || isNaN(p)) return '+0.00%';
    return (p >= 0 ? '+' : '') + p.toFixed(2) + '%';
}

function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

function scoreColor(s) {
    if (s >= 70) return 'var(--long)';
    if (s >= 50) return 'var(--amber)';
    return 'var(--short)';
}

function scoreClass(s) {
    if (s >= 70) return 'good';
    if (s >= 50) return 'mid';
    return 'low';
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🛡️ PROFESSIONAL HARDENING MODULE - 5 Critical Production Fixes
// ═══════════════════════════════════════════════════════════════════════════════

const Hardening = {
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX 1: LIVE SIGNAL LOGGING - Track every signal outcome for forward testing
    // ═══════════════════════════════════════════════════════════════════════════
    logSignal(signal, coin, tf) {
        if (!signal || !STATE.hardening) return;
        
        const logEntry = {
            id: `${coin}_${tf}_${Date.now()}`,
            timestamp: Date.now(),
            coin,
            tf,
            direction: signal.direction,
            score: signal.score,
            entry: signal.entry,
            sl: signal.levels?.sl,
            tp: signal.levels?.tp,
            grade: signal.grade,
            regime: STATE.hardening.regime.current,
            // Outcome tracking (filled later)
            outcome: null,           // 'TP_HIT', 'SL_HIT', 'TIMEOUT', 'CANCELLED'
            outcomeTime: null,
            actualPnl: null,
            mae: null,               // Maximum Adverse Excursion
            mfe: null                // Maximum Favorable Excursion
        };
        
        STATE.hardening.signalLog.unshift(logEntry);
        
        // Keep only last N signals
        if (STATE.hardening.signalLog.length > STATE.hardening.signalLogMax) {
            STATE.hardening.signalLog = STATE.hardening.signalLog.slice(0, STATE.hardening.signalLogMax);
        }
        
        // Save to localStorage
        this.saveSignalLog();
        
        return logEntry.id;
    },
    
    updateSignalOutcome(signalId, outcome, pnl, mae = null, mfe = null) {
        if (!STATE.hardening) return;
        
        const signal = STATE.hardening.signalLog.find(s => s.id === signalId);
        if (signal) {
            signal.outcome = outcome;
            signal.outcomeTime = Date.now();
            signal.actualPnl = pnl;
            signal.mae = mae;
            signal.mfe = mfe;
            this.saveSignalLog();
        }
    },
    
    getSignalStats() {
        if (!STATE.hardening?.signalLog) return null;
        
        const completed = STATE.hardening.signalLog.filter(s => s.outcome);
        if (completed.length === 0) return { total: 0, message: 'No completed signals yet' };
        
        const wins = completed.filter(s => s.outcome === 'TP_HIT').length;
        const losses = completed.filter(s => s.outcome === 'SL_HIT').length;
        const winRate = ((wins / completed.length) * 100).toFixed(1);
        const totalPnl = completed.reduce((sum, s) => sum + (s.actualPnl || 0), 0);
        
        // By regime
        const byRegime = {};
        for (const s of completed) {
            if (!byRegime[s.regime]) byRegime[s.regime] = { wins: 0, total: 0 };
            byRegime[s.regime].total++;
            if (s.outcome === 'TP_HIT') byRegime[s.regime].wins++;
        }
        
        return {
            total: STATE.hardening.signalLog.length,
            completed: completed.length,
            wins,
            losses,
            winRate,
            totalPnl: totalPnl.toFixed(2),
            byRegime
        };
    },
    
    saveSignalLog() {
        try {
            const toSave = STATE.hardening.signalLog.slice(0, 200); // Save last 200
            localStorage.setItem('hardeningSignalLog', JSON.stringify(toSave));
        } catch (e) { /* Storage full, ignore */ }
    },
    
    loadSignalLog() {
        try {
            const saved = localStorage.getItem('hardeningSignalLog');
            if (saved && STATE.hardening) {
                STATE.hardening.signalLog = JSON.parse(saved);
            }
        } catch (e) { /* Ignore */ }
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX 2: REGIME COOLDOWN - Prevent whipsaw on regime changes
    // ═══════════════════════════════════════════════════════════════════════════
    updateRegime(newRegime) {
        if (!STATE.hardening?.regime) return;
        
        const regime = STATE.hardening.regime;
        
        // If same regime, just increment counter
        if (newRegime === regime.current) {
            regime.candlesSinceChange++;
            regime.locked = false;
            return true;
        }
        
        // If trying to change during cooldown, block it
        if (regime.locked && regime.candlesSinceChange < regime.cooldownCandles) {
            regime.candlesSinceChange++;
            console.log(`🛡️ Regime change blocked: ${regime.current} → ${newRegime} (cooldown ${regime.candlesSinceChange}/${regime.cooldownCandles})`);
            return false;
        }
        
        // Allow regime change
        console.log(`🔄 Regime change: ${regime.current} → ${newRegime}`);
        regime.current = newRegime;
        regime.lastChange = Date.now();
        regime.candlesSinceChange = 0;
        regime.locked = true;
        
        return true;
    },
    
    getRegime() {
        return STATE.hardening?.regime?.current || 'UNKNOWN';
    },
    
    isRegimeLocked() {
        if (!STATE.hardening?.regime) return false;
        const r = STATE.hardening.regime;
        return r.locked && r.candlesSinceChange < r.cooldownCandles;
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX 3: MEMORY CLEANUP - Prevent memory bloat on long sessions
    // ═══════════════════════════════════════════════════════════════════════════
    cleanup() {
        if (!STATE.hardening?.cleanup) return;
        
        const cfg = STATE.hardening.cleanup;
        const now = Date.now();
        
        // Only cleanup every N ms
        if (now - cfg.lastCleanup < cfg.cleanupInterval) return;
        
        console.log('🧹 Running memory cleanup...');
        cfg.lastCleanup = now;
        
        // Trim signals array
        if (STATE.signals && STATE.signals.length > cfg.maxSignals) {
            STATE.signals = STATE.signals.slice(0, cfg.maxSignals);
        }
        
        // Trim trades array
        if (STATE.trades && STATE.trades.length > cfg.maxTrades) {
            STATE.trades = STATE.trades.slice(0, cfg.maxTrades);
        }
        
        // Trim previous signals
        if (STATE.previousSignals && STATE.previousSignals.length > cfg.maxSignals) {
            STATE.previousSignals = STATE.previousSignals.slice(0, cfg.maxSignals);
        }
        
        // Trim signal log
        if (STATE.hardening.signalLog && STATE.hardening.signalLog.length > STATE.hardening.signalLogMax) {
            STATE.hardening.signalLog = STATE.hardening.signalLog.slice(0, STATE.hardening.signalLogMax);
        }
        
        // Force garbage collection hint
        if (window.gc) window.gc();
        
        console.log('🧹 Cleanup complete');
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX 4: ERROR RETRY LIMIT - Pause scanning on repeated API failures
    // ═══════════════════════════════════════════════════════════════════════════
    recordError(errorMsg) {
        if (!STATE.hardening?.errors) return false;
        
        const err = STATE.hardening.errors;
        err.consecutive++;
        err.totalErrors++;
        err.lastError = errorMsg;
        
        console.warn(`⚠️ API Error (${err.consecutive}/${err.maxConsecutive}): ${errorMsg}`);
        
        // Pause if too many consecutive errors
        if (err.consecutive >= err.maxConsecutive && !err.paused) {
            err.paused = true;
            err.pausedAt = Date.now();
            console.error(`🛑 SCANNING PAUSED: ${err.consecutive} consecutive errors. Will resume in ${err.pauseDuration/1000}s`);
            toast(`Scanning paused: API errors`, 'error');
            return true; // Indicates pause was triggered
        }
        
        return false;
    },
    
    recordSuccess() {
        if (!STATE.hardening?.errors) return;
        STATE.hardening.errors.consecutive = 0; // Reset on success
    },
    
    canScan() {
        if (!STATE.hardening?.errors) return true;
        
        const err = STATE.hardening.errors;
        
        // If not paused, can scan
        if (!err.paused) return true;
        
        // Check if pause duration has passed
        const elapsed = Date.now() - err.pausedAt;
        if (elapsed >= err.pauseDuration) {
            err.paused = false;
            err.consecutive = 0;
            console.log('✅ Scanning resumed after pause');
            return true;
        }
        
        return false;
    },
    
    getErrorStats() {
        if (!STATE.hardening?.errors) return null;
        const e = STATE.hardening.errors;
        return {
            consecutive: e.consecutive,
            total: e.totalErrors,
            paused: e.paused,
            lastError: e.lastError,
            resumeIn: e.paused ? Math.max(0, e.pauseDuration - (Date.now() - e.pausedAt)) : 0
        };
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX 5: ASYNC MUTEX - Proper scan locking to prevent race conditions
    // ═══════════════════════════════════════════════════════════════════════════
    async acquireScanLock(timeout = 5000) {
        if (!STATE.hardening?.mutex) return true; // No hardening, allow
        
        const mutex = STATE.hardening.mutex;
        const startWait = Date.now();
        
        // Wait for lock to be released
        while (mutex.scanLock) {
            // Check for stale lock (force release after timeout)
            if (Date.now() - mutex.scanLockTime > mutex.scanLockTimeout) {
                console.warn('🔓 Force releasing stale scan lock');
                mutex.scanLock = false;
                break;
            }
            
            // Check if we've waited too long
            if (Date.now() - startWait > timeout) {
                console.warn('⏰ Scan lock timeout - scan queued');
                mutex.queuedScans++;
                return false;
            }
            
            // Wait a bit before retry
            await new Promise(r => setTimeout(r, 100));
        }
        
        // Acquire lock
        mutex.scanLock = true;
        mutex.scanLockTime = Date.now();
        return true;
    },
    
    releaseScanLock() {
        if (!STATE.hardening?.mutex) return;
        
        const mutex = STATE.hardening.mutex;
        mutex.scanLock = false;
        mutex.lastScanComplete = Date.now();
        
        // Process queued scans
        if (mutex.queuedScans > 0) {
            mutex.queuedScans--;
        }
    },
    
    isScanLocked() {
        return STATE.hardening?.mutex?.scanLock || false;
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // MASTER INIT - Call on app start
    // ═══════════════════════════════════════════════════════════════════════════
    init() {
        console.log('🛡️ Professional Hardening module initialized');
        this.loadSignalLog();
        
        // Run cleanup every minute
        setInterval(() => this.cleanup(), 60000);
    }
};

// Initialize hardening on load
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => Hardening.init(), 2000);
});

// ═══════════════════════════════════════════════════════════════════════════════
// API FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

async function fetchJSON(url, retries = 0) {
    const timeout = CONFIG.SAFETY?.API_TIMEOUT_MS || 10000;
    const maxRetries = CONFIG.SAFETY?.MAX_RETRIES || 3;
    
    try {
        // Use Promise.race for timeout (avoids AbortSignal cloning issues)
        const fetchPromise = fetch(url);
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), timeout)
        );
        
        const r = await Promise.race([fetchPromise, timeoutPromise]);
        
        // BUG FIX #7: Handle Bybit rate limiting (429)
        if (r.status === 429) {
            if (retries < maxRetries) {
                // Longer backoff for rate limits
                await sleep(2000 * (retries + 1));
                return fetchJSON(url, retries + 1);
            }
            return null;
        }
        
        // BUG FIX #7: Handle other API errors
        if (r.status === 403 || r.status === 401) {
            return null;
        }
        
        if (r.ok) return await r.json();
    } catch (e) {
        // Silent timeout handling
    }
    
    // Retry logic
    if (retries < maxRetries) {
        await sleep(500 * (retries + 1));  // Exponential backoff
        return fetchJSON(url, retries + 1);
    }
    
    // Fallback to proxy (last resort)
    try {
        const fetchPromise = fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(url));
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), timeout)
        );
        
        const r2 = await Promise.race([fetchPromise, timeoutPromise]);
        
        if (r2.ok) return await r2.json();
    } catch (e2) { 
        // Silently ignore CORS proxy errors
    }
    
    return null;
}

// ═══════════════════════════════════════════════════════════════════════════════
// BINANCE FUTURES API - 1500 CANDLES + PAGINATION FOR MORE HISTORY
// ═══════════════════════════════════════════════════════════════════════════════

// TF mapping: Internal -> Binance
const BYBIT_TF = {
    '5': '5',
    '15': '15',
    '30': '30',
    '60': '60',
    '240': '240',
    'D': 'D'
};

// Fetch klines with pagination support - BYBIT V5 API
async function fetchKlines(symbol, tf, limit = 200) {
    try {
        const bybitTf = BYBIT_TF[tf] || '15';
        
        // If requesting more than 1000, use pagination (Bybit limit is 1000)
        if (limit > 1000) {
            return await fetchKlinesPaginated(symbol, bybitTf, limit);
        }
        
        // Single call for smaller requests
        limit = Math.min(limit, 1000);
        const url = `${CONFIG.BYBIT_V5}/market/kline?category=linear&symbol=${symbol}&interval=${bybitTf}&limit=${limit}`;
        
        // Simple fetch with Promise.race for timeout (avoids AbortSignal cloning issues)
        const fetchPromise = fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });
        
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 10000)
        );
        
        const response = await Promise.race([fetchPromise, timeoutPromise]);
        
        if (!response.ok) {
            return await fetchKlinesSecondary(symbol, tf, Math.min(limit, 1000));
        }
        
        const data = await response.json();
        
        if (data && data.retCode === 0 && data.result && data.result.list && data.result.list.length > 0) {
            // Bybit V5 format: [startTime, open, high, low, close, volume, turnover]
            // Note: Bybit returns newest first, so we need to reverse
            const klines = data.result.list.map(k => ({
                time: parseInt(k[0]),
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
            })).reverse(); // Reverse to get oldest first
            
            return klines;
        }
        
        return await fetchKlinesSecondary(symbol, tf, Math.min(limit, 1000));
        
    } catch (e) {
        // Silent fail - avoid console spam
        return await fetchKlinesSecondary(symbol, tf, Math.min(limit, 1000));
    }
}

// Paginated fetch for extended history (up to 6000 candles = 6 calls for Bybit)
async function fetchKlinesPaginated(symbol, bybitTf, totalLimit) {
    try {
        const maxPerCall = 1000; // Bybit limit is 1000 per call
        const numCalls = Math.min(Math.ceil(totalLimit / maxPerCall), 6); // Max 6 calls for 6000 candles
        
        let allKlines = [];
        let endTime = Date.now();
        
        for (let i = 0; i < numCalls; i++) {
            const url = `${CONFIG.BYBIT_V5}/market/kline?category=linear&symbol=${symbol}&interval=${bybitTf}&limit=${maxPerCall}&end=${endTime}`;
            
            const response = await fetch(url);
            if (!response.ok) break;
            
            const data = await response.json();
            if (!data || data.retCode !== 0 || !data.result || !data.result.list || data.result.list.length === 0) break;
            
            // Bybit V5 format: [startTime, open, high, low, close, volume, turnover]
            const klines = data.result.list.map(k => ({
                time: parseInt(k[0]),
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
            }));
            
            // Bybit returns newest first, so we reverse and prepend
            allKlines = [...klines.reverse(), ...allKlines];
            
            // Set endTime to oldest candle for next batch (Bybit uses 'end' parameter)
            endTime = parseInt(data.result.list[data.result.list.length - 1][0]) - 1;
            
            // Small delay to avoid rate limits
            await new Promise(r => setTimeout(r, 150));
        }
        
        // Sort by time and remove duplicates
        allKlines.sort((a, b) => a.time - b.time);
        
        // Remove duplicates based on time
        const seen = new Set();
        allKlines = allKlines.filter(k => {
            if (seen.has(k.time)) return false;
            seen.add(k.time);
            return true;
        });
        
        console.log(`Bybit paginated: ${symbol} ${bybitTf} = ${allKlines.length} candles`);
        
        return allKlines.length > 0 ? allKlines : null;
        
    } catch (e) {
        // Silent fail
        return null;
    }
}

// Secondary fetch function - backup using same Bybit API
async function fetchKlinesSecondary(symbol, tf, limit = 200) {
    // This is a backup in case main fetch fails
    try {
        const bybitTf = BYBIT_TF[tf] || '15';
        limit = Math.min(limit, 1000);
        const url = `${CONFIG.BYBIT_V5}/market/kline?category=linear&symbol=${symbol}&interval=${bybitTf}&limit=${limit}`;
        
        // Simple fetch with Promise.race for timeout
        const fetchPromise = fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });
        
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 8000)
        );
        
        const response = await Promise.race([fetchPromise, timeoutPromise]);
        
        if (!response.ok) return null;
        const data = await response.json();
        if (data && data.retCode === 0 && data.result && data.result.list && data.result.list.length > 0) {
            return data.result.list.map(k => ({
                time: parseInt(k[0]),
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
            })).reverse();
        }
        return null;
    } catch (e) {
        // Silently fail - don't spam console
        return null;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🧠🧠🧠 INTELLIGENT BRAIN MODULE v1.0 - 100% INTELLIGENCE 🧠🧠🧠
// ═══════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 BRAIN 1: AUTO POSITION SIZING BY VOLATILITY
// ─────────────────────────────────────────────────────────────────────────────────

function getVolatilityCategory(atr, currentPrice) {
    if (!atr || !currentPrice || currentPrice === 0) {
        return { category: 'NORMAL', multiplier: 1.0, atrPercent: 0, description: 'Unknown', icon: '❓' };
    }
    
    const atrPercent = (atr / currentPrice) * 100;
    const cfg = CONFIG.VOLATILITY_SIZING;
    
    if (atrPercent <= cfg.atrLow) {
        return {
            category: 'LOW',
            multiplier: cfg.multipliers.LOW,
            atrPercent: atrPercent.toFixed(2),
            description: 'Calm market - can size up',
            icon: '😴'
        };
    } else if (atrPercent <= cfg.atrNormal) {
        return {
            category: 'NORMAL',
            multiplier: cfg.multipliers.NORMAL,
            atrPercent: atrPercent.toFixed(2),
            description: 'Normal conditions',
            icon: '✅'
        };
    } else if (atrPercent <= cfg.atrHigh) {
        return {
            category: 'HIGH',
            multiplier: cfg.multipliers.HIGH,
            atrPercent: atrPercent.toFixed(2),
            description: 'Volatile - reduce size',
            icon: '⚠️'
        };
    } else {
        return {
            category: 'EXTREME',
            multiplier: cfg.multipliers.EXTREME,
            atrPercent: atrPercent.toFixed(2),
            description: 'Extreme volatility - minimal size',
            icon: '🔥'
        };
    }
}

function calculateSmartPositionSize(params) {
    const {
        accountBalance = STATE.riskAccount || 1000,
        currentPrice,
        atr,
        slPrice,
        grade = 'VALID',
        confidence = 70,
        intent = 'STOP_HUNT',
        drawdownMultiplier = 1.0
    } = params;
    
    const cfg = CONFIG.VOLATILITY_SIZING;
    
    // 1. Get base risk amount
    let riskPercent = cfg.baseRiskPercent;
    
    // 2. Adjust by volatility
    const volatility = getVolatilityCategory(atr, currentPrice);
    riskPercent *= volatility.multiplier;
    
    // 3. Adjust by grade
    const gradeMultiplier = cfg.gradeMultipliers[grade] || 1.0;
    riskPercent *= gradeMultiplier;
    
    // 4. Adjust by intent
    const intentMultiplier = cfg.intentMultipliers[intent] || 1.0;
    if (intentMultiplier === 0) {
        return {
            positionSize: 0,
            riskAmount: 0,
            riskPercent: 0,
            leverage: 0,
            blocked: true,
            reason: 'ABSORPTION - No trade',
            breakdown: { volatility, grade, intent, drawdown: drawdownMultiplier }
        };
    }
    riskPercent *= intentMultiplier;
    
    // 5. Adjust by confidence
    const confidenceMultiplier = Math.max(0.5, Math.min(1.25, confidence / 80));
    riskPercent *= confidenceMultiplier;
    
    // 6. Apply drawdown protection
    riskPercent *= drawdownMultiplier;
    
    // 7. Clamp to min/max
    riskPercent = Math.max(cfg.minRiskPercent, Math.min(cfg.maxRiskPercent, riskPercent));
    
    // 8. Calculate actual position
    const riskAmount = accountBalance * (riskPercent / 100);
    const slDistance = Math.abs(currentPrice - slPrice);
    const slPercent = (slDistance / currentPrice) * 100;
    
    // Position size based on risk and SL distance
    let positionSize = 0;
    let leverage = STATE.riskLeverage || 10;
    
    if (slPercent > 0) {
        positionSize = riskAmount / (slPercent / 100);
        positionSize = Math.min(positionSize, STATE.riskMaxPosition || 500);
        leverage = Math.min(Math.ceil(positionSize / (accountBalance * 0.1)), 20);
    }
    
    return {
        positionSize: Math.round(positionSize * 100) / 100,
        riskAmount: Math.round(riskAmount * 100) / 100,
        riskPercent: Math.round(riskPercent * 100) / 100,
        leverage: leverage,
        blocked: false,
        reason: null,
        breakdown: {
            volatility: volatility,
            gradeMultiplier: gradeMultiplier,
            intentMultiplier: intentMultiplier,
            confidenceMultiplier: Math.round(confidenceMultiplier * 100) / 100,
            drawdownMultiplier: drawdownMultiplier
        }
    };
}

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 BRAIN 2: CORRELATION FILTER (OVEREXPOSURE PROTECTION)
// ─────────────────────────────────────────────────────────────────────────────────

function getCorrelationGroup(symbol) {
    const groups = CONFIG.CORRELATION.groups;
    for (const [groupName, coins] of Object.entries(groups)) {
        if (coins.includes(symbol)) {
            return groupName;
        }
    }
    return 'UNCORRELATED';
}

function checkCorrelationFilter(symbol, direction, currentSignals) {
    if (!CONFIG.CORRELATION.enabled) {
        return { allowed: true, warning: null, groupCount: 0 };
    }
    
    const group = getCorrelationGroup(symbol);
    const cfg = CONFIG.CORRELATION;
    
    // Count existing signals in same group with same direction
    const groupSignals = currentSignals.filter(sig => 
        getCorrelationGroup(sig.symbol) === group && 
        sig.direction === direction &&
        sig.symbol !== symbol
    );
    
    const groupCount = groupSignals.length;
    
    // Check thresholds
    if (groupCount >= cfg.blockThreshold) {
        return {
            allowed: false,
            warning: `🚫 BLOCKED: ${groupCount} ${direction} signals in ${group} group (max ${cfg.blockThreshold})`,
            groupCount: groupCount,
            group: group,
            relatedSignals: groupSignals.map(s => s.symbol)
        };
    }
    
    if (groupCount >= cfg.warningThreshold) {
        return {
            allowed: true,
            warning: `⚠️ WARNING: ${groupCount} ${direction} signals in ${group} group`,
            groupCount: groupCount,
            group: group,
            relatedSignals: groupSignals.map(s => s.symbol)
        };
    }
    
    return {
        allowed: true,
        warning: null,
        groupCount: groupCount,
        group: group
    };
}

function getActiveSignalsByGroup(signals) {
    const groupCounts = {};
    
    signals.forEach(sig => {
        const group = getCorrelationGroup(sig.symbol);
        const key = `${group}_${sig.direction}`;
        if (!groupCounts[key]) {
            groupCounts[key] = { count: 0, symbols: [], group: group, direction: sig.direction };
        }
        groupCounts[key].count++;
        groupCounts[key].symbols.push(sig.symbol);
    });
    
    return groupCounts;
}

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 BRAIN 3: DRAWDOWN PROTECTION (LOSS STREAK MANAGEMENT)
// ─────────────────────────────────────────────────────────────────────────────────

function initDrawdownTracking() {
    // Load from localStorage
    const saved = safeStorageGet('brainDrawdown', null);
    if (saved) {
        STATE.brain.consecutiveLosses = saved.consecutiveLosses || 0;
        STATE.brain.consecutiveWins = saved.consecutiveWins || 0;
        STATE.brain.dailyLosses = saved.dailyLosses || 0;
        STATE.brain.dailyLossPercent = saved.dailyLossPercent || 0;
        STATE.brain.isPaused = saved.isPaused || false;
        STATE.brain.pausedUntil = saved.pausedUntil ? new Date(saved.pausedUntil) : null;
        STATE.brain.lastResetDate = saved.lastResetDate || new Date().toDateString();
    }
    
    // Reset daily counters if new day
    const today = new Date().toDateString();
    if (STATE.brain.lastResetDate !== today) {
        STATE.brain.dailyLosses = 0;
        STATE.brain.dailyLossPercent = 0;
        STATE.brain.lastResetDate = today;
        STATE.brain.isPaused = false;
        STATE.brain.pausedUntil = null;
        saveDrawdownState();
    }
    
    // Check if pause has expired
    if (STATE.brain.isPaused && STATE.brain.pausedUntil) {
        if (new Date() > new Date(STATE.brain.pausedUntil)) {
            STATE.brain.isPaused = false;
            STATE.brain.pausedUntil = null;
            saveDrawdownState();
            console.log('🧠 Drawdown pause expired - trading resumed');
        }
    }
}

function saveDrawdownState() {
    safeStorageSet('brainDrawdown', {
        consecutiveLosses: STATE.brain.consecutiveLosses,
        consecutiveWins: STATE.brain.consecutiveWins,
        dailyLosses: STATE.brain.dailyLosses,
        dailyLossPercent: STATE.brain.dailyLossPercent,
        isPaused: STATE.brain.isPaused,
        pausedUntil: STATE.brain.pausedUntil,
        lastResetDate: STATE.brain.lastResetDate
    });
}

function recordTradeResult(isWin, pnlPercent = 0) {
    const cfg = CONFIG.DRAWDOWN;
    
    if (isWin) {
        STATE.brain.consecutiveWins++;
        STATE.brain.consecutiveLosses = 0;
        
        // Check recovery
        if (STATE.brain.consecutiveWins >= cfg.recoveryWins) {
            STATE.brain.isPaused = false;
            STATE.brain.pausedUntil = null;
            console.log('🧠 Recovery achieved! Trading at full capacity');
            toast('🧠 Recovery! Full trading resumed', 'success');
        }
    } else {
        STATE.brain.consecutiveLosses++;
        STATE.brain.consecutiveWins = 0;
        STATE.brain.dailyLosses++;
        STATE.brain.dailyLossPercent += Math.abs(pnlPercent);
        
        // Check if we need to pause
        if (STATE.brain.consecutiveLosses >= cfg.pauseStreak) {
            STATE.brain.isPaused = true;
            STATE.brain.pausedUntil = new Date(Date.now() + cfg.cooldownMinutes * 60 * 1000);
            console.log(`🧠 Trading PAUSED after ${STATE.brain.consecutiveLosses} consecutive losses`);
            toast(`🛑 Trading paused for ${cfg.cooldownMinutes}min (${STATE.brain.consecutiveLosses} losses)`, 'error');
        } else if (STATE.brain.dailyLosses >= cfg.maxDailyLosses) {
            STATE.brain.isPaused = true;
            STATE.brain.pausedUntil = new Date(Date.now() + cfg.cooldownMinutes * 60 * 1000);
            console.log(`🧠 Trading PAUSED after ${STATE.brain.dailyLosses} daily losses`);
            toast(`🛑 Daily loss limit reached (${STATE.brain.dailyLosses} losses)`, 'error');
        } else if (STATE.brain.dailyLossPercent >= cfg.maxDailyLossPercent) {
            STATE.brain.isPaused = true;
            STATE.brain.pausedUntil = new Date(Date.now() + cfg.cooldownMinutes * 60 * 1000);
            console.log(`🧠 Trading PAUSED - daily loss ${STATE.brain.dailyLossPercent.toFixed(1)}%`);
            toast(`🛑 Daily loss limit ${STATE.brain.dailyLossPercent.toFixed(1)}% reached`, 'error');
        }
    }
    
    saveDrawdownState();
}

function getDrawdownMultiplier() {
    const cfg = CONFIG.DRAWDOWN;
    
    // If paused, return 0
    if (STATE.brain.isPaused) {
        return { multiplier: 0, status: 'PAUSED', reason: 'Trading paused due to drawdown' };
    }
    
    // Apply reductions based on loss streak
    const losses = STATE.brain.consecutiveLosses;
    
    if (losses >= 5) {
        return { multiplier: cfg.reductions.streak5, status: 'PAUSED', reason: `${losses} consecutive losses - paused` };
    } else if (losses >= 4) {
        return { multiplier: cfg.reductions.streak4, status: 'MINIMAL', reason: `${losses} consecutive losses - 25% size` };
    } else if (losses >= 3) {
        return { multiplier: cfg.reductions.streak3, status: 'REDUCED', reason: `${losses} consecutive losses - 50% size` };
    } else if (losses >= 2) {
        return { multiplier: 0.75, status: 'WARNING', reason: `${losses} consecutive losses - 75% size` };
    }
    
    return { multiplier: 1.0, status: 'NORMAL', reason: null };
}

function checkDrawdownGradeFilter(grade) {
    const cfg = CONFIG.DRAWDOWN;
    
    if (!STATE.brain.isPaused && STATE.brain.consecutiveLosses < cfg.reduceStreak) {
        return { allowed: true, reason: null };
    }
    
    // During drawdown, only allow STRONG+ grades
    const gradeRank = { PERFECT: 5, STRONG: 4, VALID: 3, HEATING: 2, BREWING: 1 };
    const minRank = gradeRank[cfg.minGradeDuringDrawdown] || 4;
    const currentRank = gradeRank[grade] || 0;
    
    if (currentRank < minRank) {
        return {
            allowed: false,
            reason: `During drawdown: Only ${cfg.minGradeDuringDrawdown}+ signals allowed (got ${grade})`
        };
    }
    
    return { allowed: true, reason: null };
}

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 BRAIN 4: INTENT CLASSIFICATION (FROM J's BOT)
// ─────────────────────────────────────────────────────────────────────────────────

function detectLiquidityPools(klines, tolerance = 0.005) {
    if (!klines || klines.length < 20) return [];
    
    const swings = [];
    const len = klines.length;
    
    // Find swing highs and lows
    for (let i = 2; i < len - 2; i++) {
        const isHigh = klines[i].high > klines[i-1].high && 
                       klines[i].high > klines[i-2].high &&
                       klines[i].high > klines[i+1].high && 
                       klines[i].high > klines[i+2].high;
        
        const isLow = klines[i].low < klines[i-1].low && 
                      klines[i].low < klines[i-2].low &&
                      klines[i].low < klines[i+1].low && 
                      klines[i].low < klines[i+2].low;
        
        if (isHigh) swings.push({ price: klines[i].high, type: 'HIGH', index: i });
        if (isLow) swings.push({ price: klines[i].low, type: 'LOW', index: i });
    }
    
    // Cluster into pools
    const pools = [];
    const currentPrice = klines[len - 1].close;
    
    swings.forEach(swing => {
        const existingPool = pools.find(p => 
            p.type === swing.type && 
            Math.abs(p.price - swing.price) / swing.price <= tolerance
        );
        
        if (existingPool) {
            existingPool.strength++;
            existingPool.price = (existingPool.price + swing.price) / 2;
        } else {
            pools.push({
                price: swing.price,
                type: swing.type,
                strength: 1,
                distance: Math.abs(currentPrice - swing.price) / currentPrice * 100
            });
        }
    });
    
    return pools.filter(p => p.strength >= 2).sort((a, b) => a.distance - b.distance);
}

function isLiquiditySweep(candle, pool, avgVolume) {
    const wickSize = Math.abs(candle.high - candle.low);
    const bodySize = Math.abs(candle.close - candle.open);
    const wickRatio = wickSize > 0 ? (wickSize - bodySize) / wickSize : 0;
    
    const pierced = pool.type === 'HIGH' 
        ? candle.high > pool.price 
        : candle.low < pool.price;
    
    const closedBack = pool.type === 'HIGH'
        ? candle.close < pool.price
        : candle.close > pool.price;
    
    return pierced && closedBack && wickRatio > 0.55 && candle.volume > avgVolume * 1.4;
}

function classifyIntent(klines, pool, atr) {
    if (!klines || klines.length < 3) return 'ABSORPTION';
    
    const last = klines[klines.length - 1];
    const prev = klines[klines.length - 2];
    
    // Re-accepted (stop hunt)
    const reAccepted = pool.type === 'HIGH'
        ? last.close < pool.price && prev.close < pool.price
        : last.close > pool.price && prev.close > pool.price;
    
    // Breakout accepted
    const breakoutAccepted = pool.type === 'HIGH'
        ? last.close > pool.price + atr * 0.2
        : last.close < pool.price - atr * 0.2;
    
    if (reAccepted) return 'STOP_HUNT';
    if (breakoutAccepted) return 'BREAKOUT';
    return 'ABSORPTION';
}

function detectMarketIntent(klines, atr) {
    if (!klines || klines.length < 50) {
        return { intent: 'ABSORPTION', confidence: 0, pool: null };
    }
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    const tolerance = (atr / currentPrice) * 0.15;
    
    // Find liquidity pools
    const pools = detectLiquidityPools(klines, tolerance);
    
    if (pools.length === 0) {
        return { intent: 'ABSORPTION', confidence: 0, pool: null, reason: 'No liquidity pools found' };
    }
    
    // Get nearest pool
    const nearestPool = pools[0];
    
    // Check if recently swept
    const recentCandles = klines.slice(-5);
    const avgVolume = klines.slice(-20).reduce((sum, k) => sum + k.volume, 0) / 20;
    
    let swept = false;
    recentCandles.forEach(candle => {
        if (isLiquiditySweep(candle, nearestPool, avgVolume)) {
            swept = true;
        }
    });
    
    if (swept) {
        const intent = classifyIntent(recentCandles, nearestPool, atr);
        const confidence = nearestPool.strength * 20 + (swept ? 30 : 0);
        
        return {
            intent: intent,
            confidence: Math.min(100, confidence),
            pool: nearestPool,
            swept: swept,
            reason: `Liquidity sweep detected at ${nearestPool.type} pool`
        };
    }
    
    // No sweep - check for buildup
    if (nearestPool.distance < 1.0) {
        return {
            intent: 'ABSORPTION',
            confidence: 30,
            pool: nearestPool,
            swept: false,
            reason: 'Price consolidating near liquidity'
        };
    }
    
    return {
        intent: 'ABSORPTION',
        confidence: 0,
        pool: null,
        reason: 'No clear intent detected'
    };
}

function getIntentBasedLevels(intent, currentPrice, atr, direction) {
    const cfg = CONFIG.INTENT;
    
    if (!cfg.enabled || intent === 'ABSORPTION') {
        return null;
    }
    
    const slMult = cfg.slMultipliers[intent] || 2.0;
    const tpMult = cfg.tpMultipliers[intent] || 3.0;
    
    let sl, tp1, tp2, tp3;
    
    if (direction === 'LONG') {
        sl = currentPrice - (atr * slMult);
        tp1 = currentPrice + (atr * tpMult * 0.5);
        tp2 = currentPrice + (atr * tpMult);
        tp3 = currentPrice + (atr * tpMult * 1.5);
    } else {
        sl = currentPrice + (atr * slMult);
        tp1 = currentPrice - (atr * tpMult * 0.5);
        tp2 = currentPrice - (atr * tpMult);
        tp3 = currentPrice - (atr * tpMult * 1.5);
    }
    
    return {
        sl: sl,
        tp1: tp1,
        tp2: tp2,
        tp3: tp3,
        slMultiplier: slMult,
        tpMultiplier: tpMult,
        tpMode: cfg.tpModes[intent],
        entryMode: cfg.entryModes[intent],
        intent: intent
    };
}

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 BRAIN 5: PATTERN MEMORY (FROM J's BOT)
// ─────────────────────────────────────────────────────────────────────────────────

function initPatternMemory() {
    const saved = safeStorageGet('brainPatternDB', []);
    STATE.brain.patternDB = saved || [];
    console.log(`🧠 Loaded ${STATE.brain.patternDB.length} patterns from memory`);
}

function savePatternMemory() {
    // Limit to 500 patterns
    if (STATE.brain.patternDB.length > 500) {
        STATE.brain.patternDB = STATE.brain.patternDB.slice(-500);
    }
    safeStorageSet('brainPatternDB', STATE.brain.patternDB);
}

function createPatternSignature(signal) {
    // Create a unique signature for pattern matching
    return {
        symbol: signal.symbol,
        tf: signal.tf,
        direction: signal.direction,
        grade: signal.grade,
        intent: signal.intent || 'UNKNOWN',
        zoneScore: Math.round((signal.scores?.zone || 0) / 10) * 10,  // Round to nearest 10
        smcScore: Math.round((signal.scores?.smc || 0) / 10) * 10,
        momentumScore: Math.round((signal.scores?.momentum || 0) / 10) * 10,
        envVerdict: STATE.environment?.verdict || 'UNKNOWN',
        hour: new Date().getHours()  // Time of day
    };
}

function findMatchingPatterns(signature) {
    const cfg = CONFIG.PATTERN_MEMORY;
    if (!cfg.enabled || STATE.brain.patternDB.length < cfg.minOccurrences) {
        return { matches: [], successRate: 0.5, confidence: 0 };
    }
    
    const matches = STATE.brain.patternDB.filter(p => {
        // Match on key attributes (allow some flexibility)
        const symbolMatch = p.symbol === signature.symbol;
        const tfMatch = p.tf === signature.tf;
        const directionMatch = p.direction === signature.direction;
        const gradeMatch = p.grade === signature.grade;
        const intentMatch = p.intent === signature.intent;
        
        // Score similarity
        const zoneClose = Math.abs(p.zoneScore - signature.zoneScore) <= 20;
        const smcClose = Math.abs(p.smcScore - signature.smcScore) <= 20;
        
        // Must match: direction, grade
        // Should match: symbol OR tf, intent
        return directionMatch && gradeMatch && 
               (symbolMatch || tfMatch) && 
               (intentMatch || zoneClose || smcClose);
    });
    
    if (matches.length < cfg.minOccurrences) {
        return { matches: [], successRate: 0.5, confidence: 0 };
    }
    
    const wins = matches.filter(m => m.result === 'WIN').length;
    const successRate = wins / matches.length;
    
    return {
        matches: matches,
        successRate: successRate,
        confidence: matches.length >= 10 ? 'HIGH' : matches.length >= 5 ? 'MEDIUM' : 'LOW',
        totalMatches: matches.length,
        wins: wins,
        losses: matches.length - wins
    };
}

function getPatternConfidenceMultiplier(signal) {
    const cfg = CONFIG.PATTERN_MEMORY;
    if (!cfg.enabled) return { multiplier: 1.0, reason: null };
    
    const signature = createPatternSignature(signal);
    const patternData = findMatchingPatterns(signature);
    
    if (patternData.matches.length === 0) {
        return { multiplier: 1.0, reason: 'No pattern history', patternData: null };
    }
    
    const successRate = patternData.successRate;
    
    if (successRate >= cfg.minConfidence) {
        // Boost confidence for good patterns
        const boost = Math.min(cfg.boostMultiplier, 1 + (successRate - 0.5) * 0.3);
        return {
            multiplier: boost,
            reason: `Pattern ${(successRate * 100).toFixed(0)}% success (${patternData.totalMatches} trades)`,
            patternData: patternData
        };
    } else if (successRate < 0.4) {
        // Penalize bad patterns
        return {
            multiplier: cfg.penaltyMultiplier,
            reason: `⚠️ Pattern ${(successRate * 100).toFixed(0)}% success - CAUTION`,
            patternData: patternData
        };
    }
    
    return {
        multiplier: 1.0,
        reason: `Pattern ${(successRate * 100).toFixed(0)}% success`,
        patternData: patternData
    };
}

function recordPatternResult(signal, result) {
    const signature = createPatternSignature(signal);
    
    STATE.brain.patternDB.push({
        ...signature,
        result: result,  // 'WIN' or 'LOSS'
        timestamp: Date.now(),
        pnl: signal.pnl || 0
    });
    
    // Decay old patterns
    const cfg = CONFIG.PATTERN_MEMORY;
    const cutoff = Date.now() - (cfg.decayDays * 24 * 60 * 60 * 1000);
    STATE.brain.patternDB = STATE.brain.patternDB.filter(p => p.timestamp > cutoff);
    
    savePatternMemory();
    console.log(`🧠 Pattern recorded: ${result} for ${signal.symbol} ${signal.tf}`);
}

// ─────────────────────────────────────────────────────────────────────────────────
// 🧠 MASTER BRAIN: COMBINE ALL INTELLIGENCES
// ─────────────────────────────────────────────────────────────────────────────────

function applyIntelligentBrain(signal, currentSignals = []) {
    const result = {
        originalSignal: signal,
        allowed: true,
        blocked: false,
        blockReason: null,
        warnings: [],
        
        // Brain outputs
        intent: null,
        positionSize: null,
        correlation: null,
        drawdown: null,
        pattern: null,
        
        // Modified levels (if intent changes them)
        modifiedLevels: null,
        
        // Final confidence
        adjustedConfidence: signal.score || 70
    };
    
    // 1. Check if trading is paused (Brain 3)
    initDrawdownTracking();
    const drawdown = getDrawdownMultiplier();
    result.drawdown = drawdown;
    
    if (drawdown.multiplier === 0) {
        result.blocked = true;
        result.allowed = false;
        result.blockReason = drawdown.reason;
        return result;
    }
    
    // 2. Check grade during drawdown
    const gradeCheck = checkDrawdownGradeFilter(signal.grade);
    if (!gradeCheck.allowed) {
        result.blocked = true;
        result.allowed = false;
        result.blockReason = gradeCheck.reason;
        return result;
    }
    
    // 3. Detect intent (Brain 4)
    if (signal.atr && signal.price) {
        // Use existing klines if available, otherwise use signal data
        const intentData = detectMarketIntent(
            signal.klines || null, 
            signal.atr
        );
        result.intent = intentData;
        
        if (intentData.intent === 'ABSORPTION') {
            result.warnings.push('⚠️ ABSORPTION detected - weak setup');
        }
        
        // Get intent-based levels
        if (intentData.intent !== 'ABSORPTION') {
            result.modifiedLevels = getIntentBasedLevels(
                intentData.intent,
                signal.price,
                signal.atr,
                signal.direction
            );
        }
    }
    
    // 4. Check correlation (Brain 2)
    const correlation = checkCorrelationFilter(
        signal.symbol,
        signal.direction,
        currentSignals
    );
    result.correlation = correlation;
    
    if (!correlation.allowed) {
        result.blocked = true;
        result.allowed = false;
        result.blockReason = correlation.warning;
        return result;
    }
    
    if (correlation.warning) {
        result.warnings.push(correlation.warning);
    }
    
    // 5. Get pattern confidence (Brain 5)
    initPatternMemory();
    const pattern = getPatternConfidenceMultiplier(signal);
    result.pattern = pattern;
    
    if (pattern.reason) {
        if (pattern.multiplier < 1) {
            result.warnings.push(pattern.reason);
        }
    }
    
    // 6. Calculate position size (Brain 1)
    const positionSize = calculateSmartPositionSize({
        accountBalance: STATE.riskAccount || 1000,
        currentPrice: signal.price,
        atr: signal.atr,
        slPrice: signal.levels?.sl || signal.price * 0.98,
        grade: signal.grade,
        confidence: signal.score || 70,
        intent: result.intent?.intent || 'STOP_HUNT',
        drawdownMultiplier: drawdown.multiplier
    });
    result.positionSize = positionSize;
    
    if (positionSize.blocked) {
        result.blocked = true;
        result.allowed = false;
        result.blockReason = positionSize.reason;
        return result;
    }
    
    // 7. Adjust confidence
    let adjustedConfidence = signal.score || 70;
    adjustedConfidence *= pattern.multiplier;
    adjustedConfidence *= (result.intent?.intent === 'STOP_HUNT' ? 1.1 : 
                          result.intent?.intent === 'BREAKOUT' ? 1.0 : 0.8);
    result.adjustedConfidence = Math.round(Math.min(100, Math.max(0, adjustedConfidence)));
    
    return result;
}

// Initialize brains on load
function initIntelligentBrains() {
    console.log('🧠 Initializing Intelligent Brain Module v1.0...');
    initDrawdownTracking();
    initPatternMemory();
    console.log('🧠 All 5 brains activated - 100% Intelligence achieved!');
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF INTELLIGENT BRAIN MODULE
// ═══════════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════════
// 🏦 INSTITUTIONAL DATA FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

// Fetch Funding Rate for a symbol - BYBIT V5 API
async function fetchFundingRate(symbol) {
    try {
        const url = `${CONFIG.BYBIT_V5}/market/funding/history?category=linear&symbol=${symbol}&limit=1`;
        const d = await fetchJSON(url);
        if (d && d.retCode === 0 && d.result && d.result.list && d.result.list.length > 0) {
            const rate = parseFloat(d.result.list[0].fundingRate) || 0;
            const time = parseInt(d.result.list[0].fundingRateTimestamp) || 0;
            return {
                rate: rate,
                ratePercent: (rate * 100).toFixed(4),
                timestamp: time,
                // Interpretation
                sentiment: rate > 0.0003 ? 'OVERLEVERAGED_LONG' : 
                          rate < -0.0003 ? 'OVERLEVERAGED_SHORT' : 
                          rate > 0 ? 'SLIGHTLY_LONG' : 
                          rate < 0 ? 'SLIGHTLY_SHORT' : 'NEUTRAL',
                // Trading signal
                signal: rate > 0.001 ? 'SHORT_SQUEEZE_RISK' :
                       rate < -0.001 ? 'LONG_SQUEEZE_RISK' :
                       rate > 0.0005 ? 'LONGS_PAYING' :
                       rate < -0.0005 ? 'SHORTS_PAYING' : 'BALANCED'
            };
        }
    } catch(e) { 
        // Silent fail for funding rate
    }
    return null;
}

// Fetch Open Interest - BYBIT V5 API
async function fetchOpenInterest(symbol = 'BTCUSDT') {
    try {
        const url = `${CONFIG.BYBIT_V5}/market/open-interest?category=linear&symbol=${symbol}&intervalTime=5min&limit=48`;
        const d = await fetchJSON(url);
        if (d && d.retCode === 0 && d.result && d.result.list && d.result.list.length > 0) {
            const list = d.result.list;
            const currentOI = parseFloat(list[0].openInterest) || 0;
            
            let change = 0;
            let changePct = 0;
            let rising = 0, falling = 0;
            
            if (list.length > 1) {
                const oldest = parseFloat(list[list.length - 1].openInterest) || 1;
                const latest = parseFloat(list[0].openInterest) || currentOI;
                change = latest - oldest;
                changePct = oldest > 0 ? ((latest - oldest) / oldest) * 100 : 0;
                
                for (let i = 0; i < list.length - 1; i++) {
                    const curr = parseFloat(list[i].openInterest);
                    const prev = parseFloat(list[i+1].openInterest);
                    if (curr > prev) rising++;
                    else if (curr < prev) falling++;
                }
            }
            
            return {
                current: currentOI,
                change: change,
                changePct: changePct,
                change4h: changePct.toFixed(2),
                trend: rising > falling * 1.5 ? 'RISING' : 
                      falling > rising * 1.5 ? 'FALLING' : 'STABLE',
                risingCount: rising,
                fallingCount: falling,
                timestamp: Date.now(),
                // Trading interpretation
                signal: changePct > 5 ? 'NEW_POSITIONS_OPENING' :
                       changePct < -5 ? 'POSITIONS_CLOSING' :
                       changePct > 2 ? 'SLIGHT_BUILDUP' :
                       changePct < -2 ? 'SLIGHT_UNWIND' : 'STABLE'
            };
        }
    } catch(e) { 
        // Silent fail for OI fetch
    }
    return null;
}

// Fetch Long/Short Ratio - BYBIT V5 API (using tickers as proxy since L/S ratio isn't public)
async function fetchLongShortRatio(symbol) {
    try {
        // Bybit doesn't have public global L/S ratio API
        // We estimate from funding rate direction as a proxy
        const fundingData = await fetchFundingRate(symbol);
        
        if (fundingData) {
            // Positive funding = more longs, Negative = more shorts
            const rate = fundingData.rate;
            const longBias = rate > 0 ? 0.5 + Math.min(rate * 100, 0.15) : 0.5 - Math.min(Math.abs(rate) * 100, 0.15);
            const shortBias = 1 - longBias;
            
            return {
                buyRatio: (longBias * 100).toFixed(1),
                sellRatio: (shortBias * 100).toFixed(1),
                ratio: shortBias > 0 ? (longBias / shortBias).toFixed(2) : '1.00',
                dominance: longBias > 0.55 ? 'LONG_DOMINANT' :
                          shortBias > 0.55 ? 'SHORT_DOMINANT' : 'BALANCED',
                trend: rate > 0.0001 ? 'LONGS_INCREASING' :
                      rate < -0.0001 ? 'SHORTS_INCREASING' : 'STABLE',
                // Contrarian signal
                contrarianSignal: longBias > 0.65 ? 'BEARISH' :
                                 shortBias > 0.65 ? 'BULLISH' :
                                 longBias > 0.55 ? 'SLIGHTLY_BEARISH' :
                                 shortBias > 0.55 ? 'SLIGHTLY_BULLISH' : 'NEUTRAL',
                estimated: true // Flag that this is estimated from funding rate
            };
        }
    } catch(e) { 
        // Silent fail for L/S ratio 
    }
    return null;
}

// Calculate Liquidation Levels based on current price
function calculateLiquidationLevels(currentPrice, direction) {
    // SAFETY: Validate currentPrice
    if (!currentPrice || currentPrice <= 0 || isNaN(currentPrice)) {
        return { levels: [], longCluster: [], shortCluster: [], analysis: 'No price data' };
    }
    
    // Common leverage levels used by traders
    const leverages = [3, 5, 10, 20, 25, 50, 75, 100];
    const levels = [];
    
    leverages.forEach(lev => {
        // Approximate liquidation prices (simplified, doesn't account for fees/maintenance margin)
        // Long liquidation: entry * (1 - 1/leverage)
        // Short liquidation: entry * (1 + 1/leverage)
        
        const longLiqPrice = currentPrice * (1 - (0.9 / lev)); // 90% of margin used
        const shortLiqPrice = currentPrice * (1 + (0.9 / lev));
        
        // SAFETY: Safe division
        const longDist = currentPrice > 0 ? ((currentPrice - longLiqPrice) / currentPrice * 100).toFixed(2) : '0.00';
        const shortDist = currentPrice > 0 ? ((shortLiqPrice - currentPrice) / currentPrice * 100).toFixed(2) : '0.00';
        
        levels.push({
            leverage: lev,
            longLiqPrice: longLiqPrice,
            shortLiqPrice: shortLiqPrice,
            longDistPct: longDist,
            shortDistPct: shortDist
        });
    });
    
    // Find key liquidation clusters (where most retail traders would be liquidated)
    const retailLeverages = [10, 20, 25]; // Most common retail leverage
    const longCluster = levels.filter(l => retailLeverages.includes(l.leverage))
                              .map(l => l.longLiqPrice);
    const shortCluster = levels.filter(l => retailLeverages.includes(l.leverage))
                               .map(l => l.shortLiqPrice);
    
    return {
        levels: levels,
        longCluster: {
            low: longCluster.length > 0 ? Math.min(...longCluster) : 0,
            high: longCluster.length > 0 ? Math.max(...longCluster) : 0,
            mid: longCluster.length > 0 ? longCluster.reduce((a, b) => a + b, 0) / longCluster.length : 0
        },
        shortCluster: {
            low: shortCluster.length > 0 ? Math.min(...shortCluster) : 0,
            high: shortCluster.length > 0 ? Math.max(...shortCluster) : 0,
            mid: shortCluster.length > 0 ? shortCluster.reduce((a, b) => a + b, 0) / shortCluster.length : 0
        },
        // Key magnet levels (where price is attracted to grab liquidity)
        magnetLong: levels.find(l => l.leverage === 20)?.longLiqPrice || 0,
        magnetShort: levels.find(l => l.leverage === 20)?.shortLiqPrice || 0
    };
}

// Master function: Fetch all institutional data for a symbol
async function fetchInstitutionalData(symbol, currentPrice) {
    const [funding, oi, lsRatio] = await Promise.all([
        fetchFundingRate(symbol),
        fetchOpenInterest(symbol),
        fetchLongShortRatio(symbol)
    ]);
    
    const liqLevels = calculateLiquidationLevels(currentPrice, null);
    
    // Calculate institutional bias
    let bullScore = 0, bearScore = 0;
    
    // Funding Rate Analysis
    if (funding) {
        if (funding.rate > 0.0005) bearScore += 20; // Longs overleveraged
        else if (funding.rate < -0.0005) bullScore += 20; // Shorts overleveraged
        else if (funding.rate > 0.0001) bearScore += 10;
        else if (funding.rate < -0.0001) bullScore += 10;
    }
    
    // OI Analysis
    if (oi) {
        // Rising OI with price direction = trend continuation
        // Rising OI against price = reversal brewing
        if (parseFloat(oi.change4h) > 5) {
            // New positions opening - need to combine with price action
            bullScore += 5;
            bearScore += 5;
        } else if (parseFloat(oi.change4h) < -5) {
            // Positions closing - trend exhaustion
            bullScore += 0;
            bearScore += 0;
        }
    }
    
    // Long/Short Ratio (Contrarian)
    if (lsRatio) {
        if (parseFloat(lsRatio.buyRatio) > 60) bearScore += 25; // Too many longs
        else if (parseFloat(lsRatio.sellRatio) > 60) bullScore += 25; // Too many shorts
        else if (parseFloat(lsRatio.buyRatio) > 55) bearScore += 15;
        else if (parseFloat(lsRatio.sellRatio) > 55) bullScore += 15;
    }
    
    // Determine overall institutional bias
    let institutionalBias = 'NEUTRAL';
    let biasStrength = 0;
    
    if (bullScore > bearScore + 20) {
        institutionalBias = 'BULLISH';
        biasStrength = bullScore - bearScore;
    } else if (bearScore > bullScore + 20) {
        institutionalBias = 'BEARISH';
        biasStrength = bearScore - bullScore;
    } else if (bullScore > bearScore + 10) {
        institutionalBias = 'SLIGHTLY_BULLISH';
        biasStrength = bullScore - bearScore;
    } else if (bearScore > bullScore + 10) {
        institutionalBias = 'SLIGHTLY_BEARISH';
        biasStrength = bearScore - bullScore;
    }
    
    // Squeeze detection
    let squeezeRisk = null;
    if (funding && lsRatio) {
        if (funding.rate > 0.0008 && parseFloat(lsRatio.buyRatio) > 60) {
            squeezeRisk = {
                type: 'LONG_SQUEEZE',
                probability: 'HIGH',
                trigger: liqLevels.magnetLong,
                reason: 'High funding + crowded longs'
            };
        } else if (funding.rate < -0.0008 && parseFloat(lsRatio.sellRatio) > 60) {
            squeezeRisk = {
                type: 'SHORT_SQUEEZE',
                probability: 'HIGH',
                trigger: liqLevels.magnetShort,
                reason: 'Negative funding + crowded shorts'
            };
        } else if (funding.rate > 0.0005 && parseFloat(lsRatio.buyRatio) > 55) {
            squeezeRisk = {
                type: 'LONG_SQUEEZE',
                probability: 'MEDIUM',
                trigger: liqLevels.magnetLong,
                reason: 'Elevated funding + long bias'
            };
        } else if (funding.rate < -0.0005 && parseFloat(lsRatio.sellRatio) > 55) {
            squeezeRisk = {
                type: 'SHORT_SQUEEZE',
                probability: 'MEDIUM',
                trigger: liqLevels.magnetShort,
                reason: 'Negative funding + short bias'
            };
        }
    }
    
    return {
        funding: funding,
        openInterest: oi,
        longShortRatio: lsRatio,
        liquidationLevels: liqLevels,
        institutionalBias: institutionalBias,
        biasStrength: biasStrength,
        bullScore: bullScore,
        bearScore: bearScore,
        squeezeRisk: squeezeRisk,
        timestamp: Date.now()
    };
}

// Analyze institutional data for trade decision
function analyzeInstitutionalData(instData, direction) {
    if (!instData) return { score: 0, factors: [], warnings: [] };
    
    const result = {
        score: 0,
        factors: [],
        warnings: [],
        recommendation: 'NEUTRAL'
    };
    
    // Check if institutional bias aligns with trade direction
    if (direction === 'LONG') {
        if (instData.institutionalBias === 'BULLISH') {
            result.score += 25;
            result.factors.push('Institutional bias: BULLISH');
        } else if (instData.institutionalBias === 'SLIGHTLY_BULLISH') {
            result.score += 15;
            result.factors.push('Institutional bias: Slightly bullish');
        } else if (instData.institutionalBias === 'BEARISH') {
            result.score -= 20;
            result.warnings.push('⚠️ Institutional bias AGAINST long');
        } else if (instData.institutionalBias === 'SLIGHTLY_BEARISH') {
            result.score -= 10;
            result.warnings.push('Institutional bias slightly against');
        }
        
        // Squeeze risk check
        if (instData.squeezeRisk) {
            if (instData.squeezeRisk.type === 'LONG_SQUEEZE') {
                result.score -= 30;
                result.warnings.push(`🚨 ${instData.squeezeRisk.probability} LONG SQUEEZE risk`);
            } else if (instData.squeezeRisk.type === 'SHORT_SQUEEZE') {
                result.score += 20;
                result.factors.push('🚀 Short squeeze potential');
            }
        }
        
    } else { // SHORT
        if (instData.institutionalBias === 'BEARISH') {
            result.score += 25;
            result.factors.push('Institutional bias: BEARISH');
        } else if (instData.institutionalBias === 'SLIGHTLY_BEARISH') {
            result.score += 15;
            result.factors.push('Institutional bias: Slightly bearish');
        } else if (instData.institutionalBias === 'BULLISH') {
            result.score -= 20;
            result.warnings.push('⚠️ Institutional bias AGAINST short');
        } else if (instData.institutionalBias === 'SLIGHTLY_BULLISH') {
            result.score -= 10;
            result.warnings.push('Institutional bias slightly against');
        }
        
        // Squeeze risk check
        if (instData.squeezeRisk) {
            if (instData.squeezeRisk.type === 'SHORT_SQUEEZE') {
                result.score -= 30;
                result.warnings.push(`🚨 ${instData.squeezeRisk.probability} SHORT SQUEEZE risk`);
            } else if (instData.squeezeRisk.type === 'LONG_SQUEEZE') {
                result.score += 20;
                result.factors.push('🚀 Long squeeze potential');
            }
        }
    }
    
    // Funding rate bonus/penalty
    if (instData.funding) {
        if (direction === 'LONG' && instData.funding.rate < -0.0003) {
            result.score += 10;
            result.factors.push(`Negative funding (${instData.funding.ratePercent}%) - shorts paying`);
        } else if (direction === 'SHORT' && instData.funding.rate > 0.0003) {
            result.score += 10;
            result.factors.push(`Positive funding (${instData.funding.ratePercent}%) - longs paying`);
        } else if (direction === 'LONG' && instData.funding.rate > 0.0005) {
            result.score -= 10;
            result.warnings.push(`High funding (${instData.funding.ratePercent}%) - expensive longs`);
        } else if (direction === 'SHORT' && instData.funding.rate < -0.0005) {
            result.score -= 10;
            result.warnings.push(`Negative funding (${instData.funding.ratePercent}%) - expensive shorts`);
        }
    }
    
    // OI trend
    if (instData.openInterest) {
        if (instData.openInterest.trend === 'RISING') {
            result.factors.push(`OI rising +${instData.openInterest.change4h}% (new positions)`);
        } else if (instData.openInterest.trend === 'FALLING') {
            result.warnings.push(`OI falling ${instData.openInterest.change4h}% (positions closing)`);
        }
    }
    
    // Overall recommendation
    if (result.score >= 30) {
        result.recommendation = 'STRONG_CONFIRM';
    } else if (result.score >= 15) {
        result.recommendation = 'CONFIRM';
    } else if (result.score <= -20) {
        result.recommendation = 'AVOID';
    } else if (result.score <= -10) {
        result.recommendation = 'CAUTION';
    } else {
        result.recommendation = 'NEUTRAL';
    }
    
    return result;
}


async function fetchBTC() {
    try {
        const d = await fetchJSON(`${CONFIG.BYBIT_V5}/market/tickers?category=linear&symbol=BTCUSDT`);
        if (d && d.retCode === 0 && d.result && d.result.list && d.result.list.length > 0) {
            const ticker = d.result.list[0];
            STATE.btc.price = parseFloat(ticker.lastPrice);
            STATE.btc.change = parseFloat(ticker.price24hPcnt) * 100 || 0;
            // Update BTC badge
            const btcBadge = document.getElementById('badgeBTC');
            const btcVal = document.getElementById('badgeBTCVal');
            if (btcVal) {
                const priceK = '$' + (STATE.btc.price / 1000).toFixed(1) + 'K';
                const arrow = STATE.btc.change >= 0 ? '▲' : '▼';
                btcVal.textContent = priceK + arrow;
                btcBadge.className = 'info-badge ' + (STATE.btc.change >= 0 ? 'go' : 'nogo');
            }
        }
    } catch(e) {
        // Silent fail for BTC
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENVIRONMENT ANALYSIS SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Fetch BTC klines for structure and RSI analysis
async function fetchBTCAnalysis() {
    try {
        // Fetch BTC 1H and 4H klines
        const btc1H = await fetchKlines('BTCUSDT', '60', 100);
        const btc4H = await fetchKlines('BTCUSDT', '240', 100);
        
        if (!btc1H || !btc4H || btc1H.length < 50 || btc4H.length < 50) {
            return null;
        }
        
        // Calculate BTC RSI (14 period on 4H)
        const btc4HCloses = btc4H.map(k => k.close);
        const rsi = calcRSI(btc4HCloses);
        STATE.environment.btcRSI = {
            value: Math.round(rsi.value),
            status: rsi.value > 70 ? 'OVERBOUGHT' : rsi.value < 30 ? 'OVERSOLD' : 'HEALTHY'
        };
        
        // Determine BTC Trend from 4H
        const ema20 = calcEMA(btc4H.map(k => k.close), 20);
        const ema50 = calcEMA(btc4H.map(k => k.close), 50);
        const currentPrice = btc4H[btc4H.length - 1].close;
        const ema20Val = ema20[ema20.length - 1];
        const ema50Val = ema50[ema50.length - 1];
        
        let btcTrend = 'FLAT';
        let strength = 50;
        
        if (currentPrice > ema20Val && ema20Val > ema50Val) {
            btcTrend = 'BULLISH';
            strength = 70 + Math.min(30, ((currentPrice - ema50Val) / ema50Val) * 100);
        } else if (currentPrice < ema20Val && ema20Val < ema50Val) {
            btcTrend = 'BEARISH';
            strength = 70 + Math.min(30, ((ema50Val - currentPrice) / ema50Val) * 100);
        } else if (currentPrice > ema20Val) {
            btcTrend = 'BULLISH';
            strength = 55;
        } else if (currentPrice < ema20Val) {
            btcTrend = 'BEARISH';
            strength = 55;
        }
        
        STATE.environment.btcTrend = { direction: btcTrend, strength: Math.min(100, strength) };
        
        // Check BTC Structure (look for recent BOS)
        const swings = findSwingPoints(btc4H, 5, 5);
        let structureStatus = 'INTACT';
        
        // Check if recent swing low was broken (bearish structure break)
        if (swings.lows.length >= 2) {
            const recentLow = swings.lows[swings.lows.length - 1];
            const prevLow = swings.lows[swings.lows.length - 2];
            if (currentPrice < prevLow.price && recentLow.price < prevLow.price) {
                structureStatus = 'BROKEN_DOWN';
            }
        }
        
        // Check if recent swing high was broken (bullish structure break)
        if (swings.highs.length >= 2) {
            const recentHigh = swings.highs[swings.highs.length - 1];
            const prevHigh = swings.highs[swings.highs.length - 2];
            if (currentPrice > prevHigh.price && recentHigh.price > prevHigh.price) {
                structureStatus = 'BROKEN_UP';
            }
        }
        
        STATE.environment.btcStructure = {
            status: structureStatus,
            score: structureStatus === 'INTACT' ? 100 : 
                   structureStatus === 'BROKEN_UP' ? 80 : 
                   structureStatus === 'BROKEN_DOWN' ? 20 : 50
        };
        
        return true;
    } catch (e) {
        console.error('BTC Analysis error:', e);
        return null;
    }
}

// Calculate Environment Score (FULL 100 points with null safety)
function calculateEnvironmentScore(signalDirection, signal = null) {
    let score = 0;
    let details = [];
    const dir = signalDirection || 'LONG';
    const env = STATE.environment || {};
    
    // SAFETY: Default values if environment not loaded
    const dxy = env.dxy || { trend: 'FLAT', value: 0 };
    const btcTrend = env.btcTrend || { direction: 'FLAT', strength: 50 };
    const btcD = env.btcDominance || { trend: 'FLAT', value: 0 };
    const struct = env.btcStructure || { status: 'UNKNOWN', score: 50 };
    const rsi = env.btcRSI || { value: 50, status: 'HEALTHY' };
    const funding = env.funding || { rate: 0, status: 'NORMAL' };
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 1: MACRO (40 points)
    // ═══════════════════════════════════════════════════════════════════
    
    // DXY (10 points)
    if (dxy.trend === 'FALLING') {
        score += 10;
        details.push({ label: 'DXY', value: '▼ DOWN', status: 'ok', points: '+10' });
    } else if (dxy.trend === 'RISING') {
        score += 2;
        details.push({ label: 'DXY', value: '▲ UP', status: 'bad', points: '+2' });
    } else {
        score += 5;
        details.push({ label: 'DXY', value: '─ FLAT', status: 'warn', points: '+5' });
    }
    
    // BTC Trend (15 points)
    if ((dir === 'LONG' && btcTrend.direction === 'BULLISH') ||
        (dir === 'SHORT' && btcTrend.direction === 'BEARISH')) {
        score += 15;
        details.push({ label: 'BTC Trend', value: btcTrend.direction, status: 'ok', points: '+15' });
    } else if (btcTrend.direction === 'FLAT') {
        score += 7;
        details.push({ label: 'BTC Trend', value: 'FLAT', status: 'warn', points: '+7' });
    } else {
        score += 0;
        details.push({ label: 'BTC Trend', value: (btcTrend.direction || 'N/A') + ' ❌', status: 'bad', points: '+0' });
    }
    
    // BTC.D (15 points)
    if ((dir === 'LONG' && btcD.trend === 'FALLING') ||
        (dir === 'SHORT' && btcD.trend === 'RISING')) {
        score += 15;
        details.push({ label: 'BTC.D', value: btcD.trend === 'FALLING' ? '▼ ALTS' : '▲ BTC', status: 'ok', points: '+15' });
    } else if (btcD.trend === 'FLAT') {
        score += 7;
        details.push({ label: 'BTC.D', value: '─ FLAT', status: 'warn', points: '+7' });
    } else {
        score += 0;
        details.push({ label: 'BTC.D', value: btcD.trend === 'RISING' ? '▲ BTC SZN' : '▼ ALT SZN', status: 'bad', points: '+0' });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 2: BTC HEALTH (25 points)
    // ═══════════════════════════════════════════════════════════════════
    
    // BTC Structure (15 points)
    if (struct.status === 'INTACT') {
        score += 15;
        details.push({ label: 'Structure', value: 'INTACT', status: 'ok', points: '+15' });
    } else if ((dir === 'LONG' && struct.status === 'BROKEN_UP') ||
               (dir === 'SHORT' && struct.status === 'BROKEN_DOWN')) {
        score += 12;
        details.push({ label: 'Structure', value: struct.status, status: 'ok', points: '+12' });
    } else if (struct.status === 'UNKNOWN') {
        score += 7;
        details.push({ label: 'Structure', value: 'UNKNOWN', status: 'warn', points: '+7' });
    } else {
        score += 0;
        details.push({ label: 'Structure', value: (struct.status || 'N/A') + ' ❌', status: 'bad', points: '+0' });
    }
    
    // BTC RSI (10 points)
    if (rsi.status === 'HEALTHY') {
        score += 10;
        details.push({ label: 'BTC RSI', value: rsi.value + ' OK', status: 'ok', points: '+10' });
    } else if ((dir === 'LONG' && rsi.status === 'OVERSOLD') ||
               (dir === 'SHORT' && rsi.status === 'OVERBOUGHT')) {
        score += 10;
        details.push({ label: 'BTC RSI', value: rsi.value + ' ' + rsi.status, status: 'ok', points: '+10' });
    } else {
        score += 3;
        details.push({ label: 'BTC RSI', value: rsi.value + ' ⚠️', status: 'warn', points: '+3' });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 3: LEVERAGE (10 points)
    // ═══════════════════════════════════════════════════════════════════
    
    // Funding Rate (10 points)
    const fundingPct = ((funding.rate || 0) * 100).toFixed(3);
    if (funding.status === 'NORMAL') {
        score += 10;
        details.push({ label: 'Funding', value: fundingPct + '%', status: 'ok', points: '+10' });
    } else if (funding.status === 'ELEVATED') {
        if ((dir === 'LONG' && funding.rate < 0) || (dir === 'SHORT' && funding.rate > 0)) {
            score += 10;
            details.push({ label: 'Funding', value: fundingPct + '%', status: 'ok', points: '+10' });
        } else {
            score += 5;
            details.push({ label: 'Funding', value: fundingPct + '% ⚠️', status: 'warn', points: '+5' });
        }
    } else { // EXTREME
        if ((dir === 'LONG' && funding.rate > 0) || (dir === 'SHORT' && funding.rate < 0)) {
            score += 0;
            details.push({ label: 'Funding', value: fundingPct + '% ❌', status: 'bad', points: '+0' });
        } else {
            score += 10;
            details.push({ label: 'Funding', value: fundingPct + '%', status: 'ok', points: '+10' });
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 4: MARKET FLOW (10 points) - OI Analysis
    // ═══════════════════════════════════════════════════════════════════
    
    // Open Interest Analysis (10 points)
    const oiAnalysis = analyzeOIForSignal(dir, signal?.coinOI);
    score += oiAnalysis.score;
    
    if (oiAnalysis.status === 'CONFIRMED') {
        details.push({ label: 'OI Flow', value: '✅ CONFIRMED', status: 'ok', points: `+${oiAnalysis.score}` });
    } else if (oiAnalysis.status === 'SQUEEZE') {
        details.push({ label: 'OI Flow', value: '⚠️ SQUEEZE', status: 'warn', points: `+${oiAnalysis.score}` });
    } else if (oiAnalysis.status === 'DANGER') {
        details.push({ label: 'OI Flow', value: '❌ LIQUIDATIONS', status: 'bad', points: `+${oiAnalysis.score}` });
    } else {
        details.push({ label: 'OI Flow', value: '─ NEUTRAL', status: 'warn', points: `+${oiAnalysis.score}` });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 5: COIN SPECIFIC (15 points) - RS + HTF (reduced from 25)
    // ═══════════════════════════════════════════════════════════════════
    
    // Coin Relative Strength (8 points - reduced from 15)
    if (signal && signal.coinRS !== undefined) {
        const rs = signal.coinRS;
        if (rs >= 1.2) {
            score += 8;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x STRONG', status: 'ok', points: '+8' });
        } else if (rs >= 1.0) {
            score += 6;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x OK', status: 'ok', points: '+6' });
        } else if (rs >= 0.8) {
            score += 3;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x ⚠️', status: 'warn', points: '+3' });
        } else {
            score += 0;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x WEAK ❌', status: 'bad', points: '+0' });
        }
    } else {
        score += 4;
        details.push({ label: 'Coin RS', value: 'N/A', status: 'warn', points: '+4' });
    }
    
    // HTF Alignment (7 points - reduced from 10)
    if (signal && signal.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 0;
        if (htfPct >= 75) {
            score += 7;
            details.push({ label: 'HTF Align', value: Math.round(htfPct) + '% ✓', status: 'ok', points: '+7' });
        } else if (htfPct >= 50) {
            score += 4;
            details.push({ label: 'HTF Align', value: Math.round(htfPct) + '%', status: 'warn', points: '+4' });
        } else {
            score += 0;
            details.push({ label: 'HTF Align', value: Math.round(htfPct) + '% ❌', status: 'bad', points: '+0' });
        }
    } else {
        score += 3;
        details.push({ label: 'HTF Align', value: 'N/A', status: 'warn', points: '+3' });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // FINAL SCORE (100 points max)
    // DXY: 10 + BTC Trend: 15 + BTC.D: 15 + Structure: 15 + RSI: 10 + 
    // Funding: 10 + OI: 10 + RS: 8 + HTF: 7 = 100
    // ═══════════════════════════════════════════════════════════════════
    
    // Determine verdict based on 100-point scale
    let verdict = 'NO-GO';
    if (score >= 80) verdict = 'GO';
    else if (score >= 60) verdict = 'CAUTION';
    else if (score >= 40) verdict = 'RISKY';
    
    // Add OI warning if squeeze detected
    const oiWarning = oiAnalysis.warning;
    
    return { score, verdict, details, oiWarning };
}

// Update Environment Display
function updateEnvironmentDisplay() {
    const env = STATE.environment || {};
    
    // SAFETY: Default values
    const btcTrend = env.btcTrend || { direction: 'FLAT' };
    const btcDom = env.btcDominance || { trend: 'FLAT' };
    const dxy = env.dxy || { value: 0, trend: 'FLAT' };
    const struct = env.btcStructure || { status: 'UNKNOWN' };
    const rsi = env.btcRSI || { value: 50, status: 'HEALTHY' };
    const funding = env.funding || { rate: 0, status: 'NORMAL' };
    
    // BTC Trend
    const btcEl = document.getElementById('envBTC');
    const btcVal = document.getElementById('envBTCVal');
    if (btcVal && btcEl) {
        const trend = btcTrend.direction || 'FLAT';
        btcVal.textContent = trend === 'BULLISH' ? '🟢 BULL' : trend === 'BEARISH' ? '🔴 BEAR' : '🟡 FLAT';
        btcEl.className = 'env-status ' + (trend === 'BULLISH' ? 'go' : trend === 'BEARISH' ? 'nogo' : 'caution');
    }
    
    // BTC.D Trend
    const btcdEl = document.getElementById('envBTCD');
    const btcdVal = document.getElementById('envBTCDVal');
    if (btcdVal && btcdEl) {
        const trend = btcDom.trend || 'FLAT';
        btcdVal.textContent = trend === 'FALLING' ? '▼ ALTS' : trend === 'RISING' ? '▲ BTC' : '─ FLAT';
        btcdEl.className = 'env-status ' + (trend === 'FALLING' ? 'go' : trend === 'RISING' ? 'nogo' : 'caution');
    }
    
    // DXY Trend
    const dxyEl = document.getElementById('envDXY');
    const dxyVal = document.getElementById('envDXYVal');
    if (dxyVal && dxyEl) {
        const trend = dxy.trend || 'FLAT';
        const value = dxy.value || 0;
        dxyVal.textContent = value ? value.toFixed(1) + (trend === 'FALLING' ? '▼' : trend === 'RISING' ? '▲' : '') : '--';
        dxyEl.className = 'env-status ' + (trend === 'FALLING' ? 'go' : trend === 'RISING' ? 'nogo' : 'caution');
    }
    
    // Structure
    const structEl = document.getElementById('envStruct');
    const structVal = document.getElementById('envStructVal');
    if (structVal && structEl) {
        const status = struct.status || 'UNKNOWN';
        structVal.textContent = status === 'INTACT' ? '✅ OK' : status === 'BROKEN_UP' ? '⬆️ BRK' : status === 'BROKEN_DOWN' ? '⬇️ BRK' : '❓';
        structEl.className = 'env-status ' + (status === 'INTACT' ? 'go' : status === 'UNKNOWN' ? 'caution' : status === 'BROKEN_UP' ? 'caution' : 'nogo');
    }
    
    // RSI
    const rsiEl = document.getElementById('envRSI');
    const rsiVal = document.getElementById('envRSIVal');
    if (rsiVal && rsiEl) {
        const rsiStatus = rsi.status || 'HEALTHY';
        const rsiValue = rsi.value || 50;
        rsiVal.textContent = rsiValue + (rsiStatus === 'HEALTHY' ? '' : rsiStatus === 'OVERBOUGHT' ? '🔥' : '❄️');
        rsiEl.className = 'env-status ' + (rsiStatus === 'HEALTHY' ? 'go' : 'caution');
    }
    
    // Funding
    const fundEl = document.getElementById('envFund');
    const fundVal = document.getElementById('envFundVal');
    if (fundVal && fundEl) {
        const rate = funding.rate || 0;
        const status = funding.status || 'NORMAL';
        fundVal.textContent = (rate * 100).toFixed(2) + '%';
        fundEl.className = 'env-status ' + (status === 'NORMAL' ? 'go' : status === 'ELEVATED' ? 'caution' : 'nogo');
    }
    
    // Calculate overall score for favored direction
    const longEnv = calculateEnvironmentScore('LONG');
    const shortEnv = calculateEnvironmentScore('SHORT');
    
    let favoredDir = null;
    let bestScore = 0;
    let bestVerdict = 'NO-GO';
    
    if (longEnv.score > shortEnv.score) {
        favoredDir = 'LONG';
        bestScore = longEnv.score;
        bestVerdict = longEnv.verdict;
    } else if (shortEnv.score > longEnv.score) {
        favoredDir = 'SHORT';
        bestScore = shortEnv.score;
        bestVerdict = shortEnv.verdict;
    } else {
        bestScore = longEnv.score;
        bestVerdict = longEnv.verdict;
    }
    
    STATE.environment.score = bestScore;
    STATE.environment.verdict = bestVerdict;
    STATE.environment.favoredDirection = favoredDir;
    STATE.environment.lastUpdate = Date.now();
    
    // Update verdict display
    const verdictEl = document.getElementById('envVerdict');
    const scoreEl = document.getElementById('envScore');
    const verdictText = document.getElementById('envVerdictText');
    
    if (verdictEl && scoreEl && verdictText) {
        scoreEl.textContent = bestScore + '/100';
        const dirText = favoredDir ? (favoredDir === 'LONG' ? '📈' : '📉') : '';
        verdictText.textContent = dirText + ' ' + bestVerdict;
        
        const verdictClass = bestVerdict === 'GO' ? 'go' : 
                            bestVerdict === 'CAUTION' ? 'caution' : 
                            bestVerdict === 'RISKY' ? 'risky' : 'nogo';
        verdictEl.className = 'env-verdict ' + verdictClass;
    }
}

// V10.3 Structure Bar Update - Updates based on active signal or BTC structure
function updateStructureBar(structureData = null) {
    try {
        // Use provided structure data or try to get from current/selected signal
        const str = structureData || 
                   (STATE.current?.structure) || 
                   (STATE.selected?.structure) || 
                   (STATE.signals[0]?.structure) || 
                   null;
        
        // Channel
        const chEl = document.getElementById('strChannel');
        const chVal = document.getElementById('strChannelVal');
        if (chVal && chEl) {
            if (str?.channel?.isValid) {
                chVal.textContent = (str.channel.widthPct * 100).toFixed(1) + '%';
                chEl.className = 'str-status valid';
            } else {
                chVal.textContent = 'NO';
                chEl.className = 'str-status invalid';
            }
        }
        
        // Trendlines
        const tlEl = document.getElementById('strTrendline');
        const tlVal = document.getElementById('strTrendlineVal');
        if (tlVal && tlEl) {
            const bullCount = str?.trendlines?.bull?.length || 0;
            const bearCount = str?.trendlines?.bear?.length || 0;
            const totalTL = bullCount + bearCount;
            if (totalTL > 0) {
                tlVal.textContent = `↑${bullCount} ↓${bearCount}`;
                tlEl.className = 'str-status valid';
            } else {
                tlVal.textContent = 'NONE';
                tlEl.className = 'str-status neutral';
            }
        }
        
        // Compression
        const compEl = document.getElementById('strCompression');
        const compVal = document.getElementById('strCompressionVal');
        if (compVal && compEl) {
            if (str?.compression?.isCompressed) {
                compVal.textContent = '🔄 YES';
                compEl.className = 'str-status valid';
            } else if (str?.compression?.isExpanding) {
                compVal.textContent = '💥 EXP';
                compEl.className = 'str-status neutral';
            } else {
                compVal.textContent = 'NO';
                compEl.className = 'str-status';
            }
        }
        
        // Bias
        const biasEl = document.getElementById('strBias');
        const biasVal = document.getElementById('strBiasVal');
        if (biasVal && biasEl) {
            const bias = str?.bias || 'NEUTRAL';
            if (bias === 'DISCOUNT') {
                biasVal.textContent = '🟢 DISC';
                biasEl.className = 'str-status valid';
            } else if (bias === 'PREMIUM') {
                biasVal.textContent = '🔴 PREM';
                biasEl.className = 'str-status invalid';
            } else {
                biasVal.textContent = '⚖️ EQ';
                biasEl.className = 'str-status neutral';
            }
        }
        
        // Verdict
        const verdictEl = document.getElementById('strVerdict');
        const scoreEl = document.getElementById('strScore');
        const verdictText = document.getElementById('strVerdictText');
        if (verdictEl && scoreEl && verdictText) {
            const score = str?.score || 0;
            const gatePass = str?.gatePass !== false;
            
            scoreEl.textContent = score;
            verdictText.textContent = gatePass ? 'VALID' : 'WEAK';
            verdictEl.className = 'str-verdict ' + (gatePass && score >= 30 ? 'valid' : score >= 15 ? 'neutral' : 'invalid');
        }
        
    } catch (e) {
        // Silent: Structure bar
    }
}

// Full Environment Update
async function updateEnvironment() {
    try {
        // Fetch BTC analysis
        await fetchBTCAnalysis();
        
        // Update DXY trend from existing state
        if (STATE.dxy && STATE.dxy.price) {
            STATE.environment.dxy = {
                value: STATE.dxy.price,
                trend: STATE.dxy.price > STATE.dxy.prevPrice ? 'RISING' : 
                       STATE.dxy.price < STATE.dxy.prevPrice ? 'FALLING' : 'FLAT',
                favorable: STATE.dxy.price < STATE.dxy.prevPrice
            };
        }
        
        // Update BTC.D trend from existing state
        STATE.environment.btcDominance = {
            value: STATE.btcDominance || 0,
            trend: STATE.btcDomTrend === 'rising' ? 'RISING' : 
                   STATE.btcDomTrend === 'falling' ? 'FALLING' : 'FLAT'
        };
        
        // Update Funding from existing state
        if (STATE.funding !== null) {
            const rate = STATE.funding;
            STATE.environment.funding = {
                rate: rate,
                status: Math.abs(rate) > 0.001 ? 'EXTREME' : 
                        Math.abs(rate) > 0.0005 ? 'ELEVATED' : 'NORMAL'
            };
        }
        
        // Update display
        updateEnvironmentDisplay();
        
        // Update ALTS badge based on new environment
        updateAltsBadge();
        
    } catch (e) {
        console.error('Environment update error:', e);
    }
}

// Check if signal should be filtered based on environment
function shouldFilterSignal(signal) {
    const env = STATE.environment || {};
    const dir = signal?.direction || 'LONG';
    
    // SAFETY: Default values
    const structStatus = env.btcStructure?.status || 'UNKNOWN';
    const fundStatus = env.funding?.status || 'NORMAL';
    const fundRate = env.funding?.rate || 0;
    
    // HARD BLOCK 1: BTC Structure broken against signal
    if (dir === 'LONG' && structStatus === 'BROKEN_DOWN') {
        return { filter: true, reason: 'BTC Structure broken down - no longs' };
    }
    if (dir === 'SHORT' && structStatus === 'BROKEN_UP') {
        return { filter: true, reason: 'BTC Structure broken up - no shorts' };
    }
    
    // HARD BLOCK 2: Extreme funding against signal
    if (fundStatus === 'EXTREME') {
        if (dir === 'LONG' && fundRate > 0.001) {
            return { filter: true, reason: 'Extreme positive funding (longs crowded)' };
        }
        if (dir === 'SHORT' && fundRate < -0.001) {
            return { filter: true, reason: 'Extreme negative funding (shorts crowded)' };
        }
    }
    
    // HARD BLOCK 3: HTF severely misaligned (<25%)
    if (signal?.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 50;
        if (htfPct < 25) {
            return { filter: true, reason: 'HTF severely misaligned (' + Math.round(htfPct) + '%)' };
        }
    }
    
    // HARD BLOCK 4: Environment score too low (using signal for RS/HTF)
    const envScore = calculateEnvironmentScore(dir, signal);
    if (envScore.score < 30) {
        return { filter: true, reason: 'Environment score too low (' + envScore.score + '/100)' };
    }
    
    return { filter: false, reason: null };
}

// Get environment icons for signal card
function getEnvIcons(signal) {
    const env = STATE.environment || {};
    const dir = signal?.direction || 'LONG';
    const icons = [];
    
    // SAFETY: Default values
    const btcTrend = env.btcTrend?.direction || 'FLAT';
    const btcDomTrend = env.btcDominance?.trend || 'FLAT';
    const dxyTrend = env.dxy?.trend || 'FLAT';
    const structStatus = env.btcStructure?.status || 'UNKNOWN';
    const rsiStatus = env.btcRSI?.status || 'HEALTHY';
    const fundStatus = env.funding?.status || 'NORMAL';
    const fundRate = env.funding?.rate || 0;
    
    // BTC Trend
    const btcOk = (dir === 'LONG' && btcTrend === 'BULLISH') ||
                  (dir === 'SHORT' && btcTrend === 'BEARISH') ||
                  btcTrend === 'FLAT';
    icons.push({ label: 'BTC', ok: btcOk, warn: btcTrend === 'FLAT' });
    
    // BTC.D
    const btcdOk = (dir === 'LONG' && btcDomTrend === 'FALLING') ||
                   (dir === 'SHORT' && btcDomTrend === 'RISING') ||
                   btcDomTrend === 'FLAT';
    icons.push({ label: 'D', ok: btcdOk, warn: btcDomTrend === 'FLAT' });
    
    // DXY
    const dxyOk = dxyTrend === 'FALLING' || dxyTrend === 'FLAT';
    icons.push({ label: 'DXY', ok: dxyOk, warn: dxyTrend === 'FLAT' });
    
    // Structure
    const structOk = structStatus === 'INTACT' ||
                     (dir === 'LONG' && structStatus === 'BROKEN_UP') ||
                     (dir === 'SHORT' && structStatus === 'BROKEN_DOWN');
    icons.push({ label: 'STR', ok: structOk, warn: structStatus === 'UNKNOWN' });
    
    // RSI
    const rsiOk = rsiStatus === 'HEALTHY' ||
                  (dir === 'LONG' && rsiStatus === 'OVERSOLD') ||
                  (dir === 'SHORT' && rsiStatus === 'OVERBOUGHT');
    icons.push({ label: 'RSI', ok: rsiOk, warn: !rsiOk });
    
    // Funding
    const fundOk = fundStatus === 'NORMAL' ||
                   (dir === 'LONG' && fundRate < 0) ||
                   (dir === 'SHORT' && fundRate > 0);
    icons.push({ label: 'FND', ok: fundOk, warn: fundStatus === 'ELEVATED' });
    
    // HTF (from signal)
    if (signal?.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 0;
        const htfOk = htfPct >= 50;
        icons.push({ label: 'HTF', ok: htfOk, warn: htfPct >= 33 && htfPct < 50 });
    }
    
    return icons;
}

// Generate Environment HTML for signal card
function generateEnvIconsHtml(signal) {
    const icons = getEnvIcons(signal);
    const envScore = calculateEnvironmentScore(signal?.direction, signal);
    
    let html = '<div class="signal-env">';
    icons.forEach(icon => {
        const statusClass = icon.ok ? 'ok' : icon.warn ? 'warn' : 'bad';
        const symbol = icon.ok ? '✓' : icon.warn ? '!' : '✗';
        html += `<span class="env-icon ${statusClass}" title="${icon.label}">${icon.label}${symbol}</span>`;
    });
    html += `<span class="env-icon ${envScore.verdict === 'GO' ? 'ok' : envScore.verdict === 'CAUTION' ? 'warn' : 'bad'}">${envScore.score}</span>`;
    html += '</div>';
    
    return html;
}

// Generate Environment Panel HTML for main panel
function generateEnvPanelHtml(signal) {
    const envScore = calculateEnvironmentScore(signal?.direction, signal);
    const verdictClass = envScore.verdict === 'GO' ? 'go' : 
                        envScore.verdict === 'CAUTION' ? 'caution' : 
                        envScore.verdict === 'RISKY' ? 'risky' : 'nogo';
    
    let html = `
    <div class="env-panel">
        <div class="env-panel-title">📊 ENVIRONMENT ANALYSIS</div>`;
    
    envScore.details.forEach(d => {
        html += `
        <div class="env-row">
            <span class="label">${d.label}</span>
            <span class="value ${d.status}">${d.value}<span class="points">${d.points}</span></span>
        </div>`;
    });
    
    html += `
        <div class="env-divider"></div>
        <div class="env-total">
            <span>ENVIRONMENT SCORE:</span>
            <span class="score ${verdictClass}">${envScore.score}/100 ${envScore.verdict}</span>
        </div>
    </div>`;
    
    return html;
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARKET BADGES DATA FETCHING
// ═══════════════════════════════════════════════════════════════════════════════

// Fetch Fear & Greed Index
async function fetchFearGreed() {
    try {
        const d = await fetchJSON('https://api.alternative.me/fng/?limit=1');
        if (d && d.data && d.data[0]) {
            const value = parseInt(d.data[0].value);
            STATE.fearGreed = value;
            const badge = document.getElementById('badgeFG');
            const val = document.getElementById('badgeFGVal');
            if (val) {
                val.textContent = value;
                // Green for fear (<=40 = buying opportunity), Red for greed (>=60 = caution)
                if (value <= 40) {
                    badge.className = 'info-badge go';
                } else if (value >= 60) {
                    badge.className = 'info-badge nogo';
                } else {
                    badge.className = 'info-badge caution';
                }
            }
        }
    } catch(e) { /* Silent fail */ }
}

// Fetch DXY Index
async function fetchDXY() {
    try {
        // V5.1 FIX: DXY estimation from BTC inverse correlation
        // When BTC rises, DXY typically falls (80%+ correlation)
        // This is MORE RELIABLE than proxy-dependent Yahoo fetch
        
        const btcKlines = await fetchKlines('BTCUSDT', '60', 24);
        if (btcKlines && btcKlines.length >= 24) {
            const btcNow = btcKlines[btcKlines.length - 1].close;
            const btc24hAgo = btcKlines[0].close;
            const btcChange = (btcNow - btc24hAgo) / btc24hAgo;
            
            // Inverse correlation: BTC up = DXY down
            const estimatedDXYChange = -btcChange * 0.5; // DXY moves ~50% of inverse BTC
            const baseDXY = 104; // Typical DXY range
            const estimatedDXY = baseDXY * (1 + estimatedDXYChange);
            
            STATE.dxy = { 
                price: estimatedDXY, 
                prevPrice: baseDXY,
                estimated: true,
                btcBased: true
            };
            
            // Also update environment
            if (!STATE.environment) STATE.environment = {};
            if (btcChange > 0.005) {
                STATE.environment.dxy = { trend: 'FALLING', value: estimatedDXY };
            } else if (btcChange < -0.005) {
                STATE.environment.dxy = { trend: 'RISING', value: estimatedDXY };
            } else {
                STATE.environment.dxy = { trend: 'FLAT', value: estimatedDXY };
            }
        }
    } catch(e) { 
        // Silent fail
        // Fallback to FLAT
        STATE.environment = STATE.environment || {};
        STATE.environment.dxy = { trend: 'FLAT', value: 104 };
    }
}

// Fetch Funding Rate - BINANCE API
async function fetchFunding() {
    try {
        const d = await fetchJSON(`${CONFIG.BYBIT_V5}/market/tickers?category=linear&symbol=BTCUSDT`);
        if (d && d.lastFundingRate) {
            const rate = parseFloat(d.lastFundingRate);
            STATE.funding = rate; // Store as decimal (e.g., 0.0001 = 0.01%)
            // Funding display now handled by Environment Bar
        }
    } catch(e) { /* Silent fail */ }
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🕐 SESSION & TIMEZONE AWARENESS SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Initialize awareness state
if (!STATE.awareness) {
    STATE.awareness = {
        timezone: 'auto',
        currentSession: null,
        nextSession: null,
        news: [],
        lastNewsUpdate: 0
    };
}

// Trading sessions in UTC
const TRADING_SESSIONS = {
    ASIA: { start: 0, end: 8, name: 'ASIA', emoji: '🌏', volatility: 'LOW', color: 'var(--cyan)' },
    LONDON: { start: 8, end: 16, name: 'LONDON', emoji: '🇬🇧', volatility: 'HIGH', color: 'var(--amber)' },
    NEW_YORK: { start: 13, end: 21, name: 'NEW YORK', emoji: '🇺🇸', volatility: 'HIGH', color: 'var(--amber)' },
    OVERLAP: { start: 13, end: 16, name: 'LONDON/NY OVERLAP', emoji: '🔥', volatility: 'EXTREME', color: 'var(--short)' },
    OFF_HOURS: { start: 21, end: 24, name: 'OFF HOURS', emoji: '😴', volatility: 'LOW', color: 'var(--text3)' }
};

// Get user's local time based on selected timezone
function getUserTime() {
    const tz = STATE.awareness.timezone || 'auto';
    const options = { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: true,
        timeZone: tz === 'auto' ? undefined : tz
    };
    return new Date().toLocaleTimeString('en-US', options);
}

// Get user's timezone name
function getUserTimezoneName() {
    const tz = STATE.awareness.timezone || 'auto';
    if (tz === 'auto') {
        return Intl.DateTimeFormat().resolvedOptions().timeZone.split('/').pop().replace('_', ' ');
    }
    return tz.split('/').pop().replace('_', ' ');
}

// Get current UTC hour
function getUTCHour() {
    return new Date().getUTCHours();
}

// Determine current trading session
function getCurrentSession() {
    const utcHour = getUTCHour();
    
    // Check for overlap first (highest priority)
    if (utcHour >= 13 && utcHour < 16) {
        return TRADING_SESSIONS.OVERLAP;
    }
    // London session
    if (utcHour >= 8 && utcHour < 16) {
        return TRADING_SESSIONS.LONDON;
    }
    // New York session
    if (utcHour >= 13 && utcHour < 21) {
        return TRADING_SESSIONS.NEW_YORK;
    }
    // Asia session
    if (utcHour >= 0 && utcHour < 8) {
        return TRADING_SESSIONS.ASIA;
    }
    // Off hours
    return TRADING_SESSIONS.OFF_HOURS;
}

// Get next session and time until it starts
function getNextSession() {
    const utcHour = getUTCHour();
    const utcMinute = new Date().getUTCMinutes();
    
    let nextSession, hoursUntil;
    
    if (utcHour < 8) {
        nextSession = TRADING_SESSIONS.LONDON;
        hoursUntil = 8 - utcHour;
    } else if (utcHour < 13) {
        nextSession = TRADING_SESSIONS.OVERLAP;
        hoursUntil = 13 - utcHour;
    } else if (utcHour < 16) {
        nextSession = TRADING_SESSIONS.NEW_YORK;
        hoursUntil = 16 - utcHour;
    } else if (utcHour < 21) {
        nextSession = TRADING_SESSIONS.OFF_HOURS;
        hoursUntil = 21 - utcHour;
    } else {
        nextSession = TRADING_SESSIONS.ASIA;
        hoursUntil = (24 - utcHour) + 0;
    }
    
    const minutesUntil = 60 - utcMinute;
    const totalMinutes = (hoursUntil - 1) * 60 + minutesUntil;
    
    return {
        session: nextSession,
        hours: Math.floor(totalMinutes / 60),
        minutes: totalMinutes % 60
    };
}

// Fetch crypto news/events
async function fetchCryptoNews() {
    try {
        // Using CoinGecko's free events API
        const events = [];
        
        // Check for known major events (hardcoded for reliability)
        const now = new Date();
        const today = now.toISOString().split('T')[0];
        
        // Major recurring events to watch
        const majorEvents = [
            { day: 'Wednesday', time: '18:00', name: 'FOMC Minutes', impact: 'HIGH' },
            { day: 'Friday', time: '12:30', name: 'US Jobs Report', impact: 'HIGH' },
            { day: 'Thursday', time: '12:30', name: 'US CPI Data', impact: 'HIGH' },
        ];
        
        const dayOfWeek = now.toLocaleDateString('en-US', { weekday: 'long' });
        
        majorEvents.forEach(event => {
            if (event.day === dayOfWeek) {
                events.push({
                    name: event.name,
                    time: event.time + ' UTC',
                    impact: event.impact,
                    emoji: event.impact === 'HIGH' ? '⚠️' : '📰'
                });
            }
        });
        
        // Try to fetch live news from alternative API
        try {
            const newsUrl = 'https://api.coingecko.com/api/v3/events';
            const d = await fetchJSON(newsUrl);
            if (d && d.data && Array.isArray(d.data)) {
                const todayEvents = d.data.filter(e => e.start_date && e.start_date.startsWith(today)).slice(0, 3);
                todayEvents.forEach(e => {
                    events.push({
                        name: e.title || 'Crypto Event',
                        time: e.start_date,
                        impact: 'MEDIUM',
                        emoji: '📅'
                    });
                });
            }
        } catch (e) {
            // Ignore if news fetch fails - use static events only
        }
        
        STATE.awareness.news = events;
        STATE.awareness.lastNewsUpdate = Date.now();
        
    } catch(e) { 
        // Silent fail
        STATE.awareness.news = [];
    }
}

// Generate awareness check HTML for main panel
function generateAwarenessHtml() {
    const session = getCurrentSession();
    const nextSess = getNextSession();
    const userTime = getUserTime();
    const cityName = getUserTimezoneName();
    const news = STATE.awareness.news || [];
    
    const volColor = session.volatility === 'EXTREME' ? 'var(--short)' : 
                     session.volatility === 'HIGH' ? 'var(--amber)' : 'var(--long)';
    const volBg = session.volatility === 'EXTREME' ? 'var(--short-dim)' : 
                  session.volatility === 'HIGH' ? 'var(--amber-dim)' : 'var(--long-dim)';
    
    let newsHtml = '';
    if (news.length > 0) {
        newsHtml = news.map(n => `
            <div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0">
                <span style="font-size:11px">${n.emoji} ${n.name}</span>
                <span style="font-size:10px;color:${n.impact === 'HIGH' ? 'var(--short)' : 'var(--amber)'}">${n.time}</span>
            </div>
        `).join('');
    } else {
        newsHtml = '<div style="font-size:11px;color:var(--text3)">✅ No major news today</div>';
    }
    
    // Generate tips based on session
    let tips = [];
    if (session.volatility === 'EXTREME') {
        tips = ['⚠️ Widen SL by 20% during overlap', '⚠️ Reduce position size', '⚠️ Expect fast moves'];
    } else if (session.volatility === 'HIGH') {
        tips = ['📈 Good for breakout trades', '💡 Watch for fake-outs at open', '⏰ First 30min = volatile'];
    } else if (session.name === 'ASIA') {
        tips = ['📊 Range-bound trading likely', '💡 Good for scalping S/R', '😴 Lower volume expected'];
    } else {
        tips = ['😴 Low liquidity period', '⚠️ Spreads may widen', '💤 Consider waiting'];
    }
    
    return `
        <div style="background:var(--bg4);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px">
            <div style="font-size:12px;font-weight:700;color:var(--purple);margin-bottom:10px;display:flex;justify-content:space-between;align-items:center">
                <span>⚠️ AWARENESS CHECK</span>
                <span style="font-size:10px;color:var(--text3)">${userTime}</span>
            </div>
            
            <!-- Session Info -->
            <div style="background:${volBg};border:1px solid ${volColor};border-radius:6px;padding:10px;margin-bottom:10px">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                    <span style="font-size:13px;font-weight:700;color:${volColor}">${session.emoji} ${session.name}</span>
                    <span style="font-size:10px;padding:2px 8px;border-radius:3px;background:${volColor};color:var(--bg1);font-weight:600">${session.volatility} VOL</span>
                </div>
                <div style="font-size:10px;color:var(--text2)">
                    🕐 Your time: ${userTime} (${cityName})
                </div>
                <div style="font-size:10px;color:var(--text3);margin-top:4px">
                    ⏭️ Next: ${nextSess.session.emoji} ${nextSess.session.name} in ${nextSess.hours}h ${nextSess.minutes}m
                </div>
            </div>
            
            <!-- News -->
            <div style="background:var(--bg3);border-radius:6px;padding:8px;margin-bottom:10px">
                <div style="font-size:11px;font-weight:600;color:var(--amber);margin-bottom:6px">📰 TODAY'S NEWS</div>
                ${newsHtml}
            </div>
            
            <!-- Tips -->
            <div style="background:var(--bg3);border-radius:6px;padding:8px">
                <div style="font-size:11px;font-weight:600;color:var(--cyan);margin-bottom:6px">💡 SESSION TIPS</div>
                ${tips.map(t => `<div style="font-size:10px;color:var(--text2);padding:2px 0">${t}</div>`).join('')}
            </div>
        </div>
    `;
}

// Update timezone preview in settings
function updateTimezonePreview() {
    const preview = document.getElementById('timezonePreview');
    if (preview) {
        const session = getCurrentSession();
        const userTime = getUserTime();
        const cityName = getUserTimezoneName();
        preview.innerHTML = `🕐 ${userTime} (${cityName}) | ${session.emoji} ${session.name} | ${session.volatility} Vol`;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// OPEN INTEREST & LIQUIDATION TRACKING
// ═══════════════════════════════════════════════════════════════════════════════

// Initialize OI state
if (!STATE.openInterest) {
    STATE.openInterest = {
        btc: { current: 0, previous: 0, change1h: 0, change24h: 0 },
        history: [],
        lastUpdate: 0
    };
}

if (!STATE.liquidations) {
    STATE.liquidations = {
        longs1h: 0,
        shorts1h: 0,
        totalLongs24h: 0,
        totalShorts24h: 0,
        lastUpdate: 0
    };
}

// Fetch BTC Open Interest - BINANCE API
async function fetchBTCOpenInterest() {
    try {
        // Get current OI
        const currentData = await fetchJSON(`${CONFIG.BYBIT_V5}/market/open-interest?category=linear&symbol=BTCUSDT`);
        
        // Get historical OI
        const histData = await fetchJSON(`${CONFIG.BYBIT_V5}/market/open-interest?category=linear&intervalTime=1h&limit=25&symbol=BTCUSDT&period=1h&limit=25`);
        
        if (currentData && currentData.openInterest) {
            const currentOI = parseFloat(currentData.openInterest);
            const previousOI = STATE.openInterest.btc.current || currentOI;
            
            // Store OI history for trend analysis
            if (histData && Array.isArray(histData)) {
                STATE.openInterest.history = histData.map(item => ({
                    oi: parseFloat(item.sumOpenInterest),
                    time: parseInt(item.timestamp)
                }));
            }
            
            // Calculate changes
            let oi1hAgo = currentOI;
            let oi24hAgo = currentOI;
            
            if (histData && Array.isArray(histData) && histData.length > 1) {
                oi1hAgo = parseFloat(histData[histData.length - 2]?.sumOpenInterest) || currentOI;
                oi24hAgo = histData.length > 23 ? parseFloat(histData[histData.length - 24]?.sumOpenInterest) || currentOI : currentOI;
            }
            
            const change1h = oi1hAgo > 0 ? ((currentOI - oi1hAgo) / oi1hAgo) * 100 : 0;
            const change24h = oi24hAgo > 0 ? ((currentOI - oi24hAgo) / oi24hAgo) * 100 : 0;
            
            STATE.openInterest.btc = {
                current: currentOI,
                previous: previousOI,
                change1h: change1h,
                change24h: change24h,
                trend: change1h > 0.5 ? 'RISING' : change1h < -0.5 ? 'FALLING' : 'FLAT'
            };
            
            STATE.openInterest.lastUpdate = Date.now();
            
            // Update ENV bar OI display
            updateOIDisplay();
            
            // Update Market Flow panel
            updateMarketFlowPanel();
            
            console.log(`📊 BTC OI: ${(currentOI / 1e9).toFixed(2)}B (${change1h >= 0 ? '+' : ''}${change1h.toFixed(2)}% 1H)`);
        }
    } catch (e) {
        // Silent fail
    }
}

// Fetch coin-specific OI - BINANCE API
async function fetchCoinOI(symbol) {
    try {
        // Current OI
        const currentData = await fetchJSON(`${CONFIG.BYBIT_V5}/market/open-interest?category=linear&symbol=${symbol}`);
        
        if (currentData && currentData.openInterest) {
            const currentOI = parseFloat(currentData.openInterest);
            
            // Get 1h historical for change calculation
            const histData = await fetchJSON(`${CONFIG.BYBIT_V5}/market/open-interest?category=linear&intervalTime=1h&limit=25&symbol=${symbol}&period=1h&limit=2`);
            
            let prevOI = currentOI;
            if (histData && Array.isArray(histData) && histData.length > 1) {
                prevOI = parseFloat(histData[histData.length - 2]?.sumOpenInterest) || currentOI;
            }
            
            const change = prevOI > 0 ? ((currentOI - prevOI) / prevOI) * 100 : 0;
            
            return {
                current: currentOI,
                change1h: change,
                trend: change > 0.5 ? 'RISING' : change < -0.5 ? 'FALLING' : 'FLAT'
            };
        }
    } catch (e) {
        // Silent fail
    }
    return null;
}

// Fetch recent liquidations (estimated from funding + OI changes)
async function fetchLiquidations() {
    try {
        // Binance doesn't have direct liquidation API for free
        // We estimate based on OI drops during price moves
        
        const btcOI = STATE.openInterest.btc;
        const btcChange = STATE.btc.change || 0;
        
        // Estimate liquidations based on OI change vs price change
        let longsLiq = 0;
        let shortsLiq = 0;
        
        if (btcOI.change1h < -1 && btcChange < -1) {
            // OI down + Price down = Long liquidations
            longsLiq = Math.abs(btcOI.change1h) * 5; // Rough estimate in $M
        } else if (btcOI.change1h < -1 && btcChange > 1) {
            // OI down + Price up = Short liquidations
            shortsLiq = Math.abs(btcOI.change1h) * 5;
        }
        
        STATE.liquidations = {
            longs1h: longsLiq,
            shorts1h: shortsLiq,
            bias: longsLiq > shortsLiq ? 'LONGS_LIQUIDATED' : 
                  shortsLiq > longsLiq ? 'SHORTS_LIQUIDATED' : 'BALANCED',
            lastUpdate: Date.now()
        };
        
        updateMarketFlowPanel();
        
    } catch (e) {
        // Silent fail
    }
}

// Update OI display in ENV bar
function updateOIDisplay() {
    const oiEl = document.getElementById('envOI');
    const oiVal = document.getElementById('envOIVal');
    
    if (oiVal && oiEl) {
        const btcOI = STATE.openInterest.btc;
        const change = btcOI.change1h || 0;
        const arrow = change > 0.5 ? '▲' : change < -0.5 ? '▼' : '';
        const sign = change >= 0 ? '+' : '';
        
        oiVal.textContent = `${sign}${change.toFixed(1)}%${arrow}`;
        
        // Color based on OI trend
        if (change > 1) {
            oiEl.className = 'env-status go';
        } else if (change < -1) {
            oiEl.className = 'env-status nogo';
        } else {
            oiEl.className = 'env-status caution';
        }
    }
}

// Toggle Market Flow panel
function toggleFlow() {
    const content = document.getElementById('flowContent');
    const toggle = document.getElementById('flowToggle');
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    safeStorageSet('flowExpanded', !isExpanded);
}

// Restore Flow panel state
function restoreFlowState() {
    const expandedVal = safeStorageGet('flowExpanded', false);
    const expanded = expandedVal === true || expandedVal === 'true';
    if (expanded) {
        document.getElementById('flowContent')?.classList.add('expanded');
        document.getElementById('flowToggle')?.classList.add('expanded');
        // Also expand new panel
        document.getElementById('flowContentNew')?.classList.add('expanded');
        document.getElementById('flowToggleNew')?.classList.add('expanded');
    }
}

// Toggle NEW compact Flow panel
function toggleFlowNew() {
    const content = document.getElementById('flowContentNew');
    const toggle = document.getElementById('flowToggleNew');
    if (!content || !toggle) return;
    
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    safeStorageSet('flowExpanded', !isExpanded);
}

// Toggle NEW compact Backtest panel
function toggleBacktestNew() {
    const content = document.getElementById('backtestContentNew');
    const toggle = document.getElementById('backtestToggleNew');
    if (!content || !toggle) return;
    
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    safeStorageSet('backtestExpanded', !isExpanded);
}

// Quick select timeframes for backtest
function btSelectTF(mode) {
    const tf5m = document.getElementById('btTF5m');
    const tf15m = document.getElementById('btTF15m');
    const tf30m = document.getElementById('btTF30m');
    const tf1h = document.getElementById('btTF1h');
    const tf4h = document.getElementById('btTF4h');
    const tf1d = document.getElementById('btTF1d');
    
    // Uncheck all first
    if (tf5m) tf5m.checked = false;
    if (tf15m) tf15m.checked = false;
    if (tf30m) tf30m.checked = false;
    if (tf1h) tf1h.checked = false;
    if (tf4h) tf4h.checked = false;
    if (tf1d) tf1d.checked = false;
    
    // Set based on mode
    switch(mode) {
        case '15m':
            if (tf15m) tf15m.checked = true;
            break;
        case '30m':
            if (tf30m) tf30m.checked = true;
            break;
        case '1h':
            if (tf1h) tf1h.checked = true;
            break;
        case '4h':
            if (tf4h) tf4h.checked = true;
            break;
        case 'all':
            if (tf15m) tf15m.checked = true;
            if (tf30m) tf30m.checked = true;
            if (tf1h) tf1h.checked = true;
            if (tf4h) tf4h.checked = true;
            break;
    }
}

// Restore NEW panels state
function restoreNewPanelsState() {
    // Flow panel
    const flowExpanded = safeStorageGet('flowExpanded', false);
    if (flowExpanded === true || flowExpanded === 'true') {
        document.getElementById('flowContentNew')?.classList.add('expanded');
        document.getElementById('flowToggleNew')?.classList.add('expanded');
    }
    // Backtest panel
    const btExpanded = safeStorageGet('backtestExpanded', false);
    if (btExpanded === true || btExpanded === 'true') {
        document.getElementById('backtestContentNew')?.classList.add('expanded');
        document.getElementById('backtestToggleNew')?.classList.add('expanded');
    }
}

// Update Market Flow panel (both old and new compact)
function updateMarketFlowPanel() {
    const btcOI = STATE.openInterest.btc;
    const btcPrice = STATE.btc || {};
    const liq = STATE.liquidations || {};
    
    // Calculate values once
    const oiInB = (btcOI.current / 1e9).toFixed(2);
    const change = btcOI.change1h || 0;
    const changeText = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
    const changeClass = `flow-change ${change > 0 ? 'up' : change < 0 ? 'down' : 'neutral'}`;
    
    // BTC OI Value - OLD panel
    const flowBtcOI = document.getElementById('flowBtcOI');
    const flowBtcOIChange = document.getElementById('flowBtcOIChange');
    if (flowBtcOI) {
        flowBtcOI.textContent = `$${oiInB}B`;
        flowBtcOIChange.textContent = `${changeText} 1H`;
        flowBtcOIChange.className = changeClass;
    }
    
    // BTC OI Value - NEW compact panel
    const flowBtcOINew = document.getElementById('flowBtcOINew');
    const flowBtcOIChangeNew = document.getElementById('flowBtcOIChangeNew');
    if (flowBtcOINew) {
        flowBtcOINew.textContent = `$${oiInB}B`;
        flowBtcOIChangeNew.textContent = changeText;
        flowBtcOIChangeNew.className = changeClass;
    }
    
    // OI vs Price interpretation
    const oiChange = btcOI.change1h || 0;
    const priceChange = btcPrice.change || 0;
    
    let interpretation = 'NEUTRAL';
    let status = 'neutral';
    
    if (priceChange > 0.5 && oiChange > 0.5) {
        interpretation = '✅ REAL BUY';
        status = 'up';
    } else if (priceChange > 0.5 && oiChange < -0.5) {
        interpretation = '⚠️ SQUEEZE';
        status = 'down';
    } else if (priceChange < -0.5 && oiChange > 0.5) {
        interpretation = '✅ REAL SELL';
        status = 'up';
    } else if (priceChange < -0.5 && oiChange < -0.5) {
        interpretation = '⚠️ LONG LIQ';
        status = 'down';
    }
    
    const priceStatusText = `P:${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(1)}%`;
    
    // OLD panel
    const flowOIPrice = document.getElementById('flowOIPrice');
    const flowOIPriceStatus = document.getElementById('flowOIPriceStatus');
    if (flowOIPrice) {
        flowOIPrice.textContent = interpretation;
        flowOIPriceStatus.textContent = priceStatusText;
        flowOIPriceStatus.className = `flow-change ${status}`;
    }
    
    // NEW compact panel
    const flowOIPriceNew = document.getElementById('flowOIPriceNew');
    const flowOIPriceStatusNew = document.getElementById('flowOIPriceStatusNew');
    if (flowOIPriceNew) {
        flowOIPriceNew.textContent = interpretation.replace('✅ ', '').replace('⚠️ ', '');
        flowOIPriceStatusNew.textContent = priceStatusText;
        flowOIPriceStatusNew.className = `flow-change ${status}`;
    }
    
    // Store interpretation for signal filtering
    STATE.openInterest.interpretation = interpretation.includes('REAL') ? 'REAL' : 
                                        interpretation.includes('SQUEEZE') ? 'SQUEEZE' : 
                                        interpretation.includes('LIQ') ? 'LIQUIDATION' : 'NEUTRAL';
    
    // Liquidations - OLD panel
    const flowLongsLiq = document.getElementById('flowLongsLiq');
    const flowShortsLiq = document.getElementById('flowShortsLiq');
    if (flowLongsLiq && flowShortsLiq) {
        flowLongsLiq.textContent = `$${(liq.longs1h || 0).toFixed(1)}M`;
        flowShortsLiq.textContent = `$${(liq.shorts1h || 0).toFixed(1)}M`;
        
        document.getElementById('flowLongsLiqPct').textContent = liq.longs1h > 5 ? '🔥 HIGH' : 'Normal';
        document.getElementById('flowLongsLiqPct').className = `flow-change ${liq.longs1h > 5 ? 'down' : 'neutral'}`;
        
        document.getElementById('flowShortsLiqPct').textContent = liq.shorts1h > 5 ? '🔥 HIGH' : 'Normal';
        document.getElementById('flowShortsLiqPct').className = `flow-change ${liq.shorts1h > 5 ? 'down' : 'neutral'}`;
    }
    
    // Liquidations - NEW compact panel
    const flowLongsLiqNew = document.getElementById('flowLongsLiqNew');
    const flowShortsLiqNew = document.getElementById('flowShortsLiqNew');
    if (flowLongsLiqNew && flowShortsLiqNew) {
        flowLongsLiqNew.textContent = `$${(liq.longs1h || 0).toFixed(1)}M`;
        flowShortsLiqNew.textContent = `$${(liq.shorts1h || 0).toFixed(1)}M`;
        
        const flowLongsLiqPctNew = document.getElementById('flowLongsLiqPctNew');
        const flowShortsLiqPctNew = document.getElementById('flowShortsLiqPctNew');
        if (flowLongsLiqPctNew) {
            flowLongsLiqPctNew.textContent = liq.longs1h > 5 ? '🔥' : 'OK';
            flowLongsLiqPctNew.className = `flow-change ${liq.longs1h > 5 ? 'down' : 'neutral'}`;
        }
        if (flowShortsLiqPctNew) {
            flowShortsLiqPctNew.textContent = liq.shorts1h > 5 ? '🔥' : 'OK';
            flowShortsLiqPctNew.className = `flow-change ${liq.shorts1h > 5 ? 'down' : 'neutral'}`;
        }
    }
    
    // Market Bias calculation
    const interp = STATE.openInterest.interpretation || 'NEUTRAL';
    let bias = 'NEUTRAL';
    let biasClass = 'neutral';
    
    if (interp === 'REAL' && priceChange > 0) {
        bias = '🟢 BULLISH';
        biasClass = 'bullish';
    } else if (interp === 'REAL' && priceChange < 0) {
        bias = '🔴 BEARISH';
        biasClass = 'bearish';
    } else if (interp === 'SQUEEZE') {
        bias = '⚠️ SQUEEZE';
        biasClass = 'squeeze';
    } else if (interp === 'LIQUIDATION') {
        bias = '💀 LIQUIDATIONS';
        biasClass = 'squeeze';
    }
    
    // OLD panel bias
    const flowBias = document.getElementById('flowBias');
    const flowStatus = document.getElementById('flowStatus');
    if (flowBias) {
        flowBias.textContent = bias;
        flowBias.className = `flow-verdict-value ${biasClass}`;
        
        if (flowStatus) {
            flowStatus.textContent = bias.replace(/[🟢🔴⚠️💀]/g, '').trim();
            flowStatus.className = `flow-status ${biasClass}`;
        }
    }
    
    // NEW compact panel bias
    const flowBiasNew = document.getElementById('flowBiasNew');
    if (flowBiasNew) {
        flowBiasNew.textContent = bias;
        flowBiasNew.className = `value ${biasClass}`;
    }
}

// Analyze OI for signal validation
function analyzeOIForSignal(direction, coinOI = null) {
    const btcOI = STATE.openInterest.btc;
    const btcPrice = STATE.btc || {};
    const interp = STATE.openInterest.interpretation || 'NEUTRAL';
    
    let score = 5; // Base score
    let status = 'NEUTRAL';
    let warning = null;
    
    // Check if OI confirms direction
    if (direction === 'LONG') {
        if (interp === 'REAL' && btcPrice.change > 0) {
            // Real buying - great for longs
            score = 10;
            status = 'CONFIRMED';
        } else if (interp === 'SQUEEZE') {
            // Short squeeze - risky for new longs
            score = 3;
            status = 'SQUEEZE';
            warning = 'Short squeeze detected - risky entry';
        } else if (interp === 'LIQUIDATION') {
            // Long liquidations - terrible for longs
            score = 0;
            status = 'DANGER';
            warning = 'Long liquidations in progress';
        }
    } else { // SHORT
        if (interp === 'REAL' && btcPrice.change < 0) {
            // Real selling - great for shorts
            score = 10;
            status = 'CONFIRMED';
        } else if (interp === 'SQUEEZE' || interp === 'LIQUIDATION') {
            // Squeeze happening - risky for shorts
            score = 3;
            status = 'SQUEEZE';
            warning = 'Potential squeeze - risky entry';
        }
    }
    
    // Coin-specific OI boost
    if (coinOI && coinOI.trend === 'RISING') {
        score += 2;
    }
    
    return { score: Math.min(10, score), status, warning };
}

// Fetch BTC Dominance
async function fetchBTCDominance() {
    try {
        const d = await fetchJSON('https://api.coingecko.com/api/v3/global');
        if (d && d.data && d.data.market_cap_percentage) {
            const dom = d.data.market_cap_percentage.btc;
            const prevDom = STATE.btcDominance || dom;
            STATE.btcDominance = dom;
            STATE.btcDomTrend = dom > prevDom ? 'rising' : dom < prevDom ? 'falling' : 'flat';
            
            const badge = document.getElementById('badgeDom');
            const val = document.getElementById('badgeDomVal');
            if (val) {
                const arrow = STATE.btcDomTrend === 'rising' ? '▲' : STATE.btcDomTrend === 'falling' ? '▼' : '';
                val.textContent = dom.toFixed(1) + '%' + arrow;
                
                // Green if falling (good for alts), Red if rising
                badge.className = 'info-badge ' + (STATE.btcDomTrend === 'falling' ? 'go' : STATE.btcDomTrend === 'rising' ? 'nogo' : 'caution');
            }
            
            // Update Season badge based on dominance
            updateSeasonBadge(dom, STATE.btcDomTrend);
            
            // Update ALTS condition badge
            updateAltsBadge();
        }
    } catch(e) { /* Silent fail */ }
}

// Update ALTS GOOD/BAD badge
function updateAltsBadge() {
    const badge = document.getElementById('badgeAlts');
    const val = document.getElementById('badgeAltsVal');
    if (!badge || !val) return;
    
    const env = STATE.environment || {};
    const btcDomTrend = STATE.btcDomTrend || 'flat';
    const btcStructure = env.btcStructure?.status || 'UNKNOWN';
    
    // ALTS GOOD: BTC.D falling + BTC structure intact
    // ALTS BAD: BTC.D rising OR BTC structure broken down
    // ALTS FLAT: BTC.D flat
    
    if (btcDomTrend === 'falling' && btcStructure === 'INTACT') {
        val.textContent = '🟢 GOOD';
        badge.className = 'info-badge go';
    } else if (btcDomTrend === 'rising' || btcStructure === 'BROKEN_DOWN') {
        val.textContent = '🔴 BAD';
        badge.className = 'info-badge nogo';
    } else {
        val.textContent = '🟡 FLAT';
        badge.className = 'info-badge caution';
    }
}

// Update Alt/BTC Season badge
function updateSeasonBadge(dom, trend) {
    const badge = document.getElementById('badgeSeason');
    const val = document.getElementById('badgeSeasonVal');
    if (!badge || !val) return;
    
    // Calculate alt season score (0-100, higher = more alt season)
    let altScore = 100 - dom; // Base: inverse of dominance
    if (trend === 'falling') altScore += 10;
    if (trend === 'rising') altScore -= 10;
    altScore = Math.max(0, Math.min(100, altScore));
    
    STATE.altSeasonScore = altScore;
    
    if (altScore >= 60) {
        // Alt Season
        val.textContent = '🌙 ALT';
        badge.className = 'info-badge go';
    } else if (altScore <= 40) {
        // BTC Season
        val.textContent = '₿ BTC';
        badge.className = 'info-badge nogo';
    } else {
        // Neutral
        val.textContent = '⚖️ MIX';
        badge.className = 'info-badge caution';
    }
}

// Update Trading Session Badge
function updateSessionBadge() {
    const badge = document.getElementById('badgeSession');
    const val = document.getElementById('badgeSessionVal');
    if (!badge || !val) return;
    
    const now = new Date();
    const utcHour = now.getUTCHours();
    
    let session = '---';
    let isActive = false;
    
    // Session times (UTC)
    if (utcHour >= 0 && utcHour < 8) {
        session = '🌏 ASIA';
        isActive = true;
    } else if (utcHour >= 8 && utcHour < 12) {
        session = '🌍 LDN';
        isActive = true;
    } else if (utcHour >= 12 && utcHour < 21) {
        session = '🌎 NY';
        isActive = true;
    } else {
        session = '🌑 OFF';
        isActive = false;
    }
    
    val.textContent = session;
    badge.className = isActive ? 'info-badge go' : 'info-badge caution';
}

// Fetch all market data
async function fetchAllMarketData() {
    await Promise.all([
        fetchFearGreed(),
        fetchDXY(),
        fetchFunding(),
        fetchBTCDominance()
    ]);
    updateSessionBadge();
}

// Update scan progress bar when complete
function setScanComplete() {
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    const btn = document.getElementById('scanBtn');
    
    if (fill) {
        fill.style.width = '100%';
        fill.classList.remove('scanning');
        fill.classList.add('done');
    }
    if (text) {
        text.textContent = '✅ Complete';
        text.classList.add('done');
    }
    if (pct) {
        pct.textContent = '100%';
        pct.classList.add('done');
    }
    if (btn) {
        btn.classList.remove('scanning');
        btn.classList.add('scan-done');
    }
}

// Reset scan progress bar
function resetScanProgress() {
    const bar = document.getElementById('scanProgressBar');
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    const btn = document.getElementById('scanBtn');
    
    if (bar) {
        bar.classList.add('active');
    }
    if (fill) {
        fill.style.width = '5%'; // Start with visible bar
        fill.classList.remove('done', 'error');
        fill.classList.add('scanning');
    }
    if (text) {
        text.textContent = '🔄 Starting...';
        text.classList.remove('done', 'error');
    }
    if (pct) {
        pct.textContent = '0%';
        pct.classList.remove('done', 'error');
    }
    if (btn) {
        btn.classList.remove('scan-done');
        btn.classList.add('scanning');
    }
}

// Set scan error state (red)
function setScanError(message) {
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    
    if (fill) {
        fill.classList.remove('scanning', 'done');
        fill.classList.add('error');
    }
    if (text) {
        text.textContent = '❌ ' + (message || 'Error');
        text.classList.add('error');
    }
    if (pct) {
        pct.classList.add('error');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// STATS BAR FILTER FUNCTION
// ═══════════════════════════════════════════════════════════════════════════════

function filterByStats(type) {
    STATE.statsFilter = type;
    updateSignalList();
    
    // Highlight active stat box
    document.querySelectorAll('.stat-box').forEach(box => {
        box.style.borderColor = 'var(--border)';
    });
    
    const activeBox = event.currentTarget;
    if (type !== 'all') {
        activeBox.style.borderColor = 'var(--gold)';
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// BACKTEST ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

// Toggle backtest panel expand/collapse
function toggleBacktest() {
    const content = document.getElementById('backtestContent');
    const toggle = document.getElementById('backtestToggle');
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    // Save state
    safeStorageSet('backtestExpanded', !isExpanded);
}

// Restore backtest panel state on load
function restoreBacktestState() {
    const expandedVal = safeStorageGet('backtestExpanded', false);
    const expanded = expandedVal === true || expandedVal === 'true';
    if (expanded) {
        document.getElementById('backtestContent')?.classList.add('expanded');
        document.getElementById('backtestToggle')?.classList.add('expanded');
        // Also expand new panel
        document.getElementById('backtestContentNew')?.classList.add('expanded');
        document.getElementById('backtestToggleNew')?.classList.add('expanded');
    }
}

// Run backtest from NEW compact panel
async function runBacktestNew() {
    console.log('🧪 BACKTEST: Starting...');
    const btn = document.getElementById('btRunBtnNew');
    const results = document.getElementById('backtestResultsNew');
    const coinSelect = document.getElementById('btCoinNew');
    const gradeFilter = document.getElementById('btGradeNew')?.value || 'all';
    console.log('🧪 BACKTEST: Elements found:', { btn: !!btn, results: !!results, coinSelect: !!coinSelect, gradeFilter });
    
    const selectedCoin = coinSelect?.value || 'BTCUSDT';
    
    // Get enabled timeframes from checkboxes
    const enabledTFs = [];
    if (document.getElementById('btTF5m')?.checked) enabledTFs.push('5');
    if (document.getElementById('btTF15m')?.checked) enabledTFs.push('15');
    if (document.getElementById('btTF30m')?.checked) enabledTFs.push('30');
    if (document.getElementById('btTF1h')?.checked) enabledTFs.push('60');
    if (document.getElementById('btTF4h')?.checked) enabledTFs.push('240');
    if (document.getElementById('btTF1d')?.checked) enabledTFs.push('D');
    
    // If no TFs selected, default to 15m and 30m
    if (enabledTFs.length === 0) {
        enabledTFs.push('15', '30');
    }
    
    // Disable button
    if (btn) {
        btn.disabled = true;
        btn.textContent = '⏳...';
    }
    
    // ALL old coins list
    const ALL_OLD_COINS = [
        'BTCUSDT', 'ETHUSDT', 'XRPUSDT', 'SOLUSDT', 'LTCUSDT',
        'BNBUSDT', 'ADAUSDT', 'LINKUSDT', 'DOTUSDT',
        'ETCUSDT', 'XLMUSDT', 'TRXUSDT', 'UNIUSDT', 'EOSUSDT'
    ];
    
    // Get coins to test - SINGLE or ALL
    const coinsToTest = selectedCoin === 'ALL' ? ALL_OLD_COINS : [selectedCoin];
    
    // Use enabled timeframes from checkboxes
    const timeframes = enabledTFs;
    
    // Initialize results
    const allResults = {
        totalTrades: 0,
        wins: 0,
        losses: 0,
        totalPnL: 0,
        fees: 0,
        netPnL: 0,
        byGrade: {
            cream: { trades: 0, wins: 0, pnl: 0 },
            perfect: { trades: 0, wins: 0, pnl: 0 },
            strong: { trades: 0, wins: 0, pnl: 0 },
            valid: { trades: 0, wins: 0, pnl: 0 }
        },
        byTF: {},
        byCoin: {},
        dataInfo: {}
    };
    
    const FEE_RATE = 0.04; // 0.04% round trip
    
    try {
        // Process each coin ONE BY ONE
        for (let coinIdx = 0; coinIdx < coinsToTest.length; coinIdx++) {
            const coin = coinsToTest[coinIdx];
            
            // Update progress
            if (results) {
                results.innerHTML = `
                    <div class="backtest-empty">
                        <div class="icon">⏳</div>
                        <div style="font-size:12px;color:var(--accent);font-weight:700">${coin.replace('USDT','')}</div>
                        <div style="font-size:9px;color:var(--text3)">${coinIdx+1}/${coinsToTest.length} coins</div>
                        <div style="font-size:8px;color:var(--text2);margin-top:4px">Fetching 6000 candles from Bybit...</div>
                    </div>
                `;
            }
            
            // Process each timeframe
            for (const tf of timeframes) {
                try {
                    // V9.2: GET 6000 CANDLES FROM BINANCE (4 API calls)!
                    const klines = await fetchKlines(coin, tf, 6000);
                    if (!klines || klines.length < 100) continue;
                    
                    // Track data info
                    const tfLabel = CONFIG.TF_LABELS[tf] || tf;
                    if (!allResults.dataInfo[tfLabel]) {
                        allResults.dataInfo[tfLabel] = { candles: 0, days: 0, coins: 0 };
                    }
                    allResults.dataInfo[tfLabel].coins++;
                    
                    // Calculate actual days
                    const firstTime = klines[0].time;
                    const lastTime = klines[klines.length - 1].time;
                    const actualDays = Math.round((lastTime - firstTime) / (1000 * 60 * 60 * 24));
                    allResults.dataInfo[tfLabel].days = Math.max(allResults.dataInfo[tfLabel].days, actualDays);
                    allResults.dataInfo[tfLabel].candles = Math.max(allResults.dataInfo[tfLabel].candles, klines.length);
                    
                    // Skip if not enough data
                    if (actualDays < 5) continue;
                    
                    // Initialize TF tracking
                    if (!allResults.byTF[tfLabel]) {
                        allResults.byTF[tfLabel] = { trades: 0, wins: 0, pnl: 0 };
                    }
                    
                    // Initialize coin tracking
                    if (!allResults.byCoin[coin]) {
                        allResults.byCoin[coin] = { trades: 0, wins: 0 };
                    }
                    
                    // Step through candles
                    const stepSize = tf === '5' ? 12 : tf === '15' ? 8 : tf === '30' ? 6 : tf === '60' ? 4 : 2;
                    let signalCount = 0;
                    
                    for (let i = 100; i < klines.length - 20; i += stepSize) {
                        const historicalKlines = klines.slice(Math.max(0, i - 100), i);
                        if (historicalKlines.length < 50) continue;
                        
                        // Check for signal
                        try {
                            const signal = quickSignalCheck(historicalKlines, coin, tf);
                            if (!signal) continue;
                            signalCount++;
                            
                            // Apply grade filter
                            if (gradeFilter === 'cream' && !signal.isCream) continue;
                            if (gradeFilter === 'perfect' && signal.grade !== 'PERFECT' && !signal.isCream) continue;
                            if (gradeFilter === 'strong' && !['PERFECT', 'STRONG'].includes(signal.grade) && !signal.isCream) continue;
                            
                            // Get future candles for outcome
                            const futureKlines = klines.slice(i + 1, i + 21);
                            if (futureKlines.length < 5) continue;
                            
                            // Simulate outcome
                            const outcome = simulateTradeOutcome(signal, futureKlines);
                            
                            // Apply fees
                            const netPnl = outcome.pnl - FEE_RATE;
                            
                            // Record results
                            allResults.totalTrades++;
                            if (outcome.won) allResults.wins++;
                            else allResults.losses++;
                            allResults.totalPnL += outcome.pnl;
                            allResults.fees += FEE_RATE;
                            allResults.netPnL += netPnl;
                            
                            // By grade
                            const gradeKey = signal.isCream ? 'cream' : signal.grade.toLowerCase();
                        if (allResults.byGrade[gradeKey]) {
                            allResults.byGrade[gradeKey].trades++;
                            if (outcome.won) allResults.byGrade[gradeKey].wins++;
                            allResults.byGrade[gradeKey].pnl += netPnl;
                        }
                        
                        // By TF
                        allResults.byTF[tfLabel].trades++;
                        if (outcome.won) allResults.byTF[tfLabel].wins++;
                        allResults.byTF[tfLabel].pnl += netPnl;
                        
                        // By coin
                        allResults.byCoin[coin].trades++;
                        if (outcome.won) allResults.byCoin[coin].wins++;
                        } catch (sigErr) {
                            console.warn(`Signal error at ${coin} ${tf} i=${i}:`, sigErr.message);
                        }
                    }
                    
                    console.log(`🧪 BACKTEST: ${coin} ${tf} = ${signalCount} signals found`);
                    
                    // Small delay between TFs
                    await sleep(50);
                    
                } catch (e) {
                    console.warn(`Error ${coin} ${tf}:`, e);
                }
            }
            
            // Delay between coins
            await sleep(100);
        }
        
        // Display results
        displayBacktestResultsCompact(allResults, 0);
        
    } catch (error) {
        console.error('Backtest error:', error);
        if (results) {
            results.innerHTML = `
                <div class="backtest-empty">
                    <div class="icon">❌</div>
                    <div>Failed: ${error.message}</div>
                </div>
            `;
        }
    }
    
    if (btn) {
        btn.disabled = false;
        btn.textContent = '▶ RUN';
    }
}

// Display backtest results - V5.5 HONEST VERSION
function displayBacktestResultsCompact(results, days) {
    const container = document.getElementById('backtestResultsNew');
    if (!container) return;
    
    const winRate = results.totalTrades > 0 ? ((results.wins / results.totalTrades) * 100).toFixed(0) : 0;
    const grossPnL = results.totalPnL || 0;
    const fees = results.fees || 0;
    const netPnL = results.netPnL || (grossPnL - fees);
    
    // Calculate actual max days from data
    const maxDays = Object.values(results.dataInfo || {}).reduce((max, info) => Math.max(max, info.days || 0), 0);
    
    container.innerHTML = `
        <div class="backtest-summary">
            <div class="backtest-stat">
                <div class="backtest-stat-label">Win/Loss</div>
                <div class="backtest-stat-value">
                    <span class="positive">${results.wins}W</span> / <span class="negative">${results.losses}L</span>
                </div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Win Rate</div>
                <div class="backtest-stat-value ${results.wins > results.losses ? 'positive' : 'negative'}">${winRate}%</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Net PnL</div>
                <div class="backtest-stat-value ${netPnL >= 0 ? 'positive' : 'negative'}">${netPnL >= 0 ? '+' : ''}${netPnL.toFixed(1)}%</div>
            </div>
        </div>
        <div style="font-size:8px;color:var(--text3);text-align:center;margin-bottom:4px">
            Fees: -${fees.toFixed(1)}% | Real Data: ${maxDays} days max
        </div>
        <div style="font-size:9px;margin:4px 0;padding:4px 0;border-top:1px solid var(--border);border-bottom:1px solid var(--border)">
            <div style="display:flex;justify-content:space-between;margin-bottom:2px">
                <span>💎 Cream</span>
                <span>${results.byGrade.cream.trades}t | ${results.byGrade.cream.trades > 0 ? ((results.byGrade.cream.wins / results.byGrade.cream.trades) * 100).toFixed(0) : 0}% | <span class="${results.byGrade.cream.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.cream.pnl >= 0 ? '+' : ''}${results.byGrade.cream.pnl.toFixed(1)}%</span></span>
            </div>
            <div style="display:flex;justify-content:space-between;margin-bottom:2px">
                <span>🥇 Perfect</span>
                <span>${results.byGrade.perfect.trades}t | ${results.byGrade.perfect.trades > 0 ? ((results.byGrade.perfect.wins / results.byGrade.perfect.trades) * 100).toFixed(0) : 0}% | <span class="${results.byGrade.perfect.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.perfect.pnl >= 0 ? '+' : ''}${results.byGrade.perfect.pnl.toFixed(1)}%</span></span>
            </div>
            <div style="display:flex;justify-content:space-between;margin-bottom:2px">
                <span>🥈 Strong</span>
                <span>${results.byGrade.strong.trades}t | ${results.byGrade.strong.trades > 0 ? ((results.byGrade.strong.wins / results.byGrade.strong.trades) * 100).toFixed(0) : 0}% | <span class="${results.byGrade.strong.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.strong.pnl >= 0 ? '+' : ''}${results.byGrade.strong.pnl.toFixed(1)}%</span></span>
            </div>
            <div style="display:flex;justify-content:space-between">
                <span>✅ Valid</span>
                <span>${results.byGrade.valid.trades}t | ${results.byGrade.valid.trades > 0 ? ((results.byGrade.valid.wins / results.byGrade.valid.trades) * 100).toFixed(0) : 0}% | <span class="${results.byGrade.valid.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.valid.pnl >= 0 ? '+' : ''}${results.byGrade.valid.pnl.toFixed(1)}%</span></span>
            </div>
        </div>
        <div style="font-size:8px">
            <div style="color:var(--amber);margin-bottom:2px">⚠️ REAL DATA PER TF:</div>
            <div style="display:flex;flex-wrap:wrap;gap:4px">
            ${Object.entries(results.dataInfo || {}).map(([tf, info]) => {
                const wr = results.byTF[tf]?.trades > 0 ? Math.round((results.byTF[tf].wins / results.byTF[tf].trades) * 100) : 0;
                const trades = results.byTF[tf]?.trades || 0;
                const color = info.days >= 60 ? 'var(--long)' : info.days >= 14 ? 'var(--amber)' : 'var(--short)';
                const status = info.days < 14 ? '❌' : info.days >= 60 ? '✅' : '⚠️';
                return `<span style="color:${color}">${status}${tf}:${info.days}d(${trades}t,${wr}%)</span>`;
            }).join(' ')}
            </div>
        </div>
        <div style="font-size:7px;color:var(--text3);margin-top:6px;padding-top:4px;border-top:1px solid var(--border)">
            <div style="color:var(--amber)">📊 BYBIT API LIMITS:</div>
            <div>5m=5d | 15m=15d | 30m=31d | 1H=62d | 4H=250d | 1D=4yr</div>
        </div>
        <div style="text-align:center;font-size:7px;color:var(--text3);margin-top:4px">
            ${results.totalTrades} trades from real Bybit data
        </div>
    `;
}

// Run backtest
async function runBacktest() {
    const btn = document.getElementById('btRunBtn');
    const results = document.getElementById('backtestResults');
    const status = document.getElementById('backtestStatus');
    
    const range = parseInt(document.getElementById('btRange').value);
    const gradeFilter = document.getElementById('btGrade').value;
    const tfFilter = document.getElementById('btTF').value;
    
    // Disable button and show loading
    btn.disabled = true;
    btn.textContent = '⏳ Running...';
    status.textContent = '(Running...)';
    
    results.innerHTML = `
        <div class="backtest-loading">
            <div class="spinner">⏳</div>
            <div style="margin-top:10px">Fetching historical data...</div>
            <div style="font-size:10px;color:var(--text3);margin-top:4px">This may take 30-60 seconds</div>
        </div>
    `;
    
    try {
        // Get coins to backtest (use current selection or top coins)
        const coins = STATE.coins?.length > 0 ? STATE.coins.slice(0, 20) : [
            'BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'BNBUSDT', 'XRPUSDT',
            'ADAUSDT', 'AVAXUSDT', 'DOTUSDT', 'MATICUSDT', 'LINKUSDT'
        ];
        
        // Get timeframes based on filter
        let timeframes = ['60', '240', 'D'];  // 1H, 4H, 1D
        if (tfFilter === 'scalp') {
            timeframes = ['5', '15', '60'];  // 5m, 15m, 1H
        } else if (tfFilter === 'swing') {
            timeframes = ['240', 'D'];  // 4H, 1D
        }
        
        // Calculate how many candles we need
        const candlesNeeded = range * 24;  // Approximate candles per day for 1H
        
        // Run backtest simulation
        const backtestResults = await simulateBacktest(coins, timeframes, candlesNeeded, gradeFilter);
        
        // Display results
        displayBacktestResults(backtestResults, range);
        
        status.textContent = `(${backtestResults.totalTrades} trades analyzed)`;
        
    } catch (error) {
        console.error('Backtest error:', error);
        results.innerHTML = `
            <div style="text-align:center;padding:20px;color:var(--short)">
                <div style="font-size:24px;margin-bottom:8px">❌</div>
                <div>Backtest failed: ${error.message}</div>
            </div>
        `;
        status.textContent = '(Error)';
    }
    
    btn.disabled = false;
    btn.textContent = '▶ RUN';
}

// Simulate backtest using historical data - V5.5 HONEST VERSION
async function simulateBacktest(coins, timeframes, candlesNeeded, gradeFilter) {
    const results = {
        totalTrades: 0,
        wins: 0,
        losses: 0,
        totalPnL: 0,
        fees: 0,
        netPnL: 0,
        byGrade: {
            cream: { trades: 0, wins: 0, pnl: 0, avgRR: 0 },
            perfect: { trades: 0, wins: 0, pnl: 0, avgRR: 0 },
            strong: { trades: 0, wins: 0, pnl: 0, avgRR: 0 },
            valid: { trades: 0, wins: 0, pnl: 0, avgRR: 0 }
        },
        byTF: {},
        byCoin: {},
        trades: [],
        dataInfo: {} // Track actual data available per TF
    };
    
    const FEE_RATE = 0.001; // 0.1% per trade (0.2% round trip)
    
    // Process each coin/TF combination
    for (const coin of coins) {
        for (const tf of timeframes) {
            try {
                // Fetch historical klines - GET WHAT BINANCE GIVES US
                const klines = await fetchKlines(coin, tf, 1500);
                if (!klines || klines.length < 100) continue;
                
                // Track actual data received
                const tfLabel = CONFIG.TF_LABELS[tf] || tf;
                if (!results.dataInfo[tfLabel]) {
                    results.dataInfo[tfLabel] = {
                        candles: klines.length,
                        days: 0,
                        coins: 0
                    };
                }
                results.dataInfo[tfLabel].coins++;
                
                // Calculate actual days of data
                const firstTime = klines[0].time;
                const lastTime = klines[klines.length - 1].time;
                const actualDays = Math.round((lastTime - firstTime) / (1000 * 60 * 60 * 24));
                results.dataInfo[tfLabel].days = Math.max(results.dataInfo[tfLabel].days, actualDays);
                
                // HONEST: Only backtest if we have enough data
                // Skip if less than 14 days of data
                if (actualDays < 14) {
                    console.warn(`${coin} ${tfLabel}: Only ${actualDays} days of data - SKIPPING`);
                    continue;
                }
                
                // Slide through history - step based on TF to avoid oversampling
                const stepSize = tf === '5' ? 12 : tf === '15' ? 8 : tf === '30' ? 6 : tf === '60' ? 4 : 2;
                
                for (let i = 100; i < klines.length - 20; i += stepSize) {
                    // Create subset of candles up to this point
                    const historicalKlines = klines.slice(Math.max(0, i - 100), i);
                    
                    if (historicalKlines.length < 50) continue;
                    
                    // Quick signal check
                    const signalResult = quickSignalCheck(historicalKlines, coin, tf);
                    
                    if (!signalResult) continue;
                    
                    // Apply grade filter
                    if (gradeFilter === 'cream' && !signalResult.isCream) continue;
                    if (gradeFilter === 'perfect' && signalResult.grade !== 'PERFECT') continue;
                    if (gradeFilter === 'strong' && !['PERFECT', 'STRONG'].includes(signalResult.grade)) continue;
                    
                    // Simulate trade outcome
                    const futureKlines = klines.slice(i + 1, i + 21);
                    if (futureKlines.length < 5) continue;
                    
                    const outcome = simulateTradeOutcome(signalResult, futureKlines);
                    
                    // Calculate fees (0.1% entry + 0.1% exit = 0.2% total)
                    const tradeFee = 0.2; // 0.2% round trip
                    const netPnl = outcome.pnl - tradeFee;
                    
                    // Record results
                    results.totalTrades++;
                    if (outcome.won) results.wins++;
                    else results.losses++;
                    results.totalPnL += outcome.pnl;
                    results.fees += tradeFee;
                    results.netPnL += netPnl;
                    
                    // By grade
                    const gradeKey = signalResult.isCream ? 'cream' : signalResult.grade.toLowerCase();
                    if (results.byGrade[gradeKey]) {
                        results.byGrade[gradeKey].trades++;
                        if (outcome.won) results.byGrade[gradeKey].wins++;
                        results.byGrade[gradeKey].pnl += netPnl; // Net after fees
                        results.byGrade[gradeKey].avgRR += outcome.rr;
                    }
                    
                    // By TF
                    if (!results.byTF[tfLabel]) results.byTF[tfLabel] = { trades: 0, wins: 0, pnl: 0 };
                    results.byTF[tfLabel].trades++;
                    if (outcome.won) results.byTF[tfLabel].wins++;
                    results.byTF[tfLabel].pnl += netPnl;
                    
                    // By Coin
                    if (!results.byCoin[coin]) results.byCoin[coin] = { trades: 0, wins: 0 };
                    results.byCoin[coin].trades++;
                    if (outcome.won) results.byCoin[coin].wins++;
                    
                    // Store trade
                    results.trades.push({
                        coin,
                        tf: tfLabel,
                        grade: signalResult.grade,
                        direction: signalResult.direction,
                        entry: signalResult.entry,
                        outcome: outcome.won ? 'WIN' : 'LOSS',
                        pnl: netPnl,
                        rr: outcome.rr,
                        time: new Date(historicalKlines[historicalKlines.length - 1].time).toLocaleDateString()
                    });
                }
                
                // Small delay to prevent rate limiting
                await sleep(50);
                
            } catch (e) {
                console.warn(`Backtest error for ${coin} ${tf}:`, e);
            }
        }
    }
    
    // Calculate averages
    Object.keys(results.byGrade).forEach(grade => {
        const g = results.byGrade[grade];
        if (g.trades > 0) {
            g.avgRR = (g.avgRR / g.trades).toFixed(1);
        }
    });
    
    return results;
}

// V5.1 BACKTEST ZONE DETECTION - Simple and fast
function detectZones(klines, lookback = 50) {
    const zones = [];
    if (!klines || klines.length < lookback) return zones;
    
    const recentKlines = klines.slice(-lookback);
    
    // Find swing highs and lows
    for (let i = 2; i < recentKlines.length - 2; i++) {
        const candle = recentKlines[i];
        const prev2 = recentKlines[i - 2];
        const prev1 = recentKlines[i - 1];
        const next1 = recentKlines[i + 1];
        const next2 = recentKlines[i + 2];
        
        // Swing High (resistance)
        if (candle.high > prev1.high && candle.high > prev2.high &&
            candle.high > next1.high && candle.high > next2.high) {
            
            // Check if similar zone exists
            const existing = zones.find(z => 
                z.type === 'resistance' && 
                Math.abs(z.high - candle.high) / candle.high < 0.005
            );
            
            if (existing) {
                existing.touches++;
                existing.strength += 10;
            } else {
                zones.push({
                    type: 'resistance',
                    high: candle.high,
                    low: candle.high * 0.998,
                    touches: 1,
                    strength: 60
                });
            }
        }
        
        // Swing Low (support)
        if (candle.low < prev1.low && candle.low < prev2.low &&
            candle.low < next1.low && candle.low < next2.low) {
            
            const existing = zones.find(z => 
                z.type === 'support' && 
                Math.abs(z.low - candle.low) / candle.low < 0.005
            );
            
            if (existing) {
                existing.touches++;
                existing.strength += 10;
            } else {
                zones.push({
                    type: 'support',
                    high: candle.low * 1.002,
                    low: candle.low,
                    touches: 1,
                    strength: 60
                });
            }
        }
    }
    
    return zones;
}


// ═══════════════════════════════════════════════════════════════════════════
// V7 FIX: Replaced V11 quickSignalCheck with V9.6 quickSignalCheck
// The V11 version had too many gates blocking signals in backtest
// ═══════════════════════════════════════════════════════════════════════════
function quickSignalCheck(klines, symbol, tf) {
    if (klines.length < 100) return null;
    
    const len = klines.length;
    const c0 = klines[len - 1]; // Current candle
    const c1 = klines[len - 2]; // Previous candle
    const c2 = klines[len - 3]; // 2 candles ago
    const currentPrice = c0.close;
    const atr = calcATR(klines);
    const closes = klines.map(k => k.close);
    
    // ═══════════════════════════════════════════════════════════════════════════
    // STEP 1: ZONE DETECTION - Find Support/Resistance
    // ═══════════════════════════════════════════════════════════════════════════
    
    const swingLookback = 60;
    const swingLows = [];
    const swingHighs = [];
    
    // Find swing points
    for (let i = 5; i < Math.min(len - 5, swingLookback); i++) {
        const c = klines[i];
        let isHigh = true, isLow = true;
        
        for (let j = 1; j <= 4; j++) {
            if (klines[i-j]?.high >= c.high || klines[i+j]?.high >= c.high) isHigh = false;
            if (klines[i-j]?.low <= c.low || klines[i+j]?.low <= c.low) isLow = false;
        }
        
        if (isHigh) swingHighs.push({ price: c.high, index: i, volume: c.volume });
        if (isLow) swingLows.push({ price: c.low, index: i, volume: c.volume });
    }
    
    // Cluster zones (group nearby levels)
    function clusterLevels(levels, threshold) {
        if (levels.length === 0) return [];
        
        const sorted = [...levels].sort((a, b) => a.price - b.price);
        const clusters = [];
        let cluster = [sorted[0]];
        
        for (let i = 1; i < sorted.length; i++) {
            if ((sorted[i].price - cluster[0].price) / cluster[0].price < threshold) {
                cluster.push(sorted[i]);
            } else {
                clusters.push({
                    price: cluster.reduce((s, l) => s + l.price, 0) / cluster.length,
                    touches: cluster.length,
                    strength: cluster.length * 10 + (cluster.reduce((s, l) => s + l.volume, 0) > 0 ? 10 : 0)
                });
                cluster = [sorted[i]];
            }
        }
        clusters.push({
            price: cluster.reduce((s, l) => s + l.price, 0) / cluster.length,
            touches: cluster.length,
            strength: cluster.length * 10
        });
        
        return clusters;
    }
    
    const supportZones = clusterLevels(swingLows, 0.015);
    const resistanceZones = clusterLevels(swingHighs, 0.015);
    
    // Find nearest zone
    let nearestSupport = null;
    let nearestResistance = null;
    let supportDist = Infinity;
    let resistDist = Infinity;
    
    for (const zone of supportZones) {
        if (zone.price < currentPrice) {
            const dist = (currentPrice - zone.price) / currentPrice;
            if (dist < supportDist) {
                supportDist = dist;
                nearestSupport = zone;
            }
        }
    }
    
    for (const zone of resistanceZones) {
        if (zone.price > currentPrice) {
            const dist = (zone.price - currentPrice) / currentPrice;
            if (dist < resistDist) {
                resistDist = dist;
                nearestResistance = zone;
            }
        }
    }
    
    // Also check if AT zone (within 1.5% or 1 ATR)
    const zoneThreshold = Math.max(0.015, atr / currentPrice);
    
    let atSupport = nearestSupport && supportDist < zoneThreshold;
    let atResistance = nearestResistance && resistDist < zoneThreshold;
    
    // Also check if price recently touched zone (within last 3 candles)
    if (!atSupport && nearestSupport) {
        for (let i = 1; i <= 3; i++) {
            const candle = klines[len - i];
            if (candle && Math.abs(candle.low - nearestSupport.price) / nearestSupport.price < 0.008) {
                atSupport = true;
                break;
            }
        }
    }
    
    if (!atResistance && nearestResistance) {
        for (let i = 1; i <= 3; i++) {
            const candle = klines[len - i];
            if (candle && Math.abs(candle.high - nearestResistance.price) / nearestResistance.price < 0.008) {
                atResistance = true;
                break;
            }
        }
    }
    
    // NO ZONE = NO TRADE
    if (!atSupport && !atResistance) return null;
    
    // Determine direction from zone
    let direction = null;
    let zoneStrength = 0;
    
    if (atSupport && !atResistance) {
        direction = 'LONG';
        zoneStrength = nearestSupport.touches * 15;
    } else if (atResistance && !atSupport) {
        direction = 'SHORT';
        zoneStrength = nearestResistance.touches * 15;
    } else if (atSupport && atResistance) {
        // At both - pick stronger zone
        if (nearestSupport.touches >= nearestResistance.touches) {
            direction = 'LONG';
            zoneStrength = nearestSupport.touches * 15;
        } else {
            direction = 'SHORT';
            zoneStrength = nearestResistance.touches * 15;
        }
    }
    
    if (!direction) return null;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // STEP 2: REJECTION CONFIRMATIONS - Count all signs of reversal
    // ═══════════════════════════════════════════════════════════════════════════
    
    let confirmations = 0;
    let confirmList = [];
    
    // --- CANDLE REJECTION ---
    const body0 = Math.abs(c0.close - c0.open);
    const upperWick0 = c0.high - Math.max(c0.open, c0.close);
    const lowerWick0 = Math.min(c0.open, c0.close) - c0.low;
    const totalRange0 = c0.high - c0.low;
    
    // Rejection wick (long wick in direction of zone)
    if (direction === 'LONG' && lowerWick0 > body0 * 1.5 && lowerWick0 > totalRange0 * 0.5) {
        confirmations++;
        confirmList.push('RejectionWick');
    }
    if (direction === 'SHORT' && upperWick0 > body0 * 1.5 && upperWick0 > totalRange0 * 0.5) {
        confirmations++;
        confirmList.push('RejectionWick');
    }
    
    // Engulfing candle
    const body1 = Math.abs(c1.close - c1.open);
    if (direction === 'LONG' && c0.close > c0.open && c0.close > c1.high && body0 > body1) {
        confirmations++;
        confirmList.push('BullEngulf');
    }
    if (direction === 'SHORT' && c0.close < c0.open && c0.close < c1.low && body0 > body1) {
        confirmations++;
        confirmList.push('BearEngulf');
    }
    
    // Candle color matches direction
    if (direction === 'LONG' && c0.close > c0.open) {
        confirmations++;
        confirmList.push('BullCandle');
    }
    if (direction === 'SHORT' && c0.close < c0.open) {
        confirmations++;
        confirmList.push('BearCandle');
    }
    
    // --- RSI CONFIRMATION ---
    const rsi = calcRSI(klines);
    
    if (direction === 'LONG' && rsi.value < 35) {
        confirmations++;
        confirmList.push('RSI_OS');
        if (rsi.value < 25) {
            confirmations++;
            confirmList.push('RSI_DeepOS');
        }
    }
    if (direction === 'SHORT' && rsi.value > 65) {
        confirmations++;
        confirmList.push('RSI_OB');
        if (rsi.value > 75) {
            confirmations++;
            confirmList.push('RSI_DeepOB');
        }
    }
    
    // --- RSI DIVERGENCE ---
    // Check if price made lower low but RSI made higher low (bullish div)
    // Or price made higher high but RSI made lower high (bearish div)
    const rsiValues = [];
    for (let i = 20; i >= 0; i--) {
        const slice = klines.slice(0, len - i);
        if (slice.length >= 14) {
            rsiValues.push(calcRSI(slice).value);
        }
    }
    
    if (rsiValues.length >= 10) {
        const recentLows = [];
        const recentHighs = [];
        
        for (let i = 5; i < Math.min(len - 5, 20); i++) {
            const c = klines[len - 1 - i];
            let isLow = true, isHigh = true;
            for (let j = 1; j <= 2; j++) {
                if (klines[len - 1 - i - j]?.low < c.low) isLow = false;
                if (klines[len - 1 - i + j]?.low < c.low) isLow = false;
                if (klines[len - 1 - i - j]?.high > c.high) isHigh = false;
                if (klines[len - 1 - i + j]?.high > c.high) isHigh = false;
            }
            if (isLow) recentLows.push({ price: c.low, idx: i, rsi: rsiValues[rsiValues.length - 1 - i] || 50 });
            if (isHigh) recentHighs.push({ price: c.high, idx: i, rsi: rsiValues[rsiValues.length - 1 - i] || 50 });
        }
        
        // Bullish divergence: lower price low, higher RSI low
        if (direction === 'LONG' && recentLows.length >= 2) {
            const [l1, l2] = recentLows.slice(0, 2);
            if (l1.price < l2.price && l1.rsi > l2.rsi) {
                confirmations += 2;
                confirmList.push('BullDiv');
            }
        }
        
        // Bearish divergence: higher price high, lower RSI high
        if (direction === 'SHORT' && recentHighs.length >= 2) {
            const [h1, h2] = recentHighs.slice(0, 2);
            if (h1.price > h2.price && h1.rsi < h2.rsi) {
                confirmations += 2;
                confirmList.push('BearDiv');
            }
        }
    }
    
    // --- VOLUME CONFIRMATION ---
    const avgVol = klines.slice(-20).reduce((s, k) => s + k.volume, 0) / 20;
    const volRatio = c0.volume / avgVol;
    
    if (volRatio > 1.5) {
        confirmations++;
        confirmList.push('VolSpike');
    }
    
    // --- EMA TREND (Bonus, not required) ---
    const ema9 = calcEMA(closes, 9);
    const ema21 = calcEMA(closes, 21);
    const ema9Val = ema9[ema9.length - 1];
    const ema21Val = ema21[ema21.length - 1];
    
    if (direction === 'LONG' && ema9Val > ema21Val) {
        confirmations++;
        confirmList.push('TrendAlign');
    }
    if (direction === 'SHORT' && ema9Val < ema21Val) {
        confirmations++;
        confirmList.push('TrendAlign');
    }
    
    // --- LIQUIDITY SWEEP (Price went beyond zone then came back) ---
    if (direction === 'LONG' && nearestSupport) {
        // Check if any of last 5 candles swept below support then closed above
        for (let i = 1; i <= 5; i++) {
            const candle = klines[len - i];
            if (candle.low < nearestSupport.price * 0.995 && candle.close > nearestSupport.price) {
                confirmations += 2;
                confirmList.push('LiqSweep');
                break;
            }
        }
    }
    if (direction === 'SHORT' && nearestResistance) {
        for (let i = 1; i <= 5; i++) {
            const candle = klines[len - i];
            if (candle.high > nearestResistance.price * 1.005 && candle.close < nearestResistance.price) {
                confirmations += 2;
                confirmList.push('LiqSweep');
                break;
            }
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // STEP 3: GRADE BY CONFIRMATIONS
    // ═══════════════════════════════════════════════════════════════════════════
    
    // V9.1: Minimum 3 confirmations required for higher quality
    if (confirmations < 3) return null;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // V9.6 SMART MATRIX - APPLY TO BACKTEST
    // ═══════════════════════════════════════════════════════════════════════════
    
    // Build quick zone/smc/momentum data for Smart Matrix
    const zoneTouches = direction === 'LONG' ? (nearestSupport?.touches || 0) : (nearestResistance?.touches || 0);
    const quickZone = { touches: zoneTouches, direction };
    const quickSMC = { 
        direction, 
        details: { 
            bos: { detected: confirmList.includes('BOS'), bodyClose: true },
            choch: { detected: confirmList.includes('CHOCH') },
            orderBlocks: { bullish: [], bearish: [] },
            fvg: { bullish: [], bearish: [] },
            liquiditySweep: { detected: confirmList.includes('LiqSweep') }
        }
    };
    const quickMomentum = {
        direction: rsi.value < 40 ? 'LONG' : rsi.value > 60 ? 'SHORT' : 'NEUTRAL',
        details: {
            rsi: { value: rsi.value },
            macd: { crossover: confirmList.includes('MACD'), histogram: 0 },
            adx: { adx: 25 },
            volume: { ratio: volRatio },
            divergence: { detected: confirmList.includes('BullDiv') || confirmList.includes('BearDiv') }
        }
    };
    
    // Calculate Smart Matrix weights
    let smartMatrix = null;
    try {
        smartMatrix = calculateSmartMatrix(
            { direction, details: { primaryZone: quickZone } },
            quickSMC,
            quickMomentum,
            klines
        );
    } catch (e) {
        smartMatrix = { weights: { zone: 33, smc: 33, momentum: 34 }, agreement: { bonus: 1.0 }, regime: { regime: 'UNKNOWN' } };
    }
    
    // Calculate base score
    let baseScore = 40 + zoneStrength + (confirmations * 8);
    
    // Apply Smart Matrix adjustments
    // Zone touch bonus (3=baseline, 4+=bonus)
    if (zoneTouches >= 3) {
        const touchBonus = zoneTouches === 3 ? 0 : (zoneTouches - 3) * 3; // +3 per touch above 3
        baseScore += Math.min(touchBonus, 15); // Cap at +15
    }
    
    // Agreement bonus
    baseScore *= smartMatrix.agreement?.bonus || 1.0;
    
    // Regime penalty for choppy
    if (smartMatrix.regime?.regime === 'CHOPPY') {
        baseScore *= 0.90;
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // STEP 4: SET SL/TP WITH VALIDATION (ChatGPT SL/TP Fix)
    // ═══════════════════════════════════════════════════════════════════════════
    
    let sl, tp;
    let slQuality = 0; // Track SL/TP quality for score adjustment
    let tpQuality = 0;
    
    // Minimum SL distance = 0.8 ATR (prevents noise-level stops)
    const minSlDistance = atr * 0.8;
    
    if (direction === 'LONG') {
        // SL below zone
        const rawSl = nearestSupport ? nearestSupport.price * 0.995 : currentPrice - atr * 1.2;
        const slDistance = currentPrice - rawSl;
        
        // Enforce minimum SL distance
        if (slDistance < minSlDistance) {
            sl = currentPrice - minSlDistance;
            slQuality -= 5; // Penalty for weak SL
        } else {
            sl = rawSl;
            slQuality += 5; // Bonus for structural SL
        }
        
        const risk = currentPrice - sl;
        
        // TP: Check if opposing zone blocks it
        if (nearestResistance) {
            const distanceToResistance = nearestResistance.price - currentPrice;
            if (distanceToResistance < risk * 1.5) {
                // Resistance too close - TP blocked
                tp = currentPrice + risk * 2; // Force 2R anyway
                tpQuality -= 8; // Penalty for blocked TP
            } else {
                tp = Math.min(nearestResistance.price * 0.995, currentPrice + risk * 2.5);
                tpQuality += 5; // Clear path to TP
            }
        } else {
            tp = currentPrice + risk * 2;
        }
    } else {
        // SHORT
        const rawSl = nearestResistance ? nearestResistance.price * 1.005 : currentPrice + atr * 1.2;
        const slDistance = rawSl - currentPrice;
        
        // Enforce minimum SL distance
        if (slDistance < minSlDistance) {
            sl = currentPrice + minSlDistance;
            slQuality -= 5; // Penalty for weak SL
        } else {
            sl = rawSl;
            slQuality += 5; // Bonus for structural SL
        }
        
        const risk = sl - currentPrice;
        
        // TP: Check if opposing zone blocks it
        if (nearestSupport) {
            const distanceToSupport = currentPrice - nearestSupport.price;
            if (distanceToSupport < risk * 1.5) {
                // Support too close - TP blocked
                tp = currentPrice - risk * 2; // Force 2R anyway
                tpQuality -= 8; // Penalty for blocked TP
            } else {
                tp = Math.max(nearestSupport.price * 1.005, currentPrice - risk * 2.5);
                tpQuality += 5; // Clear path to TP
            }
        } else {
            tp = currentPrice - risk * 2;
        }
    }
    
    // Calculate RR for validation
    const riskAmount = Math.abs(currentPrice - sl);
    const rewardAmount = Math.abs(tp - currentPrice);
    const rr = riskAmount > 0 ? rewardAmount / riskAmount : 0;
    
    // RR quality bonus/penalty
    if (rr >= 2.5) tpQuality += 5;      // Excellent RR
    else if (rr >= 2.0) tpQuality += 2; // Good RR
    else if (rr < 1.5) tpQuality -= 10; // Poor RR - big penalty
    
    // Apply SL/TP quality to base score
    let score = Math.min(100, Math.round(baseScore + slQuality + tpQuality));
    
    // ═══════════════════════════════════════════════════════════════════════════
    // V12 EV LEARNING INTEGRATION
    // If EV Learner is bootstrapped, use learned score instead
    // ═══════════════════════════════════════════════════════════════════════════
    let evScore = null;
    let useEVScore = false;
    
    try {
        if (typeof EVLearner !== 'undefined' && EVLearner.isBootstrapped) {
            // Build temporary signal object for EV scoring
            const tempSignal = {
                zoneStrength,
                confirmations,
                rsiValue: rsi.value,
                volSpike: volRatio > 1.5,
                direction,
                confirmList,
                rr,
                slQuality,
                tpQuality,
                mode: ['5', '15', '30'].includes(tf) ? 'SCALP' : tf === '60' ? 'INTRADAY' : 'SWING'
            };
            
            evScore = EVLearner.getLearnedScore(tempSignal);
            
            // Use EV score if we have enough data for this bin
            if (evScore !== null && evScore !== undefined) {
                // Blend: 70% EV score + 30% original score
                // This prevents total override while prioritizing learned data
                score = Math.round(evScore * 0.7 + score * 0.3);
                useEVScore = true;
            }
        }
    } catch (e) {
        // EVLearner not available or error - use original score
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // GRADE ASSIGNMENT - V18 UNIFIED (P/S/V/W/X system)
    // Integrated with EV Learning from V13
    // ═══════════════════════════════════════════════════════════════════════════
    
    let grade, gradeCode, gradeColor, tradeable, sizeMultiplier;
    
    if (score >= 90) {
        grade = 'PRIME'; gradeCode = 'P'; gradeColor = '#ffd700'; 
        tradeable = true; sizeMultiplier = 1.25;
    } else if (score >= 75) {
        grade = 'STRONG'; gradeCode = 'S'; gradeColor = '#00d9a0'; 
        tradeable = true; sizeMultiplier = 1.0;
    } else if (score >= 60) {
        grade = 'VALID'; gradeCode = 'V'; gradeColor = '#3b82f6'; 
        tradeable = true; sizeMultiplier = 0.75;
    } else if (score >= 45) {
        grade = 'WEAK'; gradeCode = 'W'; gradeColor = '#f59e0b'; 
        tradeable = false; sizeMultiplier = 0.5;
    } else {
        grade = 'SKIP'; gradeCode = 'X'; gradeColor = '#ff4757'; 
        tradeable = false; sizeMultiplier = 0;
    }
    
    // V18: Block truly garbage signals (< 45 = SKIP grade)
    // Let EV optimizer test the rest freely
    if (score < 45) return null;
    
    const isCream = confirmations >= 6 && confirmList.includes('LiqSweep');
    
    return {
        direction,
        grade,
        gradeCode,
        gradeColor,
        tradeable,
        sizeMultiplier,
        score,
        evScore: useEVScore ? evScore : null,  // V12: Include EV score if used
        useEVScore,                             // V12: Flag if EV scoring was used
        entry: currentPrice,
        atr,
        isCream,
        mode: ['5', '15', '30'].includes(tf) ? 'SCALP' : tf === '60' ? 'INTRADAY' : 'SWING',
        rsiValue: rsi.value,
        volSpike: volRatio > 1.5,
        confirmations,
        confirmList,
        zoneStrength,
        zoneTouches,
        smartMatrix,
        rr: Math.round(rr * 100) / 100, // Include calculated RR
        slQuality,
        tpQuality,
        levels: { sl, tp }
    };
}


// Simulate trade outcome based on future candles
function simulateTradeOutcome(signal, futureKlines) {
    // ═══════════════════════════════════════════════════════════════════════════
    // V13 BALANCED TRADE SIMULATION
    // Goal: Accurately track what actually happens to trades
    // ═══════════════════════════════════════════════════════════════════════════
    
    if (!futureKlines || futureKlines.length === 0) {
        return { won: false, pnl: 0, rr: 0, reason: 'NO_DATA' };
    }
    
    if (!signal || !signal.levels) {
        return { won: false, pnl: 0, rr: 0, reason: 'INVALID_SIGNAL' };
    }
    
    const sl = signal.levels.sl;
    const tp = signal.levels.tp;
    const direction = signal.direction;
    
    if (!sl || !tp || isNaN(sl) || isNaN(tp)) {
        return { won: false, pnl: 0, rr: 0, reason: 'INVALID_LEVELS' };
    }
    
    // Entry on next candle open with small slippage
    const nextOpen = futureKlines[0].open;
    const SLIPPAGE = 0.0003; // 0.03% slippage
    const entry = direction === 'LONG' 
        ? nextOpen * (1 + SLIPPAGE)
        : nextOpen * (1 - SLIPPAGE);
    
    const risk = Math.abs(entry - sl);
    const reward = Math.abs(tp - entry);
    const targetRR = risk > 0 ? reward / risk : 2.0;
    
    // Check for gap through SL at entry
    if (direction === 'LONG' && entry <= sl) {
        return { won: false, pnl: -1.0, rr: -1.0, reason: 'GAP_THROUGH_SL' };
    }
    if (direction === 'SHORT' && entry >= sl) {
        return { won: false, pnl: -1.0, rr: -1.0, reason: 'GAP_THROUGH_SL' };
    }
    
    // Walk through future candles
    for (let i = 0; i < futureKlines.length; i++) {
        const candle = futureKlines[i];
        const high = candle.high;
        const low = candle.low;
        
        let slHit = false;
        let tpHit = false;
        
        if (direction === 'LONG') {
            slHit = low <= sl;
            tpHit = high >= tp;
        } else {
            slHit = high >= sl;
            tpHit = low <= tp;
        }
        
        // Both hit same candle - use candle direction as tiebreaker
        if (slHit && tpHit) {
            const isBearish = candle.close < candle.open;
            const isBullish = candle.close > candle.open;
            
            // Conservative: assume worst case based on candle direction
            if (direction === 'LONG' && isBearish) {
                return { won: false, pnl: -1.0, rr: -1.0, reason: 'SL_HIT_BOTH' };
            } else if (direction === 'SHORT' && isBullish) {
                return { won: false, pnl: -1.0, rr: -1.0, reason: 'SL_HIT_BOTH' };
            } else {
                return { won: true, pnl: targetRR, rr: targetRR, reason: 'TP_HIT_BOTH' };
            }
        }
        
        // Only SL hit
        if (slHit) {
            return { won: false, pnl: -1.0, rr: -1.0, reason: 'SL_HIT' };
        }
        
        // Only TP hit
        if (tpHit) {
            return { won: true, pnl: targetRR, rr: targetRR, reason: 'TP_HIT' };
        }
    }
    
    // Neither hit - trade times out
    // Calculate where we would exit at end of period
    const lastClose = futureKlines[futureKlines.length - 1].close;
    const move = direction === 'LONG' ? lastClose - entry : entry - lastClose;
    const rMult = risk > 0 ? move / risk : 0;
    
    // Timeout: actual P&L based on price movement
    return { 
        won: rMult > 0, 
        pnl: Math.max(-1, Math.min(targetRR, rMult)), // Cap between -1 and target
        rr: Math.max(-1, Math.min(targetRR, rMult)), 
        reason: 'TIMEOUT' 
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// CHOP FILTER - Detect sideways/low volatility conditions
// ═══════════════════════════════════════════════════════════════════════════════
function isChoppy(candles, lookback = 20) {
    if (!candles || candles.length < lookback) return false;
    
    const recent = candles.slice(-lookback);
    
    // Calculate ATR
    let atrSum = 0;
    for (let i = 1; i < recent.length; i++) {
        const tr = Math.max(
            recent[i].high - recent[i].low,
            Math.abs(recent[i].high - recent[i-1].close),
            Math.abs(recent[i].low - recent[i-1].close)
        );
        atrSum += tr;
    }
    const atr = atrSum / (recent.length - 1);
    const atrPct = (atr / recent[recent.length-1].close) * 100;
    
    // Calculate range compression
    const highest = Math.max(...recent.map(c => c.high));
    const lowest = Math.min(...recent.map(c => c.low));
    const rangePct = ((highest - lowest) / lowest) * 100;
    
    // CHOP conditions:
    // 1. ATR < 1% (low volatility)
    // 2. Range < 3% over 20 candles (compressed)
    const isLowVol = atrPct < 1.0;
    const isCompressed = rangePct < 3.0;
    
    return isLowVol || isCompressed;
}

// ═══════════════════════════════════════════════════════════════════════════════
// LOSING STREAK ANALYSIS - Capital death test
// ═══════════════════════════════════════════════════════════════════════════════
function analyzeLosingStreaks(trades) {
    if (!trades || trades.length === 0) return { maxStreak: 0, survives: true, worstSequence: 0 };
    
    let currentStreak = 0;
    let maxStreak = 0;
    let worstPnL = 0;
    let currentDrawdown = 0;
    
    for (const trade of trades) {
        const pnl = trade.netPnl !== undefined ? trade.netPnl : (trade.pnl - 0.2);
        
        if (pnl < 0) {
            currentStreak++;
            currentDrawdown += pnl;
            maxStreak = Math.max(maxStreak, currentStreak);
            worstPnL = Math.min(worstPnL, currentDrawdown);
        } else {
            currentStreak = 0;
            currentDrawdown = 0;
        }
    }
    
    // Survival test: Can we survive the worst 10-trade sequence?
    let worst10 = 0;
    for (let i = 0; i <= trades.length - 10; i++) {
        let sum = 0;
        for (let j = i; j < i + 10; j++) {
            const pnl = trades[j].netPnl !== undefined ? trades[j].netPnl : (trades[j].pnl - 0.2);
            sum += pnl;
        }
        worst10 = Math.min(worst10, sum);
    }
    
    // If worst 10-trade sequence loses more than 20% of capital, system is fragile
    const survives = worst10 > -20;
    
    return {
        maxStreak,
        worstDrawdown: worstPnL.toFixed(2),
        worst10Sequence: worst10.toFixed(2),
        survives,
        rating: maxStreak <= 5 ? 'EXCELLENT' : maxStreak <= 8 ? 'GOOD' : maxStreak <= 12 ? 'MODERATE' : 'POOR'
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// NO-TRADE SCORING - Reward silence, penalize overtrading
// ═══════════════════════════════════════════════════════════════════════════════
function calculateNoTradeScore(totalCandles, tradesCount, chopCandles = 0) {
    if (totalCandles === 0) return { score: 0, rating: 'N/A' };
    
    const tradeFrequency = tradesCount / totalCandles;
    const optimalFrequency = 0.02; // Ideal: 1 trade per 50 candles
    
    // Penalize if trading more than optimal
    let score = 100;
    if (tradeFrequency > optimalFrequency * 2) {
        score -= (tradeFrequency - optimalFrequency * 2) * 1000; // Heavy penalty
    }
    
    // Bonus for avoiding chop
    const chopAvoidance = chopCandles > 0 ? (1 - (tradesCount / chopCandles)) * 20 : 0;
    score += chopAvoidance;
    
    score = Math.max(0, Math.min(100, score));
    
    return {
        score: score.toFixed(0),
        frequency: (tradeFrequency * 100).toFixed(2) + '% of candles',
        rating: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : score >= 40 ? 'MODERATE' : 'OVERTRADING'
    };
}

// Display backtest results
function displayBacktestResults(results, days) {
    const container = document.getElementById('backtestResults');
    
    const winRate = results.totalTrades > 0 ? ((results.wins / results.totalTrades) * 100).toFixed(1) : 0;
    const pnlClass = results.totalPnL >= 0 ? 'positive' : 'negative';
    
    // Find best/worst
    let bestCoin = '-', bestCoinWin = 0;
    let worstCoin = '-', worstCoinWin = 100;
    Object.entries(results.byCoin).forEach(([coin, data]) => {
        if (data.trades >= 3) {
            const wr = (data.wins / data.trades) * 100;
            if (wr > bestCoinWin) { bestCoin = coin.replace('USDT', ''); bestCoinWin = wr; }
            if (wr < worstCoinWin) { worstCoin = coin.replace('USDT', ''); worstCoinWin = wr; }
        }
    });
    
    let bestTF = '-', bestTFWin = 0;
    Object.entries(results.byTF).forEach(([tf, data]) => {
        if (data.trades >= 3) {
            const wr = (data.wins / data.trades) * 100;
            if (wr > bestTFWin) { bestTF = tf; bestTFWin = wr; }
        }
    });
    
    container.innerHTML = `
        <div class="backtest-summary">
            <div class="backtest-stat">
                <div class="backtest-stat-label">Total Trades</div>
                <div class="backtest-stat-value neutral">${results.totalTrades}</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Win Rate</div>
                <div class="backtest-stat-value ${parseFloat(winRate) >= 50 ? 'positive' : 'negative'}">${winRate}%</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Total P&L</div>
                <div class="backtest-stat-value ${pnlClass}">${results.totalPnL >= 0 ? '+' : ''}${results.totalPnL.toFixed(0)}%</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Wins / Losses</div>
                <div class="backtest-stat-value neutral">${results.wins} / ${results.losses}</div>
            </div>
        </div>
        
        <div class="backtest-grades">
            <div class="backtest-grade-row" style="border-left:3px solid #00ffcc">
                <span class="grade-name">💎 CREAM</span>
                <span class="grade-stats">
                    <span>${results.byGrade.cream.trades} trades</span>
                    <span class="win-rate">${results.byGrade.cream.trades > 0 ? ((results.byGrade.cream.wins / results.byGrade.cream.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.cream.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.cream.pnl >= 0 ? '+' : ''}${results.byGrade.cream.pnl.toFixed(0)}%</span>
                </span>
            </div>
            <div class="backtest-grade-row" style="border-left:3px solid var(--gold)">
                <span class="grade-name">🥇 PERFECT</span>
                <span class="grade-stats">
                    <span>${results.byGrade.perfect.trades} trades</span>
                    <span class="win-rate">${results.byGrade.perfect.trades > 0 ? ((results.byGrade.perfect.wins / results.byGrade.perfect.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.perfect.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.perfect.pnl >= 0 ? '+' : ''}${results.byGrade.perfect.pnl.toFixed(0)}%</span>
                </span>
            </div>
            <div class="backtest-grade-row" style="border-left:3px solid var(--cyan)">
                <span class="grade-name">🥈 STRONG</span>
                <span class="grade-stats">
                    <span>${results.byGrade.strong.trades} trades</span>
                    <span class="win-rate">${results.byGrade.strong.trades > 0 ? ((results.byGrade.strong.wins / results.byGrade.strong.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.strong.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.strong.pnl >= 0 ? '+' : ''}${results.byGrade.strong.pnl.toFixed(0)}%</span>
                </span>
            </div>
            <div class="backtest-grade-row" style="border-left:3px solid var(--amber)">
                <span class="grade-name">🥉 VALID</span>
                <span class="grade-stats">
                    <span>${results.byGrade.valid.trades} trades</span>
                    <span class="win-rate">${results.byGrade.valid.trades > 0 ? ((results.byGrade.valid.wins / results.byGrade.valid.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.valid.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.valid.pnl >= 0 ? '+' : ''}${results.byGrade.valid.pnl.toFixed(0)}%</span>
                </span>
            </div>
        </div>
        
        <div class="backtest-insights">
            <div class="backtest-insight">
                <span class="icon">📈</span>
                <span>Best Coin: <span class="highlight">${bestCoin}</span> (${bestCoinWin.toFixed(0)}% win)</span>
            </div>
            <div class="backtest-insight">
                <span class="icon">📉</span>
                <span>Worst Coin: <span class="lowlight">${worstCoin}</span> (${worstCoinWin.toFixed(0)}% win)</span>
            </div>
            <div class="backtest-insight">
                <span class="icon">⏰</span>
                <span>Best TF: <span class="highlight">${bestTF}</span> (${bestTFWin.toFixed(0)}% win)</span>
            </div>
            <div class="backtest-insight">
                <span class="icon">📊</span>
                <span>Period: Last <span class="highlight">${days}</span> days</span>
            </div>
        </div>
    `;
}

function calculateSmartLimitEntry(currentPrice, direction, atr, zoneDetails, smcDetails, adx) {
    const result = {
        limitEntry: null,
        entryType: null,  // 'ZONE' or 'ATR'
        zoneScore: 0,
        atrScore: 0,
        confidence: 0
    };
    
    // Get relevant zone
    const zone = direction === 'LONG' ? zoneDetails.nearestSupport : zoneDetails.nearestResistance;
    
    // Calculate Zone Score (if zone exists)
    if (zone) {
        let zScore = 0;
        
        // Touch count (max 25)
        if (zone.touches >= 4) zScore += 25;
        else if (zone.touches >= 3) zScore += 20;
        else if (zone.touches >= 2) zScore += 15;
        else zScore += 5;
        
        // Distance to zone (max 25)
        const zonePrice = direction === 'LONG' ? zone.high : zone.low;
        const distancePct = currentPrice > 0 ? Math.abs(currentPrice - zonePrice) / currentPrice * 100 : 0;
        if (distancePct <= 0.5) zScore += 25;
        else if (distancePct <= 1.0) zScore += 22;
        else if (distancePct <= 1.5) zScore += 18;
        else if (distancePct <= 2.0) zScore += 12;
        else if (distancePct <= 3.0) zScore += 5;
        
        // Order Block confluence (max 20)
        if (smcDetails && smcDetails.orderBlocks) {
            const obs = direction === 'LONG' ? smcDetails.orderBlocks.bullish : smcDetails.orderBlocks.bearish;
            const obAtZone = obs && obs.some(ob => Math.abs(ob.price - zonePrice) / zonePrice < 0.01);
            if (obAtZone) zScore += 20;
        }
        
        // Zone strength (max 15)
        if (zone.strength >= 70) zScore += 15;
        else if (zone.strength >= 50) zScore += 10;
        else zScore += 5;
        
        result.zoneScore = Math.min(100, zScore);
        result.zoneEntry = direction === 'LONG' ? zone.high * 1.002 : zone.low * 0.998;
    }
    
    // Calculate ATR Entry
    let pullbackMult = 0.4;
    const adxVal = adx || 25;
    
    // Adjust by trend strength
    if (adxVal > 40) pullbackMult = 0.25;
    else if (adxVal > 30) pullbackMult = 0.35;
    else if (adxVal > 20) pullbackMult = 0.45;
    else pullbackMult = 0.55;
    
    result.atrEntry = direction === 'LONG' 
        ? currentPrice - (atr * pullbackMult)
        : currentPrice + (atr * pullbackMult);
    
    // ATR Score
    result.atrScore = 50;
    if (adxVal > 30) result.atrScore += 20;
    else if (adxVal > 25) result.atrScore += 10;
    if (!zone || result.zoneScore < 40) result.atrScore += 15;
    result.atrScore = Math.min(100, result.atrScore);
    
    // Decision: Zone vs ATR
    if (result.zoneScore >= 70 && zone) {
        const distPct = Math.abs(currentPrice - result.zoneEntry) / currentPrice * 100;
        if (distPct <= 2.0) {
            result.entryType = 'ZONE';
            result.limitEntry = result.zoneEntry;
            result.confidence = Math.round(result.zoneScore * 0.9);
        }
    }
    
    if (!result.entryType) {
        if (result.zoneScore > result.atrScore && result.zoneScore >= 50) {
            result.entryType = 'ZONE';
            result.limitEntry = result.zoneEntry;
            result.confidence = Math.round(result.zoneScore * 0.85);
        } else {
            result.entryType = 'ATR';
            result.limitEntry = result.atrEntry;
            result.confidence = Math.round(result.atrScore * 0.85);
        }
    }
    
    // Safety: max 3% from current price
    const maxDist = 0.03;
    const entryDist = Math.abs(currentPrice - result.limitEntry) / currentPrice;
    if (entryDist > maxDist) {
        result.limitEntry = direction === 'LONG'
            ? currentPrice * (1 - maxDist)
            : currentPrice * (1 + maxDist);
        result.confidence = Math.round(result.confidence * 0.8);
    }
    
    return result;
}


// ═══════════════════════════════════════════════════════════════════════════════
// ═══════════════════════════════════════════════════════════════════════════════
// V19 ULTRA RED DNA - ADVANCED LIQUIDITY HUNTING ENGINE (THE KING)
// ═══════════════════════════════════════════════════════════════════════════════
// This is the MASTER TRIGGER - More advanced than any support engine
// ~3000+ lines of institutional-grade liquidity analysis
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 1: LIQUIDITY POOL DETECTION (Advanced Multi-Algorithm)
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * ADVANCED LIQUIDITY POOL FINDER
 * Finds SSL (Sell Side Liquidity) and BSL (Buy Side Liquidity) using multiple algorithms
 * Uses: Equal Highs/Lows, Swing Clusters, Volume Profile, Order Flow Imbalance
 */
function findLiquidityPools(candles, isSSL = false) {
    if (!candles || candles.length < 50) return [];
    
    const cfg = CONFIG.LIQUIDITY.pool;
    
    // ALGORITHM 1: Swing-based pool detection (original)
    const swingPools = findSwingBasedPools(candles, isSSL, cfg);
    
    // ALGORITHM 2: Volume cluster detection
    const volumePools = findVolumeClusterPools(candles, isSSL);
    
    // ALGORITHM 3: Wick rejection clusters
    const wickPools = findWickRejectionPools(candles, isSSL);
    
    // MERGE and DEDUPLICATE pools
    const allPools = mergeLiquidityPools([...swingPools, ...volumePools, ...wickPools], cfg.clusterRange);
    
    // Score and rank pools
    const scoredPools = allPools.map(pool => ({
        ...pool,
        compositeScore: calculatePoolCompositeScore(pool, candles, isSSL)
    }));
    
    // Sort by composite score
    scoredPools.sort((a, b) => b.compositeScore - a.compositeScore);
    
    return scoredPools.slice(0, cfg.maxPools || 5);
}

/**
 * SWING-BASED POOL DETECTION (Algorithm 1)
 * Finds equal highs/lows where stops cluster
 */
function findSwingBasedPools(candles, isSSL, cfg) {
    const swings = [];
    
    // Multi-period swing detection for robustness
    const periods = [3, 5, 8]; // Check multiple lookback periods
    
    for (const period of periods) {
        for (let i = period; i < candles.length - period; i++) {
            const c = candles[i];
            const price = isSSL ? c.high : c.low;
            let isSwing = true;
            
            for (let j = 1; j <= period; j++) {
                if (isSSL) {
                    if (candles[i-j].high >= price || candles[i+j].high >= price) { 
                        isSwing = false; 
                        break; 
                    }
                } else {
                    if (candles[i-j].low <= price || candles[i+j].low <= price) { 
                        isSwing = false; 
                        break; 
                    }
                }
            }
            
            if (isSwing) {
                // Check if this swing already exists
                const exists = swings.some(s => Math.abs(s.price - price) / price < 0.001);
                if (!exists) {
                    swings.push({ 
                        price, 
                        idx: i, 
                        candle: c, 
                        volume: c.volume,
                        period: period,
                        timestamp: c.time || i
                    });
                }
            }
        }
    }
    
    if (swings.length < 2) return [];
    
    // Cluster swings into pools
    return clusterSwingsIntoPools(swings, isSSL, cfg);
}

/**
 * VOLUME CLUSTER POOL DETECTION (Algorithm 2)
 * Finds price levels where significant volume transacted
 */
function findVolumeClusterPools(candles, isSSL) {
    if (!candles || candles.length < 30) return [];
    
    // Create volume profile
    const priceMin = Math.min(...candles.map(c => c.low));
    const priceMax = Math.max(...candles.map(c => c.high));
    const range = priceMax - priceMin;
    const bucketSize = range / 50; // 50 price buckets
    
    const volumeProfile = {};
    
    for (const c of candles) {
        // Distribute volume across the candle's range
        const candleRange = c.high - c.low;
        if (candleRange === 0) continue;
        
        const bucketStart = Math.floor((c.low - priceMin) / bucketSize);
        const bucketEnd = Math.floor((c.high - priceMin) / bucketSize);
        
        for (let b = bucketStart; b <= bucketEnd && b < 50; b++) {
            const bucketPrice = priceMin + (b * bucketSize) + (bucketSize / 2);
            if (!volumeProfile[b]) {
                volumeProfile[b] = { price: bucketPrice, volume: 0, touches: 0 };
            }
            volumeProfile[b].volume += c.volume / (bucketEnd - bucketStart + 1);
            volumeProfile[b].touches++;
        }
    }
    
    // Find high volume nodes (HVN) - these are liquidity pools
    const buckets = Object.values(volumeProfile);
    const avgVolume = buckets.reduce((s, b) => s + b.volume, 0) / buckets.length;
    
    const hvnPools = buckets
        .filter(b => b.volume > avgVolume * 1.5) // HVN = 1.5x average
        .map(b => ({
            type: isSSL ? 'SSL' : 'BSL',
            price: b.price,
            lowPrice: b.price - bucketSize / 2,
            highPrice: b.price + bucketSize / 2,
            touches: b.touches,
            volume: b.volume,
            strength: Math.min(100, (b.volume / avgVolume) * 30),
            source: 'VOLUME_CLUSTER',
            isHVN: true
        }))
        .filter(p => isSSL ? p.price > candles[candles.length - 1].close : p.price < candles[candles.length - 1].close);
    
    return hvnPools.slice(0, 3);
}

/**
 * WICK REJECTION POOL DETECTION (Algorithm 3)
 * Finds levels where wicks consistently reject
 */
function findWickRejectionPools(candles, isSSL) {
    if (!candles || candles.length < 30) return [];
    
    const rejections = [];
    
    for (let i = 0; i < candles.length; i++) {
        const c = candles[i];
        const body = Math.abs(c.close - c.open);
        const range = c.high - c.low;
        
        if (range === 0) continue;
        
        if (isSSL) {
            // Top wick rejection (bearish rejection at highs)
            const topWick = c.high - Math.max(c.open, c.close);
            const wickRatio = topWick / range;
            
            if (wickRatio >= 0.4) { // 40%+ top wick
                rejections.push({
                    price: c.high,
                    wickSize: topWick,
                    wickRatio: wickRatio,
                    volume: c.volume,
                    idx: i
                });
            }
        } else {
            // Bottom wick rejection (bullish rejection at lows)
            const bottomWick = Math.min(c.open, c.close) - c.low;
            const wickRatio = bottomWick / range;
            
            if (wickRatio >= 0.4) { // 40%+ bottom wick
                rejections.push({
                    price: c.low,
                    wickSize: bottomWick,
                    wickRatio: wickRatio,
                    volume: c.volume,
                    idx: i
                });
            }
        }
    }
    
    // Cluster rejections at similar prices
    const clusters = [];
    const used = new Set();
    
    for (let i = 0; i < rejections.length; i++) {
        if (used.has(i)) continue;
        
        const cluster = [rejections[i]];
        for (let j = i + 1; j < rejections.length; j++) {
            if (used.has(j)) continue;
            const diff = Math.abs(rejections[j].price - rejections[i].price) / rejections[i].price;
            if (diff <= 0.005) { // 0.5% cluster range
                cluster.push(rejections[j]);
                used.add(j);
            }
        }
        used.add(i);
        
        if (cluster.length >= 2) { // At least 2 rejections
            const avgPrice = cluster.reduce((s, r) => s + r.price, 0) / cluster.length;
            const totalVolume = cluster.reduce((s, r) => s + r.volume, 0);
            const avgWickRatio = cluster.reduce((s, r) => s + r.wickRatio, 0) / cluster.length;
            
            clusters.push({
                type: isSSL ? 'SSL' : 'BSL',
                price: avgPrice,
                lowPrice: Math.min(...cluster.map(r => r.price)) * 0.999,
                highPrice: Math.max(...cluster.map(r => r.price)) * 1.001,
                touches: cluster.length,
                volume: totalVolume,
                strength: cluster.length * 15 + (avgWickRatio * 30),
                source: 'WICK_REJECTION',
                avgWickRatio: avgWickRatio
            });
        }
    }
    
    return clusters;
}

/**
 * CLUSTER SWINGS INTO POOLS
 * Groups nearby swings into liquidity pools
 */
function clusterSwingsIntoPools(swings, isSSL, cfg) {
    const pools = [];
    const used = new Set();
    
    for (let i = 0; i < swings.length; i++) {
        if (used.has(i)) continue;
        
        const cluster = [swings[i]];
        for (let j = i + 1; j < swings.length; j++) {
            if (used.has(j)) continue;
            const diff = Math.abs(swings[j].price - swings[i].price) / swings[i].price;
            if (diff <= cfg.equalRange) {
                cluster.push(swings[j]);
                used.add(j);
            }
        }
        used.add(i);
        
        if (cluster.length >= cfg.minTouches) {
            const avgPrice = cluster.reduce((s, p) => s + p.price, 0) / cluster.length;
            const lowestPrice = Math.min(...cluster.map(c => c.price));
            const highestPrice = Math.max(...cluster.map(c => c.price));
            const totalVolume = cluster.reduce((s, p) => s + p.volume, 0);
            const avgPeriod = cluster.reduce((s, p) => s + p.period, 0) / cluster.length;
            
            pools.push({
                type: isSSL ? 'SSL' : 'BSL',
                price: avgPrice,
                lowPrice: lowestPrice,
                highPrice: highestPrice,
                touches: cluster.length,
                lastIdx: Math.max(...cluster.map(c => c.idx)),
                volume: totalVolume,
                strength: cluster.length * 10 + (totalVolume > 0 ? 10 : 0),
                source: 'SWING_CLUSTER',
                avgPeriod: avgPeriod,
                timespan: Math.max(...cluster.map(c => c.idx)) - Math.min(...cluster.map(c => c.idx))
            });
        }
    }
    
    pools.sort((a, b) => isSSL ? b.price - a.price : a.price - b.price);
    return pools;
}

/**
 * MERGE LIQUIDITY POOLS
 * Combines pools from different algorithms that are at similar prices
 */
function mergeLiquidityPools(pools, clusterRange = 0.008) {
    if (pools.length === 0) return [];
    
    const merged = [];
    const used = new Set();
    
    // Sort by price first
    pools.sort((a, b) => a.price - b.price);
    
    for (let i = 0; i < pools.length; i++) {
        if (used.has(i)) continue;
        
        const cluster = [pools[i]];
        for (let j = i + 1; j < pools.length; j++) {
            if (used.has(j)) continue;
            const diff = Math.abs(pools[j].price - pools[i].price) / pools[i].price;
            if (diff <= clusterRange) {
                cluster.push(pools[j]);
                used.add(j);
            }
        }
        used.add(i);
        
        // Merge cluster into single pool
        const avgPrice = cluster.reduce((s, p) => s + p.price, 0) / cluster.length;
        const totalTouches = cluster.reduce((s, p) => s + p.touches, 0);
        const totalVolume = cluster.reduce((s, p) => s + p.volume, 0);
        const totalStrength = cluster.reduce((s, p) => s + p.strength, 0);
        const sources = [...new Set(cluster.map(p => p.source))];
        
        merged.push({
            type: cluster[0].type,
            price: avgPrice,
            lowPrice: Math.min(...cluster.map(p => p.lowPrice)),
            highPrice: Math.max(...cluster.map(p => p.highPrice)),
            touches: totalTouches,
            volume: totalVolume,
            strength: totalStrength,
            sources: sources,
            algorithmCount: sources.length, // More algorithms = stronger confirmation
            mergedFrom: cluster.length
        });
    }
    
    return merged;
}

/**
 * CALCULATE POOL COMPOSITE SCORE
 * Comprehensive scoring of pool quality
 */
function calculatePoolCompositeScore(pool, candles, isSSL) {
    let score = 0;
    
    // Base score from touches (max 30)
    score += Math.min(30, pool.touches * 8);
    
    // Algorithm confirmation bonus (max 25)
    score += (pool.algorithmCount || 1) * 10;
    
    // Volume score (max 20)
    const avgVolume = candles.slice(-30).reduce((s, c) => s + c.volume, 0) / 30;
    if (pool.volume > avgVolume * 2) score += 20;
    else if (pool.volume > avgVolume) score += 10;
    
    // Recency bonus - recent pools are more relevant (max 15)
    if (pool.lastIdx) {
        const recency = pool.lastIdx / candles.length;
        score += Math.round(recency * 15);
    }
    
    // Distance penalty - too far pools are less relevant
    const currentPrice = candles[candles.length - 1].close;
    const distance = Math.abs(pool.price - currentPrice) / currentPrice;
    if (distance > 0.05) score -= 20; // >5% away
    else if (distance > 0.03) score -= 10; // >3% away
    
    // Wick rejection bonus
    if (pool.source === 'WICK_REJECTION' && pool.avgWickRatio > 0.5) {
        score += 10;
    }
    
    return Math.max(0, Math.min(100, score));
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 2: ADVANCED SWEEP DETECTION
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * ADVANCED SWEEP DETECTION ENGINE
 * Detects liquidity grabs with multiple confirmation layers
 */
function detectLiquiditySweep(candles, pool, isSSL = false) {
    // Null safety checks
    if (!candles || candles.length < 15 || !pool || !pool.price) {
        return { swept: false, confirmed: false, hasVolume: false, sweepType: null };
    }
    
    const cfg = CONFIG.LIQUIDITY.sweep;
    const last = candles.slice(-cfg.lookback);
    const avgVol = candles.slice(-30, -10).reduce((s, c) => s + c.volume, 0) / 20;
    
    // Check for different sweep types
    const wickSweep = detectWickSweep(last, pool, isSSL, avgVol, cfg);
    const bodySweep = detectBodySweep(last, pool, isSSL, avgVol);
    const engulfingSweep = detectEngulfingSweep(last, pool, isSSL, avgVol);
    
    // Return the best sweep found
    if (wickSweep.swept && wickSweep.confirmed) return { ...wickSweep, sweepType: 'WICK' };
    if (bodySweep.swept && bodySweep.confirmed) return { ...bodySweep, sweepType: 'BODY' };
    if (engulfingSweep.swept && engulfingSweep.confirmed) return { ...engulfingSweep, sweepType: 'ENGULFING' };
    
    if (wickSweep.swept) return { ...wickSweep, sweepType: 'WICK' };
    if (bodySweep.swept) return { ...bodySweep, sweepType: 'BODY' };
    if (engulfingSweep.swept) return { ...engulfingSweep, sweepType: 'ENGULFING' };
    
    return { swept: false, confirmed: false, hasVolume: false, sweepType: null };
}

/**
 * WICK SWEEP DETECTION
 * Classic sweep: wick through pool, close back inside
 */
function detectWickSweep(candles, pool, isSSL, avgVol, cfg) {
    for (let i = 0; i < candles.length - 1; i++) {
        const c = candles[i];
        const next = candles[i + 1];
        
        let grabbed = false;
        let rejection = false;
        
        if (isSSL) {
            // SSL sweep: wick ABOVE pool, close BELOW
            grabbed = c.high > pool.price * 1.001 && c.close < pool.price;
            const topWick = c.high - Math.max(c.open, c.close);
            const range = c.high - c.low;
            rejection = range > 0 && (topWick / range) >= cfg.wickRatio;
        } else {
            // BSL sweep: wick BELOW pool, close ABOVE
            grabbed = c.low < pool.price * 0.999 && c.close > pool.price;
            const bottomWick = Math.min(c.open, c.close) - c.low;
            const range = c.high - c.low;
            rejection = range > 0 && (bottomWick / range) >= cfg.wickRatio;
        }
        
        if (!grabbed) continue;
        
        const hasVolume = c.volume > avgVol * cfg.volumeSpike;
        
        // Confirmation candle
        let confirms = false;
        if (!isSSL && next.close > next.open && next.close > c.close) confirms = true;
        if (isSSL && next.close < next.open && next.close < c.close) confirms = true;
        
        if (grabbed && rejection) {
            return {
                swept: true,
                confirmed: confirms && hasVolume,
                sweepCandle: c,
                confirmCandle: next,
                hasRejection: rejection,
                hasVolume: hasVolume,
                volumeRatio: avgVol > 0 ? (c.volume / avgVol).toFixed(1) : '0',
                sweepDepth: isSSL 
                    ? ((c.high - pool.price) / pool.price * 100).toFixed(2)
                    : ((pool.price - c.low) / pool.price * 100).toFixed(2)
            };
        }
    }
    
    return { swept: false, confirmed: false, hasVolume: false };
}

/**
 * BODY SWEEP DETECTION
 * Stronger sweep: body closes through pool then reverses
 */
function detectBodySweep(candles, pool, isSSL, avgVol) {
    for (let i = 0; i < candles.length - 2; i++) {
        const c1 = candles[i];
        const c2 = candles[i + 1];
        const c3 = candles[i + 2];
        
        let grabbed = false;
        let reversed = false;
        
        if (isSSL) {
            // Body closes above pool, then reverses back
            grabbed = c1.close > pool.price && c1.open < pool.price;
            reversed = c2.close < pool.price || c3.close < pool.price;
        } else {
            // Body closes below pool, then reverses back
            grabbed = c1.close < pool.price && c1.open > pool.price;
            reversed = c2.close > pool.price || c3.close > pool.price;
        }
        
        if (grabbed && reversed) {
            const hasVolume = c1.volume > avgVol * 1.5;
            return {
                swept: true,
                confirmed: hasVolume,
                sweepCandle: c1,
                confirmCandle: c2,
                hasRejection: true,
                hasVolume: hasVolume,
                volumeRatio: avgVol > 0 ? (c1.volume / avgVol).toFixed(1) : '0',
                sweepDepth: isSSL
                    ? ((c1.high - pool.price) / pool.price * 100).toFixed(2)
                    : ((pool.price - c1.low) / pool.price * 100).toFixed(2)
            };
        }
    }
    
    return { swept: false, confirmed: false, hasVolume: false };
}

/**
 * ENGULFING SWEEP DETECTION
 * Engulfing pattern at pool level
 */
function detectEngulfingSweep(candles, pool, isSSL, avgVol) {
    for (let i = 1; i < candles.length - 1; i++) {
        const prev = candles[i - 1];
        const curr = candles[i];
        const next = candles[i + 1];
        
        const prevBody = Math.abs(prev.close - prev.open);
        const currBody = Math.abs(curr.close - curr.open);
        
        // Check if at pool level
        const atPool = isSSL 
            ? (curr.high >= pool.price * 0.998)
            : (curr.low <= pool.price * 1.002);
        
        if (!atPool) continue;
        
        let isEngulfing = false;
        let isBullish = false;
        
        // Bullish engulfing (for BSL sweep)
        if (!isSSL && curr.close > curr.open && prev.close < prev.open) {
            if (curr.close > prev.open && curr.open < prev.close && currBody > prevBody) {
                isEngulfing = true;
                isBullish = true;
            }
        }
        
        // Bearish engulfing (for SSL sweep)
        if (isSSL && curr.close < curr.open && prev.close > prev.open) {
            if (curr.open > prev.close && curr.close < prev.open && currBody > prevBody) {
                isEngulfing = true;
                isBullish = false;
            }
        }
        
        if (isEngulfing) {
            const hasVolume = curr.volume > avgVol * 1.3;
            const confirms = isBullish ? (next.close > curr.close) : (next.close < curr.close);
            
            return {
                swept: true,
                confirmed: confirms && hasVolume,
                sweepCandle: curr,
                confirmCandle: next,
                hasRejection: true,
                hasVolume: hasVolume,
                volumeRatio: avgVol > 0 ? (curr.volume / avgVol).toFixed(1) : '0',
                engulfingStrength: (currBody / prevBody).toFixed(1)
            };
        }
    }
    
    return { swept: false, confirmed: false, hasVolume: false };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 3: MULTI-TIMEFRAME POOL ANALYSIS
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * MULTI-TIMEFRAME POOL ANALYSIS
 * Finds pools across multiple timeframes and identifies confluence
 */
async function analyzeMultiTfPools(symbol, entryTf) {
    const tfMap = {
        '5': ['15', '30', '60'],
        '15': ['30', '60', '240'],
        '30': ['60', '240'],
        '60': ['240', 'D'],
        '240': ['D']
    };
    
    const tfsToCheck = [entryTf, ...(tfMap[entryTf] || [])];
    const allPools = { bsl: [], ssl: [] };
    const poolsByTf = {};
    
    for (const tf of tfsToCheck) {
        try {
            const klines = await fetchKlines(symbol, tf, 150);
            if (!klines || klines.length < 50) continue;
            
            const bslPools = findLiquidityPools(klines, false);
            const sslPools = findLiquidityPools(klines, true);
            
            poolsByTf[tf] = { bsl: bslPools, ssl: sslPools };
            
            bslPools.forEach(p => { 
                p.tf = tf; 
                p.tfWeight = getTfWeight(tf);
                allPools.bsl.push(p); 
            });
            sslPools.forEach(p => { 
                p.tf = tf; 
                p.tfWeight = getTfWeight(tf);
                allPools.ssl.push(p); 
            });
        } catch (e) {
            console.warn(`Multi-TF pool analysis error for ${tf}:`, e.message);
        }
    }
    
    return {
        pools: allPools,
        byTf: poolsByTf,
        tfsAnalyzed: tfsToCheck
    };
}

/**
 * GET TIMEFRAME WEIGHT
 * Higher timeframes have more weight
 */
function getTfWeight(tf) {
    const weights = {
        '5': 1,
        '15': 2,
        '30': 3,
        '60': 5,
        '240': 8,
        'D': 12,
        'W': 20
    };
    return weights[tf] || 1;
}

/**
 * FIND STACKED POOLS (Multi-TF Confluence)
 * Pools at similar price across timeframes = VERY strong level
 */
function findStackedPools(allPools, direction, currentPrice) {
    const pools = direction === 'LONG' ? allPools.bsl : allPools.ssl;
    if (!pools || pools.length === 0) return { stacked: false, count: 0, pools: [], bestStack: null };
    
    // Filter pools in the right direction
    const relevantPools = pools.filter(p => {
        if (direction === 'LONG') return p.price < currentPrice;
        return p.price > currentPrice;
    });
    
    if (relevantPools.length === 0) return { stacked: false, count: 0, pools: [], bestStack: null };
    
    // Find clusters of pools at similar price levels
    const clusterRange = 0.015; // 1.5% range for stacking
    const stacks = [];
    const used = new Set();
    
    for (let i = 0; i < relevantPools.length; i++) {
        if (used.has(i)) continue;
        
        const stack = [relevantPools[i]];
        for (let j = i + 1; j < relevantPools.length; j++) {
            if (used.has(j)) continue;
            const diff = Math.abs(relevantPools[j].price - relevantPools[i].price) / relevantPools[i].price;
            if (diff <= clusterRange) {
                stack.push(relevantPools[j]);
                used.add(j);
            }
        }
        used.add(i);
        
        // Calculate stack strength
        const uniqueTfs = [...new Set(stack.map(p => p.tf))];
        const totalTfWeight = stack.reduce((s, p) => s + (p.tfWeight || 1), 0);
        const totalTouches = stack.reduce((s, p) => s + p.touches, 0);
        const avgPrice = stack.reduce((s, p) => s + p.price, 0) / stack.length;
        
        if (uniqueTfs.length > 1 || stack.length >= 3) { // Multi-TF OR many pools
            stacks.push({
                price: avgPrice,
                pools: stack,
                tfCount: uniqueTfs.length,
                tfs: uniqueTfs,
                totalTfWeight: totalTfWeight,
                totalTouches: totalTouches,
                stackStrength: uniqueTfs.length * 25 + totalTfWeight * 3 + totalTouches * 5,
                distance: Math.abs(avgPrice - currentPrice) / currentPrice
            });
        }
    }
    
    // Sort by stack strength
    stacks.sort((a, b) => b.stackStrength - a.stackStrength);
    
    // Find best stack (highest strength, reasonable distance)
    const bestStack = stacks.find(s => s.distance <= 0.03) || stacks[0] || null;
    
    return {
        stacked: stacks.length > 0,
        count: stacks.length,
        pools: stacks,
        bestStack: bestStack,
        totalStrength: stacks.reduce((s, st) => s + st.stackStrength, 0)
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 4: ADAPTIVE LIMIT ZONES
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * CALCULATE ADAPTIVE LIMIT ZONES
 * Returns 3 entry levels: Aggressive, Optimal, Safe
 */
function calculateAdaptiveLimitZones(pool, currentPrice, direction, atr) {
    if (!pool) return null;
    
    const poolPrice = pool.price;
    const poolRange = pool.highPrice - pool.lowPrice;
    
    let aggressive, optimal, safe;
    
    if (direction === 'LONG') {
        // For LONG: entries are BELOW current price, at/near pool
        // Aggressive = very close to pool (risky, might not fill)
        // Optimal = at pool level (good R:R)
        // Safe = above pool (better fill, less R:R)
        
        aggressive = poolPrice * 1.001; // Just above pool low
        optimal = poolPrice * 1.003;    // Slightly above pool
        safe = poolPrice * 1.008;       // Further above (safer fill)
        
        // Adjust based on pool strength
        if (pool.touches >= 4 || pool.algorithmCount >= 2) {
            // Strong pool - can be more aggressive
            aggressive = poolPrice * 0.999;
            optimal = poolPrice * 1.001;
            safe = poolPrice * 1.005;
        }
        
    } else {
        // For SHORT: entries are ABOVE current price, at/near pool
        aggressive = poolPrice * 0.999; // Just below pool high
        optimal = poolPrice * 0.997;
        safe = poolPrice * 0.992;
        
        if (pool.touches >= 4 || pool.algorithmCount >= 2) {
            aggressive = poolPrice * 1.001;
            optimal = poolPrice * 0.999;
            safe = poolPrice * 0.995;
        }
    }
    
    // Calculate distances
    const distToAggressive = Math.abs(currentPrice - aggressive) / currentPrice;
    const distToOptimal = Math.abs(currentPrice - optimal) / currentPrice;
    const distToSafe = Math.abs(currentPrice - safe) / currentPrice;
    
    return {
        aggressive: {
            price: aggressive,
            distance: distToAggressive,
            distancePct: (distToAggressive * 100).toFixed(2),
            riskLevel: 'HIGH',
            fillProbability: 'LOW',
            rrBonus: '+0.3 R:R'
        },
        optimal: {
            price: optimal,
            distance: distToOptimal,
            distancePct: (distToOptimal * 100).toFixed(2),
            riskLevel: 'MEDIUM',
            fillProbability: 'MEDIUM',
            rrBonus: '+0.15 R:R'
        },
        safe: {
            price: safe,
            distance: distToSafe,
            distancePct: (distToSafe * 100).toFixed(2),
            riskLevel: 'LOW',
            fillProbability: 'HIGH',
            rrBonus: 'Baseline'
        },
        poolPrice: poolPrice,
        poolStrength: pool.compositeScore || pool.strength,
        recommendation: distToOptimal <= 0.015 ? 'OPTIMAL' : (distToSafe <= 0.02 ? 'SAFE' : 'WAIT')
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 5: LIQUIDITY FLOW ANALYSIS
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * ANALYZE LIQUIDITY FLOW
 * Determines if liquidity is building or depleting at a level
 */
function analyzeLiquidityFlow(candles, pool, isSSL) {
    if (!candles || candles.length < 30) {
        return { flow: 'UNKNOWN', building: false, depleting: false };
    }
    
    const last20 = candles.slice(-20);
    const poolZone = { low: pool.lowPrice, high: pool.highPrice };
    
    // Count interactions with pool zone
    let approaches = 0;
    let rejections = 0;
    let breakAttempts = 0;
    let volumeAtPool = 0;
    
    for (const c of last20) {
        const touchesPool = isSSL 
            ? (c.high >= poolZone.low && c.high <= poolZone.high * 1.005)
            : (c.low <= poolZone.high && c.low >= poolZone.low * 0.995);
        
        if (touchesPool) {
            approaches++;
            volumeAtPool += c.volume;
            
            // Check for rejection
            const bodyTop = Math.max(c.open, c.close);
            const bodyBottom = Math.min(c.open, c.close);
            
            if (isSSL && bodyTop < pool.price) rejections++;
            if (!isSSL && bodyBottom > pool.price) rejections++;
            
            // Check for break attempt
            if (isSSL && c.close > pool.price) breakAttempts++;
            if (!isSSL && c.close < pool.price) breakAttempts++;
        }
    }
    
    // Determine flow
    let flow = 'NEUTRAL';
    let building = false;
    let depleting = false;
    
    if (approaches >= 3 && rejections >= 2) {
        flow = 'BUILDING';
        building = true;
    } else if (breakAttempts >= 2 && rejections < 2) {
        flow = 'DEPLETING';
        depleting = true;
    } else if (approaches >= 2) {
        flow = 'TESTING';
    }
    
    // Volume analysis
    const avgVolume = candles.slice(-30).reduce((s, c) => s + c.volume, 0) / 30;
    const volumeRatio = approaches > 0 ? (volumeAtPool / approaches) / avgVolume : 0;
    
    return {
        flow,
        building,
        depleting,
        approaches,
        rejections,
        breakAttempts,
        volumeAtPool,
        volumeRatio: volumeRatio.toFixed(1),
        conviction: building ? 'HIGH' : (depleting ? 'LOW' : 'MEDIUM')
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 6: RECLAIM DETECTION
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * DETECT POOL RECLAIM
 * Checks if price has reclaimed a pool level after sweep
 */
function detectPoolReclaim(candles, pool, sweep, isSSL) {
    if (!sweep || !sweep.swept) {
        return { reclaimed: false, reclaimStrength: 0 };
    }
    
    // Find candles after the sweep
    const sweepIdx = candles.findIndex(c => c === sweep.sweepCandle);
    if (sweepIdx === -1 || sweepIdx >= candles.length - 2) {
        return { reclaimed: false, reclaimStrength: 0 };
    }
    
    const afterSweep = candles.slice(sweepIdx + 1);
    let reclaimed = false;
    let reclaimStrength = 0;
    let reclaimCandle = null;
    
    for (let i = 0; i < afterSweep.length; i++) {
        const c = afterSweep[i];
        
        if (isSSL) {
            // SSL reclaim: after sweeping high, price holds below pool
            if (c.close < pool.price && c.high < pool.price * 1.002) {
                reclaimed = true;
                reclaimStrength += 10;
                if (!reclaimCandle) reclaimCandle = c;
            }
        } else {
            // BSL reclaim: after sweeping low, price holds above pool
            if (c.close > pool.price && c.low > pool.price * 0.998) {
                reclaimed = true;
                reclaimStrength += 10;
                if (!reclaimCandle) reclaimCandle = c;
            }
        }
    }
    
    // Cap strength at 100
    reclaimStrength = Math.min(100, reclaimStrength);
    
    return {
        reclaimed,
        reclaimStrength,
        reclaimCandle,
        candlesHolding: reclaimed ? afterSweep.length : 0
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 7: INSTITUTIONAL FOOTPRINT DETECTION
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * DETECT INSTITUTIONAL FOOTPRINT AT POOL
 * Looks for signs of institutional activity at liquidity pools
 */
function detectInstitutionalFootprint(candles, pool, isSSL) {
    if (!candles || candles.length < 30) {
        return { detected: false, confidence: 0, signs: [] };
    }
    
    const signs = [];
    let confidence = 0;
    
    const last30 = candles.slice(-30);
    const avgVolume = last30.reduce((s, c) => s + c.volume, 0) / 30;
    const avgRange = last30.reduce((s, c) => s + (c.high - c.low), 0) / 30;
    
    // 1. Volume spike at pool (institutional entry)
    for (let i = 0; i < last30.length; i++) {
        const c = last30[i];
        const atPool = isSSL 
            ? (c.high >= pool.price * 0.998)
            : (c.low <= pool.price * 1.002);
        
        if (atPool && c.volume > avgVolume * 2) {
            signs.push('Volume spike at pool (2x+)');
            confidence += 25;
            break;
        }
    }
    
    // 2. Large wick rejection (stop hunt)
    for (let i = 0; i < last30.length; i++) {
        const c = last30[i];
        const range = c.high - c.low;
        
        if (isSSL) {
            const topWick = c.high - Math.max(c.open, c.close);
            if (topWick > avgRange * 1.5 && c.high >= pool.price * 0.998) {
                signs.push('Large rejection wick (1.5x ATR)');
                confidence += 20;
                break;
            }
        } else {
            const bottomWick = Math.min(c.open, c.close) - c.low;
            if (bottomWick > avgRange * 1.5 && c.low <= pool.price * 1.002) {
                signs.push('Large rejection wick (1.5x ATR)');
                confidence += 20;
                break;
            }
        }
    }
    
    // 3. Absorption pattern (many small candles followed by move)
    let smallCandles = 0;
    for (let i = 0; i < Math.min(10, last30.length); i++) {
        const c = last30[last30.length - 1 - i];
        if ((c.high - c.low) < avgRange * 0.5) {
            smallCandles++;
        }
    }
    if (smallCandles >= 5) {
        signs.push('Absorption pattern (consolidation)');
        confidence += 15;
    }
    
    // 4. Delta divergence (price vs volume direction)
    const last5 = last30.slice(-5);
    let buyVolume = 0, sellVolume = 0;
    for (const c of last5) {
        if (c.close > c.open) buyVolume += c.volume;
        else sellVolume += c.volume;
    }
    
    const priceTrend = last5[last5.length - 1].close > last5[0].close ? 'UP' : 'DOWN';
    const volumeTrend = buyVolume > sellVolume ? 'BUY' : 'SELL';
    
    if ((priceTrend === 'DOWN' && volumeTrend === 'BUY') || 
        (priceTrend === 'UP' && volumeTrend === 'SELL')) {
        signs.push('Delta divergence (accumulation/distribution)');
        confidence += 20;
    }
    
    // 5. Multiple touches without break (strong defense)
    if (pool.touches >= 4) {
        signs.push(`Strong defense (${pool.touches} touches)`);
        confidence += 15;
    }
    
    return {
        detected: confidence >= 40,
        confidence: Math.min(100, confidence),
        signs,
        verdict: confidence >= 60 ? 'STRONG' : (confidence >= 40 ? 'MODERATE' : 'WEAK')
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 8: REGIME DETECTION (Enhanced)
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * ADVANCED MARKET REGIME DETECTION
 * Determines: TREND / RANGE / CHOP / EXPANSION / COMPRESSION
 */
function detectMarketRegime(candles) {
    if (!candles || candles.length < 50) {
        return { regime: 'UNKNOWN', score: 0, favorable: false, subType: null };
    }
    
    const cfg = CONFIG.REGIME;
    const len = 20;
    const recent = candles.slice(-len);
    
    // Calculate ADX components
    let plusDM = 0, minusDM = 0, trSum = 0;
    for (let i = 1; i < recent.length; i++) {
        const curr = recent[i];
        const prev = recent[i - 1];
        
        const highDiff = curr.high - prev.high;
        const lowDiff = prev.low - curr.low;
        
        if (highDiff > lowDiff && highDiff > 0) plusDM += highDiff;
        if (lowDiff > highDiff && lowDiff > 0) minusDM += lowDiff;
        
        const tr = Math.max(
            curr.high - curr.low, 
            Math.abs(curr.high - prev.close), 
            Math.abs(curr.low - prev.close)
        );
        trSum += tr;
    }
    
    const plusDI = trSum > 0 ? (plusDM / trSum) * 100 : 0;
    const minusDI = trSum > 0 ? (minusDM / trSum) * 100 : 0;
    const dx = (plusDI + minusDI) > 0 ? Math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100 : 0;
    
    // Price efficiency (trending vs choppy)
    const priceChange = Math.abs(recent[len - 1].close - recent[0].close);
    let totalMovement = 0;
    for (let i = 1; i < recent.length; i++) {
        totalMovement += Math.abs(recent[i].close - recent[i - 1].close);
    }
    const efficiency = totalMovement > 0 ? priceChange / totalMovement : 0;
    
    // Volatility analysis
    const ranges = recent.map(c => c.high - c.low);
    const avgRange = ranges.reduce((a, b) => a + b, 0) / ranges.length;
    const rangeStdDev = Math.sqrt(ranges.reduce((sum, r) => sum + Math.pow(r - avgRange, 2), 0) / ranges.length);
    const volatilityConsistency = avgRange > 0 ? 1 - (rangeStdDev / avgRange) : 0;
    
    // ATR expansion/compression
    const atrRecent = ranges.slice(-5).reduce((a, b) => a + b, 0) / 5;
    const atrOlder = ranges.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
    const atrRatio = atrOlder > 0 ? atrRecent / atrOlder : 1;
    
    // Determine regime
    let regime = 'RANGE';
    let subType = null;
    let score = 50;
    
    if (dx > cfg.dxThreshold && efficiency > cfg.efficiencyThreshold) {
        regime = 'TREND';
        score = Math.min(100, 50 + dx + (efficiency * 50));
        subType = plusDI > minusDI ? 'UPTREND' : 'DOWNTREND';
    } else if (volatilityConsistency < cfg.chopVolatility || (dx > 15 && dx < 25 && efficiency < 0.3)) {
        regime = 'CHOP';
        score = Math.min(100, 50 + (1 - volatilityConsistency) * 50);
        subType = 'ERRATIC';
    } else {
        regime = 'RANGE';
        score = Math.min(100, 50 + volatilityConsistency * 50);
        
        // Check for expansion/compression
        if (atrRatio > 1.3) {
            subType = 'EXPANSION';
        } else if (atrRatio < 0.7) {
            subType = 'COMPRESSION';
        } else {
            subType = 'BALANCED';
        }
    }
    
    return {
        regime,
        subType,
        score: Math.round(score),
        dx: dx.toFixed(1),
        efficiency: (efficiency * 100).toFixed(0),
        volatilityConsistency: (volatilityConsistency * 100).toFixed(0),
        atrRatio: atrRatio.toFixed(2),
        plusDI: plusDI.toFixed(1),
        minusDI: minusDI.toFixed(1),
        favorable: regime !== 'CHOP',
        tradingAdvice: regime === 'TREND' ? 'Trade with trend' : 
                       regime === 'RANGE' ? 'Trade reversals at extremes' : 
                       'Avoid or reduce size'
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 9: VOLUME ANALYSIS AT POOL
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * CHECK VOLUME AT POOL
 * Comprehensive volume analysis at liquidity pool
 */
function checkVolumeAtPool(candles, poolPrice, isSSL = false) {
    // Null safety checks
    if (!candles || candles.length < 30 || !poolPrice || poolPrice <= 0) {
        return { hasVolume: false, volumeRatio: '0', analysis: null };
    }
    
    const avgVol = candles.slice(-30, -10).reduce((s, c) => s + c.volume, 0) / 20;
    const last10 = candles.slice(-10);
    
    let volumeAtPool = 0;
    let candlesAtPool = 0;
    let buyVolumeAtPool = 0;
    let sellVolumeAtPool = 0;
    
    for (const c of last10) {
        const touchedPool = isSSL 
            ? (c.high >= poolPrice * 0.995)
            : (c.low <= poolPrice * 1.005);
        
        if (touchedPool) {
            volumeAtPool += c.volume;
            candlesAtPool++;
            
            if (c.close > c.open) buyVolumeAtPool += c.volume;
            else sellVolumeAtPool += c.volume;
        }
    }
    
    const avgVolumeAtPool = candlesAtPool > 0 ? volumeAtPool / candlesAtPool : 0;
    const volumeRatio = avgVol > 0 ? avgVolumeAtPool / avgVol : 0;
    
    // Delta analysis
    const delta = buyVolumeAtPool - sellVolumeAtPool;
    const deltaRatio = volumeAtPool > 0 ? delta / volumeAtPool : 0;
    
    // Determine volume verdict
    let verdict = 'NEUTRAL';
    if (volumeRatio > 2) verdict = 'STRONG';
    else if (volumeRatio > 1.5) verdict = 'ELEVATED';
    else if (volumeRatio < 0.7) verdict = 'WEAK';
    
    return {
        hasVolume: volumeRatio > 1.3,
        volumeRatio: volumeRatio.toFixed(1),
        avgVolumeAtPool,
        candlesAtPool,
        buyVolume: buyVolumeAtPool,
        sellVolume: sellVolumeAtPool,
        delta,
        deltaRatio: (deltaRatio * 100).toFixed(0),
        verdict,
        analysis: {
            isAccumulation: !isSSL && deltaRatio > 0.3,
            isDistribution: isSSL && deltaRatio < -0.3,
            isNeutral: Math.abs(deltaRatio) <= 0.3
        }
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 10: SIGNAL MODE DETERMINATION
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * DETERMINE SIGNAL MODE
 * Based on liquidity status, returns CONFIRMED / LIMIT / CAUTION / WATCH
 */
function determineSignalMode(hasPool, hasSweep, sweepConfirmed, hasVolume, score) {
    const modes = CONFIG.SIGNAL_MODES;
    
    // CONFIRMED: Everything aligned - sweep + volume + high score
    if (sweepConfirmed && hasVolume && score >= modes.CONFIRMED.minScore) {
        return 'CONFIRMED';
    }
    
    // LIMIT: Good setup for limit order - pool exists, decent score
    if (hasPool && score >= modes.LIMIT.minScore) {
        if (hasSweep || hasVolume) {
            return 'LIMIT';
        }
    }
    
    // CAUTION: Setup exists but missing confirmations
    if (hasPool && score >= modes.CAUTION.minScore) {
        if (!hasVolume || !hasSweep) {
            return 'CAUTION';
        }
    }
    
    // WATCH: Pool exists, waiting for trigger
    if (hasPool) {
        return 'WATCH';
    }
    
    return null;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 11: MASTER LIQUIDITY ANALYSIS (ORCHESTRATOR)
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * MASTER LIQUIDITY ANALYSIS
 * The main orchestration function - runs all liquidity analysis
 */
async function performLiquidityAnalysis(klines, symbol, tf, currentPrice, direction) {
    const cfg = CONFIG.LIQUIDITY;
    
    // Skip if liquidity engine disabled
    if (!cfg.enabled) {
        return { enabled: false, hasPool: false };
    }
    
    const result = {
        enabled: true,
        hasPool: false,
        hasSweep: false,
        sweepConfirmed: false,
        hasVolume: false,
        pools: { bsl: [], ssl: [] },
        nearestPool: null,
        sweep: null,
        regime: null,
        mode: null,
        score: 0,
        blocked: false,
        blockReason: null,
        // Advanced data
        multiTf: null,
        stackedPools: null,
        limitZones: null,
        liquidityFlow: null,
        reclaim: null,
        institutionalFootprint: null,
        volumeAnalysis: null
    };
    
    // 1. DETECT MARKET REGIME
    result.regime = detectMarketRegime(klines);
    
    // Block in CHOP if configured
    if (CONFIG.REGIME.enabled && CONFIG.REGIME.blockChop && result.regime.regime === 'CHOP') {
        result.blocked = true;
        result.blockReason = 'REGIME_CHOP';
        return result;
    }
    
    // 2. FIND LIQUIDITY POOLS (Advanced multi-algorithm)
    const bslPools = findLiquidityPools(klines, false);
    const sslPools = findLiquidityPools(klines, true);
    
    result.pools = { bsl: bslPools, ssl: sslPools };
    
    // 3. FIND NEAREST RELEVANT POOL
    const relevantPools = direction === 'LONG' ? bslPools : sslPools;
    const isSSL = direction === 'SHORT';
    
    let nearestPool = null;
    let nearestDist = Infinity;
    
    for (const pool of relevantPools) {
        const dist = Math.abs(pool.price - currentPrice) / currentPrice;
        
        const validPosition = direction === 'LONG' 
            ? pool.price < currentPrice 
            : pool.price > currentPrice;
            
        if (validPosition && dist < nearestDist && dist <= cfg.limits.maxDistance) {
            nearestDist = dist;
            nearestPool = pool;
        }
    }
    
    // MASTER GATE: No pool = no signal
    if (!nearestPool) {
        if (cfg.masterGate.requirePool) {
            result.blocked = true;
            result.blockReason = 'NO_LIQUIDITY_POOL';
            return result;
        }
    }
    
    result.hasPool = !!nearestPool;
    result.nearestPool = nearestPool;
    result.poolDistance = nearestPool ? nearestDist : null;
    result.atLevel = nearestPool && nearestDist <= cfg.limits.atLevelDist;
    
    // 4. DETECT SWEEP (Advanced multi-type)
    if (nearestPool) {
        const sweep = detectLiquiditySweep(klines, nearestPool, isSSL);
        result.sweep = sweep;
        result.hasSweep = sweep.swept;
        result.sweepConfirmed = sweep.confirmed;
        result.hasVolume = sweep.hasVolume;
        
        // 5. VOLUME ANALYSIS AT POOL
        result.volumeAnalysis = checkVolumeAtPool(klines, nearestPool.price, isSSL);
        if (!result.hasVolume && result.volumeAnalysis.hasVolume) {
            result.hasVolume = true;
        }
        
        // 6. LIQUIDITY FLOW ANALYSIS
        result.liquidityFlow = analyzeLiquidityFlow(klines, nearestPool, isSSL);
        
        // 7. RECLAIM DETECTION
        if (sweep.swept) {
            result.reclaim = detectPoolReclaim(klines, nearestPool, sweep, isSSL);
        }
        
        // 8. INSTITUTIONAL FOOTPRINT
        result.institutionalFootprint = detectInstitutionalFootprint(klines, nearestPool, isSSL);
        
        // 9. ADAPTIVE LIMIT ZONES
        const atr = klines.slice(-14).reduce((s, c) => s + (c.high - c.low), 0) / 14;
        result.limitZones = calculateAdaptiveLimitZones(nearestPool, currentPrice, direction, atr);
    }
    
    // 10. MULTI-TF POOL ANALYSIS
    try {
        result.multiTf = await analyzeMultiTfPools(symbol, tf);
        result.stackedPools = findStackedPools(result.multiTf.pools, direction, currentPrice);
    } catch (e) {
        console.warn('Multi-TF analysis error:', e.message);
    }
    
    // 11. CALCULATE COMPOSITE LIQUIDITY SCORE
    result.score = calculateLiquidityCompositeScore(result);
    
    // 12. DETERMINE SIGNAL MODE
    result.mode = determineSignalMode(
        result.hasPool,
        result.hasSweep,
        result.sweepConfirmed,
        result.hasVolume,
        result.score
    );
    
    return result;
}

/**
 * CALCULATE LIQUIDITY COMPOSITE SCORE
 * Comprehensive scoring of liquidity setup quality
 */
function calculateLiquidityCompositeScore(result) {
    let score = 0;
    
    // Base: Pool exists (20)
    if (result.hasPool) score += 20;
    
    // Pool quality (max 20)
    if (result.nearestPool) {
        score += Math.min(20, result.nearestPool.compositeScore * 0.2 || result.nearestPool.strength * 0.3);
    }
    
    // Sweep detected (15)
    if (result.hasSweep) score += 15;
    
    // Sweep confirmed (10)
    if (result.sweepConfirmed) score += 10;
    
    // Volume confirmed (10)
    if (result.hasVolume) score += 10;
    
    // Multi-TF stacking (max 15)
    if (result.stackedPools && result.stackedPools.stacked) {
        score += Math.min(15, result.stackedPools.bestStack.tfCount * 5);
    }
    
    // Liquidity flow (max 10)
    if (result.liquidityFlow) {
        if (result.liquidityFlow.building) score += 10;
        else if (result.liquidityFlow.flow === 'TESTING') score += 5;
    }
    
    // Institutional footprint (max 10)
    if (result.institutionalFootprint && result.institutionalFootprint.detected) {
        score += Math.min(10, result.institutionalFootprint.confidence * 0.1);
    }
    
    // Reclaim bonus (5)
    if (result.reclaim && result.reclaim.reclaimed) score += 5;
    
    // Regime penalty
    if (result.regime && result.regime.regime === 'CHOP') score -= 20;
    
    // Cap at 100
    return Math.max(0, Math.min(100, Math.round(score)));
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SECTION 12: V19 SCORING (Liquidity-First)
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * V19 SCORE CALCULATOR
 * Liquidity-first scoring with capped bonuses and subtractive penalties
 */
function calculateV19Score(liquidityResult, smcResult, zoneResult, momentumResult, htfResult) {
    const cfg = CONFIG.SCORING_V19;
    
    // BASE SCORE: From liquidity analysis
    let baseScore = liquidityResult.score || 0;
    
    // Scale base score (liquidity gives 0-100, we want 30-60 range)
    baseScore = 30 + (baseScore * 0.3);
    
    // SUPPORT ENGINE BONUSES (will be capped)
    let bonuses = 0;
    let bonusDetails = [];
    
    // SMC Confirms (+20)
    if (smcResult && smcResult.score >= 40 && smcResult.direction) {
        bonuses += cfg.bonuses.smcConfirms;
        bonusDetails.push(`SMC +${cfg.bonuses.smcConfirms}`);
    }
    
    // Zone Confirms (+15)
    if (zoneResult && zoneResult.score >= 50) {
        bonuses += cfg.bonuses.zoneConfirms;
        bonusDetails.push(`Zone +${cfg.bonuses.zoneConfirms}`);
    }
    
    // Momentum Aligned (+10)
    if (momentumResult && momentumResult.direction && !momentumResult.opposing) {
        bonuses += cfg.bonuses.momentumAligned;
        bonusDetails.push(`Mom +${cfg.bonuses.momentumAligned}`);
    }
    
    // HTF Aligned (+10)
    if (htfResult && htfResult.aligned) {
        bonuses += cfg.bonuses.htfAligned;
        bonusDetails.push(`HTF +${cfg.bonuses.htfAligned}`);
    }
    
    // Multi-TF Stack (+5 per TF, max 15)
    if (liquidityResult.stackedPools && liquidityResult.stackedPools.stacked) {
        const stackBonus = Math.min(15, liquidityResult.stackedPools.bestStack.tfCount * cfg.bonuses.multiTfStack);
        bonuses += stackBonus;
        bonusDetails.push(`Stack +${stackBonus}`);
    }
    
    // Institutional Footprint (+10)
    if (liquidityResult.institutionalFootprint && liquidityResult.institutionalFootprint.detected) {
        bonuses += 10;
        bonusDetails.push('Inst +10');
    }
    
    // CAP BONUSES at max
    const cappedBonuses = Math.min(bonuses, cfg.maxTotalBonus);
    
    // PENALTIES (subtractive)
    let penalties = 0;
    let penaltyDetails = [];
    
    // HTF Opposes (-15)
    if (htfResult && htfResult.opposing) {
        penalties += Math.abs(cfg.penalties.htfOpposes);
        penaltyDetails.push(`HTF ${cfg.penalties.htfOpposes}`);
    }
    
    // HTF Weak (-10)
    if (htfResult && htfResult.pct >= 40 && htfResult.pct < 60) {
        penalties += Math.abs(cfg.penalties.htfWeak);
        penaltyDetails.push(`HTF weak ${cfg.penalties.htfWeak}`);
    }
    
    // Momentum Opposes (-15)
    if (momentumResult && momentumResult.opposing && momentumResult.score >= 40) {
        penalties += Math.abs(cfg.penalties.momentumOpposes);
        penaltyDetails.push(`Mom ${cfg.penalties.momentumOpposes}`);
    }
    
    // No Volume (-10)
    if (!liquidityResult.hasVolume) {
        penalties += Math.abs(cfg.penalties.noVolume);
        penaltyDetails.push(`NoVol ${cfg.penalties.noVolume}`);
    }
    
    // Low touches (-5)
    if (liquidityResult.nearestPool && liquidityResult.nearestPool.touches < 3) {
        penalties += Math.abs(cfg.penalties.lowTouches);
        penaltyDetails.push(`LowTouch ${cfg.penalties.lowTouches}`);
    }
    
    // CHOP regime (-20)
    if (liquidityResult.regime && liquidityResult.regime.regime === 'CHOP') {
        penalties += 20;
        penaltyDetails.push('CHOP -20');
    }
    
    // FINAL SCORE
    const finalScore = Math.max(0, Math.min(100, Math.round(baseScore + cappedBonuses - penalties)));
    
    return {
        baseScore: Math.round(baseScore),
        bonuses: cappedBonuses,
        bonusesRaw: bonuses,
        bonusesCapped: bonuses > cfg.maxTotalBonus,
        penalties,
        finalScore,
        breakdown: {
            base: Math.round(baseScore),
            bonusDetails,
            penaltyDetails,
            liquidityScore: liquidityResult.score
        }
    };
}

console.log('👑 V19 ULTRA - ADVANCED LIQUIDITY HUNTING ENGINE (THE KING) LOADED');
console.log('📊 ~600 lines of institutional-grade liquidity analysis');
console.log('🔍 11 Sections: Pools, Sweeps, Multi-TF, Limits, Flow, Reclaim, Institutional, Regime, Volume, Modes, Scoring');


// ═══════════════════════════════════════════════════════════════════════════════
// ZONE ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════════

// Find swing highs and lows with configurable left/right bars
function findSwingPoints(klines, leftBars = 5, rightBars = 5) {
    const swingHighs = [];
    const swingLows = [];
    
    if (!klines || klines.length < leftBars + rightBars + 1) return { highs: [], lows: [] };
    
    for (let i = leftBars; i < klines.length - rightBars; i++) {
        let isHigh = true;
        let isLow = true;
        
        const currentHigh = klines[i].high;
        const currentLow = klines[i].low;
        
        // Check left bars
        for (let j = i - leftBars; j < i; j++) {
            if (klines[j].high >= currentHigh) isHigh = false;
            if (klines[j].low <= currentLow) isLow = false;
        }
        
        // Check right bars
        for (let j = i + 1; j <= i + rightBars; j++) {
            if (klines[j].high >= currentHigh) isHigh = false;
            if (klines[j].low <= currentLow) isLow = false;
        }
        
        if (isHigh) {
            swingHighs.push({
                index: i,
                price: currentHigh,
                time: klines[i].time,
                volume: klines[i].volume
            });
        }
        
        if (isLow) {
            swingLows.push({
                index: i,
                price: currentLow,
                time: klines[i].time,
                volume: klines[i].volume
            });
        }
    }
    
    return { highs: swingHighs, lows: swingLows };
}

// Cluster nearby price levels into zones
function clusterZones(points, threshold = 0.005) {
    if (!points || points.length === 0) return [];
    
    const sorted = [...points].sort((a, b) => a.price - b.price);
    const clusters = [];
    let currentCluster = [sorted[0]];
    
    for (let i = 1; i < sorted.length; i++) {
        const clusterAvg = currentCluster.reduce((sum, p) => sum + p.price, 0) / currentCluster.length;
        const pctDiff = Math.abs(sorted[i].price - clusterAvg) / clusterAvg;
        
        if (pctDiff <= threshold) {
            currentCluster.push(sorted[i]);
        } else {
            clusters.push(currentCluster);
            currentCluster = [sorted[i]];
        }
    }
    clusters.push(currentCluster);
    
    // Convert clusters to zones
    return clusters.map(cluster => {
        const prices = cluster.map(p => p.price);
        const high = Math.max(...prices);
        const low = Math.min(...prices);
        const totalVolume = cluster.reduce((sum, p) => sum + (p.volume || 0), 0);
        const times = cluster.map(p => p.time);
        
        return {
            high: high,
            low: low,
            price: (high + low) / 2,
            touches: cluster.length,
            volume: totalVolume,
            firstTouch: Math.min(...times),
            lastTouch: Math.max(...times),
            indices: cluster.map(p => p.index)
        };
    });
}

// Calculate zone strength with decay over time
function calcZoneStrength(zone, currentIndex, totalBars, avgVolume) {
    // SAFETY: Validate inputs
    if (!zone) return 0;
    
    let strength = 0;
    const touches = zone.touches || 0;
    const volume = zone.volume || 0;
    const indices = zone.indices || [];
    
    // Touch count bonus (max 30 points)
    if (touches >= 5) strength += 30;
    else if (touches >= 4) strength += 25;
    else if (touches >= 3) strength += 20;
    else if (touches >= 2) strength += 12;
    else strength += 5;
    
    // Volume bonus (max 20 points) - FIXED: Safe division
    if (avgVolume > 0 && touches > 0) {
        const volRatio = volume / (avgVolume * touches);
        if (!isNaN(volRatio) && isFinite(volRatio)) {
            if (volRatio >= 2.0) strength += 20;
            else if (volRatio >= 1.5) strength += 15;
            else if (volRatio >= 1.2) strength += 10;
            else if (volRatio >= 1.0) strength += 5;
        }
    }
    
    // Freshness bonus (max 20 points) - newer zones are stronger
    // SAFETY: Check indices array is not empty
    if (indices.length > 0) {
        const lastTouchIndex = Math.max(...indices);
        const barsSinceTouch = currentIndex - lastTouchIndex;
        if (barsSinceTouch <= 10) strength += 20;
        else if (barsSinceTouch <= 25) strength += 15;
        else if (barsSinceTouch <= 50) strength += 10;
        else if (barsSinceTouch <= 100) strength += 5;
        
        // Age decay - reduce strength for very old zones
        const firstTouchIndex = Math.min(...indices);
        const zoneAge = currentIndex - firstTouchIndex;
        if (zoneAge > 150) strength -= 10;
        else if (zoneAge > 100) strength -= 5;
    }
    
    return Math.max(0, Math.min(100, strength));
}

// Check if price is at a round number
function checkRoundNumber(price) {
    let bonus = 0;
    const priceStr = price.toString();
    
    // Check for major round numbers
    if (price >= 1000) {
        if (price % 10000 === 0) bonus = 8;      // 10000, 20000, etc.
        else if (price % 5000 === 0) bonus = 6;  // 5000, 15000, etc.
        else if (price % 1000 === 0) bonus = 4;  // 1000, 2000, etc.
        else if (price % 500 === 0) bonus = 3;
        else if (price % 100 === 0) bonus = 2;
    } else if (price >= 1) {
        if (price % 100 === 0) bonus = 5;
        else if (price % 50 === 0) bonus = 4;
        else if (price % 10 === 0) bonus = 3;
        else if (price % 5 === 0) bonus = 2;
        else if (price % 1 === 0) bonus = 1;
    } else {
        // For small prices like 0.00001234
        const decimals = priceStr.split('.')[1] || '';
        const zeros = (decimals.match(/0+$/) || [''])[0].length;
        if (zeros >= 4) bonus = 4;
        else if (zeros >= 3) bonus = 3;
        else if (zeros >= 2) bonus = 2;
    }
    
    return bonus;
}

// Calculate Fibonacci levels from swing high to swing low
function calcFibLevels(swingHigh, swingLow) {
    const range = swingHigh - swingLow;
    return {
        level_0: swingLow,
        level_236: swingLow + range * 0.236,
        level_382: swingLow + range * 0.382,
        level_5: swingLow + range * 0.5,
        level_618: swingLow + range * 0.618,
        level_786: swingLow + range * 0.786,
        level_1: swingHigh
    };
}

// Check if zone aligns with Fibonacci level
function checkFibAlignment(zonePrice, fibLevels, tolerance = 0.005) {
    const fibs = [0.236, 0.382, 0.5, 0.618, 0.786];
    const fibPrices = [fibLevels.level_236, fibLevels.level_382, fibLevels.level_5, fibLevels.level_618, fibLevels.level_786];
    
    for (let i = 0; i < fibPrices.length; i++) {
        const pctDiff = Math.abs(zonePrice - fibPrices[i]) / fibPrices[i];
        if (pctDiff <= tolerance) {
            return { aligned: true, level: fibs[i], bonus: fibs[i] === 0.618 ? 8 : fibs[i] === 0.5 ? 6 : 4 };
        }
    }
    return { aligned: false, level: null, bonus: 0 };
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🎯 ADVANCED GP (GOLDEN POCKET) & OTE (OPTIMAL TRADE ENTRY) SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

/*
 * SMC FIBONACCI ZONES - INSTITUTIONAL GRADE:
 * 
 * GP (Golden Pocket): 0.618 - 0.65 (tightest reversal zone - highest probability)
 * OTE (Optimal Trade Entry): 0.62 - 0.79 (wider high-probability zone)
 * 
 * ADVANCED FEATURES:
 * - Multi-swing detection (finds best impulse)
 * - Volume confirmation at zones
 * - OB/FVG confluence detection
 * - Liquidity sweep confirmation
 * - Time-based decay
 * - HTF alignment bonus
 * 
 * COLOR LOGIC:
 * - BULLISH impulse + price retracing DOWN into GP/OTE = GREEN (LONG setup)
 * - BEARISH impulse + price retracing UP into GP/OTE = RED (SHORT setup)
 */

// GP/OTE Configuration
const GP_OTE_CONFIG = {
    // Zone definitions
    GP: { start: 0.618, end: 0.65, name: 'Golden Pocket', icon: '🎯', weight: 1.3 },
    OTE: { start: 0.62, end: 0.79, name: 'Optimal Trade Entry', icon: '📍', weight: 1.0 },
    
    // Extended zones for context
    DEEP: { start: 0.79, end: 0.886, name: 'Deep Retracement', icon: '⚠️', weight: 0.7 },
    SHALLOW: { start: 0.382, end: 0.5, name: 'Shallow Pullback', icon: '📉', weight: 0.5 },
    
    // Minimum impulse size (as % of price)
    minImpulsePercent: 1.0,
    
    // Distance thresholds
    distances: {
        IN_ZONE: 0.15,      // Within 0.15% = IN ZONE
        TOUCHING: 0.3,      // Within 0.3% = TOUCHING
        NEAR: 0.8,          // Within 0.8% = NEAR
        APPROACHING: 1.5,   // Within 1.5% = APPROACHING
        FAR: 999            // Beyond = FAR
    },
    
    // Score bonuses
    scores: {
        IN_GP: 25,
        IN_OTE: 18,
        TOUCHING_GP: 15,
        TOUCHING_OTE: 10,
        NEAR_GP: 8,
        NEAR_OTE: 5,
        VOLUME_CONFIRM: 8,
        OB_CONFLUENCE: 12,
        FVG_CONFLUENCE: 10,
        LIQUIDITY_SWEEP: 15,
        HTF_ALIGNMENT: 10,
        FRESH_ZONE: 5,
        STALE_PENALTY: -5
    }
};

// Find significant swing points for GP/OTE
function findGPOTESwings(klines, leftBars = 5, rightBars = 5) {
    if (!klines || klines.length < leftBars + rightBars + 10) return { highs: [], lows: [] };
    
    const len = klines.length;
    const highs = [];
    const lows = [];
    
    for (let i = leftBars; i < len - rightBars; i++) {
        let isHigh = true;
        let isLow = true;
        
        for (let j = i - leftBars; j <= i + rightBars; j++) {
            if (j === i) continue;
            if (klines[j].high >= klines[i].high) isHigh = false;
            if (klines[j].low <= klines[i].low) isLow = false;
        }
        
        if (isHigh) {
            highs.push({
                index: i,
                price: klines[i].high,
                time: klines[i].time,
                volume: klines[i].volume,
                candle: klines[i]
            });
        }
        if (isLow) {
            lows.push({
                index: i,
                price: klines[i].low,
                time: klines[i].time,
                volume: klines[i].volume,
                candle: klines[i]
            });
        }
    }
    
    return { highs, lows };
}

// Find the best impulse move for GP/OTE calculation
function findBestImpulse(klines, swings) {
    if (!swings || !klines || klines.length < 30) return null;
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    const avgVolume = klines.slice(-50).reduce((s, k) => s + k.volume, 0) / 50;
    
    // Get recent swings (prioritize last 40 bars for freshness)
    const recentHighs = swings.highs.filter(s => s.index > len - 50).sort((a, b) => b.price - a.price);
    const recentLows = swings.lows.filter(s => s.index > len - 50).sort((a, b) => a.price - b.price);
    
    if (recentHighs.length === 0 || recentLows.length === 0) return null;
    
    // Find potential impulse pairs
    const impulses = [];
    
    for (const high of recentHighs.slice(0, 3)) {
        for (const low of recentLows.slice(0, 3)) {
            const range = high.price - low.price;
            const rangePercent = (range / low.price) * 100;
            
            // Skip if impulse too small
            if (rangePercent < GP_OTE_CONFIG.minImpulsePercent) continue;
            
            // Determine direction
            let direction, isValid;
            if (high.index > low.index) {
                // Low → High = BULLISH impulse (look for LONG on pullback)
                direction = 'BULLISH';
                // Valid if price has pulled back from high
                isValid = currentPrice < high.price && currentPrice > low.price;
            } else {
                // High → Low = BEARISH impulse (look for SHORT on pullback)
                direction = 'BEARISH';
                // Valid if price has pulled back from low
                isValid = currentPrice > low.price && currentPrice < high.price;
            }
            
            if (!isValid) continue;
            
            // Calculate retracement level
            const retracement = direction === 'BULLISH'
                ? (high.price - currentPrice) / range
                : (currentPrice - low.price) / range;
            
            // Score this impulse
            let score = 50;
            score += rangePercent * 5;  // Bigger impulse = better
            score += (len - Math.max(high.index, low.index)) < 20 ? 20 : 0;  // Fresh = better
            score += (high.volume + low.volume) > avgVolume * 2 ? 10 : 0;  // Volume confirmation
            
            impulses.push({
                high,
                low,
                direction,
                range,
                rangePercent,
                retracement,
                score,
                freshness: len - Math.max(high.index, low.index)
            });
        }
    }
    
    if (impulses.length === 0) return null;
    
    // Return best impulse
    return impulses.sort((a, b) => b.score - a.score)[0];
}

// Calculate GP and OTE zones from impulse
function calculateGPOTEZones(impulse) {
    if (!impulse) return null;
    
    const { high, low, direction, range } = impulse;
    
    let zones;
    
    if (direction === 'BULLISH') {
        // BULLISH: Fib from LOW to HIGH, retracement DOWN
        // GP/OTE are measured from HIGH going down
        zones = {
            direction: 'LONG',
            impulseDirection: 'BULLISH',
            swingHigh: high.price,
            swingLow: low.price,
            range: range,
            
            // Golden Pocket (0.618 - 0.65 retracement from high)
            GP: {
                high: high.price - (range * GP_OTE_CONFIG.GP.start),
                low: high.price - (range * GP_OTE_CONFIG.GP.end),
                mid: high.price - (range * ((GP_OTE_CONFIG.GP.start + GP_OTE_CONFIG.GP.end) / 2)),
                name: GP_OTE_CONFIG.GP.name,
                icon: GP_OTE_CONFIG.GP.icon,
                weight: GP_OTE_CONFIG.GP.weight,
                fibLevels: { start: GP_OTE_CONFIG.GP.start, end: GP_OTE_CONFIG.GP.end }
            },
            
            // OTE Zone (0.62 - 0.79 retracement from high)
            OTE: {
                high: high.price - (range * GP_OTE_CONFIG.OTE.start),
                low: high.price - (range * GP_OTE_CONFIG.OTE.end),
                mid: high.price - (range * ((GP_OTE_CONFIG.OTE.start + GP_OTE_CONFIG.OTE.end) / 2)),
                name: GP_OTE_CONFIG.OTE.name,
                icon: GP_OTE_CONFIG.OTE.icon,
                weight: GP_OTE_CONFIG.OTE.weight,
                fibLevels: { start: GP_OTE_CONFIG.OTE.start, end: GP_OTE_CONFIG.OTE.end }
            },
            
            // Deep zone (warning)
            DEEP: {
                high: high.price - (range * GP_OTE_CONFIG.DEEP.start),
                low: high.price - (range * GP_OTE_CONFIG.DEEP.end),
                mid: high.price - (range * ((GP_OTE_CONFIG.DEEP.start + GP_OTE_CONFIG.DEEP.end) / 2)),
                name: GP_OTE_CONFIG.DEEP.name,
                icon: GP_OTE_CONFIG.DEEP.icon
            },
            
            // Key fib levels
            fib_0: low.price,
            fib_236: high.price - (range * 0.236),
            fib_382: high.price - (range * 0.382),
            fib_5: high.price - (range * 0.5),
            fib_618: high.price - (range * 0.618),
            fib_65: high.price - (range * 0.65),
            fib_705: high.price - (range * 0.705),
            fib_79: high.price - (range * 0.79),
            fib_886: high.price - (range * 0.886),
            fib_1: high.price
        };
    } else {
        // BEARISH: Fib from HIGH to LOW, retracement UP
        // GP/OTE are measured from LOW going up
        zones = {
            direction: 'SHORT',
            impulseDirection: 'BEARISH',
            swingHigh: high.price,
            swingLow: low.price,
            range: range,
            
            // Golden Pocket (0.618 - 0.65 retracement from low)
            GP: {
                low: low.price + (range * GP_OTE_CONFIG.GP.start),
                high: low.price + (range * GP_OTE_CONFIG.GP.end),
                mid: low.price + (range * ((GP_OTE_CONFIG.GP.start + GP_OTE_CONFIG.GP.end) / 2)),
                name: GP_OTE_CONFIG.GP.name,
                icon: GP_OTE_CONFIG.GP.icon,
                weight: GP_OTE_CONFIG.GP.weight,
                fibLevels: { start: GP_OTE_CONFIG.GP.start, end: GP_OTE_CONFIG.GP.end }
            },
            
            // OTE Zone (0.62 - 0.79 retracement from low)
            OTE: {
                low: low.price + (range * GP_OTE_CONFIG.OTE.start),
                high: low.price + (range * GP_OTE_CONFIG.OTE.end),
                mid: low.price + (range * ((GP_OTE_CONFIG.OTE.start + GP_OTE_CONFIG.OTE.end) / 2)),
                name: GP_OTE_CONFIG.OTE.name,
                icon: GP_OTE_CONFIG.OTE.icon,
                weight: GP_OTE_CONFIG.OTE.weight,
                fibLevels: { start: GP_OTE_CONFIG.OTE.start, end: GP_OTE_CONFIG.OTE.end }
            },
            
            // Deep zone (warning)
            DEEP: {
                low: low.price + (range * GP_OTE_CONFIG.DEEP.start),
                high: low.price + (range * GP_OTE_CONFIG.DEEP.end),
                mid: low.price + (range * ((GP_OTE_CONFIG.DEEP.start + GP_OTE_CONFIG.DEEP.end) / 2)),
                name: GP_OTE_CONFIG.DEEP.name,
                icon: GP_OTE_CONFIG.DEEP.icon
            },
            
            // Key fib levels
            fib_0: high.price,
            fib_236: low.price + (range * 0.236),
            fib_382: low.price + (range * 0.382),
            fib_5: low.price + (range * 0.5),
            fib_618: low.price + (range * 0.618),
            fib_65: low.price + (range * 0.65),
            fib_705: low.price + (range * 0.705),
            fib_79: low.price + (range * 0.79),
            fib_886: low.price + (range * 0.886),
            fib_1: low.price
        };
    }
    
    return zones;
}

// Get price position relative to GP/OTE zones
function getPricePositionInZones(currentPrice, zones) {
    if (!zones) return null;
    
    const { GP, OTE, DEEP, direction } = zones;
    const cfg = GP_OTE_CONFIG.distances;
    
    // Helper to check if price is in zone
    const inZone = (price, zone) => price >= zone.low && price <= zone.high;
    
    // Helper to get distance to zone
    const distanceToZone = (price, zone) => {
        if (price >= zone.low && price <= zone.high) return 0;
        if (price < zone.low) return ((zone.low - price) / price) * 100;
        return ((price - zone.high) / price) * 100;
    };
    
    // Calculate positions
    const gpDistance = distanceToZone(currentPrice, GP);
    const oteDistance = distanceToZone(currentPrice, OTE);
    const deepDistance = distanceToZone(currentPrice, DEEP);
    
    const inGP = inZone(currentPrice, GP);
    const inOTE = inZone(currentPrice, OTE);
    const inDEEP = inZone(currentPrice, DEEP);
    
    // Determine status for each zone
    const getStatus = (distance, inZoneFlag) => {
        if (inZoneFlag) return 'IN_ZONE';
        if (distance <= cfg.TOUCHING) return 'TOUCHING';
        if (distance <= cfg.NEAR) return 'NEAR';
        if (distance <= cfg.APPROACHING) return 'APPROACHING';
        return 'FAR';
    };
    
    // Progress percentage (0-100, where 100 = in zone)
    const getProgress = (distance) => {
        if (distance === 0) return 100;
        if (distance >= 2) return 0;
        return Math.round((1 - distance / 2) * 100);
    };
    
    return {
        direction,
        currentPrice,
        
        GP: {
            ...GP,
            inZone: inGP,
            distance: gpDistance,
            status: getStatus(gpDistance, inGP),
            progress: getProgress(gpDistance),
            color: direction === 'LONG' ? 'var(--long)' : 'var(--short)',
            bgColor: direction === 'LONG' ? 'var(--long-dim)' : 'var(--short-dim)'
        },
        
        OTE: {
            ...OTE,
            inZone: inOTE,
            distance: oteDistance,
            status: getStatus(oteDistance, inOTE),
            progress: getProgress(oteDistance),
            color: direction === 'LONG' ? 'var(--long)' : 'var(--short)',
            bgColor: direction === 'LONG' ? 'var(--long-dim)' : 'var(--short-dim)'
        },
        
        DEEP: {
            ...DEEP,
            inZone: inDEEP,
            distance: deepDistance,
            status: getStatus(deepDistance, inDEEP),
            isWarning: inDEEP
        },
        
        // Summary
        bestZone: inGP ? 'GP' : inOTE ? 'OTE' : inDEEP ? 'DEEP' : 'NONE',
        isInOptimalZone: inGP || inOTE,
        overallStatus: inGP ? 'PERFECT_ENTRY' : inOTE ? 'GOOD_ENTRY' : inDEEP ? 'RISKY_ENTRY' : 
                       gpDistance < 0.5 ? 'APPROACHING_GP' : oteDistance < 0.5 ? 'APPROACHING_OTE' : 'WAITING'
    };
}

// Check for confluence with OB/FVG
function checkGPOTEConfluence(zones, orderBlocks, fvgs, currentPrice) {
    if (!zones) return { hasConfluence: false, factors: [] };
    
    const factors = [];
    let confluenceScore = 0;
    const { GP, OTE, direction } = zones;
    
    // Check OB confluence
    if (orderBlocks && orderBlocks.length > 0) {
        for (const ob of orderBlocks) {
            const obMid = (ob.high + ob.low) / 2;
            
            // Check if OB overlaps with GP
            if (obMid >= GP.low && obMid <= GP.high) {
                factors.push({ type: 'OB_AT_GP', text: 'Order Block at GP', score: GP_OTE_CONFIG.scores.OB_CONFLUENCE });
                confluenceScore += GP_OTE_CONFIG.scores.OB_CONFLUENCE;
            }
            // Check if OB overlaps with OTE
            else if (obMid >= OTE.low && obMid <= OTE.high) {
                factors.push({ type: 'OB_AT_OTE', text: 'Order Block at OTE', score: GP_OTE_CONFIG.scores.OB_CONFLUENCE * 0.8 });
                confluenceScore += GP_OTE_CONFIG.scores.OB_CONFLUENCE * 0.8;
            }
        }
    }
    
    // Check FVG confluence
    if (fvgs && fvgs.length > 0) {
        for (const fvg of fvgs) {
            const fvgMid = (fvg.high + fvg.low) / 2;
            
            // Check if FVG overlaps with GP
            if (fvgMid >= GP.low && fvgMid <= GP.high) {
                factors.push({ type: 'FVG_AT_GP', text: 'FVG at GP', score: GP_OTE_CONFIG.scores.FVG_CONFLUENCE });
                confluenceScore += GP_OTE_CONFIG.scores.FVG_CONFLUENCE;
            }
            // Check if FVG overlaps with OTE
            else if (fvgMid >= OTE.low && fvgMid <= OTE.high) {
                factors.push({ type: 'FVG_AT_OTE', text: 'FVG at OTE', score: GP_OTE_CONFIG.scores.FVG_CONFLUENCE * 0.8 });
                confluenceScore += GP_OTE_CONFIG.scores.FVG_CONFLUENCE * 0.8;
            }
        }
    }
    
    return {
        hasConfluence: factors.length > 0,
        factors,
        confluenceScore,
        confluenceCount: factors.length
    };
}

// Check for liquidity sweep at GP/OTE
function checkLiquiditySweepAtZone(klines, zones, lookback = 10) {
    if (!klines || !zones || klines.length < lookback) return { swept: false };
    
    const recent = klines.slice(-lookback);
    const { GP, OTE, direction } = zones;
    
    for (const candle of recent) {
        const wickLow = candle.low;
        const wickHigh = candle.high;
        const bodyLow = Math.min(candle.open, candle.close);
        const bodyHigh = Math.max(candle.open, candle.close);
        
        if (direction === 'LONG') {
            // For LONG: Look for wick below GP/OTE that closed back inside
            if (wickLow < GP.low && bodyLow > GP.low) {
                return {
                    swept: true,
                    zone: 'GP',
                    type: 'BULLISH_SWEEP',
                    description: 'Liquidity swept below GP',
                    score: GP_OTE_CONFIG.scores.LIQUIDITY_SWEEP
                };
            }
            if (wickLow < OTE.low && bodyLow > OTE.low) {
                return {
                    swept: true,
                    zone: 'OTE',
                    type: 'BULLISH_SWEEP',
                    description: 'Liquidity swept below OTE',
                    score: GP_OTE_CONFIG.scores.LIQUIDITY_SWEEP * 0.8
                };
            }
        } else {
            // For SHORT: Look for wick above GP/OTE that closed back inside
            if (wickHigh > GP.high && bodyHigh < GP.high) {
                return {
                    swept: true,
                    zone: 'GP',
                    type: 'BEARISH_SWEEP',
                    description: 'Liquidity swept above GP',
                    score: GP_OTE_CONFIG.scores.LIQUIDITY_SWEEP
                };
            }
            if (wickHigh > OTE.high && bodyHigh < OTE.high) {
                return {
                    swept: true,
                    zone: 'OTE',
                    type: 'BEARISH_SWEEP',
                    description: 'Liquidity swept above OTE',
                    score: GP_OTE_CONFIG.scores.LIQUIDITY_SWEEP * 0.8
                };
            }
        }
    }
    
    return { swept: false };
}

// MASTER FUNCTION: Complete GP/OTE Analysis
function analyzeGPOTE(klines, orderBlocks = [], fvgs = []) {
    try {
        if (!klines || klines.length < 50) {
            return {
                valid: false,
                reason: 'Insufficient data',
                zones: null,
                position: null,
                score: 0
            };
        }
        
        const len = klines.length;
        const currentPrice = klines[len - 1].close;
        
        // Step 1: Find swing points
        const swings = findGPOTESwings(klines, 5, 5);
        
        // Step 2: Find best impulse
        const impulse = findBestImpulse(klines, swings);
        
        if (!impulse) {
            return {
                valid: false,
                reason: 'No valid impulse found',
                zones: null,
                position: null,
                score: 0
            };
        }
        
        // Step 3: Calculate GP/OTE zones
        const zones = calculateGPOTEZones(impulse);
        
        if (!zones) {
            return {
                valid: false,
                reason: 'Could not calculate zones',
                zones: null,
                position: null,
                score: 0
            };
        }
        
        // Step 4: Get price position
        const position = getPricePositionInZones(currentPrice, zones);
        
        // Safety check for position
        if (!position || !position.GP || !position.OTE) {
            return {
                valid: false,
                reason: 'Could not calculate position',
                zones: zones,
                position: null,
                score: 0
            };
        }
        
        // Step 5: Check confluence
        const confluence = checkGPOTEConfluence(zones, orderBlocks, fvgs, currentPrice);
        
        // Step 6: Check liquidity sweep
        const sweep = checkLiquiditySweepAtZone(klines, zones);
        
        // Step 7: Calculate total score
        let score = 0;
        const factors = [];
        
        // Position score - with null checks
        if (position.GP && position.GP.inZone) {
            score += GP_OTE_CONFIG.scores.IN_GP;
            factors.push({ text: '🎯 IN Golden Pocket', score: GP_OTE_CONFIG.scores.IN_GP });
        } else if (position.OTE && position.OTE.inZone) {
            score += GP_OTE_CONFIG.scores.IN_OTE;
            factors.push({ text: '📍 IN OTE Zone', score: GP_OTE_CONFIG.scores.IN_OTE });
        } else if (position.GP && position.GP.status === 'TOUCHING') {
            score += GP_OTE_CONFIG.scores.TOUCHING_GP;
            factors.push({ text: '🎯 Touching GP', score: GP_OTE_CONFIG.scores.TOUCHING_GP });
        } else if (position.OTE && position.OTE.status === 'TOUCHING') {
            score += GP_OTE_CONFIG.scores.TOUCHING_OTE;
            factors.push({ text: '📍 Touching OTE', score: GP_OTE_CONFIG.scores.TOUCHING_OTE });
        } else if (position.GP && position.GP.status === 'NEAR') {
            score += GP_OTE_CONFIG.scores.NEAR_GP;
            factors.push({ text: '🎯 Near GP', score: GP_OTE_CONFIG.scores.NEAR_GP });
        } else if (position.OTE && position.OTE.status === 'NEAR') {
            score += GP_OTE_CONFIG.scores.NEAR_OTE;
            factors.push({ text: '📍 Near OTE', score: GP_OTE_CONFIG.scores.NEAR_OTE });
        }
        
        // Confluence score
        if (confluence && confluence.hasConfluence) {
            score += confluence.confluenceScore || 0;
            if (confluence.factors) {
                confluence.factors.forEach(f => factors.push({ text: f.text, score: f.score }));
            }
        }
        
        // Sweep score
        if (sweep && sweep.swept) {
            score += sweep.score || 0;
            factors.push({ text: '💧 ' + (sweep.description || 'Sweep'), score: sweep.score || 0 });
        }
        
        // Freshness bonus/penalty
        if (impulse.freshness < 15) {
            score += GP_OTE_CONFIG.scores.FRESH_ZONE;
            factors.push({ text: '✨ Fresh zone', score: GP_OTE_CONFIG.scores.FRESH_ZONE });
        } else if (impulse.freshness > 40) {
            score += GP_OTE_CONFIG.scores.STALE_PENALTY;
            factors.push({ text: '⏳ Stale zone', score: GP_OTE_CONFIG.scores.STALE_PENALTY });
        }
        
        // Deep zone warning
        if (position.DEEP && position.DEEP.inZone) {
            factors.push({ text: '⚠️ Deep retracement - risky', score: 0, warning: true });
        }
        
        return {
            valid: true,
            direction: zones.direction,
            impulse: {
                type: impulse.direction,
                range: impulse.range,
                rangePercent: impulse.rangePercent,
                freshness: impulse.freshness,
                swingHigh: zones.swingHigh,
                swingLow: zones.swingLow
            },
            zones: zones,
            position: position,
            confluence: confluence,
            sweep: sweep,
            score: Math.min(100, Math.max(0, score)),
            factors: factors,
            
            // Quick access - with null safety
            isInGP: position.GP ? position.GP.inZone : false,
            isInOTE: position.OTE ? position.OTE.inZone : false,
            isOptimalEntry: (position.GP && position.GP.inZone) || (position.OTE && position.OTE.inZone),
            
            // Colors for UI
            color: zones.direction === 'LONG' ? 'var(--long)' : 'var(--short)',
            bgColor: zones.direction === 'LONG' ? 'var(--long-dim)' : 'var(--short-dim)',
            
            // Display data - with null safety
            display: {
                GP: {
                    range: position.GP ? `${fmtPrice(position.GP.low)} - ${fmtPrice(position.GP.high)}` : 'N/A',
                    status: position.GP ? position.GP.status : 'FAR',
                    progress: position.GP ? position.GP.progress : 0,
                    distance: position.GP ? position.GP.distance.toFixed(2) + '%' : 'N/A',
                    icon: GP_OTE_CONFIG.GP.icon,
                    name: GP_OTE_CONFIG.GP.name
                },
                OTE: {
                    range: position.OTE ? `${fmtPrice(position.OTE.low)} - ${fmtPrice(position.OTE.high)}` : 'N/A',
                    status: position.OTE ? position.OTE.status : 'FAR',
                    progress: position.OTE ? position.OTE.progress : 0,
                    distance: position.OTE ? position.OTE.distance.toFixed(2) + '%' : 'N/A',
                    icon: GP_OTE_CONFIG.OTE.icon,
                    name: GP_OTE_CONFIG.OTE.name
                }
            }
        };
    } catch (gpoteError) {
        console.error('GP/OTE Analysis Error:', gpoteError);
        return {
            valid: false,
            reason: 'Analysis error: ' + gpoteError.message,
            zones: null,
            position: null,
            score: 0
        };
    }
}

// Generate GP/OTE HTML display
function generateGPOTEDisplay(gpoteData, compact = false) {
    if (!gpoteData || !gpoteData.valid) {
        return '<div style="color:var(--text3);font-size:11px;padding:8px">No GP/OTE zones detected</div>';
    }
    
    const { direction, position, display, score, factors, isInGP, isInOTE, color, bgColor } = gpoteData;
    const dirIcon = direction === 'LONG' ? '🟢' : '🔴';
    const dirText = direction === 'LONG' ? 'LONG SETUP' : 'SHORT SETUP';
    
    // Status icons
    const getStatusIcon = (status) => {
        switch(status) {
            case 'IN_ZONE': return '✓';
            case 'TOUCHING': return '◉';
            case 'NEAR': return '○';
            case 'APPROACHING': return '◌';
            default: return '·';
        }
    };
    
    // Progress bar
    const progressBar = (progress, color) => {
        const filled = Math.round(progress / 10);
        const empty = 10 - filled;
        return `<span style="font-family:monospace;font-size:10px;color:${color}">${'█'.repeat(filled)}${'░'.repeat(empty)}</span>`;
    };
    
    if (compact) {
        // Compact single-row display
        return `
            <div style="display:flex;align-items:center;gap:8px;padding:6px 10px;background:${bgColor};border:1px solid ${color};border-radius:6px;font-size:11px">
                <span style="font-weight:700;color:${color}">${dirIcon} ${dirText}</span>
                <span style="color:var(--text2)">|</span>
                <span>${display.GP.icon} GP ${getStatusIcon(display.GP.status)}</span>
                <span>${display.OTE.icon} OTE ${getStatusIcon(display.OTE.status)}</span>
                <span style="margin-left:auto;font-weight:700;color:${color}">${score}</span>
            </div>
        `;
    }
    
    // Full detailed display
    return `
        <div style="background:var(--bg3);border:1px solid ${color};border-radius:8px;overflow:hidden">
            <!-- Header -->
            <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:${bgColor};border-bottom:1px solid ${color}">
                <div style="display:flex;align-items:center;gap:8px">
                    <span style="font-size:13px;font-weight:700;color:${color}">${dirIcon} FIB ZONES</span>
                    <span style="font-size:10px;padding:2px 6px;background:${color};color:var(--bg1);border-radius:3px;font-weight:700">${dirText}</span>
                </div>
                <div style="font-size:14px;font-weight:700;color:${color}">${score}/100</div>
            </div>
            
            <!-- GP Row -->
            <div style="display:flex;align-items:center;padding:10px 12px;border-bottom:1px solid var(--border);gap:10px">
                <div style="font-size:16px">${display.GP.icon}</div>
                <div style="flex:1">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
                        <span style="font-size:11px;font-weight:700;color:${color}">GOLDEN POCKET</span>
                        <span style="font-size:10px;padding:2px 6px;background:${isInGP ? color : 'var(--bg4)'};color:${isInGP ? 'var(--bg1)' : 'var(--text2)'};border-radius:3px;font-weight:700">
                            ${display.GP.status.replace('_', ' ')}
                        </span>
                    </div>
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
                        <span style="font-size:12px;color:var(--text)">${display.GP.range}</span>
                        <span style="font-size:10px;color:var(--text3)">${display.GP.distance} away</span>
                    </div>
                    <div style="display:flex;align-items:center;gap:6px">
                        ${progressBar(display.GP.progress, color)}
                        <span style="font-size:10px;color:var(--text3)">${display.GP.progress}%</span>
                    </div>
                </div>
            </div>
            
            <!-- OTE Row -->
            <div style="display:flex;align-items:center;padding:10px 12px;border-bottom:1px solid var(--border);gap:10px">
                <div style="font-size:16px">${display.OTE.icon}</div>
                <div style="flex:1">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
                        <span style="font-size:11px;font-weight:700;color:${color}">OPTIMAL TRADE ENTRY</span>
                        <span style="font-size:10px;padding:2px 6px;background:${isInOTE ? color : 'var(--bg4)'};color:${isInOTE ? 'var(--bg1)' : 'var(--text2)'};border-radius:3px;font-weight:700">
                            ${display.OTE.status.replace('_', ' ')}
                        </span>
                    </div>
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
                        <span style="font-size:12px;color:var(--text)">${display.OTE.range}</span>
                        <span style="font-size:10px;color:var(--text3)">${display.OTE.distance} away</span>
                    </div>
                    <div style="display:flex;align-items:center;gap:6px">
                        ${progressBar(display.OTE.progress, color)}
                        <span style="font-size:10px;color:var(--text3)">${display.OTE.progress}%</span>
                    </div>
                </div>
            </div>
            
            <!-- Factors -->
            ${factors.length > 0 ? `
                <div style="padding:8px 12px;background:var(--bg4)">
                    <div style="display:flex;flex-wrap:wrap;gap:4px">
                        ${factors.map(f => `
                            <span style="font-size:9px;padding:2px 6px;background:${f.warning ? 'var(--amber-dim)' : 'var(--bg3)'};color:${f.warning ? 'var(--amber)' : 'var(--text2)'};border-radius:3px">
                                ${f.text} ${f.score > 0 ? '+' + f.score : f.score < 0 ? f.score : ''}
                            </span>
                        `).join('')}
                    </div>
                </div>
            ` : ''}
        </div>
    `;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF ADVANCED GP/OTE SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Detect fakeout (wick through zone but close back inside)
function detectFakeout(klines, zone, lookback = 5) {
    if (!klines || klines.length < lookback) return { detected: false };
    
    const recent = klines.slice(-lookback);
    
    for (const candle of recent) {
        // Bullish fakeout: wick below support but close above
        if (candle.low < zone.low && candle.close > zone.low && candle.close > candle.open) {
            return { detected: true, type: 'bullish', strength: 'strong' };
        }
        // Bearish fakeout: wick above resistance but close below
        if (candle.high > zone.high && candle.close < zone.high && candle.close < candle.open) {
            return { detected: true, type: 'bearish', strength: 'strong' };
        }
    }
    
    return { detected: false };
}

// Get distance status from current price to zone
function getZoneDistance(currentPrice, zone) {
    const zoneMid = zone.price;
    const pctDistance = Math.abs(currentPrice - zoneMid) / currentPrice * 100;
    
    let status, score;
    if (pctDistance <= 0.3) {
        status = 'AT';
        score = 40;
    } else if (pctDistance <= 0.8) {
        status = 'CLOSE';
        score = 30;
    } else if (pctDistance <= 1.5) {
        status = 'NEAR';
        score = 20;
    } else if (pctDistance <= 3.0) {
        status = 'APPROACHING';
        score = 10;
    } else {
        status = 'FAR';
        score = 0;
    }
    
    return { status, score, pctDistance };
}

// Multi-timeframe zone confluence analysis
async function analyzeZoneConfluence(symbol, currentPrice, entryTF) {
    const confluenceTFs = CONFIG.ZONE_TFS;
    const allZones = { support: [], resistance: [] };
    
    for (const tf of confluenceTFs) {
        try {
            const klines = await fetchKlines(symbol, tf, 200);
            if (!klines || klines.length < 50) continue;
            
            const swings = findSwingPoints(klines, 5, 5);
            const supportZones = clusterZones(swings.lows, 0.005);
            const resistanceZones = clusterZones(swings.highs, 0.005);
            
            // Tag zones with their timeframe
            supportZones.forEach(z => {
                z.tf = tf;
                z.type = 'support';
                if (z.price < currentPrice) allZones.support.push(z);
            });
            
            resistanceZones.forEach(z => {
                z.tf = tf;
                z.type = 'resistance';
                if (z.price > currentPrice) allZones.resistance.push(z);
            });
            
            await sleep(50);
        } catch (e) {
            console.error(`Zone confluence error for ${tf}:`, e);
        }
    }
    
    // Find confluent zones (zones that appear in multiple TFs)
    const findConfluent = (zones) => {
        const confluent = [];
        const used = new Set();
        
        for (let i = 0; i < zones.length; i++) {
            if (used.has(i)) continue;
            
            const zone = zones[i];
            const matching = [zone];
            
            for (let j = i + 1; j < zones.length; j++) {
                if (used.has(j)) continue;
                
                const other = zones[j];
                const pctDiff = Math.abs(zone.price - other.price) / zone.price;
                
                if (pctDiff <= 0.015) { // 1.5% tolerance for confluence
                    matching.push(other);
                    used.add(j);
                }
            }
            
            if (matching.length >= 1) {
                const tfs = [...new Set(matching.map(m => m.tf))];
                const avgPrice = matching.reduce((sum, m) => sum + m.price, 0) / matching.length;
                const totalTouches = matching.reduce((sum, m) => sum + m.touches, 0);
                
                confluent.push({
                    price: avgPrice,
                    high: Math.max(...matching.map(m => m.high)),
                    low: Math.min(...matching.map(m => m.low)),
                    tfs: tfs,
                    tfCount: tfs.length,
                    totalTouches: totalTouches,
                    type: zone.type
                });
            }
            used.add(i);
        }
        
        return confluent.sort((a, b) => b.tfCount - a.tfCount);
    };
    
    return {
        support: findConfluent(allZones.support),
        resistance: findConfluent(allZones.resistance)
    };
}

// MAIN ZONE ANALYSIS FUNCTION
async function performZoneAnalysis(klines, symbol, tf, currentPrice) {
    const result = {
        score: 0,
        direction: null,
        status: 'FAR',
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const len = klines.length;
    // FIXED: Safe volume calculation
    const volSlice = klines.slice(-50).filter(k => k?.volume > 0);
    const avgVolume = volSlice.length > 0 ? volSlice.reduce((sum, k) => sum + k.volume, 0) / volSlice.length : 1;
    
    // Find swing points
    const swings = findSwingPoints(klines, 5, 5);
    
    // Cluster into zones
    const supportZones = clusterZones(swings.lows, 0.005).filter(z => z.price < currentPrice);
    const resistanceZones = clusterZones(swings.highs, 0.005).filter(z => z.price > currentPrice);
    
    // Calculate strength for each zone
    supportZones.forEach(z => {
        z.strength = calcZoneStrength(z, len - 1, len, avgVolume);
    });
    resistanceZones.forEach(z => {
        z.strength = calcZoneStrength(z, len - 1, len, avgVolume);
    });
    
    // Sort by strength
    supportZones.sort((a, b) => b.strength - a.strength);
    resistanceZones.sort((a, b) => b.strength - a.strength);
    
    // Get nearest zones
    const nearestSupport = supportZones.length > 0 ? supportZones[0] : null;
    const nearestResistance = resistanceZones.length > 0 ? resistanceZones[0] : null;
    
    result.details.nearestSupport = nearestSupport;
    result.details.nearestResistance = nearestResistance;
    result.details.supportCount = supportZones.length;
    result.details.resistanceCount = resistanceZones.length;
    
    // Calculate Fib levels
    const recentHigh = Math.max(...klines.slice(-100).map(k => k.high));
    const recentLow = Math.min(...klines.slice(-100).map(k => k.low));
    const fibLevels = calcFibLevels(recentHigh, recentLow);
    result.details.fibLevels = fibLevels;
    
    let score = 0;
    
    // Check support zone
    if (nearestSupport) {
        const dist = getZoneDistance(currentPrice, nearestSupport);
        
        if (dist.status !== 'FAR') {
            result.direction = 'LONG';
            result.status = dist.status;
            score += dist.score;
            result.factors.push(`${dist.status} Support`);
            
            // Touch count bonus
            if (nearestSupport.touches >= 4) {
                score += 15;
                result.factors.push(`${nearestSupport.touches} touches`);
            } else if (nearestSupport.touches >= 3) {
                score += 10;
                result.factors.push(`${nearestSupport.touches} touches`);
            } else if (nearestSupport.touches >= 2) {
                score += 5;
            }
            
            // Strength bonus
            if (nearestSupport.strength >= 60) {
                score += 10;
                result.factors.push('Strong zone');
            } else if (nearestSupport.strength >= 40) {
                score += 5;
            }
            
            // Round number bonus
            const roundBonus = checkRoundNumber(nearestSupport.price);
            if (roundBonus >= 4) {
                score += roundBonus;
                result.factors.push('Round number');
            }
            
            // Fib alignment bonus
            const fibCheck = checkFibAlignment(nearestSupport.price, fibLevels);
            if (fibCheck.aligned) {
                score += fibCheck.bonus;
                result.factors.push(`Fib ${fibCheck.level}`);
            }
            
            // Fakeout bonus
            const fakeout = detectFakeout(klines, nearestSupport);
            if (fakeout.detected && fakeout.type === 'bullish') {
                score += 12;
                result.factors.push('Fakeout sweep ✓');
            }
        }
    }
    
    // Check resistance zone
    if (nearestResistance) {
        const dist = getZoneDistance(currentPrice, nearestResistance);
        
        if (dist.status !== 'FAR' && !result.direction) {
            result.direction = 'SHORT';
            result.status = dist.status;
            score += dist.score;
            result.factors.push(`${dist.status} Resistance`);
            
            // Touch count bonus
            if (nearestResistance.touches >= 4) {
                score += 15;
                result.factors.push(`${nearestResistance.touches} touches`);
            } else if (nearestResistance.touches >= 3) {
                score += 10;
                result.factors.push(`${nearestResistance.touches} touches`);
            } else if (nearestResistance.touches >= 2) {
                score += 5;
            }
            
            // Strength bonus
            if (nearestResistance.strength >= 60) {
                score += 10;
                result.factors.push('Strong zone');
            } else if (nearestResistance.strength >= 40) {
                score += 5;
            }
            
            // Round number bonus
            const roundBonus = checkRoundNumber(nearestResistance.price);
            if (roundBonus >= 4) {
                score += roundBonus;
                result.factors.push('Round number');
            }
            
            // Fib alignment bonus
            const fibCheck = checkFibAlignment(nearestResistance.price, fibLevels);
            if (fibCheck.aligned) {
                score += fibCheck.bonus;
                result.factors.push(`Fib ${fibCheck.level}`);
            }
            
            // Fakeout bonus
            const fakeout = detectFakeout(klines, nearestResistance);
            if (fakeout.detected && fakeout.type === 'bearish') {
                score += 12;
                result.factors.push('Fakeout sweep ✓');
            }
        }
    }
    
    // If price is between zones (no clear direction)
    if (!result.direction && nearestSupport && nearestResistance) {
        const supDist = (currentPrice - nearestSupport.price) / currentPrice;
        const resDist = (nearestResistance.price - currentPrice) / currentPrice;
        
        if (supDist < resDist) {
            result.direction = 'LONG';
            result.factors.push('Closer to support');
            score += 5;
        } else {
            result.direction = 'SHORT';
            result.factors.push('Closer to resistance');
            score += 5;
        }
        result.status = 'BETWEEN';
        result.warnings.push('Mid-range - wait for zone');
    }
    
    result.score = Math.min(100, Math.max(0, score));
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF PART 1 - Zone Analysis Complete
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// SMC ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════════

// Detect market structure (HH, HL, LH, LL)
function detectStructure(klines, lookback = 50) {
    if (!klines || klines.length < lookback) return { trend: 'NEUTRAL', swings: [], counts: {} };
    
    const swings = findSwingPoints(klines, 3, 3);
    const allSwings = [];
    
    // Combine and sort swings by index
    swings.highs.forEach(h => allSwings.push({ ...h, type: 'high' }));
    swings.lows.forEach(l => allSwings.push({ ...l, type: 'low' }));
    allSwings.sort((a, b) => a.index - b.index);
    
    // Label structure points
    let lastHigh = null;
    let lastLow = null;
    const structure = [];
    const counts = { HH: 0, HL: 0, LH: 0, LL: 0 };
    
    for (const swing of allSwings) {
        if (swing.type === 'high') {
            if (lastHigh !== null) {
                if (swing.price > lastHigh.price) {
                    structure.push({ ...swing, label: 'HH' });
                    counts.HH++;
                } else {
                    structure.push({ ...swing, label: 'LH' });
                    counts.LH++;
                }
            } else {
                structure.push({ ...swing, label: 'H' });
            }
            lastHigh = swing;
        } else {
            if (lastLow !== null) {
                if (swing.price > lastLow.price) {
                    structure.push({ ...swing, label: 'HL' });
                    counts.HL++;
                } else {
                    structure.push({ ...swing, label: 'LL' });
                    counts.LL++;
                }
            } else {
                structure.push({ ...swing, label: 'L' });
            }
            lastLow = swing;
        }
    }
    
    // Determine trend from recent structure
    const recentStructure = structure.slice(-6);
    let bullishPoints = 0;
    let bearishPoints = 0;
    
    recentStructure.forEach(s => {
        if (s.label === 'HH' || s.label === 'HL') bullishPoints++;
        if (s.label === 'LH' || s.label === 'LL') bearishPoints++;
    });
    
    let trend = 'NEUTRAL';
    if (bullishPoints >= 3 && bullishPoints > bearishPoints) trend = 'BULLISH';
    else if (bearishPoints >= 3 && bearishPoints > bullishPoints) trend = 'BEARISH';
    
    return { trend, swings: structure, counts, lastHigh, lastLow };
}

// Detect Break of Structure (BOS) - BODY CLOSE confirmation
function detectBOS(klines, structure) {
    if (!klines || klines.length < 10 || !structure.swings || structure.swings.length < 2) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const prevCandle = klines[len - 2];
    
    // Get recent swing highs and lows
    const recentHighs = structure.swings.filter(s => s.type === 'high').slice(-3);
    const recentLows = structure.swings.filter(s => s.type === 'low').slice(-3);
    
    // Bullish BOS: Current candle BODY CLOSES above recent swing high
    for (const high of recentHighs) {
        if (prevCandle.close <= high.price && currentCandle.close > high.price) {
            // Confirm it's a body close, not just wick
            if (currentCandle.close > currentCandle.open) { // Green candle
                const bodyTop = currentCandle.close;
                if (bodyTop > high.price) {
                    return {
                        detected: true,
                        direction: 'BULLISH',
                        type: 'BOS',
                        level: high.price,
                        strength: currentCandle.close - high.price > (currentCandle.high - currentCandle.low) * 0.3 ? 'STRONG' : 'NORMAL'
                    };
                }
            }
        }
    }
    
    // Bearish BOS: Current candle BODY CLOSES below recent swing low
    for (const low of recentLows) {
        if (prevCandle.close >= low.price && currentCandle.close < low.price) {
            // Confirm it's a body close, not just wick
            if (currentCandle.close < currentCandle.open) { // Red candle
                const bodyBottom = currentCandle.close;
                if (bodyBottom < low.price) {
                    return {
                        detected: true,
                        direction: 'BEARISH',
                        type: 'BOS',
                        level: low.price,
                        strength: low.price - currentCandle.close > (currentCandle.high - currentCandle.low) * 0.3 ? 'STRONG' : 'NORMAL'
                    };
                }
            }
        }
    }
    
    return { detected: false };
}

// Detect Change of Character (CHoCH)
function detectCHoCH(klines, structure) {
    if (!klines || klines.length < 10 || !structure.swings || structure.swings.length < 4) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const trend = structure.trend;
    
    const recentHighs = structure.swings.filter(s => s.type === 'high').slice(-3);
    const recentLows = structure.swings.filter(s => s.type === 'low').slice(-3);
    
    // Bullish CHoCH: In a downtrend, price breaks above a lower high
    if (trend === 'BEARISH' && recentHighs.length >= 2) {
        const lastLH = recentHighs.find(h => h.label === 'LH');
        if (lastLH && currentCandle.close > lastLH.price) {
            return {
                detected: true,
                direction: 'BULLISH',
                type: 'CHoCH',
                level: lastLH.price,
                previousTrend: 'BEARISH'
            };
        }
    }
    
    // Bearish CHoCH: In an uptrend, price breaks below a higher low
    if (trend === 'BULLISH' && recentLows.length >= 2) {
        const lastHL = recentLows.find(l => l.label === 'HL');
        if (lastHL && currentCandle.close < lastHL.price) {
            return {
                detected: true,
                direction: 'BEARISH',
                type: 'CHoCH',
                level: lastHL.price,
                previousTrend: 'BULLISH'
            };
        }
    }
    
    return { detected: false };
}

// Detect Order Blocks with Mitigation Tracking
function detectOrderBlocks(klines, lookback = 50) {
    if (!klines || klines.length < lookback) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const bullishOBs = [];
    const bearishOBs = [];
    const currentPrice = klines[len - 1].close;
    
    // Calculate average volume for filtering - FIXED: Safe calculation
    const volSlice = klines.slice(-50).filter(k => k?.volume > 0);
    const avgVolume = volSlice.length > 0 ? volSlice.reduce((sum, k) => sum + k.volume, 0) / volSlice.length : 1;
    
    for (let i = len - lookback; i < len - 3; i++) {
        if (i < 1) continue;
        
        const candle = klines[i];
        const nextCandle = klines[i + 1];
        const followCandle = klines[i + 2];
        
        // Bullish Order Block: Down candle followed by strong up move
        if (candle.close < candle.open) { // Red candle
            const moveUp = followCandle.close - candle.low;
            const candleRange = candle.high - candle.low;
            
            // Strong impulse move away
            if (moveUp > candleRange * 2 && candle.volume > avgVolume * 0.8) {
                // Check if OB has been mitigated
                let mitigated = false;
                let mitigationPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].low <= candle.high) {
                        mitigated = true;
                        mitigationPct = Math.min(100, ((candle.high - klines[j].low) / candleRange) * 100);
                        break;
                    }
                }
                
                // Only add if not fully mitigated and price is above
                if (mitigationPct < 100 && currentPrice > candle.low) {
                    bullishOBs.push({
                        high: candle.high,
                        low: candle.low,
                        price: (candle.high + candle.low) / 2,
                        index: i,
                        time: candle.time,
                        volume: candle.volume,
                        mitigated: mitigated,
                        mitigationPct: mitigationPct,
                        fresh: !mitigated
                    });
                }
            }
        }
        
        // Bearish Order Block: Up candle followed by strong down move
        if (candle.close > candle.open) { // Green candle
            const moveDown = candle.high - followCandle.close;
            const candleRange = candle.high - candle.low;
            
            // Strong impulse move away
            if (moveDown > candleRange * 2 && candle.volume > avgVolume * 0.8) {
                // Check if OB has been mitigated
                let mitigated = false;
                let mitigationPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].high >= candle.low) {
                        mitigated = true;
                        mitigationPct = Math.min(100, ((klines[j].high - candle.low) / candleRange) * 100);
                        break;
                    }
                }
                
                // Only add if not fully mitigated and price is below
                if (mitigationPct < 100 && currentPrice < candle.high) {
                    bearishOBs.push({
                        high: candle.high,
                        low: candle.low,
                        price: (candle.high + candle.low) / 2,
                        index: i,
                        time: candle.time,
                        volume: candle.volume,
                        mitigated: mitigated,
                        mitigationPct: mitigationPct,
                        fresh: !mitigated
                    });
                }
            }
        }
    }
    
    // Sort by freshness and proximity to current price
    bullishOBs.sort((a, b) => {
        if (a.fresh !== b.fresh) return a.fresh ? -1 : 1;
        return Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price);
    });
    
    bearishOBs.sort((a, b) => {
        if (a.fresh !== b.fresh) return a.fresh ? -1 : 1;
        return Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price);
    });
    
    return { bullish: bullishOBs.slice(0, 5), bearish: bearishOBs.slice(0, 5) };
}

// Detect Breaker Blocks (Mitigated OB that becomes S/R)
function detectBreakerBlocks(klines, orderBlocks) {
    if (!klines || !orderBlocks) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    const bullishBreakers = [];
    const bearishBreakers = [];
    
    // Bullish Breaker: Former bearish OB that got broken and now acts as support
    for (const ob of orderBlocks.bearish) {
        if (ob.mitigated && ob.mitigationPct >= 80) {
            // Check if price broke through and is now above
            if (currentPrice > ob.high) {
                // This bearish OB is now a bullish breaker (support)
                bullishBreakers.push({
                    high: ob.high,
                    low: ob.low,
                    price: ob.price,
                    type: 'BREAKER',
                    originalType: 'BEARISH_OB',
                    index: ob.index
                });
            }
        }
    }
    
    // Bearish Breaker: Former bullish OB that got broken and now acts as resistance
    for (const ob of orderBlocks.bullish) {
        if (ob.mitigated && ob.mitigationPct >= 80) {
            // Check if price broke through and is now below
            if (currentPrice < ob.low) {
                // This bullish OB is now a bearish breaker (resistance)
                bearishBreakers.push({
                    high: ob.high,
                    low: ob.low,
                    price: ob.price,
                    type: 'BREAKER',
                    originalType: 'BULLISH_OB',
                    index: ob.index
                });
            }
        }
    }
    
    return { bullish: bullishBreakers, bearish: bearishBreakers };
}

// Detect Fair Value Gaps (FVG) with Fill Tracking
function detectFVG(klines, lookback = 30) {
    if (!klines || klines.length < lookback) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const bullishFVGs = [];
    const bearishFVGs = [];
    const currentPrice = klines[len - 1].close;
    
    for (let i = len - lookback; i < len - 2; i++) {
        if (i < 1) continue;
        
        const candle1 = klines[i];
        const candle2 = klines[i + 1];
        const candle3 = klines[i + 2];
        
        // Bullish FVG: Gap between candle1 high and candle3 low
        if (candle3.low > candle1.high) {
            const gapHigh = candle3.low;
            const gapLow = candle1.high;
            const gapSize = gapHigh - gapLow;
            const gapPct = (gapSize / candle2.close) * 100;
            
            if (gapPct >= 0.1) { // Minimum gap size
                // Check if FVG has been filled
                let filled = false;
                let fillPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].low <= gapHigh) {
                        const fillAmount = gapHigh - Math.max(klines[j].low, gapLow);
                        fillPct = Math.min(100, (fillAmount / gapSize) * 100);
                        if (fillPct >= 100) {
                            filled = true;
                            break;
                        }
                    }
                }
                
                // Check if price is in the FVG zone
                const inZone = currentPrice >= gapLow && currentPrice <= gapHigh;
                
                if (!filled) {
                    bullishFVGs.push({
                        high: gapHigh,
                        low: gapLow,
                        price: (gapHigh + gapLow) / 2,
                        size: gapSize,
                        sizePct: gapPct,
                        index: i + 1,
                        time: candle2.time,
                        filled: filled,
                        fillPct: fillPct,
                        inZone: inZone
                    });
                }
            }
        }
        
        // Bearish FVG: Gap between candle1 low and candle3 high
        if (candle3.high < candle1.low) {
            const gapHigh = candle1.low;
            const gapLow = candle3.high;
            const gapSize = gapHigh - gapLow;
            const gapPct = (gapSize / candle2.close) * 100;
            
            if (gapPct >= 0.1) { // Minimum gap size
                // Check if FVG has been filled
                let filled = false;
                let fillPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].high >= gapLow) {
                        const fillAmount = Math.min(klines[j].high, gapHigh) - gapLow;
                        fillPct = Math.min(100, (fillAmount / gapSize) * 100);
                        if (fillPct >= 100) {
                            filled = true;
                            break;
                        }
                    }
                }
                
                // Check if price is in the FVG zone
                const inZone = currentPrice >= gapLow && currentPrice <= gapHigh;
                
                if (!filled) {
                    bearishFVGs.push({
                        high: gapHigh,
                        low: gapLow,
                        price: (gapHigh + gapLow) / 2,
                        size: gapSize,
                        sizePct: gapPct,
                        index: i + 1,
                        time: candle2.time,
                        filled: filled,
                        fillPct: fillPct,
                        inZone: inZone
                    });
                }
            }
        }
    }
    
    // Sort by proximity to current price
    bullishFVGs.sort((a, b) => Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price));
    bearishFVGs.sort((a, b) => Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price));
    
    return { bullish: bullishFVGs.slice(0, 5), bearish: bearishFVGs.slice(0, 5) };
}


// Detect Equal Highs and Equal Lows (Liquidity Pools)
function detectEqualLevels(klines, tolerance = 0.002) {
    if (!klines || klines.length < 50) return { equalHighs: [], equalLows: [] };
    
    const swings = findSwingPoints(klines, 4, 4);
    const equalHighs = [];
    const equalLows = [];
    
    // Find equal highs
    for (let i = 0; i < swings.highs.length; i++) {
        const matches = [swings.highs[i]];
        
        for (let j = i + 1; j < swings.highs.length; j++) {
            const pctDiff = Math.abs(swings.highs[i].price - swings.highs[j].price) / swings.highs[i].price;
            if (pctDiff <= tolerance) {
                matches.push(swings.highs[j]);
            }
        }
        
        if (matches.length >= 2) {
            const avgPrice = matches.reduce((sum, m) => sum + m.price, 0) / matches.length;
            // Check if not already added
            const exists = equalHighs.some(eh => Math.abs(eh.price - avgPrice) / avgPrice < tolerance);
            if (!exists) {
                equalHighs.push({
                    price: avgPrice,
                    count: matches.length,
                    indices: matches.map(m => m.index),
                    type: 'EQH'
                });
            }
        }
    }
    
    // Find equal lows
    for (let i = 0; i < swings.lows.length; i++) {
        const matches = [swings.lows[i]];
        
        for (let j = i + 1; j < swings.lows.length; j++) {
            const pctDiff = Math.abs(swings.lows[i].price - swings.lows[j].price) / swings.lows[i].price;
            if (pctDiff <= tolerance) {
                matches.push(swings.lows[j]);
            }
        }
        
        if (matches.length >= 2) {
            const avgPrice = matches.reduce((sum, m) => sum + m.price, 0) / matches.length;
            // Check if not already added
            const exists = equalLows.some(el => Math.abs(el.price - avgPrice) / avgPrice < tolerance);
            if (!exists) {
                equalLows.push({
                    price: avgPrice,
                    count: matches.length,
                    indices: matches.map(m => m.index),
                    type: 'EQL'
                });
            }
        }
    }
    
    return { equalHighs, equalLows };
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🎯 V18 ULTIMATE: SWEEP + ENTRY + SL + TP + ADAPTIVE PULLBACK SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Detect Liquidity Sweep (Enhanced) - OLD V18 VERSION - RENAMED TO AVOID CONFLICT
function detectLiquiditySweepLegacy(klines, equalLevels) {
    if (!klines || klines.length < 5 || !equalLevels) return { detected: false };
    
    const len = klines.length;
    const lastCandle = klines[len - 1];
    const prevCandle = klines[len - 2];
    
    // Check sweep of equal highs (bullish reversal setup after sweep)
    for (const eqh of equalLevels.equalHighs) {
        if (lastCandle.high > eqh.price && lastCandle.close < eqh.price && lastCandle.close < lastCandle.open) {
            const wickAbove = lastCandle.high - Math.max(lastCandle.open, lastCandle.close);
            const body = Math.abs(lastCandle.close - lastCandle.open);
            
            if (wickAbove > body * 0.5) {
                return {
                    detected: true,
                    direction: 'BEARISH',
                    type: 'SWEEP',
                    level: eqh.price,
                    sweepType: 'EQH',
                    sweepHigh: lastCandle.high,
                    sweepLow: lastCandle.low,
                    rejectionClose: lastCandle.close,
                    significance: eqh.count >= 3 ? 'HIGH' : 'MEDIUM'
                };
            }
        }
    }
    
    // Check sweep of equal lows
    for (const eql of equalLevels.equalLows) {
        if (lastCandle.low < eql.price && lastCandle.close > eql.price && lastCandle.close > lastCandle.open) {
            const wickBelow = Math.min(lastCandle.open, lastCandle.close) - lastCandle.low;
            const body = Math.abs(lastCandle.close - lastCandle.open);
            
            if (wickBelow > body * 0.5) {
                return {
                    detected: true,
                    direction: 'BULLISH',
                    type: 'SWEEP',
                    level: eql.price,
                    sweepType: 'EQL',
                    sweepHigh: lastCandle.high,
                    sweepLow: lastCandle.low,
                    rejectionClose: lastCandle.close,
                    significance: eql.count >= 3 ? 'HIGH' : 'MEDIUM'
                };
            }
        }
    }
    
    return { detected: false };
}

// Detect Recent Sweep (within last N candles)
function detectRecentSweep(klines, direction, lookback = 5) {
    if (!klines || klines.length < lookback + 10) return { swept: false };
    
    const equalLevels = detectEqualLevels(klines.slice(0, -1), 0.002);
    
    for (let i = 1; i <= lookback; i++) {
        const checkKlines = klines.slice(0, klines.length - i + 1);
        const sweep = detectLiquiditySweep(checkKlines, equalLevels);
        
        if (sweep.detected) {
            const sweepDir = sweep.direction;
            if ((direction === 'LONG' && sweepDir === 'BULLISH') || 
                (direction === 'SHORT' && sweepDir === 'BEARISH')) {
                return {
                    swept: true,
                    sweepType: sweep.sweepType,
                    sweepLevel: sweep.level,
                    sweepHigh: sweep.sweepHigh,
                    sweepLow: sweep.sweepLow,
                    rejectionClose: sweep.rejectionClose,
                    candlesAgo: i,
                    significance: sweep.significance
                };
            }
        }
    }
    
    return { swept: false };
}

// Get Entry Trigger (SNIPER/ZONE/WAIT)
function getEntryTrigger(direction, klines, gpoteData, atr) {
    const result = {
        type: 'WAIT',
        canEnter: false,
        quality: 0,
        reason: '',
        entryPrice: null,
        usePullback: false,
        sizing: { entry1: 0, entry2: 0 }
    };
    
    if (!klines || klines.length < 50) return result;
    
    const currentPrice = klines[klines.length - 1].close;
    const sweepData = detectRecentSweep(klines, direction, 5);
    
    // BEST: Sweep detected = SNIPER entry
    if (sweepData.swept) {
        result.type = 'SNIPER';
        result.canEnter = true;
        result.quality = sweepData.significance === 'HIGH' ? 100 : 85;
        result.reason = `${sweepData.sweepType} swept → Safe entry`;
        result.entryPrice = sweepData.rejectionClose || currentPrice;
        result.usePullback = false;
        result.sizing = { entry1: 100, entry2: 0 };
        result.sweepData = sweepData;
        return result;
    }
    
    // GOOD: At GP zone
    if (gpoteData?.isInGP) {
        result.type = 'ZONE';
        result.canEnter = true;
        result.quality = 85;
        result.reason = 'In Golden Pocket';
        result.entryPrice = currentPrice;
        result.usePullback = true;
        result.sizing = { entry1: 50, entry2: 50 };
        return result;
    }
    
    // OKAY: At OTE zone
    if (gpoteData?.isInOTE) {
        result.type = 'ZONE';
        result.canEnter = true;
        result.quality = 75;
        result.reason = 'In OTE zone';
        result.entryPrice = currentPrice;
        result.usePullback = true;
        result.sizing = { entry1: 50, entry2: 50 };
        return result;
    }
    
    // NO TRIGGER: Wait
    result.type = 'WAIT';
    result.canEnter = false;
    result.quality = 0;
    result.reason = 'Wait for sweep or GP';
    
    return result;
}

// Calculate Surviving SL (beyond swept liquidity)
function calculateSurvivingSL(direction, entryPrice, sweepData, klines, atr) {
    const result = { price: null, reason: '', survivalRate: 0, riskPct: 0 };
    
    // BEST: SL beyond sweep wick
    if (sweepData?.swept) {
        const buffer = atr * 0.3;
        if (direction === 'LONG') {
            result.price = sweepData.sweepLow - buffer;
            result.reason = 'Below sweep wick (SAFE)';
            result.survivalRate = 95;
        } else {
            result.price = sweepData.sweepHigh + buffer;
            result.reason = 'Above sweep wick (SAFE)';
            result.survivalRate = 95;
        }
        result.riskPct = Math.abs(entryPrice - result.price) / entryPrice * 100;
        return result;
    }
    
    // GOOD: Beyond all nearby liquidity
    if (klines && klines.length >= 50) {
        const equalLevels = detectEqualLevels(klines, 0.002);
        
        if (direction === 'LONG') {
            const allEQLs = equalLevels.equalLows
                .filter(e => e.price < entryPrice)
                .sort((a, b) => a.price - b.price);
            
            if (allEQLs.length > 0) {
                result.price = allEQLs[0].price - (atr * 0.5);
                result.reason = 'Below all EQL liquidity';
                result.survivalRate = 85;
                result.riskPct = Math.abs(entryPrice - result.price) / entryPrice * 100;
                return result;
            }
        } else {
            const allEQHs = equalLevels.equalHighs
                .filter(e => e.price > entryPrice)
                .sort((a, b) => b.price - a.price);
            
            if (allEQHs.length > 0) {
                result.price = allEQHs[0].price + (atr * 0.5);
                result.reason = 'Above all EQH liquidity';
                result.survivalRate = 85;
                result.riskPct = Math.abs(entryPrice - result.price) / entryPrice * 100;
                return result;
            }
        }
    }
    
    // FALLBACK: ATR-based
    result.price = direction === 'LONG' 
        ? entryPrice - (atr * 2.5)
        : entryPrice + (atr * 2.5);
    result.reason = 'ATR-based (wide)';
    result.survivalRate = 70;
    result.riskPct = Math.abs(entryPrice - result.price) / entryPrice * 100;
    
    return result;
}

// Calculate Simple 2 TPs
function calculate2TPs(direction, entryPrice, slPrice, klines) {
    const risk = Math.abs(entryPrice - slPrice) || (entryPrice * 0.02); // Fallback to 2% if risk is 0
    const result = { tp1: null, tp2: null };
    
    // TP1: 50% at 1.5R or first structure
    let tp1Price = direction === 'LONG'
        ? entryPrice + (risk * 1.5)
        : entryPrice - (risk * 1.5);
    
    result.tp1 = {
        price: tp1Price,
        reason: '1.5R',
        closePercent: 50,
        rr: 1.5,
        action: 'Move SL to BE'
    };
    
    // TP2: 50% at opposite liquidity or 3R
    let tp2Price, tp2Reason;
    
    if (klines && klines.length >= 50) {
        const equalLevels = detectEqualLevels(klines, 0.002);
        
        if (direction === 'LONG') {
            const eqh = equalLevels.equalHighs
                .filter(e => e.price > tp1Price)
                .sort((a, b) => a.price - b.price)[0];
            
            if (eqh) {
                tp2Price = eqh.price;
                tp2Reason = `EQH ${eqh.count}x`;
            }
        } else {
            const eql = equalLevels.equalLows
                .filter(e => e.price < tp1Price)
                .sort((a, b) => b.price - a.price)[0];
            
            if (eql) {
                tp2Price = eql.price;
                tp2Reason = `EQL ${eql.count}x`;
            }
        }
    }
    
    if (!tp2Price) {
        tp2Price = direction === 'LONG'
            ? entryPrice + (risk * 3)
            : entryPrice - (risk * 3);
        tp2Reason = '3R';
    }
    
    result.tp2 = {
        price: tp2Price,
        reason: tp2Reason,
        closePercent: 50,
        rr: Math.abs(tp2Price - entryPrice) / risk
    };
    
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🧠 ADAPTIVE PULLBACK LEARNING ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

// Get pullback history from storage
function getPullbackHistory() {
    try {
        const stored = localStorage.getItem('v18_pullback_history');
        return stored ? JSON.parse(stored) : {};
    } catch (e) {
        return {};
    }
}

// Save pullback history
function savePullbackHistory(history) {
    try {
        localStorage.setItem('v18_pullback_history', JSON.stringify(history));
    } catch (e) {
        console.warn('Could not save pullback history');
    }
}

// Track pullback result
function trackPullbackResult(symbol, tf, usedPullback, pullbackFilled, won, entryImprovement) {
    const history = getPullbackHistory();
    
    if (!history[symbol]) history[symbol] = {};
    if (!history[symbol][tf]) {
        history[symbol][tf] = {
            totalTrades: 0,
            pullbackUsed: 0,
            pullbackFilled: 0,
            winsWithPB: 0,
            winsWithoutPB: 0,
            tradesWithPB: 0,
            tradesWithoutPB: 0,
            totalImprovement: 0
        };
    }
    
    const h = history[symbol][tf];
    h.totalTrades++;
    
    if (usedPullback) {
        h.pullbackUsed++;
        h.tradesWithPB++;
        if (pullbackFilled) {
            h.pullbackFilled++;
            h.totalImprovement += entryImprovement || 0;
        }
        if (won) h.winsWithPB++;
    } else {
        h.tradesWithoutPB++;
        if (won) h.winsWithoutPB++;
    }
    
    savePullbackHistory(history);
}

// Decide if should use pullback (adaptive)
function shouldUsePullback(symbol, tf, marketRegime) {
    const history = getPullbackHistory();
    const h = history[symbol]?.[tf];
    
    // Default if no history
    if (!h || h.totalTrades < 5) {
        return {
            usePullback: true,
            reason: 'Default (no history)',
            sizing: { entry1: 50, entry2: 50 },
            confidence: 50
        };
    }
    
    const fillRate = h.pullbackUsed > 0 ? (h.pullbackFilled / h.pullbackUsed) * 100 : 50;
    const winRateWith = h.tradesWithPB > 0 ? (h.winsWithPB / h.tradesWithPB) * 100 : 50;
    const winRateWithout = h.tradesWithoutPB > 0 ? (h.winsWithoutPB / h.tradesWithoutPB) * 100 : 50;
    
    // RULE 1: If pullbacks rarely fill, skip
    if (fillRate < 30) {
        return {
            usePullback: false,
            reason: `Low fill rate (${fillRate.toFixed(0)}%)`,
            sizing: { entry1: 100, entry2: 0 },
            confidence: 80,
            stats: { fillRate, winRateWith, winRateWithout }
        };
    }
    
    // RULE 2: If trending, skip pullback
    if (marketRegime === 'TRENDING') {
        return {
            usePullback: false,
            reason: 'Trending market',
            sizing: { entry1: 100, entry2: 0 },
            confidence: 75,
            stats: { fillRate, winRateWith, winRateWithout }
        };
    }
    
    // RULE 3: If win rate worse with pullback, skip
    if (winRateWith < winRateWithout - 5 && h.tradesWithPB >= 5) {
        return {
            usePullback: false,
            reason: `Better without PB (${winRateWithout.toFixed(0)}% vs ${winRateWith.toFixed(0)}%)`,
            sizing: { entry1: 100, entry2: 0 },
            confidence: 70,
            stats: { fillRate, winRateWith, winRateWithout }
        };
    }
    
    // RULE 4: If high fill rate, increase pullback allocation
    if (fillRate > 80) {
        return {
            usePullback: true,
            reason: `High fill rate (${fillRate.toFixed(0)}%)`,
            sizing: { entry1: 30, entry2: 70 },
            confidence: 85,
            stats: { fillRate, winRateWith, winRateWithout }
        };
    }
    
    // DEFAULT: Standard 50/50
    return {
        usePullback: true,
        reason: 'Standard',
        sizing: { entry1: 50, entry2: 50 },
        confidence: 60,
        stats: { fillRate, winRateWith, winRateWithout }
    };
}

// Get complete entry plan
function getUltimateEntryPlan(direction, klines, gpoteData, atr, symbol, tf, marketRegime) {
    // Null safety check
    if (!klines || klines.length < 50) {
        return {
            canEnter: false,
            type: 'WAIT',
            reason: 'Insufficient data'
        };
    }
    
    const currentPrice = klines[klines.length - 1].close;
    
    // Step 1: Get entry trigger
    const trigger = getEntryTrigger(direction, klines, gpoteData, atr);
    
    if (!trigger.canEnter) {
        return {
            canEnter: false,
            type: 'WAIT',
            reason: trigger.reason
        };
    }
    
    // Step 2: Determine if pullback should be used
    let usePullback = trigger.usePullback;
    let sizing = trigger.sizing;
    let pullbackDecision = null;
    
    if (trigger.type === 'ZONE') {
        pullbackDecision = shouldUsePullback(symbol, tf, marketRegime);
        usePullback = pullbackDecision.usePullback;
        sizing = pullbackDecision.sizing;
    }
    
    // Step 3: Calculate entry price
    const entryPrice = trigger.entryPrice || currentPrice;
    
    // Step 4: Calculate surviving SL
    const slResult = calculateSurvivingSL(direction, entryPrice, trigger.sweepData, klines, atr);
    
    // Step 5: Calculate 2 TPs
    const tpResult = calculate2TPs(direction, entryPrice, slResult.price, klines);
    
    // Step 6: Build complete plan
    return {
        canEnter: true,
        type: trigger.type,
        quality: trigger.quality,
        reason: trigger.reason,
        
        entry: {
            price: entryPrice,
            sizing: sizing
        },
        
        pullback: usePullback ? {
            enabled: true,
            reason: pullbackDecision?.reason || 'Zone entry',
            sizing: sizing
        } : {
            enabled: false,
            reason: trigger.type === 'SNIPER' ? 'Sweep entry - already optimal' : pullbackDecision?.reason
        },
        
        sl: {
            price: slResult.price,
            reason: slResult.reason,
            survivalRate: slResult.survivalRate,
            riskPct: slResult.riskPct
        },
        
        tp1: tpResult.tp1,
        tp2: tpResult.tp2,
        
        sweepData: trigger.sweepData,
        pullbackStats: pullbackDecision?.stats
    };
}

// Get Premium/Discount Zones
function getPremiumDiscount(klines, lookback = 100) {
    if (!klines || klines.length < lookback) return null;
    
    const recent = klines.slice(-lookback);
    const high = Math.max(...recent.map(k => k.high));
    const low = Math.min(...recent.map(k => k.low));
    const range = high - low;
    const currentPrice = klines[klines.length - 1].close;
    
    const equilibrium = (high + low) / 2;
    const premium = high - range * 0.3;      // Top 30%
    const discount = low + range * 0.3;      // Bottom 30%
    
    let zone;
    if (currentPrice >= premium) zone = 'PREMIUM';
    else if (currentPrice <= discount) zone = 'DISCOUNT';
    else zone = 'EQUILIBRIUM';
    
    const percentFromEQ = ((currentPrice - equilibrium) / equilibrium) * 100;
    const positionPct = ((currentPrice - low) / range) * 100;
    
    return {
        high,
        low,
        equilibrium,
        premium,
        discount,
        currentPrice,
        zone,
        percentFromEQ,
        positionPct,
        favorsBuy: zone === 'DISCOUNT',
        favorsSell: zone === 'PREMIUM'
    };
}

// Detect Kill Zone (Trading Sessions)
function getKillZone() {
    const now = new Date();
    const utcHour = now.getUTCHours();
    
    const sessions = [
        { name: 'ASIA', start: 0, end: 3, color: '#06b6d4', active: false },
        { name: 'LONDON', start: 7, end: 10, color: '#a855f7', active: false },
        { name: 'NY_AM', start: 12, end: 15, color: '#f59e0b', active: false },
        { name: 'NY_PM', start: 15, end: 17, color: '#ef4444', active: false }
    ];
    
    for (const session of sessions) {
        if (utcHour >= session.start && utcHour < session.end) {
            return { ...session, active: true, bonus: session.name === 'LONDON' || session.name === 'NY_AM' ? 10 : 5 };
        }
    }
    
    return { name: 'OFF_SESSION', active: false, bonus: 0, color: '#64748b' };
}

// Signal State Machine
function getSignalState(bos, choch, ob, fvg, currentPrice) {
    // LOCKED: Clear trigger present (BOS or CHoCH)
    if (bos.detected || choch.detected) {
        // Check if we're in pullback to OB or FVG
        const direction = bos.detected ? bos.direction : choch.direction;
        
        if (direction === 'BULLISH') {
            // Check if price pulled back to bullish OB or FVG
            const nearOB = ob.bullish.length > 0 && 
                Math.abs(currentPrice - ob.bullish[0].price) / currentPrice < 0.01;
            const nearFVG = fvg.bullish.length > 0 && 
                (currentPrice >= fvg.bullish[0].low && currentPrice <= fvg.bullish[0].high);
            
            if (nearOB || nearFVG) {
                return { state: 'ENTRY', reason: nearOB ? 'At Bullish OB' : 'In Bullish FVG' };
            }
            return { state: 'PULLBACK', reason: 'Waiting for pullback to OB/FVG' };
        } else {
            // Check if price pulled back to bearish OB or FVG
            const nearOB = ob.bearish.length > 0 && 
                Math.abs(currentPrice - ob.bearish[0].price) / currentPrice < 0.01;
            const nearFVG = fvg.bearish.length > 0 && 
                (currentPrice >= fvg.bearish[0].low && currentPrice <= fvg.bearish[0].high);
            
            if (nearOB || nearFVG) {
                return { state: 'ENTRY', reason: nearOB ? 'At Bearish OB' : 'In Bearish FVG' };
            }
            return { state: 'PULLBACK', reason: 'Waiting for pullback to OB/FVG' };
        }
    }
    
    // FORMING: OB or FVG present but no trigger yet
    if (ob.bullish.length > 0 || ob.bearish.length > 0 || fvg.bullish.length > 0 || fvg.bearish.length > 0) {
        return { state: 'FORMING', reason: 'Waiting for BOS/CHoCH trigger' };
    }
    
    return { state: 'WAITING', reason: 'No setup detected' };
}

// MAIN SMC ANALYSIS FUNCTION
function performSMCAnalysis(klines, tf) {
    const result = {
        score: 0,
        direction: null,
        trigger: null,
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    
    // Get market structure
    const structure = detectStructure(klines);
    result.details.structure = structure;
    result.details.trend = structure.trend;
    
    // Detect BOS
    const bos = detectBOS(klines, structure);
    result.details.bos = bos;
    
    // Detect CHoCH
    const choch = detectCHoCH(klines, structure);
    result.details.choch = choch;
    
    // Detect Order Blocks
    const orderBlocks = detectOrderBlocks(klines);
    result.details.orderBlocks = orderBlocks;
    
    // Detect Breaker Blocks
    const breakerBlocks = detectBreakerBlocks(klines, orderBlocks);
    result.details.breakerBlocks = breakerBlocks;
    
    // Detect FVG
    const fvg = detectFVG(klines);
    result.details.fvg = fvg;
    
    // Detect Equal Levels
    const equalLevels = detectEqualLevels(klines);
    result.details.equalLevels = equalLevels;
    
    // Detect Liquidity Sweep
    const sweep = detectLiquiditySweep(klines, equalLevels);
    result.details.sweep = sweep;
    
    // Get Premium/Discount
    const pdZone = getPremiumDiscount(klines);
    result.details.pdZone = pdZone;
    
    // Get Kill Zone
    const killZone = getKillZone();
    result.details.killZone = killZone;
    
    // Get Signal State
    const signalState = getSignalState(bos, choch, orderBlocks, fvg, currentPrice);
    result.details.signalState = signalState;
    
    // SCORING
    let score = 0;
    let bullScore = 0;
    let bearScore = 0;
    
    // Structure trend (10 points)
    if (structure.trend === 'BULLISH') {
        bullScore += 10;
        result.factors.push('Bullish Structure');
    } else if (structure.trend === 'BEARISH') {
        bearScore += 10;
        result.factors.push('Bearish Structure');
    }
    
    // BOS (25 points)
    if (bos.detected) {
        if (bos.direction === 'BULLISH') {
            bullScore += 25;
            result.factors.push('BOS↑');
            if (bos.strength === 'STRONG') {
                bullScore += 5;
                result.factors.push('Strong BOS');
            }
        } else {
            bearScore += 25;
            result.factors.push('BOS↓');
            if (bos.strength === 'STRONG') {
                bearScore += 5;
                result.factors.push('Strong BOS');
            }
        }
        result.trigger = 'BOS';
    }
    
    // CHoCH (30 points - stronger signal)
    if (choch.detected) {
        if (choch.direction === 'BULLISH') {
            bullScore += 30;
            result.factors.push('CHoCH↑');
        } else {
            bearScore += 30;
            result.factors.push('CHoCH↓');
        }
        result.trigger = result.trigger ? result.trigger + '+CHoCH' : 'CHoCH';
    }
    
    // Order Blocks (15 points)
    if (orderBlocks.bullish.length > 0) {
        const nearestOB = orderBlocks.bullish[0];
        const distance = Math.abs(currentPrice - nearestOB.price) / currentPrice;
        if (distance < 0.01) {
            bullScore += 15;
            result.factors.push(nearestOB.fresh ? 'Fresh Bull OB' : 'Bull OB');
        } else if (distance < 0.02) {
            bullScore += 8;
        }
    }
    if (orderBlocks.bearish.length > 0) {
        const nearestOB = orderBlocks.bearish[0];
        const distance = Math.abs(currentPrice - nearestOB.price) / currentPrice;
        if (distance < 0.01) {
            bearScore += 15;
            result.factors.push(nearestOB.fresh ? 'Fresh Bear OB' : 'Bear OB');
        } else if (distance < 0.02) {
            bearScore += 8;
        }
    }
    
    // Breaker Blocks (12 points)
    if (breakerBlocks.bullish.length > 0) {
        const distance = Math.abs(currentPrice - breakerBlocks.bullish[0].price) / currentPrice;
        if (distance < 0.015) {
            bullScore += 12;
            result.factors.push('Bull Breaker');
        }
    }
    if (breakerBlocks.bearish.length > 0) {
        const distance = Math.abs(currentPrice - breakerBlocks.bearish[0].price) / currentPrice;
        if (distance < 0.015) {
            bearScore += 12;
            result.factors.push('Bear Breaker');
        }
    }
    
    // FVG (10 points)
    if (fvg.bullish.length > 0 && fvg.bullish[0].inZone) {
        bullScore += 10;
        result.factors.push('In Bull FVG');
    }
    if (fvg.bearish.length > 0 && fvg.bearish[0].inZone) {
        bearScore += 10;
        result.factors.push('In Bear FVG');
    }
    
    // Liquidity Sweep (15 points)
    if (sweep.detected) {
        if (sweep.direction === 'BULLISH') {
            bullScore += sweep.significance === 'HIGH' ? 18 : 12;
            result.factors.push('Liq Sweep↑');
        } else {
            bearScore += sweep.significance === 'HIGH' ? 18 : 12;
            result.factors.push('Liq Sweep↓');
        }
        result.trigger = result.trigger ? result.trigger + '+Sweep' : 'Sweep';
    }
    
    // Premium/Discount (10 points)
    if (pdZone) {
        if (pdZone.zone === 'DISCOUNT') {
            bullScore += 10;
            result.factors.push('Discount Zone');
        } else if (pdZone.zone === 'PREMIUM') {
            bearScore += 10;
            result.factors.push('Premium Zone');
        }
    }
    
    // Kill Zone bonus
    if (killZone.active) {
        score += killZone.bonus;
        result.factors.push(killZone.name + ' Session');
    }
    
    // Determine direction and final score
    if (bullScore > bearScore + 10) {
        result.direction = 'LONG';
        score += bullScore;
    } else if (bearScore > bullScore + 10) {
        result.direction = 'SHORT';
        score += bearScore;
    } else {
        // Mixed signals
        score += Math.max(bullScore, bearScore) * 0.5;
        result.warnings.push('Mixed SMC signals');
    }
    
    // Signal state bonus/penalty
    if (signalState.state === 'ENTRY') {
        score += 10;
        result.factors.push(signalState.reason);
    } else if (signalState.state === 'FORMING') {
        result.warnings.push(signalState.reason);
    }
    
    result.score = Math.min(100, Math.max(0, Math.round(score)));
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF PART 2 - SMC Analysis Complete
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// CANDLE PATTERN DETECTION ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

function analyzeCandlePatterns(klines) {
    if (!klines || klines.length < 10) {
        return { patterns: [], currentCandle: null, behavior: null, strength: 0 };
    }
    
    const result = {
        patterns: [],
        currentCandle: null,
        behavior: null,
        strength: 0,
        control: 'NEUTRAL',
        factors: []
    };
    
    // Get recent candles
    const candles = klines.slice(-10);
    const current = candles[candles.length - 1];
    const prev = candles[candles.length - 2];
    const prev2 = candles[candles.length - 3];
    
    // Calculate candle metrics
    const calcCandleMetrics = (c) => {
        const range = c.high - c.low;
        const body = Math.abs(c.close - c.open);
        const upperWick = c.high - Math.max(c.close, c.open);
        const lowerWick = Math.min(c.close, c.open) - c.low;
        const isBullish = c.close > c.open;
        
        return {
            range,
            body,
            bodyPercent: range > 0 ? (body / range) * 100 : 0,
            upperWick,
            lowerWick,
            upperWickPercent: range > 0 ? (upperWick / range) * 100 : 0,
            lowerWickPercent: range > 0 ? (lowerWick / range) * 100 : 0,
            isBullish,
            isBearish: !isBullish && c.close !== c.open
        };
    };
    
    const cm = calcCandleMetrics(current);
    const pm = calcCandleMetrics(prev);
    
    // Current candle analysis
    result.currentCandle = {
        type: 'Unknown',
        bodyPercent: Math.round(cm.bodyPercent || 0),
        upperWickPercent: Math.round(cm.upperWickPercent || 0),
        lowerWickPercent: Math.round(cm.lowerWickPercent || 0),
        isBullish: cm.isBullish,
        behavior: ''
    };
    
    // Calculate average volume - FIXED: Safe calculation
    const volumes = candles.map(c => c?.volume || 0).filter(v => v > 0);
    const avgVolume = volumes.length > 0 ? volumes.reduce((a, b) => a + b, 0) / volumes.length : 1;
    const volumeRatio = avgVolume > 0 ? (current?.volume || 0) / avgVolume : 1;
    result.currentCandle.volumeRatio = isNaN(volumeRatio) ? 1 : Math.round(volumeRatio * 10) / 10;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // PATTERN DETECTION
    // ═══════════════════════════════════════════════════════════════════════════
    
    // 1. DOJI - Small body, indecision
    const isDoji = cm.bodyPercent < 10;
    if (isDoji) {
        result.patterns.push({ 
            name: 'Doji', 
            signal: 'NEUTRAL', 
            strength: 'Medium',
            meaning: 'Indecision - trend may pause or reverse'
        });
        result.currentCandle.type = 'Doji';
    }
    
    // 2. HAMMER / HANGING MAN - Long lower wick at bottom
    const isHammer = cm.lowerWickPercent > 60 && cm.upperWickPercent < 15 && cm.bodyPercent < 35;
    if (isHammer) {
        // Hammer at support = bullish, at resistance = bearish (hanging man)
        result.patterns.push({ 
            name: cm.isBullish ? 'Hammer' : 'Hanging Man', 
            signal: 'BULLISH', 
            strength: 'High',
            meaning: 'Buyers rejected lower prices - potential reversal up'
        });
        result.currentCandle.type = cm.isBullish ? 'Hammer' : 'Hanging Man';
    }
    
    // 3. SHOOTING STAR / INVERTED HAMMER - Long upper wick at top
    const isShootingStar = cm.upperWickPercent > 60 && cm.lowerWickPercent < 15 && cm.bodyPercent < 35;
    if (isShootingStar) {
        result.patterns.push({ 
            name: cm.isBullish ? 'Inverted Hammer' : 'Shooting Star', 
            signal: 'BEARISH', 
            strength: 'High',
            meaning: 'Sellers rejected higher prices - potential reversal down'
        });
        result.currentCandle.type = cm.isBullish ? 'Inverted Hammer' : 'Shooting Star';
    }
    
    // 4. BULLISH ENGULFING
    const isBullishEngulfing = cm.isBullish && pm.isBearish && 
        current.close > prev.open && current.open < prev.close &&
        cm.body > pm.body;
    if (isBullishEngulfing) {
        result.patterns.push({ 
            name: 'Bullish Engulfing', 
            signal: 'BULLISH', 
            strength: 'Very High',
            meaning: 'Strong buying pressure - buyers overwhelmed sellers'
        });
        result.currentCandle.type = 'Bullish Engulfing';
        result.strength += 25;
    }
    
    // 5. BEARISH ENGULFING
    const isBearishEngulfing = cm.isBearish && pm.isBullish && 
        current.close < prev.open && current.open > prev.close &&
        cm.body > pm.body;
    if (isBearishEngulfing) {
        result.patterns.push({ 
            name: 'Bearish Engulfing', 
            signal: 'BEARISH', 
            strength: 'Very High',
            meaning: 'Strong selling pressure - sellers overwhelmed buyers'
        });
        result.currentCandle.type = 'Bearish Engulfing';
        result.strength += 25;
    }
    
    // 6. MORNING STAR (3 candle bullish reversal)
    if (candles.length >= 3) {
        const pm2 = calcCandleMetrics(prev2);
        const isMorningStar = pm2.isBearish && pm2.bodyPercent > 50 && // Strong red
            pm.bodyPercent < 30 && // Small body (star)
            cm.isBullish && cm.bodyPercent > 50 && // Strong green
            current.close > (prev2.open + prev2.close) / 2;
        if (isMorningStar) {
            result.patterns.push({ 
                name: 'Morning Star', 
                signal: 'BULLISH', 
                strength: 'Very High',
                meaning: 'Major bullish reversal - high probability long'
            });
            result.strength += 30;
        }
    }
    
    // 7. EVENING STAR (3 candle bearish reversal)
    if (candles.length >= 3) {
        const pm2 = calcCandleMetrics(prev2);
        const isEveningStar = pm2.isBullish && pm2.bodyPercent > 50 && // Strong green
            pm.bodyPercent < 30 && // Small body (star)
            cm.isBearish && cm.bodyPercent > 50 && // Strong red
            current.close < (prev2.open + prev2.close) / 2;
        if (isEveningStar) {
            result.patterns.push({ 
                name: 'Evening Star', 
                signal: 'BEARISH', 
                strength: 'Very High',
                meaning: 'Major bearish reversal - high probability short'
            });
            result.strength += 30;
        }
    }
    
    // 8. INSIDE BAR - Consolidation, breakout coming
    const isInsideBar = current.high < prev.high && current.low > prev.low;
    if (isInsideBar) {
        result.patterns.push({ 
            name: 'Inside Bar', 
            signal: 'NEUTRAL', 
            strength: 'Medium',
            meaning: 'Consolidation - breakout expected soon'
        });
        result.currentCandle.type = 'Inside Bar';
    }
    
    // 9. PIN BAR - Rejection candle
    const isPinBar = (cm.upperWickPercent > 65 || cm.lowerWickPercent > 65) && cm.bodyPercent < 25;
    if (isPinBar && !isHammer && !isShootingStar) {
        const pinSignal = cm.lowerWickPercent > cm.upperWickPercent ? 'BULLISH' : 'BEARISH';
        result.patterns.push({ 
            name: 'Pin Bar', 
            signal: pinSignal, 
            strength: 'High',
            meaning: pinSignal === 'BULLISH' ? 'Strong rejection of lows' : 'Strong rejection of highs'
        });
        result.currentCandle.type = 'Pin Bar';
        result.strength += 20;
    }
    
    // 10. MARUBOZU - Full body, strong momentum
    const isMarubozu = cm.bodyPercent > 85 && cm.upperWickPercent < 8 && cm.lowerWickPercent < 8;
    if (isMarubozu) {
        result.patterns.push({ 
            name: cm.isBullish ? 'Bullish Marubozu' : 'Bearish Marubozu', 
            signal: cm.isBullish ? 'BULLISH' : 'BEARISH', 
            strength: 'Very High',
            meaning: cm.isBullish ? 'Extreme buying pressure - no resistance' : 'Extreme selling pressure - no support'
        });
        result.currentCandle.type = cm.isBullish ? 'Bullish Marubozu' : 'Bearish Marubozu';
        result.strength += 25;
    }
    
    // 11. TWEEZER TOP/BOTTOM
    const isTweezerBottom = Math.abs(current.low - prev.low) / current.low < 0.001 && cm.isBullish && pm.isBearish;
    const isTweezerTop = Math.abs(current.high - prev.high) / current.high < 0.001 && cm.isBearish && pm.isBullish;
    if (isTweezerBottom) {
        result.patterns.push({ 
            name: 'Tweezer Bottom', 
            signal: 'BULLISH', 
            strength: 'High',
            meaning: 'Double rejection at support - reversal likely'
        });
        result.strength += 20;
    }
    if (isTweezerTop) {
        result.patterns.push({ 
            name: 'Tweezer Top', 
            signal: 'BEARISH', 
            strength: 'High',
            meaning: 'Double rejection at resistance - reversal likely'
        });
        result.strength += 20;
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // BEHAVIOR ANALYSIS
    // ═══════════════════════════════════════════════════════════════════════════
    
    // Determine who's in control (last 3 candles)
    let bullishCandles = 0;
    let bearishCandles = 0;
    let totalBullishBody = 0;
    let totalBearishBody = 0;
    
    for (let i = candles.length - 3; i < candles.length; i++) {
        if (i >= 0) {
            const c = candles[i];
            if (c.close > c.open) {
                bullishCandles++;
                totalBullishBody += c.close - c.open;
            } else {
                bearishCandles++;
                totalBearishBody += c.open - c.close;
            }
        }
    }
    
    if (bullishCandles > bearishCandles && totalBullishBody > totalBearishBody) {
        result.control = 'BUYERS';
        result.controlBuyers = true;
        result.controlSellers = false;
    } else if (bearishCandles > bullishCandles && totalBearishBody > totalBullishBody) {
        result.control = 'SELLERS';
        result.controlBuyers = false;
        result.controlSellers = true;
    } else {
        result.control = 'CONTESTED';
        result.controlBuyers = false;
        result.controlSellers = false;
    }
    
    // Momentum direction
    let momentum = 'NEUTRAL';
    const bodyTrend = [];
    for (let i = candles.length - 5; i < candles.length; i++) {
        if (i >= 0) {
            const c = candles[i];
            bodyTrend.push(Math.abs(c.close - c.open));
        }
    }
    if (bodyTrend.length >= 3) {
        const recentAvg = bodyTrend.slice(-2).reduce((a, b) => a + b, 0) / 2;
        const olderAvg = bodyTrend.slice(0, 2).reduce((a, b) => a + b, 0) / 2;
        if (recentAvg > olderAvg * 1.2) momentum = 'INCREASING';
        else if (recentAvg < olderAvg * 0.8) momentum = 'DECREASING';
    }
    
    // Check for exhaustion
    let exhaustionSigns = [];
    if (isDoji && volumeRatio > 1.5) exhaustionSigns.push('Doji on high volume');
    if (cm.upperWickPercent > 50 && cm.isBullish) exhaustionSigns.push('Long upper wick on green');
    if (cm.lowerWickPercent > 50 && cm.isBearish) exhaustionSigns.push('Long lower wick on red');
    
    // Check for trap potential
    let trapPotential = 'LOW';
    if (isShootingStar && volumeRatio < 0.7) trapPotential = 'HIGH - Low volume rejection';
    if (isBullishEngulfing && volumeRatio < 0.8) trapPotential = 'MEDIUM - Engulfing on weak volume';
    
    // Build behavior object
    result.behavior = {
        control: result.control,
        momentum: momentum,
        exhaustionSigns: exhaustionSigns.length > 0 ? exhaustionSigns : ['None detected'],
        trapPotential: trapPotential,
        volumeConfirmation: volumeRatio > 1.2 ? 'STRONG' : volumeRatio > 0.8 ? 'NORMAL' : 'WEAK'
    };
    
    // Current candle behavior text
    if (cm.isBullish && cm.bodyPercent > 60) {
        result.currentCandle.behavior = 'Aggressive buying, strong conviction';
    } else if (cm.isBearish && cm.bodyPercent > 60) {
        result.currentCandle.behavior = 'Aggressive selling, strong conviction';
    } else if (cm.lowerWickPercent > 40) {
        result.currentCandle.behavior = 'Buyers absorbed selling pressure';
    } else if (cm.upperWickPercent > 40) {
        result.currentCandle.behavior = 'Sellers absorbed buying pressure';
    } else if (isDoji) {
        result.currentCandle.behavior = 'Indecision, equilibrium between buyers and sellers';
    } else {
        result.currentCandle.behavior = cm.isBullish ? 'Mild buying pressure' : 'Mild selling pressure';
    }
    
    // Set default type if none detected
    if (result.currentCandle.type === 'Unknown') {
        if (cm.isBullish && cm.bodyPercent > 60) result.currentCandle.type = 'Strong Bullish';
        else if (cm.isBearish && cm.bodyPercent > 60) result.currentCandle.type = 'Strong Bearish';
        else if (cm.isBullish) result.currentCandle.type = 'Bullish';
        else if (cm.isBearish) result.currentCandle.type = 'Bearish';
        else result.currentCandle.type = 'Neutral';
    }
    
    // Calculate overall pattern strength
    const patternCount = result.patterns.length;
    const bullishPatterns = result.patterns.filter(p => p.signal === 'BULLISH').length;
    const bearishPatterns = result.patterns.filter(p => p.signal === 'BEARISH').length;
    
    result.patternSignal = bullishPatterns > bearishPatterns ? 'BULLISH' : 
                           bearishPatterns > bullishPatterns ? 'BEARISH' : 'NEUTRAL';
    
    // Strength score (0-100)
    result.strength = Math.min(100, result.strength + (patternCount * 10) + (volumeRatio > 1.2 ? 15 : 0));
    
    // Add factors for display
    if (result.patterns.length > 0) {
        result.factors = result.patterns.map(p => p.name + ' (' + p.signal + ')');
    }
    
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// V1 ULTIMATE - NEW ENGINES (Sequence, Pattern-at-Level, Rejection Score)
// ═══════════════════════════════════════════════════════════════════════════════

// SEQUENCE VALIDATOR - Checks if signal follows proper SMC sequence
// FIX #1: Added direction parameter to filter zones/OBs/FVGs by signal direction
function validateSequence(smcData, zoneData, candlePatterns, klines, direction) {
    const result = {
        steps: {
            sweep: false,
            bos: false,
            fvg: false,
            ob: false,
            pullback: false,
            pattern: false
        },
        completed: 0,
        total: 6,
        score: 0,
        state: 'NEUTRAL',
        quality: 'WEAK',
        details: []
    };
    
    const smcD = smcData.details || {};
    const currentPrice = klines[klines.length - 1].close;
    
    // Step 1: Check for Liquidity Sweep
    if (smcD.liquidityData && (smcD.liquidityData.recentSweep || smcD.liquidityData.sweepCount > 0)) {
        result.steps.sweep = true;
        result.details.push('✅ Sweep: Liquidity taken');
    }
    
    // Step 2: Check for BOS/CHoCH
    if (smcD.structure && (smcD.structure.bos || smcD.structure.choch)) {
        result.steps.bos = true;
        result.details.push('✅ BOS/CHoCH: Structure confirmed');
    }
    
    // Step 3: Check for FVG (direction-appropriate ONLY)
    const fvgData = smcD.fvg || {};
    let hasFVG = false;
    if (direction === 'LONG' && fvgData.bullish && fvgData.bullish.length > 0) {
        hasFVG = true;
        result.details.push('✅ FVG: Bullish imbalance detected');
    } else if (direction === 'SHORT' && fvgData.bearish && fvgData.bearish.length > 0) {
        hasFVG = true;
        result.details.push('✅ FVG: Bearish imbalance detected');
    } else if ((fvgData.bullish && fvgData.bullish.length > 0) || (fvgData.bearish && fvgData.bearish.length > 0)) {
        // FIX: Wrong direction FVG = NO step credit (hasFVG stays false)
        result.details.push('❌ FVG: Found but OPPOSITE direction (no credit)');
    }
    if (hasFVG) {
        result.steps.fvg = true;
    }
    
    // Step 4: Check for Order Block (direction-appropriate ONLY)
    const obData = smcD.orderBlocks || {};
    let hasOB = false;
    if (direction === 'LONG' && obData.bullish && obData.bullish.length > 0) {
        hasOB = true;
        result.details.push('✅ OB: Bullish Order Block identified');
    } else if (direction === 'SHORT' && obData.bearish && obData.bearish.length > 0) {
        hasOB = true;
        result.details.push('✅ OB: Bearish Order Block identified');
    } else if ((obData.bullish && obData.bullish.length > 0) || (obData.bearish && obData.bearish.length > 0)) {
        // FIX: Wrong direction OB = NO step credit (hasOB stays false)
        result.details.push('❌ OB: Found but OPPOSITE direction (no credit)');
    }
    if (hasOB) {
        result.steps.ob = true;
    }
    
    // Step 5: Check if price pulled back to DIRECTION-APPROPRIATE POI
    const zoneD = zoneData.details || {};
    let atCorrectZone = false;
    let atOB = false;
    let atFVG = false;
    let poiType = '';
    
    // For LONG: Check support zones, bullish OBs, bullish FVGs
    // For SHORT: Check resistance zones, bearish OBs, bearish FVGs
    if (direction === 'LONG') {
        // Check support zone
        if (zoneD.nearestSupport) {
            const distPct = Math.abs(currentPrice - zoneD.nearestSupport.price) / currentPrice;
            if (distPct < 0.015) {
                atCorrectZone = true;
                poiType = 'Support';
            }
        }
        // Check bullish OB
        if (obData.bullish && obData.bullish.length > 0) {
            atOB = obData.bullish.some(ob => currentPrice >= ob.low && currentPrice <= ob.high * 1.005);
            if (atOB) poiType = 'Bullish OB';
        }
        // Check bullish FVG
        if (fvgData.bullish && fvgData.bullish.length > 0) {
            atFVG = fvgData.bullish.some(fvg => currentPrice >= fvg.low && currentPrice <= fvg.high * 1.005);
            if (atFVG) poiType = 'Bullish FVG';
        }
    } else if (direction === 'SHORT') {
        // Check resistance zone
        if (zoneD.nearestResistance) {
            const distPct = Math.abs(currentPrice - zoneD.nearestResistance.price) / currentPrice;
            if (distPct < 0.015) {
                atCorrectZone = true;
                poiType = 'Resistance';
            }
        }
        // Check bearish OB
        if (obData.bearish && obData.bearish.length > 0) {
            atOB = obData.bearish.some(ob => currentPrice >= ob.low * 0.995 && currentPrice <= ob.high);
            if (atOB) poiType = 'Bearish OB';
        }
        // Check bearish FVG
        if (fvgData.bearish && fvgData.bearish.length > 0) {
            atFVG = fvgData.bearish.some(fvg => currentPrice >= fvg.low * 0.995 && currentPrice <= fvg.high);
            if (atFVG) poiType = 'Bearish FVG';
        }
    }
    
    if (atCorrectZone || atOB || atFVG) {
        result.steps.pullback = true;
        result.details.push(`✅ Pullback: Price at ${poiType}`);
    } else {
        result.details.push(`❌ Pullback: Price not at ${direction === 'LONG' ? 'support/bullish' : 'resistance/bearish'} POI`);
    }
    
    // Step 6: Check for Pattern at Level
    if (candlePatterns && candlePatterns.patterns && candlePatterns.patterns.length > 0) {
        if (result.steps.pullback) {
            result.steps.pattern = true;
            result.details.push('✅ Pattern: Confirmation at POI');
        } else {
            result.details.push('⚠️ Pattern: Found but NOT at POI');
        }
    }
    
    // Calculate completion
    result.completed = Object.values(result.steps).filter(Boolean).length;
    
    // Calculate score (0-100)
    result.score = Math.round((result.completed / result.total) * 100);
    
    // Determine state
    if (result.completed >= 5) {
        result.state = 'ENTRY_READY';
        result.quality = 'PERFECT';
    } else if (result.completed >= 4) {
        result.state = 'PATTERN_CONFIRMED';
        result.quality = 'STRONG';
    } else if (result.completed >= 3) {
        result.state = 'PULLBACK_TO_POI';
        result.quality = 'VALID';
    } else if (result.completed >= 2) {
        result.state = 'POI_IDENTIFIED';
        result.quality = 'DEVELOPING';
    } else {
        result.state = 'FORMING';
        result.quality = 'WEAK';
    }
    
    return result;
}

// PATTERN-AT-LEVEL - Checks if pattern is at a significant level
// FIX #2: Added direction parameter to only check direction-appropriate levels
function checkPatternAtLevel(candlePatterns, zoneData, smcData, currentPrice, direction) {
    const result = {
        atLevel: false,
        levelType: 'NONE',
        levelPrice: null,
        distance: 999,
        distancePercent: 999,
        bonus: 0,
        details: ''
    };
    
    if (!candlePatterns || !candlePatterns.patterns || candlePatterns.patterns.length === 0) {
        result.details = 'No pattern detected';
        return result;
    }
    
    const zoneD = zoneData.details || {};
    const smcD = smcData.details || {};
    const levels = [];
    const obData = smcD.orderBlocks || {};
    const fvgData = smcD.fvg || {};
    
    // Collect DIRECTION-APPROPRIATE levels only
    if (direction === 'LONG') {
        // For LONG: Support zones, Bullish OBs, Bullish FVGs
        if (zoneD.nearestSupport) {
            levels.push({ type: 'SUPPORT', price: zoneD.nearestSupport.price, strength: zoneD.nearestSupport.strength || 50 });
        }
        if (obData.bullish) {
            obData.bullish.forEach(ob => {
                levels.push({ type: 'BULLISH_OB', price: (ob.high + ob.low) / 2, high: ob.high, low: ob.low, strength: 70 });
            });
        }
        if (fvgData.bullish) {
            fvgData.bullish.forEach(fvg => {
                levels.push({ type: 'BULLISH_FVG', price: (fvg.high + fvg.low) / 2, high: fvg.high, low: fvg.low, strength: 60 });
            });
        }
    } else if (direction === 'SHORT') {
        // For SHORT: Resistance zones, Bearish OBs, Bearish FVGs
        if (zoneD.nearestResistance) {
            levels.push({ type: 'RESISTANCE', price: zoneD.nearestResistance.price, strength: zoneD.nearestResistance.strength || 50 });
        }
        if (obData.bearish) {
            obData.bearish.forEach(ob => {
                levels.push({ type: 'BEARISH_OB', price: (ob.high + ob.low) / 2, high: ob.high, low: ob.low, strength: 70 });
            });
        }
        if (fvgData.bearish) {
            fvgData.bearish.forEach(fvg => {
                levels.push({ type: 'BEARISH_FVG', price: (fvg.high + fvg.low) / 2, high: fvg.high, low: fvg.low, strength: 60 });
            });
        }
    }
    
    // If no direction-appropriate levels found, return early
    if (levels.length === 0) {
        result.details = `No ${direction === 'LONG' ? 'support/bullish' : 'resistance/bearish'} levels found`;
        return result;
    }
    
    // Find closest level
    let closestLevel = null;
    let closestDist = Infinity;
    
    for (const level of levels) {
        let dist;
        if (level.high && level.low) {
            // For ranges (OB, FVG), check if price is within range
            if (currentPrice >= level.low && currentPrice <= level.high) {
                dist = 0;
            } else {
                dist = Math.min(
                    Math.abs(currentPrice - level.high),
                    Math.abs(currentPrice - level.low)
                );
            }
        } else {
            dist = Math.abs(currentPrice - level.price);
        }
        
        if (dist < closestDist) {
            closestDist = dist;
            closestLevel = level;
        }
    }
    
    if (closestLevel) {
        result.levelType = closestLevel.type;
        result.levelPrice = closestLevel.price;
        result.distance = closestDist;
        result.distancePercent = (closestDist / currentPrice) * 100;
        
        // Determine if "at level" (within 0.5%)
        if (result.distancePercent <= 0.5) {
            result.atLevel = true;
            result.bonus = 25;
            result.details = `Pattern AT ${closestLevel.type} (${result.distancePercent.toFixed(2)}%)`;
        } else if (result.distancePercent <= 1.0) {
            result.atLevel = true;
            result.bonus = 15;
            result.details = `Pattern CLOSE to ${closestLevel.type} (${result.distancePercent.toFixed(2)}%)`;
        } else if (result.distancePercent <= 1.5) {
            result.bonus = 5;
            result.details = `Pattern NEAR ${closestLevel.type} (${result.distancePercent.toFixed(2)}%)`;
        } else {
            result.details = `Pattern FAR from levels (${result.distancePercent.toFixed(2)}%)`;
        }
    }
    
    return result;
}

// REJECTION SCORE - Rates quality of price rejection at level
function calculateRejectionScore(klines, zoneData, smcData, direction) {
    const result = {
        score: 0,
        breakdown: {
            wickTouch: 0,
            bodyClosed: 0,
            wickRatio: 0,
            volumeConfirm: 0,
            followThrough: 0
        },
        quality: 'NONE',
        details: []
    };
    
    if (!klines || klines.length < 3) return result;
    
    const current = klines[klines.length - 1];
    const prev = klines[klines.length - 2];
    const zoneD = zoneData.details || {};
    const smcD = smcData.details || {};
    
    // Get target level based on direction
    let targetLevel = null;
    if (direction === 'LONG') {
        if (zoneD.nearestSupport) targetLevel = zoneD.nearestSupport.price;
        const obData = smcD.orderBlocks || {};
        if (obData.bullish && obData.bullish.length > 0) {
            const obLevel = obData.bullish[0].low;
            if (!targetLevel || Math.abs(current.close - obLevel) < Math.abs(current.close - targetLevel)) {
                targetLevel = obLevel;
            }
        }
    } else if (direction === 'SHORT') {
        if (zoneD.nearestResistance) targetLevel = zoneD.nearestResistance.price;
        const obData = smcD.orderBlocks || {};
        if (obData.bearish && obData.bearish.length > 0) {
            const obLevel = obData.bearish[0].high;
            if (!targetLevel || Math.abs(current.close - obLevel) < Math.abs(current.close - targetLevel)) {
                targetLevel = obLevel;
            }
        }
    }
    
    if (!targetLevel) {
        result.details.push('No target level found');
        return result;
    }
    
    const distanceToLevel = Math.abs(current.close - targetLevel) / targetLevel * 100;
    
    // 1. WICK TOUCH (max 30 points) - Proximity based
    const wickTouchLevel = direction === 'LONG' ? current.low : current.high;
    const wickDistance = Math.abs(wickTouchLevel - targetLevel) / targetLevel * 100;
    
    if (wickDistance <= 0.1) {
        result.breakdown.wickTouch = 30;
        result.details.push('Wick touched level exactly (+30)');
    } else if (wickDistance <= 0.3) {
        result.breakdown.wickTouch = 25;
        result.details.push('Wick very close to level (+25)');
    } else if (wickDistance <= 0.5) {
        result.breakdown.wickTouch = 20;
        result.details.push('Wick near level (+20)');
    } else if (wickDistance <= 1.0) {
        result.breakdown.wickTouch = 10;
        result.details.push('Wick approaching level (+10)');
    }
    
    // 2. BODY CLOSED (max 25 points)
    if (direction === 'LONG' && current.close > current.open && current.close > targetLevel) {
        result.breakdown.bodyClosed = 25;
        result.details.push('Body closed bullish above level (+25)');
    } else if (direction === 'SHORT' && current.close < current.open && current.close < targetLevel) {
        result.breakdown.bodyClosed = 25;
        result.details.push('Body closed bearish below level (+25)');
    } else if (direction === 'LONG' && current.close > current.open) {
        result.breakdown.bodyClosed = 15;
        result.details.push('Body closed bullish (+15)');
    } else if (direction === 'SHORT' && current.close < current.open) {
        result.breakdown.bodyClosed = 15;
        result.details.push('Body closed bearish (+15)');
    }
    
    // 3. WICK RATIO (max 20 points)
    const bodySize = Math.abs(current.close - current.open);
    const upperWick = current.high - Math.max(current.open, current.close);
    const lowerWick = Math.min(current.open, current.close) - current.low;
    const relevantWick = direction === 'LONG' ? lowerWick : upperWick;
    const wickRatio = bodySize > 0 ? relevantWick / bodySize : 0;
    
    if (wickRatio > 2) {
        result.breakdown.wickRatio = 20;
        result.details.push('Strong wick ratio >2x (+20)');
    } else if (wickRatio > 1.5) {
        result.breakdown.wickRatio = 15;
        result.details.push('Good wick ratio >1.5x (+15)');
    } else if (wickRatio > 1) {
        result.breakdown.wickRatio = 10;
        result.details.push('Moderate wick ratio >1x (+10)');
    }
    
    // 4. VOLUME CONFIRMATION (max 15 points) - FIXED: Safe calculation
    const volSlice = klines.slice(-20).filter(k => k?.volume > 0);
    const avgVolume = volSlice.length > 0 ? volSlice.reduce((sum, k) => sum + k.volume, 0) / volSlice.length : 1;
    const volumeRatio = avgVolume > 0 ? ((current?.volume || 0) / avgVolume) : 1;
    
    if (!isNaN(volumeRatio) && volumeRatio > 1.5) {
        result.breakdown.volumeConfirm = 15;
        result.details.push('High volume confirmation (+15)');
    } else if (volumeRatio > 1.2) {
        result.breakdown.volumeConfirm = 10;
        result.details.push('Good volume (+10)');
    } else if (volumeRatio > 1.0) {
        result.breakdown.volumeConfirm = 5;
        result.details.push('Normal volume (+5)');
    }
    
    // 5. FOLLOW THROUGH (max 10 points) - Check previous candle direction
    const prevDirection = prev.close > prev.open ? 'BULLISH' : 'BEARISH';
    const currDirection = current.close > current.open ? 'BULLISH' : 'BEARISH';
    
    if (direction === 'LONG' && currDirection === 'BULLISH' && prevDirection === 'BEARISH') {
        result.breakdown.followThrough = 10;
        result.details.push('Reversal follow-through (+10)');
    } else if (direction === 'SHORT' && currDirection === 'BEARISH' && prevDirection === 'BULLISH') {
        result.breakdown.followThrough = 10;
        result.details.push('Reversal follow-through (+10)');
    } else if ((direction === 'LONG' && currDirection === 'BULLISH') || 
               (direction === 'SHORT' && currDirection === 'BEARISH')) {
        result.breakdown.followThrough = 5;
        result.details.push('Directional alignment (+5)');
    }
    
    // Calculate total
    result.score = Object.values(result.breakdown).reduce((sum, v) => sum + v, 0);
    
    // Determine quality
    if (result.score >= 80) result.quality = 'PERFECT';
    else if (result.score >= 60) result.quality = 'STRONG';
    else if (result.score >= 40) result.quality = 'MODERATE';
    else if (result.score >= 20) result.quality = 'WEAK';
    else result.quality = 'NONE';
    
    return result;
}

// ZONE OVERRIDE CHECK - Can bypass weak SMC if zone is strong
function checkZoneOverride(zoneData, smcData, momentumData, direction, currentPrice) {
    const result = {
        eligible: false,
        conditions: {
            zoneScore: false,
            priceAtZone: false,
            touchCount: false,
            directionMatch: false,
            momentumNotOpposing: false,
            zoneFresh: false
        },
        passed: 0,
        required: 5,
        reason: ''
    };
    
    const zoneD = zoneData.details || {};
    const zoneScore = zoneData.score || 0;
    
    // Condition 1: Zone Score >= 75
    if (zoneScore >= 75) {
        result.conditions.zoneScore = true;
        result.passed++;
    }
    
    // Condition 2: Price within 1% of zone
    let targetZone = null;
    let distancePercent = 999;
    
    if (direction === 'LONG' && zoneD.nearestSupport) {
        targetZone = zoneD.nearestSupport;
        distancePercent = Math.abs(currentPrice - targetZone.price) / currentPrice * 100;
    } else if (direction === 'SHORT' && zoneD.nearestResistance) {
        targetZone = zoneD.nearestResistance;
        distancePercent = Math.abs(currentPrice - targetZone.price) / currentPrice * 100;
    }
    
    if (distancePercent <= 1.0) {
        result.conditions.priceAtZone = true;
        result.passed++;
    }
    
    // Condition 3: Zone has 3+ touches
    if (targetZone && targetZone.touches >= 3) {
        result.conditions.touchCount = true;
        result.passed++;
    }
    
    // Condition 4: Direction matches (LONG at support, SHORT at resistance)
    if ((direction === 'LONG' && zoneD.nearestSupport) || 
        (direction === 'SHORT' && zoneD.nearestResistance)) {
        result.conditions.directionMatch = true;
        result.passed++;
    }
    
    // Condition 5: Momentum NOT strongly opposing
    const momDir = momentumData.direction || 'NEUTRAL';
    const momScore = momentumData.score || 0;
    const momOpposing = (direction === 'LONG' && momDir === 'SHORT') || 
                        (direction === 'SHORT' && momDir === 'LONG');
    
    if (!momOpposing || momScore < 60) {
        result.conditions.momentumNotOpposing = true;
        result.passed++;
    }
    
    // Condition 6: Zone freshness (at least 1 touch in last 50 candles) - bonus
    if (targetZone && targetZone.lastTouch && targetZone.lastTouch < 50) {
        result.conditions.zoneFresh = true;
    }
    
    // Check eligibility (need 5 of 5 main conditions)
    result.eligible = result.passed >= 5;
    
    if (result.eligible) {
        result.reason = `Zone Override ACTIVE: ${result.passed}/5 conditions met`;
    } else {
        const missing = [];
        if (!result.conditions.zoneScore) missing.push('Zone<75');
        if (!result.conditions.priceAtZone) missing.push('Price>1%');
        if (!result.conditions.touchCount) missing.push('Touches<3');
        if (!result.conditions.directionMatch) missing.push('Direction');
        if (!result.conditions.momentumNotOpposing) missing.push('Momentum opposing');
        result.reason = `Zone Override DENIED: Missing ${missing.join(', ')}`;
    }
    
    return result;
}

// CONFLICT DETECTOR - Identifies and handles engine conflicts
function detectEngineConflicts(zoneData, smcData, momentumData, candlePatterns) {
    const result = {
        hasConflict: false,
        conflictCount: 0,
        neutralCount: 0,
        conflicts: [],
        directions: {
            zone: 'NEUTRAL',
            smc: 'NEUTRAL',
            momentum: 'NEUTRAL',
            candle: 'NEUTRAL'
        },
        votes: { LONG: 0, SHORT: 0, NEUTRAL: 0 },
        shouldSkip: false,
        reason: ''
    };
    
    // Get directions (treat score < 30 as NEUTRAL)
    result.directions.zone = (zoneData.score >= 30) ? (zoneData.direction || 'NEUTRAL') : 'NEUTRAL';
    result.directions.smc = (smcData.score >= 30) ? (smcData.direction || 'NEUTRAL') : 'NEUTRAL';
    result.directions.momentum = (momentumData.score >= 30) ? (momentumData.direction || 'NEUTRAL') : 'NEUTRAL';
    result.directions.candle = candlePatterns.patternSignal || 'NEUTRAL';
    
    // Normalize candle direction
    if (result.directions.candle === 'BULLISH') result.directions.candle = 'LONG';
    if (result.directions.candle === 'BEARISH') result.directions.candle = 'SHORT';
    
    // Count votes
    for (const [engine, dir] of Object.entries(result.directions)) {
        if (dir === 'LONG') result.votes.LONG++;
        else if (dir === 'SHORT') result.votes.SHORT++;
        else result.votes.NEUTRAL++;
    }
    
    result.neutralCount = result.votes.NEUTRAL;
    
    // Check for LONG vs SHORT conflicts
    const activeEngines = Object.entries(result.directions).filter(([k, v]) => v !== 'NEUTRAL');
    const longEngines = activeEngines.filter(([k, v]) => v === 'LONG').map(([k]) => k);
    const shortEngines = activeEngines.filter(([k, v]) => v === 'SHORT').map(([k]) => k);
    
    if (longEngines.length > 0 && shortEngines.length > 0) {
        result.hasConflict = true;
        result.conflictCount = Math.min(longEngines.length, shortEngines.length);
        result.conflicts.push(`${longEngines.join('+')} say LONG vs ${shortEngines.join('+')} say SHORT`);
    }
    
    // RULE 3: 2+ engines conflict → SKIP
    if (result.conflictCount >= 2) {
        result.shouldSkip = true;
        result.reason = 'RULE 3: 2+ engines conflict';
    }
    
    // RULE 4: 2+ engines NEUTRAL → WAIT (not skip, but warning)
    if (result.neutralCount >= 2 && !result.shouldSkip) {
        result.reason = 'RULE 4: 2+ engines neutral - low conviction';
    }
    
    return result;
}

// V5.1 ULTRA-RELAXED MANDATORY RULES - Almost never blocks
// V18: 7 MANDATORY RULES AS GATES - HARD BLOCKS
function checkMandatoryRules(zoneData, smcData, momentumData, htfBias, conflictResult, zoneOverride, trapDetection, direction) {
    const result = {
        allPassed: true,
        rules: {},
        verdict: 'TAKE',
        violations: [],
        blocked: false,
        blockReason: null
    };
    
    const smcScore = smcData?.score || 0;
    const zoneScore = zoneData?.score || 0;
    const momScore = momentumData?.score || 0;
    const momDir = momentumData?.direction || 'NEUTRAL';
    const htfPct = htfBias?.total > 0 ? (htfBias.aligned / htfBias.total) * 100 : 50;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // RULE 1: SMC < 20 → NO_TRADE (unless Zone Override)
    // ═══════════════════════════════════════════════════════════════════════════
    if (smcScore < 20) {
        if (zoneOverride?.eligible) {
            result.rules.rule1 = { passed: true, reason: 'Zone Override applied' };
            result.violations.push('⚠️ R1: SMC < 20 but Zone Override active');
        } else {
            result.rules.rule1 = { passed: false, reason: `SMC ${smcScore} < 20` };
            result.violations.push(`🚫 R1 BLOCKED: SMC ${smcScore} < 20`);
            result.blocked = true;
            result.blockReason = 'RULE_1_SMC_CRITICAL';
            result.verdict = 'NO_TRADE';
            result.allPassed = false;
        }
    } else {
        result.rules.rule1 = { passed: true, reason: `SMC ${smcScore} >= 20` };
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // RULE 2: SMC < 30 → SKIP (unless Zone Override)
    // ═══════════════════════════════════════════════════════════════════════════
    if (smcScore >= 20 && smcScore < 30) {
        if (zoneOverride?.eligible) {
            result.rules.rule2 = { passed: true, reason: 'Zone Override applied' };
            result.violations.push('⚠️ R2: SMC < 30 but Zone Override active');
        } else {
            result.rules.rule2 = { passed: false, reason: `SMC ${smcScore} < 30` };
            result.violations.push(`🚫 R2 BLOCKED: SMC ${smcScore} < 30 (no override)`);
            result.blocked = true;
            result.blockReason = 'RULE_2_SMC_WEAK';
            result.verdict = 'SKIP';
            result.allPassed = false;
        }
    } else {
        result.rules.rule2 = { passed: true, reason: smcScore >= 30 ? `SMC ${smcScore} >= 30` : 'N/A' };
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // RULE 3: 2+ engines conflict → SKIP
    // ═══════════════════════════════════════════════════════════════════════════
    if (conflictResult?.conflictCount >= 2) {
        result.rules.rule3 = { passed: false, reason: `${conflictResult.conflictCount} engines conflict` };
        result.violations.push(`🚫 R3 BLOCKED: ${conflictResult.conflictCount} engines conflict`);
        result.blocked = true;
        result.blockReason = 'RULE_3_CONFLICT';
        result.verdict = 'SKIP';
        result.allPassed = false;
    } else {
        result.rules.rule3 = { passed: true, reason: 'No major conflicts' };
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // RULE 4: 2+ engines NEUTRAL → WAIT (soft block - info only for EV learning)
    // ═══════════════════════════════════════════════════════════════════════════
    if (conflictResult?.neutralCount >= 2) {
        result.rules.rule4 = { passed: false, reason: `${conflictResult.neutralCount} engines neutral` };
        result.violations.push(`⏸️ R4: ${conflictResult.neutralCount} engines neutral → WAIT`);
        // V18: Soft block - let EV learner decide if these are actually profitable
        result.allPassed = false;
    } else {
        result.rules.rule4 = { passed: true, reason: 'Engines have direction' };
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // RULE 5: Momentum opposes + score ≥ 60 → SKIP (raised threshold for EV)
    // ═══════════════════════════════════════════════════════════════════════════
    const momOpposes = (direction === 'LONG' && momDir === 'SHORT') || 
                       (direction === 'SHORT' && momDir === 'LONG');
    if (momOpposes && momScore >= 60) {
        result.rules.rule5 = { passed: false, reason: `Momentum ${momDir} (${momScore}) opposes ${direction}` };
        result.violations.push(`🚫 R5 BLOCKED: Strong momentum opposes (${momScore})`);
        result.blocked = true;
        result.blockReason = 'RULE_5_MOMENTUM_OPPOSE';
        result.verdict = 'SKIP';
        result.allPassed = false;
    } else {
        result.rules.rule5 = { passed: true, reason: momOpposes ? `Momentum weak (${momScore})` : 'Momentum aligned' };
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // RULE 6: HTF < 40% → SKIP (lowered from 50% for EV learning flexibility)
    // ═══════════════════════════════════════════════════════════════════════════
    if (htfPct < 40) {
        result.rules.rule6 = { passed: false, reason: `HTF ${htfPct.toFixed(0)}% < 40%` };
        result.violations.push(`🚫 R6 BLOCKED: HTF alignment ${htfPct.toFixed(0)}% < 40%`);
        result.blocked = true;
        result.blockReason = 'RULE_6_HTF_WEAK';
        result.verdict = 'SKIP';
        result.allPassed = false;
    } else {
        result.rules.rule6 = { passed: true, reason: `HTF ${htfPct.toFixed(0)}% >= 40%` };
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // RULE 7: Trap HIGH confidence → NO_TRADE
    // ═══════════════════════════════════════════════════════════════════════════
    if (trapDetection?.confidence === 'HIGH') {
        result.rules.rule7 = { passed: false, reason: `${trapDetection.type} detected` };
        result.violations.push(`🚫 R7 BLOCKED: ${trapDetection.type} HIGH confidence`);
        result.blocked = true;
        result.blockReason = 'RULE_7_TRAP';
        result.verdict = 'NO_TRADE';
        result.allPassed = false;
    } else {
        result.rules.rule7 = { passed: true, reason: trapDetection?.confidence === 'MEDIUM' ? 'Medium trap risk' : 'No trap detected' };
    }
    
    return result;
}

// ULTIMATE SCORE CALCULATOR - New formula
function calculateUltimateScore(sequenceResult, rejectionResult, htfBias, momentumData, volumeConfirmed) {
    // NEW FORMULA: Sequence 40% + Rejection 25% + HTF 15% + Momentum 10% + Volume 10%
    const sequenceScore = sequenceResult.score || 0;
    const rejectionScore = rejectionResult.score || 0;
    const htfScore = htfBias.total > 0 ? (htfBias.aligned / htfBias.total) * 100 : 50;
    // FIX: Use typeof check so score of 0 is valid (not replaced with 50)
    const momentumScore = typeof momentumData.score === 'number' ? momentumData.score : 50;
    const volumeScore = volumeConfirmed ? 100 : 50;
    
    const finalScore = 
        (sequenceScore * 0.40) +
        (rejectionScore * 0.25) +
        (htfScore * 0.15) +
        (momentumScore * 0.10) +
        (volumeScore * 0.10);
    
    return {
        final: Math.round(finalScore),
        breakdown: {
            sequence: { raw: sequenceScore, weighted: Math.round(sequenceScore * 0.40), weight: '40%' },
            rejection: { raw: rejectionScore, weighted: Math.round(rejectionScore * 0.25), weight: '25%' },
            htf: { raw: Math.round(htfScore), weighted: Math.round(htfScore * 0.15), weight: '15%' },
            momentum: { raw: momentumScore, weighted: Math.round(momentumScore * 0.10), weight: '10%' },
            volume: { raw: volumeScore, weighted: Math.round(volumeScore * 0.10), weight: '10%' }
        }
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// MOMENTUM ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════════

// Calculate RSI with Wilder Smoothing (correct implementation)
function calcRSI(closes, period = 14) {
    if (!closes || closes.length < period + 1) return { value: 50, trend: 'NEUTRAL' };
    
    const gains = [];
    const losses = [];
    
    for (let i = 1; i < closes.length; i++) {
        const change = closes[i] - closes[i - 1];
        gains.push(change > 0 ? change : 0);
        losses.push(change < 0 ? -change : 0);
    }
    
    // Initial average (SMA)
    let avgGain = 0;
    let avgLoss = 0;
    for (let i = 0; i < period; i++) {
        avgGain += gains[i];
        avgLoss += losses[i];
    }
    avgGain /= period;
    avgLoss /= period;
    
    // Wilder smoothing for remaining values
    for (let i = period; i < gains.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
    }
    
    if (avgLoss === 0) return { value: 100, trend: 'OVERBOUGHT' };
    
    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));
    
    let trend = 'NEUTRAL';
    if (rsi >= 70) trend = 'OVERBOUGHT';
    else if (rsi >= 60) trend = 'BULLISH';
    else if (rsi <= 30) trend = 'OVERSOLD';
    else if (rsi <= 40) trend = 'BEARISH';
    
    return { value: rsi, trend, avgGain, avgLoss };
}

// Calculate MACD with Signal Line and Histogram
function calcMACD(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
    if (!closes || closes.length < slowPeriod + signalPeriod) {
        return { macd: 0, signal: 0, histogram: 0, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate EMAs
    const calcEMA = (data, period) => {
        const k = 2 / (period + 1);
        let ema = data[0];
        const emaValues = [ema];
        
        for (let i = 1; i < data.length; i++) {
            ema = data[i] * k + ema * (1 - k);
            emaValues.push(ema);
        }
        return emaValues;
    };
    
    const ema12 = calcEMA(closes, fastPeriod);
    const ema26 = calcEMA(closes, slowPeriod);
    
    // MACD Line
    const macdLine = [];
    for (let i = 0; i < closes.length; i++) {
        macdLine.push(ema12[i] - ema26[i]);
    }
    
    // Signal Line (EMA of MACD)
    const signalLine = calcEMA(macdLine.slice(slowPeriod - 1), signalPeriod);
    
    const currentMACD = macdLine[macdLine.length - 1];
    const currentSignal = signalLine[signalLine.length - 1];
    const prevMACD = macdLine[macdLine.length - 2];
    const prevSignal = signalLine[signalLine.length - 2];
    const histogram = currentMACD - currentSignal;
    const prevHistogram = prevMACD - prevSignal;
    
    // Detect crossover
    let crossover = null;
    if (prevMACD <= prevSignal && currentMACD > currentSignal) {
        crossover = 'BULLISH';
    } else if (prevMACD >= prevSignal && currentMACD < currentSignal) {
        crossover = 'BEARISH';
    }
    
    // Histogram momentum
    let histogramTrend = 'NEUTRAL';
    if (histogram > 0 && histogram > prevHistogram) histogramTrend = 'BULLISH_EXPANDING';
    else if (histogram > 0 && histogram < prevHistogram) histogramTrend = 'BULLISH_CONTRACTING';
    else if (histogram < 0 && histogram < prevHistogram) histogramTrend = 'BEARISH_EXPANDING';
    else if (histogram < 0 && histogram > prevHistogram) histogramTrend = 'BEARISH_CONTRACTING';
    
    let trend = 'NEUTRAL';
    if (currentMACD > 0 && currentMACD > currentSignal) trend = 'BULLISH';
    else if (currentMACD < 0 && currentMACD < currentSignal) trend = 'BEARISH';
    
    return {
        macd: currentMACD,
        signal: currentSignal,
        histogram,
        histogramTrend,
        trend,
        crossover,
        ema12: ema12[ema12.length - 1],
        ema26: ema26[ema26.length - 1]
    };
}

// Calculate ADX with DI+ and DI-
function calcADX(klines, period = 14) {
    // SAFETY: Comprehensive null/edge case checks
    if (!klines || !Array.isArray(klines) || klines.length < period * 2) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK', crossover: null, trending: false };
    }
    
    const plusDM = [];
    const minusDM = [];
    const tr = [];
    
    for (let i = 1; i < klines.length; i++) {
        const candle = klines[i];
        const prevCandle = klines[i - 1];
        
        // SAFETY: Validate candle data exists
        if (!candle || !prevCandle) continue;
        
        const high = candle.high || 0;
        const low = candle.low || 0;
        const prevHigh = prevCandle.high || 0;
        const prevLow = prevCandle.low || 0;
        const prevClose = prevCandle.close || 0;
        
        // Directional Movement
        const upMove = high - prevHigh;
        const downMove = prevLow - low;
        
        plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
        minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);
        
        // True Range
        tr.push(Math.max(
            high - low,
            Math.abs(high - prevClose),
            Math.abs(low - prevClose)
        ));
    }
    
    // SAFETY: Check we have enough data after filtering
    if (plusDM.length < period || minusDM.length < period || tr.length < period) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK', crossover: null, trending: false };
    }
    
    // Smoothed values
    let smoothPlusDM = 0;
    let smoothMinusDM = 0;
    let smoothTR = 0;
    
    for (let i = 0; i < period; i++) {
        smoothPlusDM += plusDM[i] || 0;
        smoothMinusDM += minusDM[i] || 0;
        smoothTR += tr[i] || 0;
    }
    
    const dxValues = [];
    
    for (let i = period; i < plusDM.length; i++) {
        smoothPlusDM = smoothPlusDM - smoothPlusDM / period + (plusDM[i] || 0);
        smoothMinusDM = smoothMinusDM - smoothMinusDM / period + (minusDM[i] || 0);
        smoothTR = smoothTR - smoothTR / period + (tr[i] || 0);
        
        // SAFETY: Prevent division by zero
        const diPlus = smoothTR > 0 ? (smoothPlusDM / smoothTR) * 100 : 0;
        const diMinus = smoothTR > 0 ? (smoothMinusDM / smoothTR) * 100 : 0;
        const diSum = diPlus + diMinus;
        const dx = diSum > 0 ? Math.abs(diPlus - diMinus) / diSum * 100 : 0;
        
        dxValues.push({ dx, diPlus, diMinus });
    }
    
    if (dxValues.length < period) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK', crossover: null, trending: false };
    }
    
    // ADX (smoothed DX)
    let adx = 0;
    for (let i = 0; i < period; i++) {
        adx += dxValues[i]?.dx || 0;
    }
    adx /= period;
    
    for (let i = period; i < dxValues.length; i++) {
        adx = (adx * (period - 1) + (dxValues[i]?.dx || 0)) / period;
    }
    
    // SAFETY: Ensure we have DI values
    const lastDI = dxValues[dxValues.length - 1] || { diPlus: 0, diMinus: 0 };
    const prevDI = dxValues[dxValues.length - 2] || { diPlus: 0, diMinus: 0 };
    
    // Trend direction and strength
    let trend = 'NEUTRAL';
    if (lastDI.diPlus > lastDI.diMinus) trend = 'BULLISH';
    else if (lastDI.diMinus > lastDI.diPlus) trend = 'BEARISH';
    
    let strength = 'WEAK';
    if (adx >= 50) strength = 'VERY_STRONG';
    else if (adx >= 35) strength = 'STRONG';
    else if (adx >= 25) strength = 'TRENDING';
    else if (adx >= 20) strength = 'WEAK_TREND';
    
    // DI crossover detection
    let crossover = null;
    if (prevDI.diPlus <= prevDI.diMinus && lastDI.diPlus > lastDI.diMinus) {
        crossover = 'BULLISH';
    } else if (prevDI.diPlus >= prevDI.diMinus && lastDI.diPlus < lastDI.diMinus) {
        crossover = 'BEARISH';
    }
    
    return {
        adx: isNaN(adx) ? 0 : adx,
        diPlus: isNaN(lastDI.diPlus) ? 0 : lastDI.diPlus,
        diMinus: isNaN(lastDI.diMinus) ? 0 : lastDI.diMinus,
        trend,
        strength,
        crossover,
        trending: adx >= 25
    };
}

// Calculate Stochastic RSI
function calcStochRSI(closes, rsiPeriod = 14, stochPeriod = 14, kPeriod = 3, dPeriod = 3) {
    if (!closes || closes.length < rsiPeriod + stochPeriod + kPeriod) {
        return { k: 50, d: 50, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate RSI values
    const rsiValues = [];
    for (let i = rsiPeriod; i < closes.length; i++) {
        const rsi = calcRSI(closes.slice(0, i + 1), rsiPeriod);
        rsiValues.push(rsi.value);
    }
    
    if (rsiValues.length < stochPeriod) {
        return { k: 50, d: 50, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate Stochastic of RSI
    const stochRSI = [];
    for (let i = stochPeriod - 1; i < rsiValues.length; i++) {
        const period = rsiValues.slice(i - stochPeriod + 1, i + 1);
        const minRSI = Math.min(...period);
        const maxRSI = Math.max(...period);
        const range = maxRSI - minRSI;
        
        if (range === 0) {
            stochRSI.push(50);
        } else {
            stochRSI.push(((rsiValues[i] - minRSI) / range) * 100);
        }
    }
    
    // Calculate %K (SMA of Stochastic RSI)
    const kValues = [];
    for (let i = kPeriod - 1; i < stochRSI.length; i++) {
        const sum = stochRSI.slice(i - kPeriod + 1, i + 1).reduce((a, b) => a + b, 0);
        kValues.push(sum / kPeriod);
    }
    
    // Calculate %D (SMA of %K)
    const dValues = [];
    for (let i = dPeriod - 1; i < kValues.length; i++) {
        const sum = kValues.slice(i - dPeriod + 1, i + 1).reduce((a, b) => a + b, 0);
        dValues.push(sum / dPeriod);
    }
    
    const k = kValues[kValues.length - 1] || 50;
    const d = dValues[dValues.length - 1] || 50;
    const prevK = kValues[kValues.length - 2] || 50;
    const prevD = dValues[dValues.length - 2] || 50;
    
    // Crossover detection
    let crossover = null;
    if (prevK <= prevD && k > d) crossover = 'BULLISH';
    else if (prevK >= prevD && k < d) crossover = 'BEARISH';
    
    let trend = 'NEUTRAL';
    if (k >= 80) trend = 'OVERBOUGHT';
    else if (k <= 20) trend = 'OVERSOLD';
    else if (k > d && k > 50) trend = 'BULLISH';
    else if (k < d && k < 50) trend = 'BEARISH';
    
    return { k, d, trend, crossover };
}

// Calculate On-Balance Volume (OBV) with trend
function calcOBV(klines) {
    if (!klines || klines.length < 20) {
        return { obv: 0, trend: 'NEUTRAL', divergence: null };
    }
    
    let obv = 0;
    const obvValues = [0];
    
    for (let i = 1; i < klines.length; i++) {
        if (klines[i].close > klines[i - 1].close) {
            obv += klines[i].volume;
        } else if (klines[i].close < klines[i - 1].close) {
            obv -= klines[i].volume;
        }
        obvValues.push(obv);
    }
    
    // Calculate OBV trend using EMA
    const len = obvValues.length;
    const shortEMA = obvValues.slice(-10).reduce((a, b) => a + b, 0) / 10;
    const longEMA = obvValues.slice(-20).reduce((a, b) => a + b, 0) / 20;
    
    let trend = 'NEUTRAL';
    if (shortEMA > longEMA * 1.05) trend = 'BULLISH';
    else if (shortEMA < longEMA * 0.95) trend = 'BEARISH';
    
    // Check for OBV divergence with price
    const recentOBV = obvValues.slice(-20);
    const recentClose = klines.slice(-20).map(k => k.close);
    
    const priceUp = recentClose[recentClose.length - 1] > recentClose[0];
    const obvUp = recentOBV[recentOBV.length - 1] > recentOBV[0];
    
    let divergence = null;
    if (priceUp && !obvUp) divergence = 'BEARISH'; // Price up, OBV down
    else if (!priceUp && obvUp) divergence = 'BULLISH'; // Price down, OBV up
    
    return {
        obv: obvValues[obvValues.length - 1],
        obvValues,
        trend,
        divergence,
        shortEMA,
        longEMA
    };
}

// Calculate Volume Metrics
function calcVolumeMetrics(klines) {
    if (!klines || klines.length < 25) {
        return { ratio: 1, spike: false, trend: 'NEUTRAL' };
    }
    
    const len = klines.length;
    const currentVolume = klines[len - 1].volume;
    
    // Average volume (20 period)
    const avgVolume = klines.slice(-21, -1).reduce((sum, k) => sum + k.volume, 0) / 20;
    
    const ratio = avgVolume > 0 ? currentVolume / avgVolume : 1;
    const spike = ratio >= 2.5;
    
    // Volume trend
    const recentAvg = klines.slice(-5).reduce((sum, k) => sum + k.volume, 0) / 5;
    const olderAvg = klines.slice(-15, -10).reduce((sum, k) => sum + k.volume, 0) / 5;
    
    let trend = 'NEUTRAL';
    if (recentAvg > olderAvg * 1.3) trend = 'INCREASING';
    else if (recentAvg < olderAvg * 0.7) trend = 'DECREASING';
    
    return {
        current: currentVolume,
        average: avgVolume,
        ratio,
        spike,
        trend,
        percentAboveAvg: ((ratio - 1) * 100)
    };
}


// Calculate EMA values
function calcEMA(closes, period) {
    if (!closes || closes.length < period) return null;
    
    const k = 2 / (period + 1);
    let ema = closes.slice(0, period).reduce((a, b) => a + b, 0) / period;
    
    for (let i = period; i < closes.length; i++) {
        ema = closes[i] * k + ema * (1 - k);
    }
    
    return ema;
}

// Get EMA Cross signals (9/21 for scalping, 50/200 for trend)
function getEMACross(closes) {
    if (!closes || closes.length < 200) {
        return { 
            ema9: 0, ema21: 0, ema50: 0, ema200: 0,
            shortCross: null, longCross: null, 
            priceVsEMA: 'NEUTRAL'
        };
    }
    
    const ema9 = calcEMA(closes, 9);
    const ema21 = calcEMA(closes, 21);
    const ema50 = calcEMA(closes, 50);
    const ema200 = calcEMA(closes, 200);
    const currentPrice = closes[closes.length - 1];
    
    // Calculate previous EMAs for crossover detection
    const prevCloses = closes.slice(0, -1);
    const prevEma9 = calcEMA(prevCloses, 9);
    const prevEma21 = calcEMA(prevCloses, 21);
    const prevEma50 = calcEMA(prevCloses, 50);
    const prevEma200 = calcEMA(prevCloses, 200);
    
    // Short-term cross (9/21)
    let shortCross = null;
    if (prevEma9 <= prevEma21 && ema9 > ema21) shortCross = 'BULLISH';
    else if (prevEma9 >= prevEma21 && ema9 < ema21) shortCross = 'BEARISH';
    
    // Long-term cross (50/200 - Golden/Death Cross)
    let longCross = null;
    if (prevEma50 <= prevEma200 && ema50 > ema200) longCross = 'GOLDEN';
    else if (prevEma50 >= prevEma200 && ema50 < ema200) longCross = 'DEATH';
    
    // Price position vs EMAs
    let priceVsEMA = 'NEUTRAL';
    if (currentPrice > ema9 && currentPrice > ema21 && currentPrice > ema50) {
        priceVsEMA = 'STRONG_BULLISH';
    } else if (currentPrice > ema9 && currentPrice > ema21) {
        priceVsEMA = 'BULLISH';
    } else if (currentPrice < ema9 && currentPrice < ema21 && currentPrice < ema50) {
        priceVsEMA = 'STRONG_BEARISH';
    } else if (currentPrice < ema9 && currentPrice < ema21) {
        priceVsEMA = 'BEARISH';
    }
    
    return {
        ema9, ema21, ema50, ema200,
        shortCross, longCross,
        priceVsEMA,
        aboveEMA200: currentPrice > ema200,
        aboveEMA50: currentPrice > ema50
    };
}

// Detect Divergence (Regular, Hidden, Compound)
function detectDivergence(klines, indicatorFn = 'rsi') {
    if (!klines || klines.length < 50) {
        return { type: null, strength: null, direction: null };
    }
    
    const closes = klines.map(k => k.close);
    const highs = klines.map(k => k.high);
    const lows = klines.map(k => k.low);
    
    // Find swing points in price
    const priceSwings = findSwingPoints(klines, 4, 4);
    
    // Calculate indicator values
    let indicatorValues = [];
    if (indicatorFn === 'rsi') {
        for (let i = 14; i < closes.length; i++) {
            indicatorValues.push({
                index: i,
                value: calcRSI(closes.slice(0, i + 1), 14).value
            });
        }
    } else if (indicatorFn === 'macd') {
        for (let i = 35; i < closes.length; i++) {
            indicatorValues.push({
                index: i,
                value: calcMACD(closes.slice(0, i + 1)).histogram
            });
        }
    }
    
    if (indicatorValues.length < 20 || priceSwings.highs.length < 2 || priceSwings.lows.length < 2) {
        return { type: null, strength: null, direction: null };
    }
    
    // Get indicator values at swing points
    const getIndicatorAtIndex = (idx) => {
        const found = indicatorValues.find(v => v.index === idx);
        if (found) return found.value;
        // Find closest
        const closest = indicatorValues.reduce((prev, curr) => 
            Math.abs(curr.index - idx) < Math.abs(prev.index - idx) ? curr : prev
        );
        return closest.value;
    };
    
    // Check for Regular Bullish Divergence (price lower low, indicator higher low)
    const recentLows = priceSwings.lows.slice(-4);
    for (let i = 0; i < recentLows.length - 1; i++) {
        const firstLow = recentLows[i];
        const secondLow = recentLows[i + 1];
        
        const ind1 = getIndicatorAtIndex(firstLow.index);
        const ind2 = getIndicatorAtIndex(secondLow.index);
        
        // Price makes lower low, indicator makes higher low
        if (secondLow.price < firstLow.price && ind2 > ind1) {
            // Check for compound (3+ swings)
            if (i > 0) {
                const thirdLow = recentLows[i - 1];
                const ind0 = getIndicatorAtIndex(thirdLow.index);
                if (thirdLow.price > firstLow.price && ind0 < ind1) {
                    return { type: 'COMPOUND', strength: 'STRONG', direction: 'BULLISH' };
                }
            }
            return { type: 'REGULAR', strength: 'MEDIUM', direction: 'BULLISH' };
        }
        
        // Hidden Bullish: price higher low, indicator lower low
        if (secondLow.price > firstLow.price && ind2 < ind1) {
            return { type: 'HIDDEN', strength: 'MEDIUM', direction: 'BULLISH' };
        }
    }
    
    // Check for Regular Bearish Divergence (price higher high, indicator lower high)
    const recentHighs = priceSwings.highs.slice(-4);
    for (let i = 0; i < recentHighs.length - 1; i++) {
        const firstHigh = recentHighs[i];
        const secondHigh = recentHighs[i + 1];
        
        const ind1 = getIndicatorAtIndex(firstHigh.index);
        const ind2 = getIndicatorAtIndex(secondHigh.index);
        
        // Price makes higher high, indicator makes lower high
        if (secondHigh.price > firstHigh.price && ind2 < ind1) {
            // Check for compound
            if (i > 0) {
                const thirdHigh = recentHighs[i - 1];
                const ind0 = getIndicatorAtIndex(thirdHigh.index);
                if (thirdHigh.price < firstHigh.price && ind0 > ind1) {
                    return { type: 'COMPOUND', strength: 'STRONG', direction: 'BEARISH' };
                }
            }
            return { type: 'REGULAR', strength: 'MEDIUM', direction: 'BEARISH' };
        }
        
        // Hidden Bearish: price lower high, indicator higher high
        if (secondHigh.price < firstHigh.price && ind2 > ind1) {
            return { type: 'HIDDEN', strength: 'MEDIUM', direction: 'BEARISH' };
        }
    }
    
    return { type: null, strength: null, direction: null };
}

// Detect Momentum Exhaustion
function detectExhaustion(klines, rsi, macd, volume) {
    if (!klines || klines.length < 20) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const isBullishCandle = currentCandle.close > currentCandle.open;
    
    // Bullish Exhaustion: RSI overbought + volume spike + small body or doji
    if (rsi.value >= 70 && volume.spike) {
        const body = Math.abs(currentCandle.close - currentCandle.open);
        const range = currentCandle.high - currentCandle.low;
        const bodyRatio = range > 0 ? body / range : 0;
        
        if (bodyRatio < 0.3) { // Small body (doji-like)
            return {
                detected: true,
                direction: 'BEARISH', // Bullish exhaustion = bearish signal
                reason: 'RSI OB + Vol spike + weak candle'
            };
        }
        
        // Check for shooting star / hanging man
        const upperWick = currentCandle.high - Math.max(currentCandle.open, currentCandle.close);
        if (upperWick > body * 2) {
            return {
                detected: true,
                direction: 'BEARISH',
                reason: 'Rejection candle at RSI OB'
            };
        }
    }
    
    // Bearish Exhaustion: RSI oversold + volume spike + small body
    if (rsi.value <= 30 && volume.spike) {
        const body = Math.abs(currentCandle.close - currentCandle.open);
        const range = currentCandle.high - currentCandle.low;
        const bodyRatio = range > 0 ? body / range : 0;
        
        if (bodyRatio < 0.3) {
            return {
                detected: true,
                direction: 'BULLISH', // Bearish exhaustion = bullish signal
                reason: 'RSI OS + Vol spike + weak candle'
            };
        }
        
        // Check for hammer
        const lowerWick = Math.min(currentCandle.open, currentCandle.close) - currentCandle.low;
        if (lowerWick > body * 2) {
            return {
                detected: true,
                direction: 'BULLISH',
                reason: 'Hammer candle at RSI OS'
            };
        }
    }
    
    // MACD histogram exhaustion
    if (macd.histogramTrend === 'BULLISH_CONTRACTING' && rsi.value > 65) {
        return {
            detected: true,
            direction: 'BEARISH',
            reason: 'MACD momentum fading'
        };
    }
    
    if (macd.histogramTrend === 'BEARISH_CONTRACTING' && rsi.value < 35) {
        return {
            detected: true,
            direction: 'BULLISH',
            reason: 'MACD momentum fading'
        };
    }
    
    return { detected: false };
}

// Calculate ATR for volatility
function calcATR(klines, period = 14) {
    if (!klines || klines.length < period + 1) return 0;
    
    const tr = [];
    for (let i = 1; i < klines.length; i++) {
        tr.push(Math.max(
            klines[i].high - klines[i].low,
            Math.abs(klines[i].high - klines[i - 1].close),
            Math.abs(klines[i].low - klines[i - 1].close)
        ));
    }
    
    // Wilder smoothing
    let atr = tr.slice(0, period).reduce((a, b) => a + b, 0) / period;
    
    for (let i = period; i < tr.length; i++) {
        atr = (atr * (period - 1) + tr[i]) / period;
    }
    
    return atr;
}

// MAIN MOMENTUM ANALYSIS FUNCTION
function performMomentumAnalysis(klines) {
    const result = {
        score: 0,
        direction: null,
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const closes = klines.map(k => k.close);
    
    // Calculate all indicators
    const rsi = calcRSI(closes, 14);
    result.details.rsi = rsi;
    
    const macd = calcMACD(closes);
    result.details.macd = macd;
    
    const adx = calcADX(klines, 14);
    result.details.adx = adx;
    
    const stochRSI = calcStochRSI(closes);
    result.details.stochRSI = stochRSI;
    
    const obv = calcOBV(klines);
    result.details.obv = obv;
    
    const volume = calcVolumeMetrics(klines);
    result.details.volume = volume;
    
    const emaCross = getEMACross(closes);
    result.details.emaCross = emaCross;
    
    const divergenceRSI = detectDivergence(klines, 'rsi');
    const divergenceMACD = detectDivergence(klines, 'macd');
    result.details.divergence = { rsi: divergenceRSI, macd: divergenceMACD };
    
    const exhaustion = detectExhaustion(klines, rsi, macd, volume);
    result.details.exhaustion = exhaustion;
    
    const atr = calcATR(klines);
    result.details.atr = atr;
    
    // SCORING
    let bullScore = 0;
    let bearScore = 0;
    
    // RSI (max 25 points)
    if (rsi.value <= 30) {
        bullScore += 25;
        result.factors.push(`RSI OS(${rsi.value.toFixed(0)})`);
    } else if (rsi.value <= 40) {
        bullScore += 12;
        result.factors.push(`RSI Low(${rsi.value.toFixed(0)})`);
    } else if (rsi.value >= 70) {
        bearScore += 25;
        result.factors.push(`RSI OB(${rsi.value.toFixed(0)})`);
    } else if (rsi.value >= 60) {
        bearScore += 12;
        result.factors.push(`RSI High(${rsi.value.toFixed(0)})`);
    }
    
    // MACD (max 20 points)
    if (macd.crossover === 'BULLISH') {
        bullScore += 20;
        result.factors.push('MACD Cross↑');
    } else if (macd.crossover === 'BEARISH') {
        bearScore += 20;
        result.factors.push('MACD Cross↓');
    } else if (macd.trend === 'BULLISH') {
        bullScore += 10;
        result.factors.push('MACD+');
    } else if (macd.trend === 'BEARISH') {
        bearScore += 10;
        result.factors.push('MACD-');
    }
    
    // MACD Histogram momentum
    if (macd.histogramTrend === 'BULLISH_EXPANDING') {
        bullScore += 8;
        result.factors.push('Hist↑↑');
    } else if (macd.histogramTrend === 'BEARISH_EXPANDING') {
        bearScore += 8;
        result.factors.push('Hist↓↓');
    }
    
    // ADX (max 15 points)
    if (adx.trending) {
        if (adx.trend === 'BULLISH') {
            bullScore += 15;
            result.factors.push(`ADX↑(${adx.adx.toFixed(0)})`);
        } else if (adx.trend === 'BEARISH') {
            bearScore += 15;
            result.factors.push(`ADX↓(${adx.adx.toFixed(0)})`);
        }
        
        if (adx.crossover === 'BULLISH') {
            bullScore += 8;
            result.factors.push('DI+ Cross');
        } else if (adx.crossover === 'BEARISH') {
            bearScore += 8;
            result.factors.push('DI- Cross');
        }
    } else {
        result.warnings.push('Weak trend (ADX<25)');
    }
    
    // Stochastic RSI (max 15 points)
    if (stochRSI.trend === 'OVERSOLD') {
        bullScore += 12;
        result.factors.push('StochRSI OS');
    } else if (stochRSI.trend === 'OVERBOUGHT') {
        bearScore += 12;
        result.factors.push('StochRSI OB');
    }
    
    if (stochRSI.crossover === 'BULLISH' && stochRSI.k < 30) {
        bullScore += 10;
        result.factors.push('StochRSI Cross↑');
    } else if (stochRSI.crossover === 'BEARISH' && stochRSI.k > 70) {
        bearScore += 10;
        result.factors.push('StochRSI Cross↓');
    }
    
    // OBV (max 10 points)
    if (obv.trend === 'BULLISH') {
        bullScore += 8;
        result.factors.push('OBV+');
    } else if (obv.trend === 'BEARISH') {
        bearScore += 8;
        result.factors.push('OBV-');
    }
    
    if (obv.divergence === 'BULLISH') {
        bullScore += 10;
        result.factors.push('OBV Div↑');
    } else if (obv.divergence === 'BEARISH') {
        bearScore += 10;
        result.factors.push('OBV Div↓');
    }
    
    // Volume (max 10 points)
    if (volume.spike) {
        result.factors.push(`Vol Spike(${volume.ratio.toFixed(1)}x)`);
        // Volume confirms direction
    }
    
    // EMA Cross (max 12 points)
    if (emaCross.shortCross === 'BULLISH') {
        bullScore += 12;
        result.factors.push('EMA 9/21↑');
    } else if (emaCross.shortCross === 'BEARISH') {
        bearScore += 12;
        result.factors.push('EMA 9/21↓');
    }
    
    if (emaCross.priceVsEMA === 'STRONG_BULLISH') {
        bullScore += 8;
    } else if (emaCross.priceVsEMA === 'STRONG_BEARISH') {
        bearScore += 8;
    }
    
    if (emaCross.longCross === 'GOLDEN') {
        bullScore += 15;
        result.factors.push('Golden Cross!');
    } else if (emaCross.longCross === 'DEATH') {
        bearScore += 15;
        result.factors.push('Death Cross!');
    }
    
    // Divergence (max 25 points)
    const div = divergenceRSI.type ? divergenceRSI : divergenceMACD;
    if (div.type) {
        const divPoints = div.type === 'COMPOUND' ? 25 : div.type === 'REGULAR' ? 18 : 10;
        if (div.direction === 'BULLISH') {
            bullScore += divPoints;
            result.factors.push(`${div.type} Div↑`);
        } else {
            bearScore += divPoints;
            result.factors.push(`${div.type} Div↓`);
        }
    }
    
    // Exhaustion (warning)
    if (exhaustion.detected) {
        result.warnings.push(exhaustion.reason);
        if (exhaustion.direction === 'BULLISH') {
            bullScore += 5;
        } else {
            bearScore += 5;
        }
    }
    
    // Determine direction
    if (bullScore > bearScore + 10) {
        result.direction = 'LONG';
        result.score = Math.min(100, bullScore);
    } else if (bearScore > bullScore + 10) {
        result.direction = 'SHORT';
        result.score = Math.min(100, bearScore);
    } else {
        result.direction = null;
        result.score = Math.min(100, Math.max(bullScore, bearScore) * 0.6);
        result.warnings.push('Mixed momentum signals');
    }
    
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF PART 3 - Momentum Analysis Complete
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// 🧠 SMART TRADE SYSTEM - 6 INTELLIGENT ENGINES
// ═══════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 1: SMART STOP LOSS
// Finds structure-based SL that avoids liquidity traps
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartSL(direction, currentPrice, klines, atr) {
    const result = {
        price: null,
        reason: '',
        riskPct: 0,
        trapAvoided: false,
        structureUsed: null,
        score: 0
    };
    
    if (!klines || klines.length < 50) {
        // Fallback to ATR-based SL
        result.price = direction === 'LONG' 
            ? currentPrice - (atr * 2)
            : currentPrice + (atr * 2);
        result.reason = 'ATR fallback';
        result.riskPct = ((Math.abs(currentPrice - result.price) / currentPrice) * 100).toFixed(2);
        return result;
    }
    
    // Get all structure data
    const swings = findSwingPoints(klines, 5, 5);
    const equalLevels = detectEqualLevels(klines, 0.002);
    const orderBlocks = detectOrderBlocks(klines, 50);
    
    // Collect candidate SL levels
    const candidates = [];
    
    if (direction === 'LONG') {
        // Find swing lows below current price
        swings.lows.filter(s => s.price < currentPrice).forEach(swing => {
            const dist = ((currentPrice - swing.price) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) { // Between 0.3% and 5%
                candidates.push({
                    price: swing.price * 0.998, // Buffer below
                    type: 'SWING',
                    dist: dist,
                    score: 50
                });
            }
        });
        
        // Find bullish OBs below current price (SL below OB low)
        orderBlocks.bullish.filter(ob => ob.low < currentPrice && ob.fresh).forEach(ob => {
            const dist = ((currentPrice - ob.low) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) {
                candidates.push({
                    price: ob.low * 0.997, // Buffer below OB
                    type: 'OB',
                    dist: dist,
                    score: ob.fresh ? 70 : 40
                });
            }
        });
        
        // Check for equal lows (TRAP ZONES - avoid these!)
        const trapZones = equalLevels.equalLows.filter(el => el.price < currentPrice);
        
        // Score and filter candidates - FIXED: No distance bonus, stronger penalties
        candidates.forEach(c => {
            // FIX 1: REMOVED distance bonus - SL should be structure-based, not R:R optimized
            // Tight SLs are NOT better - they get hunted
            
            // FIX 2: ATR validation with STRONGER penalty
            const atrRatio = (currentPrice - c.price) / atr;
            if (atrRatio >= 1.5) c.score += 20;      // Good - gives room
            else if (atrRatio >= 1) c.score += 10;   // OK
            else c.score -= 30;                       // FIX: Was -10, now -30 (HARD penalty)
            
            // FIX 3: Check if SL is ABOVE any trap zone - DISQUALIFY completely
            trapZones.forEach(trap => {
                if (c.price > trap.price && c.price < trap.price * 1.01) {
                    c.disqualified = true;  // FIX: Was score -= 30, now DISQUALIFIED
                    c.inTrap = true;
                }
            });
            
            // Check if SL is BELOW trap zone (good - survives hunt)
            trapZones.forEach(trap => {
                if (c.price < trap.price * 0.995) {
                    c.score += 20; // Increased bonus for being below trap
                    c.belowTrap = true;
                }
            });
        });
        
        // FIX 3b: Filter out disqualified candidates BEFORE sorting
        const validCandidates = candidates.filter(c => !c.disqualified);
        
        // Select best candidate from VALID (non-disqualified) candidates
        validCandidates.sort((a, b) => b.score - a.score);
        
        if (validCandidates.length > 0 && validCandidates[0].score >= 40) {
            const best = validCandidates[0];
            result.price = best.price;
            result.structureUsed = best.type;
            result.score = best.score;
            result.trapAvoided = best.belowTrap || false;
            
            if (best.type === 'SWING') {
                result.reason = best.belowTrap 
                    ? 'Below swing + avoids EQL trap'
                    : 'Below swing low';
            } else if (best.type === 'OB') {
                result.reason = best.belowTrap
                    ? 'Below OB + avoids EQL trap'
                    : 'Below fresh OB';
            }
        } else {
            // Fallback - check if we need to go below trap zones
            if (trapZones.length > 0) {
                const lowestTrap = Math.min(...trapZones.map(t => t.price));
                result.price = lowestTrap * 0.995; // Below all traps
                result.reason = 'Below liquidity trap zone';
                result.trapAvoided = true;
            } else {
                result.price = currentPrice - (atr * 2);
                result.reason = 'ATR-based (no structure)';
            }
        }
        
    } else { // SHORT
        // Find swing highs above current price
        swings.highs.filter(s => s.price > currentPrice).forEach(swing => {
            const dist = ((swing.price - currentPrice) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) {
                candidates.push({
                    price: swing.price * 1.002, // Buffer above
                    type: 'SWING',
                    dist: dist,
                    score: 50
                });
            }
        });
        
        // Find bearish OBs above current price
        orderBlocks.bearish.filter(ob => ob.high > currentPrice && ob.fresh).forEach(ob => {
            const dist = ((ob.high - currentPrice) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) {
                candidates.push({
                    price: ob.high * 1.003,
                    type: 'OB',
                    dist: dist,
                    score: ob.fresh ? 70 : 40
                });
            }
        });
        
        // Check for equal highs (TRAP ZONES)
        const trapZones = equalLevels.equalHighs.filter(eh => eh.price > currentPrice);
        
        // Score and filter candidates - FIXED: No distance bonus, stronger penalties
        candidates.forEach(c => {
            // FIX 1: REMOVED distance bonus - SL should be structure-based
            
            // FIX 2: ATR validation with STRONGER penalty
            const atrRatio = (c.price - currentPrice) / atr;
            if (atrRatio >= 1.5) c.score += 20;
            else if (atrRatio >= 1) c.score += 10;
            else c.score -= 30;  // FIX: Was -10, now -30
            
            // FIX 3: DISQUALIFY trapped SLs
            trapZones.forEach(trap => {
                if (c.price < trap.price && c.price > trap.price * 0.99) {
                    c.disqualified = true;  // FIX: Was score -= 30
                    c.inTrap = true;
                }
            });
            
            trapZones.forEach(trap => {
                if (c.price > trap.price * 1.005) {
                    c.score += 20;  // Increased bonus
                    c.aboveTrap = true;
                }
            });
        });
        
        // FIX 3b: Filter out disqualified candidates
        const validCandidates = candidates.filter(c => !c.disqualified);
        validCandidates.sort((a, b) => b.score - a.score);
        
        if (validCandidates.length > 0 && validCandidates[0].score >= 40) {
            const best = validCandidates[0];
            result.price = best.price;
            result.structureUsed = best.type;
            result.score = best.score;
            result.trapAvoided = best.aboveTrap || false;
            
            if (best.type === 'SWING') {
                result.reason = best.aboveTrap
                    ? 'Above swing + avoids EQH trap'
                    : 'Above swing high';
            } else if (best.type === 'OB') {
                result.reason = best.aboveTrap
                    ? 'Above OB + avoids EQH trap'
                    : 'Above fresh OB';
            }
        } else {
            if (trapZones.length > 0) {
                const highestTrap = Math.max(...trapZones.map(t => t.price));
                result.price = highestTrap * 1.005;
                result.reason = 'Above liquidity trap zone';
                result.trapAvoided = true;
            } else {
                result.price = currentPrice + (atr * 2);
                result.reason = 'ATR-based (no structure)';
            }
        }
    }
    
    // Calculate risk percentage
    result.riskPct = ((Math.abs(currentPrice - result.price) / currentPrice) * 100).toFixed(2);
    
    // Cap SL at max 3%
    if (parseFloat(result.riskPct) > 3) {
        result.price = direction === 'LONG'
            ? currentPrice * 0.97
            : currentPrice * 1.03;
        result.riskPct = '3.00';
        result.reason += ' (capped at 3%)';
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 2: SMART PULLBACK LEVELS
// Finds 2 best add levels between Entry and SL
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartPullbacks(direction, currentPrice, slPrice, klines, atr) {
    const result = {
        pullback1: null,
        pullback2: null,
        marketOnly: false,
        reason: ''
    };
    
    if (!klines || klines.length < 50) {
        result.marketOnly = true;
        result.reason = 'Insufficient data';
        return result;
    }
    
    const orderBlocks = detectOrderBlocks(klines, 50);
    const fvgs = detectFVG(klines, 30);
    const swings = findSwingPoints(klines, 4, 4);
    
    // Collect candidate pullback levels
    const candidates = [];
    const minGapFromSL = 0.005; // Min 0.5% above SL
    
    if (direction === 'LONG') {
        // Entry is above, SL is below. Find levels IN BETWEEN.
        const slBuffer = slPrice * (1 + minGapFromSL);
        
        // FIX: Include ALL bullish OBs, fresh ones get higher score
        orderBlocks.bullish.filter(ob => {
            return ob.high < currentPrice && ob.high > slBuffer;
        }).forEach(ob => {
            candidates.push({
                price: ob.high,
                type: 'OB',
                reason: ob.fresh ? 'Fresh bullish OB' : 'Bullish OB',
                dist: ((currentPrice - ob.high) / currentPrice) * 100,
                score: ob.fresh ? 80 : 55
            });
        });
        
        // FIX: Include ALL bullish FVGs, unfilled ones get higher score
        fvgs.bullish.filter(fvg => {
            return fvg.high < currentPrice && fvg.low > slBuffer;
        }).forEach(fvg => {
            candidates.push({
                price: fvg.high, // Enter at top of FVG
                type: 'FVG',
                reason: fvg.filled ? 'Bullish FVG' : 'Unfilled bullish FVG',
                dist: ((currentPrice - fvg.high) / currentPrice) * 100,
                score: fvg.filled ? 55 : 70
            });
        });
        
        // Swing lows between entry and SL
        swings.lows.filter(s => {
            return s.price < currentPrice && s.price > slBuffer;
        }).forEach(swing => {
            candidates.push({
                price: swing.price * 1.002, // Slightly above swing
                type: 'SWING',
                reason: 'Swing low support',
                dist: ((currentPrice - swing.price) / currentPrice) * 100,
                score: 55
            });
        });
        
    } else { // SHORT
        const slBuffer = slPrice * (1 - minGapFromSL);
        
        // FIX: Include ALL bearish OBs, fresh ones get higher score
        orderBlocks.bearish.filter(ob => {
            return ob.low > currentPrice && ob.low < slBuffer;
        }).forEach(ob => {
            candidates.push({
                price: ob.low,
                type: 'OB',
                reason: ob.fresh ? 'Fresh bearish OB' : 'Bearish OB',
                dist: ((ob.low - currentPrice) / currentPrice) * 100,
                score: ob.fresh ? 80 : 55
            });
        });
        
        // FIX: Include ALL bearish FVGs, unfilled ones get higher score
        fvgs.bearish.filter(fvg => {
            return fvg.low > currentPrice && fvg.high < slBuffer;
        }).forEach(fvg => {
            candidates.push({
                price: fvg.low,
                type: 'FVG',
                reason: fvg.filled ? 'Bearish FVG' : 'Unfilled bearish FVG',
                dist: ((fvg.low - currentPrice) / currentPrice) * 100,
                score: fvg.filled ? 55 : 70
            });
        });
        
        // Swing highs
        swings.highs.filter(s => {
            return s.price > currentPrice && s.price < slBuffer;
        }).forEach(swing => {
            candidates.push({
                price: swing.price * 0.998,
                type: 'SWING',
                reason: 'Swing high resistance',
                dist: ((swing.price - currentPrice) / currentPrice) * 100,
                score: 55
            });
        });
    }
    
    // Score adjustments
    candidates.forEach(c => {
        // Prefer levels 0.5% - 1.5% from entry (optimal pullback)
        if (c.dist >= 0.5 && c.dist <= 1.5) c.score += 20;
        else if (c.dist > 1.5 && c.dist <= 2.5) c.score += 10;
        else if (c.dist < 0.5) c.score -= 10; // Too close
        
        // OB + FVG confluence
        if (c.type === 'OB') {
            const hasFvgConfluence = candidates.some(other => 
                other.type === 'FVG' && 
                Math.abs(other.price - c.price) / c.price < 0.005
            );
            if (hasFvgConfluence) {
                c.score += 25;
                c.reason += ' + FVG confluence';
            }
        }
    });
    
    // Sort by score and remove duplicates (within 0.3% of each other)
    candidates.sort((a, b) => b.score - a.score);
    
    const uniqueCandidates = [];
    candidates.forEach(c => {
        const isDuplicate = uniqueCandidates.some(u => 
            Math.abs(u.price - c.price) / c.price < 0.003
        );
        if (!isDuplicate) uniqueCandidates.push(c);
    });
    
    // Select top 2 with minimum 0.5% gap between them
    if (uniqueCandidates.length >= 1) {
        result.pullback1 = {
            price: uniqueCandidates[0].price,
            type: uniqueCandidates[0].type,
            reason: uniqueCandidates[0].reason,
            distPct: uniqueCandidates[0].dist.toFixed(2),
            score: uniqueCandidates[0].score
        };
        
        // Find second pullback with min gap from first
        for (let i = 1; i < uniqueCandidates.length; i++) {
            const gap = Math.abs(uniqueCandidates[i].price - result.pullback1.price) / result.pullback1.price;
            if (gap >= 0.005) { // Min 0.5% gap
                result.pullback2 = {
                    price: uniqueCandidates[i].price,
                    type: uniqueCandidates[i].type,
                    reason: uniqueCandidates[i].reason,
                    distPct: uniqueCandidates[i].dist.toFixed(2),
                    score: uniqueCandidates[i].score
                };
                break;
            }
        }
    }
    
    if (!result.pullback1) {
        // FIX: ATR-based fallback pullbacks when no SMC structure found
        const atrValue = atr || (Math.abs(currentPrice - slPrice) * 0.3);
        
        if (direction === 'LONG') {
            // Pullback 1: 0.5 ATR below entry
            const pb1Price = currentPrice - (atrValue * 0.5);
            if (pb1Price > slPrice * 1.01) { // Must be above SL with buffer
                result.pullback1 = {
                    price: pb1Price,
                    type: 'ATR',
                    reason: 'ATR-based (0.5 ATR)',
                    distPct: ((currentPrice - pb1Price) / currentPrice * 100).toFixed(2),
                    score: 50
                };
                
                // Pullback 2: 1 ATR below entry
                const pb2Price = currentPrice - (atrValue * 1.0);
                if (pb2Price > slPrice * 1.01) {
                    result.pullback2 = {
                        price: pb2Price,
                        type: 'ATR',
                        reason: 'ATR-based (1.0 ATR)',
                        distPct: ((currentPrice - pb2Price) / currentPrice * 100).toFixed(2),
                        score: 45
                    };
                }
            }
        } else { // SHORT
            // Pullback 1: 0.5 ATR above entry
            const pb1Price = currentPrice + (atrValue * 0.5);
            if (pb1Price < slPrice * 0.99) { // Must be below SL with buffer
                result.pullback1 = {
                    price: pb1Price,
                    type: 'ATR',
                    reason: 'ATR-based (0.5 ATR)',
                    distPct: ((pb1Price - currentPrice) / currentPrice * 100).toFixed(2),
                    score: 50
                };
                
                // Pullback 2: 1 ATR above entry
                const pb2Price = currentPrice + (atrValue * 1.0);
                if (pb2Price < slPrice * 0.99) {
                    result.pullback2 = {
                        price: pb2Price,
                        type: 'ATR',
                        reason: 'ATR-based (1.0 ATR)',
                        distPct: ((pb2Price - currentPrice) / currentPrice * 100).toFixed(2),
                        score: 45
                    };
                }
            }
        }
        
        if (!result.pullback1) {
            result.marketOnly = true;
            result.reason = 'SL too tight for pullbacks';
        } else {
            result.reason = 'ATR fallback (no SMC structure)';
        }
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 3: SMART TAKE PROFITS
// Finds liquidity-based targets with probability
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartTPs(direction, currentPrice, slPrice, klines, zoneDetails) {
    const result = {
        tp1: null,
        tp2: null,
        tp3: null,
        fallbackUsed: false
    };
    
    if (!klines || klines.length < 50) {
        // Fallback to R:R based
        const risk = Math.abs(currentPrice - slPrice);
        result.tp1 = { price: direction === 'LONG' ? currentPrice + risk * 1.5 : currentPrice - risk * 1.5, reason: 'R:R fallback', probability: 60 };
        result.tp2 = { price: direction === 'LONG' ? currentPrice + risk * 2.5 : currentPrice - risk * 2.5, reason: 'R:R fallback', probability: 45 };
        result.tp3 = { price: direction === 'LONG' ? currentPrice + risk * 4 : currentPrice - risk * 4, reason: 'R:R fallback', probability: 30 };
        result.fallbackUsed = true;
        return result;
    }
    
    const equalLevels = detectEqualLevels(klines, 0.002);
    const orderBlocks = detectOrderBlocks(klines, 50);
    const risk = Math.abs(currentPrice - slPrice);
    
    // Collect target candidates
    const candidates = [];
    const minDist = 0.01; // Min 1% from entry
    const maxDist = 0.15; // Max 15% from entry
    
    if (direction === 'LONG') {
        // Equal Highs = Liquidity targets (highest probability)
        equalLevels.equalHighs.filter(eh => {
            const dist = (eh.price - currentPrice) / currentPrice;
            return dist > minDist && dist < maxDist;
        }).forEach(eh => {
            candidates.push({
                price: eh.price,
                type: 'EQH',
                reason: `Equal Highs (${eh.count} touches)`,
                dist: ((eh.price - currentPrice) / currentPrice) * 100,
                probability: 80, // High prob - liquidity always gets grabbed
                score: 90 + (eh.count * 5)
            });
        });
        
        // Bearish OBs = Reversal zones (medium probability)
        orderBlocks.bearish.filter(ob => {
            const dist = (ob.low - currentPrice) / currentPrice;
            return dist > minDist && dist < maxDist && ob.fresh;
        }).forEach(ob => {
            candidates.push({
                price: ob.low,
                type: 'BEAR_OB',
                reason: 'Bearish OB (reversal zone)',
                dist: ((ob.low - currentPrice) / currentPrice) * 100,
                probability: 65,
                score: 75
            });
        });
        
        // Resistance zones (medium probability)
        if (zoneDetails && zoneDetails.nearestResistance) {
            const res = zoneDetails.nearestResistance;
            const dist = (res.low - currentPrice) / currentPrice;
            if (dist > minDist && dist < maxDist) {
                candidates.push({
                    price: res.low,
                    type: 'RESISTANCE',
                    reason: 'Resistance zone',
                    dist: dist * 100,
                    probability: 60,
                    score: 60
                });
            }
        }
        
    } else { // SHORT
        // Equal Lows = Liquidity targets
        equalLevels.equalLows.filter(el => {
            const dist = (currentPrice - el.price) / currentPrice;
            return dist > minDist && dist < maxDist;
        }).forEach(el => {
            candidates.push({
                price: el.price,
                type: 'EQL',
                reason: `Equal Lows (${el.count} touches)`,
                dist: ((currentPrice - el.price) / currentPrice) * 100,
                probability: 80,
                score: 90 + (el.count * 5)
            });
        });
        
        // Bullish OBs = Reversal zones
        orderBlocks.bullish.filter(ob => {
            const dist = (currentPrice - ob.high) / currentPrice;
            return dist > minDist && dist < maxDist && ob.fresh;
        }).forEach(ob => {
            candidates.push({
                price: ob.high,
                type: 'BULL_OB',
                reason: 'Bullish OB (reversal zone)',
                dist: ((currentPrice - ob.high) / currentPrice) * 100,
                probability: 65,
                score: 75
            });
        });
        
        // Support zones
        if (zoneDetails && zoneDetails.nearestSupport) {
            const sup = zoneDetails.nearestSupport;
            const dist = (currentPrice - sup.high) / currentPrice;
            if (dist > minDist && dist < maxDist) {
                candidates.push({
                    price: sup.high,
                    type: 'SUPPORT',
                    reason: 'Support zone',
                    dist: dist * 100,
                    probability: 60,
                    score: 60
                });
            }
        }
    }
    
    // Sort by distance (closer first for TP1, further for TP3)
    candidates.sort((a, b) => a.dist - b.dist);
    
    // Select TPs with minimum 1.5% gap between them
    const selectedTPs = [];
    const minGap = 1.5;
    
    for (const c of candidates) {
        if (selectedTPs.length === 0) {
            // First TP - must be at least 1.5R
            const rrRatio = c.dist / (parseFloat(result.tp1?.dist) || (Math.abs(currentPrice - slPrice) / currentPrice * 100));
            selectedTPs.push(c);
        } else {
            // Check gap from last selected TP
            const lastTP = selectedTPs[selectedTPs.length - 1];
            const gap = Math.abs(c.dist - lastTP.dist);
            if (gap >= minGap && selectedTPs.length < 3) {
                // Reduce probability for further TPs
                c.probability = Math.max(30, c.probability - (selectedTPs.length * 15));
                selectedTPs.push(c);
            }
        }
        if (selectedTPs.length >= 3) break;
    }
    
    // Assign to result
    if (selectedTPs.length >= 1) {
        result.tp1 = {
            price: selectedTPs[0].price,
            type: selectedTPs[0].type,
            reason: selectedTPs[0].reason,
            distPct: selectedTPs[0].dist.toFixed(2),
            probability: selectedTPs[0].probability,
            rrRatio: (selectedTPs[0].dist / (Math.abs(currentPrice - slPrice) / currentPrice * 100)).toFixed(1)
        };
    }
    
    if (selectedTPs.length >= 2) {
        result.tp2 = {
            price: selectedTPs[1].price,
            type: selectedTPs[1].type,
            reason: selectedTPs[1].reason,
            distPct: selectedTPs[1].dist.toFixed(2),
            probability: selectedTPs[1].probability,
            rrRatio: (selectedTPs[1].dist / (Math.abs(currentPrice - slPrice) / currentPrice * 100)).toFixed(1)
        };
    }
    
    if (selectedTPs.length >= 3) {
        result.tp3 = {
            price: selectedTPs[2].price,
            type: selectedTPs[2].type,
            reason: selectedTPs[2].reason,
            distPct: selectedTPs[2].dist.toFixed(2),
            probability: selectedTPs[2].probability,
            rrRatio: (selectedTPs[2].dist / (Math.abs(currentPrice - slPrice) / currentPrice * 100)).toFixed(1)
        };
    }
    
    // Fallback for missing TPs
    if (!result.tp1) {
        result.tp1 = { price: direction === 'LONG' ? currentPrice + risk * 1.5 : currentPrice - risk * 1.5, reason: '1.5R (fallback)', probability: 65, distPct: ((risk * 1.5) / currentPrice * 100).toFixed(2) };
        result.fallbackUsed = true;
    }
    if (!result.tp2) {
        result.tp2 = { price: direction === 'LONG' ? currentPrice + risk * 2.5 : currentPrice - risk * 2.5, reason: '2.5R (fallback)', probability: 50, distPct: ((risk * 2.5) / currentPrice * 100).toFixed(2) };
    }
    if (!result.tp3) {
        result.tp3 = { price: direction === 'LONG' ? currentPrice + risk * 4 : currentPrice - risk * 4, reason: '4R (fallback)', probability: 35, distPct: ((risk * 4) / currentPrice * 100).toFixed(2) };
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 4: ENTRY GRADE CALCULATOR
// Grades entries from A+ to D based on SL distance, ATR, structure
// ─────────────────────────────────────────────────────────────────────────────────
function calculateEntryGrade(entryPrice, slPrice, atr, structureScore = 70) {
    const result = {
        grade: 'C',
        score: 50,
        slDistScore: 0,
        atrScore: 0,
        structureScore: 0,
        leverage: { safe: 5, max: 10 },
        size: '50%',
        confidence: 'MEDIUM'
    };
    
    const slDist = Math.abs(entryPrice - slPrice) / entryPrice * 100;
    const atrRatio = Math.abs(entryPrice - slPrice) / atr;
    
    // SL Distance Score (40% weight)
    if (slDist < 0.5) result.slDistScore = 100;
    else if (slDist < 0.75) result.slDistScore = 90;
    else if (slDist < 1.0) result.slDistScore = 80;
    else if (slDist < 1.25) result.slDistScore = 70;
    else if (slDist < 1.5) result.slDistScore = 60;
    else if (slDist < 2.0) result.slDistScore = 50;
    else if (slDist < 2.5) result.slDistScore = 40;
    else result.slDistScore = 25;
    
    // ATR Safety Score (30% weight) - SL should be 1-2x ATR
    if (atrRatio >= 2.0) result.atrScore = 100;
    else if (atrRatio >= 1.5) result.atrScore = 90;
    else if (atrRatio >= 1.2) result.atrScore = 75;
    else if (atrRatio >= 1.0) result.atrScore = 60;
    else if (atrRatio >= 0.7) result.atrScore = 40;
    else result.atrScore = 20; // Too tight, will get stopped
    
    // Structure Score (30% weight) - passed in
    result.structureScore = Math.min(100, Math.max(0, structureScore));
    
    // Calculate final score
    result.score = Math.round(
        (result.slDistScore * 0.4) +
        (result.atrScore * 0.3) +
        (result.structureScore * 0.3)
    );
    
    // Assign grade
    if (result.score >= 85) {
        result.grade = 'A+';
        result.leverage = { safe: 12, max: 20 };
        result.size = '100%';
        result.confidence = 'VERY HIGH';
    } else if (result.score >= 75) {
        result.grade = 'A';
        result.leverage = { safe: 10, max: 15 };
        result.size = '100%';
        result.confidence = 'HIGH';
    } else if (result.score >= 65) {
        result.grade = 'B+';
        result.leverage = { safe: 8, max: 12 };
        result.size = '75%';
        result.confidence = 'GOOD';
    } else if (result.score >= 55) {
        result.grade = 'B';
        result.leverage = { safe: 6, max: 10 };
        result.size = '75%';
        result.confidence = 'GOOD';
    } else if (result.score >= 45) {
        result.grade = 'C';
        result.leverage = { safe: 5, max: 7 };
        result.size = '50%';
        result.confidence = 'MEDIUM';
    } else {
        result.grade = 'D';
        result.leverage = { safe: 3, max: 5 };
        result.size = '25%';
        result.confidence = 'LOW';
    }
    
    result.slDistPct = slDist.toFixed(2);
    result.atrRatio = atrRatio.toFixed(2);
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 5: SMART ENTRY DECISION
// Decides MARKET / LIMIT / WAIT / SKIP
// ─────────────────────────────────────────────────────────────────────────────────
function determineSmartEntry(direction, grade, momentumData, candleData, pullbacks) {
    const result = {
        decision: 'MARKET',
        reason: '',
        sizing: {
            market: 25,
            pullback1: 50,
            pullback2: 25
        }
    };
    
    // Check if price is running (strong momentum)
    const isRunning = momentumData && (
        (direction === 'LONG' && momentumData.details.rsi && momentumData.details.rsi.value > 65) ||
        (direction === 'SHORT' && momentumData.details.rsi && momentumData.details.rsi.value < 35)
    );
    
    // Check if extended (overbought/oversold)
    const isExtended = momentumData && (
        (direction === 'LONG' && momentumData.details.rsi && momentumData.details.rsi.value > 75) ||
        (direction === 'SHORT' && momentumData.details.rsi && momentumData.details.rsi.value < 25)
    );
    
    // Check candle pattern
    const hasBullishPattern = candleData && candleData.patternSignal === 'BULLISH';
    const hasBearishPattern = candleData && candleData.patternSignal === 'BEARISH';
    const controlBuyers = candleData && candleData.behavior && candleData.behavior.control === 'BUYERS';
    const controlSellers = candleData && candleData.behavior && candleData.behavior.control === 'SELLERS';
    
    // Decision logic
    if (isExtended) {
        result.decision = 'WAIT';
        result.reason = 'Price extended - wait for pullback';
        result.sizing = { market: 0, pullback1: 60, pullback2: 40 };
    } else if (isRunning && grade.score >= 65) {
        result.decision = 'MARKET';
        result.reason = 'Strong momentum - enter now';
        result.sizing = { market: 50, pullback1: 35, pullback2: 15 };
    } else if (!isRunning && pullbacks.pullback1) {
        result.decision = 'LIMIT';
        result.reason = 'Moderate momentum - wait for pullback';
        result.sizing = { market: 25, pullback1: 50, pullback2: 25 };
    } else if (grade.grade === 'D') {
        result.decision = 'WAIT';
        result.reason = 'Low grade entry - wait for better setup';
        result.sizing = { market: 0, pullback1: 75, pullback2: 25 };
    } else {
        result.decision = 'MARKET';
        result.reason = 'Standard entry';
        result.sizing = { market: 25, pullback1: 50, pullback2: 25 };
    }
    
    // Adjust sizing based on grade
    if (grade.grade === 'A+' || grade.grade === 'A') {
        if (result.decision === 'MARKET') {
            result.sizing.market = Math.min(100, result.sizing.market + 25);
        }
    } else if (grade.grade === 'D') {
        result.sizing.market = Math.max(0, result.sizing.market - 15);
        result.sizing.pullback1 = Math.min(75, result.sizing.pullback1 + 10);
    }
    
    // Check for conflicting patterns
    if (direction === 'LONG' && hasBearishPattern) {
        result.decision = 'WAIT';
        result.reason = 'Bearish candle pattern - wait for confirmation';
    } else if (direction === 'SHORT' && hasBullishPattern) {
        result.decision = 'WAIT';
        result.reason = 'Bullish candle pattern - wait for confirmation';
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 6: SMART EXIT MONITOR
// Real-time monitoring for exit signals
// ─────────────────────────────────────────────────────────────────────────────────
function monitorTradeExit(direction, entryPrice, currentPrice, tpData, klines) {
    const result = {
        recommendation: 'HOLD',
        reason: '',
        tp1Prob: tpData.tp1 ? tpData.tp1.probability : 65,
        tp2Prob: tpData.tp2 ? tpData.tp2.probability : 50,
        tp3Prob: tpData.tp3 ? tpData.tp3.probability : 35,
        warnings: [],
        urgency: 'LOW'
    };
    
    if (!klines || klines.length < 10) return result;
    
    const recentKlines = klines.slice(-10);
    const candlePatterns = analyzeCandlePatterns(klines);
    const closes = klines.map(k => k.close);
    const rsi = calcRSI(closes, 14);
    const macd = calcMACD(closes);
    
    // Check for reversal candle patterns
    if (candlePatterns.patterns && candlePatterns.patterns.length > 0) {
        const recentPatterns = candlePatterns.patterns.filter(p => p.index >= klines.length - 3);
        
        for (const pattern of recentPatterns) {
            if (direction === 'LONG') {
                if (['Shooting Star', 'Bearish Engulfing', 'Evening Star', 'Hanging Man'].includes(pattern.name)) {
                    result.warnings.push(`${pattern.name} detected`);
                    result.tp2Prob = Math.max(15, result.tp2Prob - 20);
                    result.tp3Prob = Math.max(10, result.tp3Prob - 25);
                }
            } else {
                if (['Hammer', 'Bullish Engulfing', 'Morning Star', 'Inverted Hammer'].includes(pattern.name)) {
                    result.warnings.push(`${pattern.name} detected`);
                    result.tp2Prob = Math.max(15, result.tp2Prob - 20);
                    result.tp3Prob = Math.max(10, result.tp3Prob - 25);
                }
            }
        }
    }
    
    // Check for momentum divergence
    if (direction === 'LONG') {
        // Price making higher high but RSI lower high = bearish divergence
        const priceHigh = Math.max(...recentKlines.map(k => k.high));
        const prevPriceHigh = Math.max(...klines.slice(-20, -10).map(k => k.high));
        
        if (priceHigh > prevPriceHigh && rsi < 60) {
            result.warnings.push('RSI divergence forming');
            result.tp2Prob = Math.max(20, result.tp2Prob - 15);
            result.tp3Prob = Math.max(15, result.tp3Prob - 20);
        }
    } else {
        const priceLow = Math.min(...recentKlines.map(k => k.low));
        const prevPriceLow = Math.min(...klines.slice(-20, -10).map(k => k.low));
        
        if (priceLow < prevPriceLow && rsi > 40) {
            result.warnings.push('RSI divergence forming');
            result.tp2Prob = Math.max(20, result.tp2Prob - 15);
            result.tp3Prob = Math.max(15, result.tp3Prob - 20);
        }
    }
    
    // Check for volume dying
    const recentVol = recentKlines.slice(-3).reduce((s, k) => s + k.volume, 0) / 3;
    const avgVol = klines.slice(-20).reduce((s, k) => s + k.volume, 0) / 20;
    
    if (recentVol < avgVol * 0.6) {
        result.warnings.push('Volume declining');
        result.tp2Prob = Math.max(20, result.tp2Prob - 10);
        result.tp3Prob = Math.max(15, result.tp3Prob - 15);
    }
    
    // Check for failed breakout
    if (direction === 'LONG' && tpData.tp1) {
        const nearTP1 = Math.abs(currentPrice - tpData.tp1.price) / tpData.tp1.price < 0.005;
        if (nearTP1) {
            // Check if rejected
            const rejectionCandle = recentKlines[recentKlines.length - 1];
            const upperWick = rejectionCandle.high - Math.max(rejectionCandle.open, rejectionCandle.close);
            const body = Math.abs(rejectionCandle.close - rejectionCandle.open);
            
            if (upperWick > body * 2) {
                result.warnings.push('Rejection at TP1 level');
                result.tp2Prob = Math.max(15, result.tp2Prob - 25);
                result.tp3Prob = Math.max(10, result.tp3Prob - 30);
            }
        }
    }
    
    // Determine recommendation
    if (result.warnings.length >= 3) {
        result.recommendation = 'EXIT';
        result.reason = 'Multiple warning signals - exit recommended';
        result.urgency = 'HIGH';
    } else if (result.warnings.length >= 2) {
        result.recommendation = 'REDUCE';
        result.reason = 'Warning signals detected - consider reducing position';
        result.urgency = 'MEDIUM';
    } else if (result.warnings.length === 1) {
        result.recommendation = 'CAUTION';
        result.reason = 'Minor warning - monitor closely';
        result.urgency = 'LOW';
    } else {
        result.recommendation = 'HOLD';
        result.reason = 'No warning signals - trade on track';
    }
    
    // MACD cross check
    if (macd && macd.histogram) {
        const histLen = macd.histogram.length;
        if (histLen >= 2) {
            const currentHist = macd.histogram[histLen - 1];
            const prevHist = macd.histogram[histLen - 2];
            
            if (direction === 'LONG' && currentHist < prevHist && currentHist < 0) {
                result.warnings.push('MACD momentum weakening');
                result.tp2Prob = Math.max(20, result.tp2Prob - 10);
            } else if (direction === 'SHORT' && currentHist > prevHist && currentHist > 0) {
                result.warnings.push('MACD momentum weakening');
                result.tp2Prob = Math.max(20, result.tp2Prob - 10);
            }
        }
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// MASTER FUNCTION: CALCULATE SMART TRADE LEVELS
// Combines all 6 engines into one comprehensive output
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartTradeLevels(currentPrice, direction, atr, klines, zoneDetails, smcDetails, momentumData, candleData) {
    // Engine 1: Smart SL
    const smartSL = calculateSmartSL(direction, currentPrice, klines, atr);
    
    // Engine 2: Smart Pullbacks (needs SL)
    const smartPullbacks = calculateSmartPullbacks(direction, currentPrice, smartSL.price, klines, atr);
    
    // Engine 3: Smart TPs (needs SL)
    const smartTPs = calculateSmartTPs(direction, currentPrice, smartSL.price, klines, zoneDetails);
    
    // Calculate structure score for grade
    let structureScore = 50;
    if (smartSL.structureUsed === 'OB') structureScore += 20;
    if (smartSL.structureUsed === 'SWING') structureScore += 15;
    if (smartSL.trapAvoided) structureScore += 15;
    if (smartPullbacks.pullback1 && smartPullbacks.pullback1.type === 'OB') structureScore += 10;
    if (smartTPs.tp1 && smartTPs.tp1.type === 'EQH') structureScore += 10;
    
    // Engine 4: Entry Grade for Market entry
    const marketGrade = calculateEntryGrade(currentPrice, smartSL.price, atr, structureScore);
    
    // Entry grades for pullback levels
    let pb1Grade = null, pb2Grade = null;
    if (smartPullbacks.pullback1) {
        pb1Grade = calculateEntryGrade(smartPullbacks.pullback1.price, smartSL.price, atr, structureScore + 10);
    }
    if (smartPullbacks.pullback2) {
        pb2Grade = calculateEntryGrade(smartPullbacks.pullback2.price, smartSL.price, atr, structureScore + 15);
    }
    
    // Engine 5: Smart Entry Decision
    const entryDecision = determineSmartEntry(direction, marketGrade, momentumData, candleData, smartPullbacks);
    
    // Engine 6: Exit Monitor (initial state)
    const exitMonitor = monitorTradeExit(direction, currentPrice, currentPrice, smartTPs, klines);
    
    // Calculate average entry if all levels fill
    let avgEntry = currentPrice;
    if (smartPullbacks.pullback1 && smartPullbacks.pullback2) {
        avgEntry = (currentPrice * 0.25 + smartPullbacks.pullback1.price * 0.5 + smartPullbacks.pullback2.price * 0.25);
    } else if (smartPullbacks.pullback1) {
        avgEntry = (currentPrice * 0.4 + smartPullbacks.pullback1.price * 0.6);
    }
    
    // Calculate R:R from average entry
    const avgRisk = Math.abs(avgEntry - smartSL.price);
    const avgRewardTP2 = smartTPs.tp2 ? Math.abs(smartTPs.tp2.price - avgEntry) : avgRisk * 2.5;
    const avgRR = avgRisk > 0 ? (avgRewardTP2 / avgRisk).toFixed(2) : '0';
    
    return {
        // Entry Plan
        entry: {
            market: {
                price: currentPrice,
                grade: marketGrade,
                size: entryDecision.sizing.market + '%'
            },
            pullback1: smartPullbacks.pullback1 ? {
                price: smartPullbacks.pullback1.price,
                reason: smartPullbacks.pullback1.reason,
                distPct: smartPullbacks.pullback1.distPct,
                grade: pb1Grade,
                size: entryDecision.sizing.pullback1 + '%'
            } : null,
            pullback2: smartPullbacks.pullback2 ? {
                price: smartPullbacks.pullback2.price,
                reason: smartPullbacks.pullback2.reason,
                distPct: smartPullbacks.pullback2.distPct,
                grade: pb2Grade,
                size: entryDecision.sizing.pullback2 + '%'
            } : null,
            decision: entryDecision.decision,
            decisionReason: entryDecision.reason,
            avgEntry: avgEntry,
            marketOnly: smartPullbacks.marketOnly
        },
        
        // Stop Loss
        sl: {
            price: smartSL.price,
            reason: smartSL.reason,
            riskPct: smartSL.riskPct,
            trapAvoided: smartSL.trapAvoided,
            structureUsed: smartSL.structureUsed
        },
        
        // Take Profits
        tp1: smartTPs.tp1,
        tp2: smartTPs.tp2,
        tp3: smartTPs.tp3,
        
        // Risk/Reward
        rr: avgRR,
        avgEntry: avgEntry,
        
        // Exit Monitor
        exitMonitor: exitMonitor,
        
        // Legacy compatibility
        limitEntry: smartPullbacks.pullback1 ? smartPullbacks.pullback1.price : currentPrice * (direction === 'LONG' ? 0.995 : 1.005),
        limitType: smartPullbacks.pullback1 ? smartPullbacks.pullback1.type : 'ATR',
        limitConfidence: smartPullbacks.pullback1 ? smartPullbacks.pullback1.score : 50,
        limitRR: (smartPullbacks.pullback1 && smartTPs.tp2) ? 
            ((Math.abs(smartTPs.tp2.price - smartPullbacks.pullback1.price)) / (Math.abs(smartPullbacks.pullback1.price - smartSL.price))).toFixed(2) : avgRR,
        risk: Math.abs(currentPrice - smartSL.price),
        reward: smartTPs.tp2 ? Math.abs(smartTPs.tp2.price - currentPrice) : Math.abs(currentPrice - smartSL.price) * 2.5,
        riskPct: smartSL.riskPct
    };
}


// ═══════════════════════════════════════════════════════════════════════════════
// END OF SMART TRADE SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// MASTER INTEGRATION ENGINE - WEIGHTED AVERAGE SCORING
// ═══════════════════════════════════════════════════════════════════════════════

// HTF Bias Analysis
async function analyzeHTFBias(symbol, entryTF, direction) {
    const htfList = CONFIG.HTF_MAP[entryTF] || ['60', '240', 'D'];
    const result = {
        aligned: 0,
        total: htfList.length,
        bias: {},
        score: 0
    };
    
    for (const tf of htfList) {
        try {
            const klines = await fetchKlines(symbol, tf, 100);
            if (!klines || klines.length < 50) {
                result.bias[CONFIG.TF_LABELS[tf] || tf] = 'N/A';
                continue;
            }
            
            const closes = klines.map(k => k.close);
            const currentPrice = closes[closes.length - 1];
            
            // EMA 20 for trend
            const ema20 = calcEMA(closes, 20);
            // EMA 50 for stronger trend
            const ema50 = calcEMA(closes, 50);
            
            // Structure analysis
            const structure = detectStructure(klines);
            
            let bias = 'NEUTRAL';
            let biasStrength = 0;
            
            // Price above both EMAs = bullish
            if (currentPrice > ema20 && currentPrice > ema50 && structure.trend === 'BULLISH') {
                bias = 'BULLISH';
                biasStrength = 2;
            } else if (currentPrice > ema20 && currentPrice > ema50) {
                bias = 'BULLISH';
                biasStrength = 1;
            } else if (currentPrice < ema20 && currentPrice < ema50 && structure.trend === 'BEARISH') {
                bias = 'BEARISH';
                biasStrength = 2;
            } else if (currentPrice < ema20 && currentPrice < ema50) {
                bias = 'BEARISH';
                biasStrength = 1;
            }
            
            result.bias[CONFIG.TF_LABELS[tf] || tf] = bias;
            
            // Check alignment with entry direction
            if ((direction === 'LONG' && bias === 'BULLISH') ||
                (direction === 'SHORT' && bias === 'BEARISH')) {
                result.aligned++;
            }
            
            await sleep(50);
        } catch (e) {
            console.error(`HTF analysis error for ${tf}:`, e);
            result.bias[CONFIG.TF_LABELS[tf] || tf] = 'ERR';
        }
    }
    
    // Score based on alignment
    if (result.aligned === result.total) {
        result.score = 30; // Full alignment bonus
    } else if (result.aligned >= result.total - 1) {
        result.score = 20;
    } else if (result.aligned >= 1) {
        result.score = 10;
    }
    
    return result;
}

// Detect Conflicts between analyses
function detectConflicts(zone, smc, momentum) {
    const conflicts = [];
    let penalty = 0;
    
    // Zone vs SMC direction conflict
    if (zone.direction && smc.direction && zone.direction !== smc.direction) {
        conflicts.push('Zone vs SMC conflict');
        penalty += CONFIG.PENALTIES.ZONE_SMC_CONFLICT;
    }
    
    // SMC bullish but RSI overbought (exhaustion risk)
    if (smc.direction === 'LONG' && momentum.details.rsi && momentum.details.rsi.value >= 75) {
        conflicts.push('RSI exhaustion risk');
        penalty += CONFIG.PENALTIES.EXHAUSTION;
    }
    
    // SMC bearish but RSI oversold (exhaustion risk)
    if (smc.direction === 'SHORT' && momentum.details.rsi && momentum.details.rsi.value <= 25) {
        conflicts.push('RSI exhaustion risk');
        penalty += CONFIG.PENALTIES.EXHAUSTION;
    }
    
    // Divergence against trade direction
    const div = momentum.details.divergence;
    if (div) {
        if (smc.direction === 'LONG' && (div.rsi.direction === 'BEARISH' || div.macd.direction === 'BEARISH')) {
            conflicts.push('Divergence against long');
            penalty += CONFIG.PENALTIES.DIVERGENCE_AGAINST;
        }
        if (smc.direction === 'SHORT' && (div.rsi.direction === 'BULLISH' || div.macd.direction === 'BULLISH')) {
            conflicts.push('Divergence against short');
            penalty += CONFIG.PENALTIES.DIVERGENCE_AGAINST;
        }
    }
    
    return { conflicts, penalty };
}

// Calculate Trade Levels
function calculateTradeLevels(currentPrice, direction, atr, zoneDetails, smcDetails, adx) {
    let entry = currentPrice;
    let sl, tp1, tp2, tp3;
    
    const atrMultiplier = 2.0;
    
    // Calculate Smart Limit Entry
    const limitData = calculateSmartLimitEntry(currentPrice, direction, atr, zoneDetails, smcDetails, adx);
    
    if (direction === 'LONG') {
        // Stop loss below support or ATR-based
        if (zoneDetails.nearestSupport) {
            sl = Math.min(
                zoneDetails.nearestSupport.low * 0.998,
                currentPrice - atr * atrMultiplier
            );
        } else {
            sl = currentPrice - atr * atrMultiplier;
        }
        
        // Take profit levels
        const risk = entry - sl;
        tp1 = entry + risk * 1.5;  // 1:1.5 RR
        tp2 = entry + risk * 2.5;  // 1:2.5 RR
        tp3 = entry + risk * 4.0;  // 1:4 RR
        
        // Adjust TP if near resistance - ONLY if resistance is ABOVE calculated TP
        if (zoneDetails.nearestResistance && zoneDetails.nearestResistance.low > entry) {
            tp1 = Math.min(tp1, zoneDetails.nearestResistance.low * 0.998);
            // Ensure TP1 is still above entry
            if (tp1 <= entry) {
                tp1 = entry + risk * 1.5;
            }
        }
        
    } else { // SHORT
        // Stop loss above resistance or ATR-based
        if (zoneDetails.nearestResistance) {
            sl = Math.max(
                zoneDetails.nearestResistance.high * 1.002,
                currentPrice + atr * atrMultiplier
            );
        } else {
            sl = currentPrice + atr * atrMultiplier;
        }
        
        // Take profit levels
        const risk = sl - entry;
        tp1 = entry - risk * 1.5;
        tp2 = entry - risk * 2.5;
        tp3 = entry - risk * 4.0;
        
        // Adjust TP if near support - ONLY if support is BELOW calculated TP
        if (zoneDetails.nearestSupport && zoneDetails.nearestSupport.high < entry) {
            tp1 = Math.max(tp1, zoneDetails.nearestSupport.high * 1.002);
            // Ensure TP1 is still below entry
            if (tp1 >= entry) {
                tp1 = entry - risk * 1.5;
            }
        }
    }
    
    const risk = Math.abs(entry - sl);
    const reward = Math.abs(tp2 - entry);
    const rr = risk > 0 ? (reward / risk).toFixed(2) : '0';
    
    // Calculate R:R for limit entry
    const limitRisk = Math.abs(limitData.limitEntry - sl);
    const limitReward = Math.abs(tp2 - limitData.limitEntry);
    const limitRR = limitRisk > 0 ? (limitReward / limitRisk).toFixed(2) : '0';
    
    return {
        entry,
        limitEntry: limitData.limitEntry,
        limitType: limitData.entryType,
        limitConfidence: limitData.confidence,
        sl,
        tp1,
        tp2,
        tp3,
        rr,
        limitRR,
        risk,
        reward,
        riskPct: ((risk / entry) * 100).toFixed(2)
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// COIN RELATIVE STRENGTH (RS) - Compare coin performance vs BTC
// ═══════════════════════════════════════════════════════════════════════════════

async function calculateCoinRS(symbol, klines) {
    try {
        // Skip for BTC itself
        if (symbol === 'BTCUSDT') return 1.0;
        
        // Use cached BTC klines or fetch
        if (!STATE.btcKlines || STATE.btcKlines.length < 20) {
            STATE.btcKlines = await fetchKlines('BTCUSDT', '1h', 50);
        }
        
        if (!STATE.btcKlines || STATE.btcKlines.length < 20 || !klines || klines.length < 20) {
            return 1.0; // Default neutral RS
        }
        
        // Calculate 24h performance for both
        const coinStart = klines[klines.length - 25]?.close || klines[0].close;
        const coinEnd = klines[klines.length - 1].close;
        const coinChange = ((coinEnd - coinStart) / coinStart) * 100;
        
        const btcStart = STATE.btcKlines[STATE.btcKlines.length - 25]?.close || STATE.btcKlines[0].close;
        const btcEnd = STATE.btcKlines[STATE.btcKlines.length - 1].close;
        const btcChange = ((btcEnd - btcStart) / btcStart) * 100;
        
        // RS = coin performance / BTC performance
        // RS > 1 = outperforming BTC
        // RS < 1 = underperforming BTC
        
        // Handle zero/negative cases
        if (btcChange === 0) {
            return coinChange > 0 ? 1.5 : coinChange < 0 ? 0.5 : 1.0;
        }
        
        // Calculate relative strength ratio
        let rs;
        if (btcChange > 0 && coinChange > 0) {
            // Both up: coin/btc ratio
            rs = coinChange / btcChange;
        } else if (btcChange < 0 && coinChange < 0) {
            // Both down: inverse ratio (less down = stronger)
            rs = btcChange / coinChange;
        } else if (btcChange < 0 && coinChange > 0) {
            // BTC down, coin up = very strong
            rs = 1.5 + (coinChange / 10); // Bonus for going against BTC
        } else {
            // BTC up, coin down = very weak
            rs = 0.5 - (Math.abs(coinChange) / 20);
        }
        
        // Clamp to reasonable range (0.3 - 2.0)
        return Math.max(0.3, Math.min(2.0, rs));
        
    } catch (e) {
        // Silent: RS calc
        return 1.0; // Default neutral
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// SMART MATRIX - DYNAMIC ADAPTIVE WEIGHTING SYSTEM V1.0
// ═══════════════════════════════════════════════════════════════════════════════

// SECTION 1: ZONE CONFIDENCE (Touch-based)
function getZoneConfidence(zone) {
    if (!zone || typeof zone.touches !== 'number') {
        return { level: 'NONE', multiplier: 0.5, score: 0 }; // Low but not zero
    }
    
    const touches = zone.touches;
    
    // < 3 touches = WEAK (reduced weight but not zero)
    if (touches < 3) return { level: 'WEAK', multiplier: 0.5, score: 20 };
    
    // 3 touches = BASELINE (minimum to qualify, no penalty)
    if (touches === 3) return { level: 'BASELINE', multiplier: 1.00, score: 60 };
    
    // 4+ touches = BONUS (more = stronger)
    if (touches === 4) return { level: 'GOOD', multiplier: 1.10, score: 70 };
    if (touches === 5) return { level: 'STRONG', multiplier: 1.20, score: 80 };
    if (touches === 6) return { level: 'HIGH', multiplier: 1.30, score: 85 };
    if (touches === 7) return { level: 'VERY_HIGH', multiplier: 1.40, score: 90 };
    
    // 8+ touches = MAX (capped)
    return { level: 'MAXIMUM', multiplier: 1.50, score: 95 };
}

// SECTION 2: SMC CONFIDENCE
function getSMCConfidence(smc) {
    if (!smc) return { level: 'NONE', multiplier: 0.5, score: 0 };
    
    let confidenceScore = 0;
    const factors = [];
    
    // BOS with body close = +25, wick only = +15
    if (smc.details?.bos?.detected && smc.details?.bos?.bodyClose) {
        confidenceScore += 25;
        factors.push('BOS_BODY');
    } else if (smc.details?.bos?.detected) {
        confidenceScore += 15;
        factors.push('BOS_WICK');
    }
    
    // CHoCH = +20
    if (smc.details?.choch?.detected) {
        confidenceScore += 20;
        factors.push('CHOCH');
    }
    
    // Unmitigated Order Block = +20, mitigated = +10
    const obs = smc.details?.orderBlocks;
    if (obs) {
        const hasUnmitigated = [...(obs.bullish || []), ...(obs.bearish || [])].some(ob => !ob.mitigated);
        if (hasUnmitigated) {
            confidenceScore += 20;
            factors.push('OB_FRESH');
        } else if (obs.bullish?.length || obs.bearish?.length) {
            confidenceScore += 10;
            factors.push('OB_MITIGATED');
        }
    }
    
    // Unfilled FVG (<50%) = +15, filled = +5
    const fvgs = smc.details?.fvg;
    if (fvgs) {
        const hasUnfilled = [...(fvgs.bullish || []), ...(fvgs.bearish || [])].some(f => (f.fillPercent || 0) < 50);
        if (hasUnfilled) {
            confidenceScore += 15;
            factors.push('FVG_OPEN');
        } else if (fvgs.bullish?.length || fvgs.bearish?.length) {
            confidenceScore += 5;
            factors.push('FVG_FILLED');
        }
    }
    
    // Liquidity sweep = +15
    if (smc.details?.liquiditySweep?.detected) {
        confidenceScore += 15;
        factors.push('SWEEP');
    }
    
    // Equal Highs/Lows = +10
    if (smc.details?.equalHL?.hasEQL || smc.details?.equalHL?.hasEQH) {
        confidenceScore += 10;
        factors.push('EQ_HL');
    }
    
    // Determine level and multiplier
    let level, multiplier;
    if (confidenceScore >= 70) { level = 'HIGH'; multiplier = 1.30; }
    else if (confidenceScore >= 50) { level = 'MEDIUM_HIGH'; multiplier = 1.15; }
    else if (confidenceScore >= 35) { level = 'MEDIUM'; multiplier = 1.00; }
    else if (confidenceScore >= 20) { level = 'LOW'; multiplier = 0.85; }
    else { level = 'VERY_LOW'; multiplier = 0.70; }
    
    return { level, multiplier, score: confidenceScore, factors };
}

// SECTION 3: MOMENTUM CONFIDENCE
function getMomentumConfidence(momentum) {
    if (!momentum) return { level: 'NONE', multiplier: 0.5, score: 0 };
    
    let confidenceScore = 0;
    const factors = [];
    
    // RSI extreme = +25
    const rsi = momentum.details?.rsi?.value || 50;
    if (rsi <= 30 || rsi >= 70) {
        confidenceScore += 25;
        factors.push('RSI_EXTREME');
    } else if (rsi <= 40 || rsi >= 60) {
        confidenceScore += 10;
        factors.push('RSI_MODERATE');
    }
    
    // MACD crossover = +20, aligned = +10
    const macd = momentum.details?.macd;
    if (macd?.crossover) {
        confidenceScore += 20;
        factors.push('MACD_CROSS');
    } else if (macd?.histogram > 0 || macd?.histogram < 0) {
        confidenceScore += 10;
        factors.push('MACD_ALIGNED');
    }
    
    // ADX trending (>25) = +15, moderate (>20) = +8
    const adx = momentum.details?.adx?.adx || 20;
    if (adx >= 25) {
        confidenceScore += 15;
        factors.push('ADX_TRENDING');
    } else if (adx >= 20) {
        confidenceScore += 8;
        factors.push('ADX_MODERATE');
    }
    
    // Volume spike = +15, above avg = +8
    const volRatio = momentum.details?.volume?.ratio || 1;
    if (volRatio >= 1.5) {
        confidenceScore += 15;
        factors.push('VOL_SPIKE');
    } else if (volRatio >= 1.2) {
        confidenceScore += 8;
        factors.push('VOL_ABOVE_AVG');
    }
    
    // Divergence = +20 compound, +12 regular
    if (momentum.details?.divergence?.type === 'COMPOUND') {
        confidenceScore += 20;
        factors.push('DIV_COMPOUND');
    } else if (momentum.details?.divergence?.detected) {
        confidenceScore += 12;
        factors.push('DIV_REGULAR');
    }
    
    // Determine level and multiplier
    let level, multiplier;
    if (confidenceScore >= 60) { level = 'HIGH'; multiplier = 1.30; }
    else if (confidenceScore >= 45) { level = 'MEDIUM_HIGH'; multiplier = 1.15; }
    else if (confidenceScore >= 30) { level = 'MEDIUM'; multiplier = 1.00; }
    else if (confidenceScore >= 15) { level = 'LOW'; multiplier = 0.85; }
    else { level = 'VERY_LOW'; multiplier = 0.70; }
    
    return { level, multiplier, score: confidenceScore, factors };
}

// SECTION 4: MARKET REGIME DETECTION - OLD VERSION - RENAMED
function detectMarketRegimeLegacy(klines, adxValue) {
    if (!klines || klines.length < 20) {
        return { regime: 'UNKNOWN', confidence: 0, advice: { bias: 'NEUTRAL', strategy: 'Insufficient data' } };
    }
    
    const closes = klines.slice(-20).map(k => parseFloat(k.close || k[4] || 0));
    const len = closes.length;
    
    // Calculate direction changes (chop indicator)
    let dirChanges = 0;
    for (let i = 2; i < len; i++) {
        const prev = closes[i-1] > closes[i-2] ? 'UP' : 'DOWN';
        const curr = closes[i] > closes[i-1] ? 'UP' : 'DOWN';
        if (prev !== curr) dirChanges++;
    }
    
    // Calculate range percent
    const high20 = Math.max(...closes);
    const low20 = Math.min(...closes);
    const rangePercent = low20 > 0 ? ((high20 - low20) / low20) * 100 : 0;
    
    // Use provided ADX or default
    const adx = adxValue || 20;
    
    // Determine regime
    let regime, confidence, advice;
    
    if (adx > 25 && dirChanges < 8) {
        const direction = closes[len-1] > closes[0] ? 'UPTREND' : 'DOWNTREND';
        regime = direction;
        confidence = Math.min(100, adx * 2);
        advice = direction === 'UPTREND' 
            ? { bias: 'LONG', strategy: 'Buy dips to support' }
            : { bias: 'SHORT', strategy: 'Sell rallies to resistance' };
    } else if (adx < 20 && rangePercent < 8) {
        regime = 'RANGING';
        confidence = 100 - adx * 2;
        advice = { bias: 'NEUTRAL', strategy: 'Fade extremes, tight stops' };
    } else if (dirChanges > 12) {
        regime = 'CHOPPY';
        confidence = Math.min(100, dirChanges * 5);
        advice = { bias: 'AVOID', strategy: 'Reduce size or skip' };
    } else {
        regime = 'TRANSITIONAL';
        confidence = 50;
        advice = { bias: 'CAUTION', strategy: 'Wait for clarity' };
    }
    
    // 🛡️ HARDENING: Apply regime cooldown to prevent whipsaw
    if (typeof Hardening !== 'undefined') {
        const allowed = Hardening.updateRegime(regime);
        if (!allowed) {
            // Regime change was blocked by cooldown - use previous regime
            regime = Hardening.getRegime();
            advice.cooldownActive = true;
        }
    }
    
    return { regime, confidence, dirChanges, rangePercent, adx, advice };
}

// SECTION 5: DIRECTION AGREEMENT CHECK
function checkSmartAgreement(zoneDir, smcDir, momentumDir) {
    const directions = [zoneDir, smcDir, momentumDir].filter(d => d && d !== 'NEUTRAL');
    
    if (directions.length === 0) {
        return { agreement: 'NONE', count: 0, bonus: 1.0, direction: null };
    }
    
    const longCount = directions.filter(d => d === 'LONG').length;
    const shortCount = directions.filter(d => d === 'SHORT').length;
    
    // All 3 agree
    if (longCount === 3 || shortCount === 3) {
        return { 
            agreement: 'FULL', 
            direction: longCount === 3 ? 'LONG' : 'SHORT',
            count: 3, 
            bonus: 1.20 
        };
    }
    
    // 2 out of 3 agree
    if (longCount === 2 || shortCount === 2) {
        return { 
            agreement: 'MAJORITY', 
            direction: longCount > shortCount ? 'LONG' : 'SHORT',
            count: 2, 
            bonus: 1.10 
        };
    }
    
    // Conflict (1 LONG, 1 SHORT)
    if (longCount === 1 && shortCount === 1) {
        return { 
            agreement: 'CONFLICT', 
            direction: 'MIXED',
            count: 0, 
            bonus: 0.70 
        };
    }
    
    // Only 1 has direction
    return { 
        agreement: 'SINGLE', 
        direction: longCount === 1 ? 'LONG' : 'SHORT',
        count: 1, 
        bonus: 0.90 
    };
}

// SECTION 6: SMART MATRIX - MAIN WEIGHT CALCULATOR
function calculateSmartMatrix(zoneAnalysis, smcAnalysis, momentumAnalysis, klines) {
    
    // Step 1: Get confidence for each engine
    const zoneConf = getZoneConfidence(zoneAnalysis?.details?.primaryZone || zoneAnalysis?.details);
    const smcConf = getSMCConfidence(smcAnalysis);
    const momConf = getMomentumConfidence(momentumAnalysis);
    
    // Step 2: Detect market regime
    const adxValue = momentumAnalysis?.details?.adx?.adx || 20;
    const regime = detectMarketRegime(klines, adxValue);
    
    // Step 3: Check direction agreement
    const agreement = checkSmartAgreement(
        zoneAnalysis?.direction,
        smcAnalysis?.direction,
        momentumAnalysis?.direction
    );
    
    // Step 4: Calculate base weights from confidence
    let zoneWeight = 0.33 * (zoneConf.multiplier || 1);
    let smcWeight = 0.33 * (smcConf.multiplier || 1);
    let momWeight = 0.34 * (momConf.multiplier || 1);
    
    // Step 5: Apply regime adjustments
    switch (regime.regime) {
        case 'UPTREND':
        case 'DOWNTREND':
            smcWeight *= 1.15;
            momWeight *= 1.10;
            zoneWeight *= 0.90;
            break;
        case 'RANGING':
            zoneWeight *= 1.25;
            smcWeight *= 0.90;
            momWeight *= 0.85;
            break;
        case 'CHOPPY':
            momWeight *= 1.20;
            zoneWeight *= 0.85;
            smcWeight *= 0.85;
            break;
    }
    
    // Step 6: Normalize weights to 100%
    const totalWeight = zoneWeight + smcWeight + momWeight;
    if (totalWeight > 0) {
        zoneWeight = zoneWeight / totalWeight;
        smcWeight = smcWeight / totalWeight;
        momWeight = momWeight / totalWeight;
    } else {
        zoneWeight = 0.33; smcWeight = 0.33; momWeight = 0.34;
    }
    
    // Step 7: Determine dominant engine
    let dominant = 'BALANCED';
    if (zoneWeight > 0.40) dominant = 'ZONE';
    else if (smcWeight > 0.40) dominant = 'SMC';
    else if (momWeight > 0.40) dominant = 'MOMENTUM';
    
    return {
        weights: {
            zone: Math.round(zoneWeight * 100),
            smc: Math.round(smcWeight * 100),
            momentum: Math.round(momWeight * 100)
        },
        confidence: {
            zone: zoneConf,
            smc: smcConf,
            momentum: momConf
        },
        regime,
        agreement,
        dominant,
        display: `Z:${Math.round(zoneWeight * 100)}% S:${Math.round(smcWeight * 100)}% M:${Math.round(momWeight * 100)}%`
    };
}

// SECTION 7: APPLY SMART MATRIX TO SCORE
function applySmartMatrixScore(zoneScore, smcScore, momentumScore, smartMatrix) {
    // Null safety
    if (!smartMatrix || !smartMatrix.weights) {
        return {
            finalScore: Math.round((zoneScore * 0.35) + (smcScore * 0.35) + (momentumScore * 0.30)),
            breakdown: {
                zone: { raw: zoneScore, weighted: Math.round(zoneScore * 0.35), weight: '35%' },
                smc: { raw: smcScore, weighted: Math.round(smcScore * 0.35), weight: '35%' },
                momentum: { raw: momentumScore, weighted: Math.round(momentumScore * 0.30), weight: '30%' }
            }
        };
    }
    
    const w = smartMatrix.weights;
    
    // Apply weighted scores
    const weightedZone = zoneScore * ((w.zone || 33) / 100);
    const weightedSMC = smcScore * ((w.smc || 33) / 100);
    const weightedMom = momentumScore * ((w.momentum || 34) / 100);
    
    let finalScore = weightedZone + weightedSMC + weightedMom;
    
    // Apply agreement bonus/penalty (with null safety)
    finalScore *= smartMatrix.agreement?.bonus || 1.0;
    
    // Apply regime penalty for choppy (with null safety)
    if (smartMatrix.regime?.regime === 'CHOPPY') {
        finalScore *= 0.90;
    } else if ((smartMatrix.regime?.confidence || 0) > 70) {
        finalScore *= 1.05;
    }
    
    return {
        finalScore: Math.min(100, Math.round(finalScore)),
        breakdown: {
            zone: { raw: zoneScore, weighted: Math.round(weightedZone), weight: (w.zone || 33) + '%' },
            smc: { raw: smcScore, weighted: Math.round(weightedSMC), weight: (w.smc || 33) + '%' },
            momentum: { raw: momentumScore, weighted: Math.round(weightedMom), weight: (w.momentum || 34) + '%' }
        }
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🔥 PHASE 1: TOP TIER LIVE DATA SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════════
// FEATURE 1: LIQUIDATION STREAM (WebSocket)
// ═══════════════════════════════════════════════════════════════════════════════

let liqWebSocket = null;
let liqReconnectTimer = null;

function initLiquidationStream() {
    if (liqWebSocket && liqWebSocket.readyState === WebSocket.OPEN) return;
    
    try {
        console.log('💀 Connecting to Bybit Liquidation Stream...');
        STATE.liveData.wsReconnectAttempts++;
        
        liqWebSocket = new WebSocket('wss://stream.bybit.com/v5/public/linear');
        
        liqWebSocket.onopen = () => {
            console.log('💀 Liquidation WebSocket CONNECTED');
            STATE.liveData.wsConnected = true;
            STATE.liveData.wsReconnectAttempts = 0;
            updateLiveDataBar();
            
            // Subscribe to all liquidations
            liqWebSocket.send(JSON.stringify({
                op: 'subscribe',
                args: ['allLiquidation.USDT']
            }));
            
            // Heartbeat every 20 seconds
            setInterval(() => {
                if (liqWebSocket && liqWebSocket.readyState === WebSocket.OPEN) {
                    liqWebSocket.send(JSON.stringify({ op: 'ping' }));
                    STATE.liveData.wsLastHeartbeat = Date.now();
                }
            }, 20000);
        };
        
        liqWebSocket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                
                if (data.topic === 'allLiquidation.USDT' && data.data) {
                    processLiquidation(data.data);
                }
            } catch (e) {
                // Silent: Liq parse
            }
        };
        
        liqWebSocket.onerror = (error) => {
            // Silent fail - WebSocket error
            STATE.liveData.wsConnected = false;
            updateLiveDataBar();
        };
        
        liqWebSocket.onclose = () => {
            console.log('💀 Liquidation WebSocket CLOSED');
            STATE.liveData.wsConnected = false;
            updateLiveDataBar();
            
            // Auto-reconnect with backoff
            if (STATE.liveData.wsReconnectAttempts < 10) {
                const delay = Math.min(5000 * STATE.liveData.wsReconnectAttempts, 30000);
                console.log(`💀 Reconnecting in ${delay/1000}s...`);
                liqReconnectTimer = setTimeout(initLiquidationStream, delay);
            }
        };
        
    } catch (e) {
        console.error('💀 Failed to init liquidation stream:', e);
    }
}

function processLiquidation(liqData) {
    const liq = {
        symbol: liqData.symbol,
        side: liqData.side, // Buy = Short liquidated, Sell = Long liquidated
        size: parseFloat(liqData.size) || 0,
        price: parseFloat(liqData.price) || 0,
        value: (parseFloat(liqData.size) || 0) * (parseFloat(liqData.price) || 0),
        time: Date.now(),
        isLongLiq: liqData.side === 'Sell', // Sell order = Long position liquidated
        isShortLiq: liqData.side === 'Buy'  // Buy order = Short position liquidated
    };
    
    // Add to recent
    STATE.liveData.liquidations.recent.unshift(liq);
    if (STATE.liveData.liquidations.recent.length > 100) {
        STATE.liveData.liquidations.recent.pop();
    }
    
    // Update per-coin tracking
    if (!STATE.liveData.liquidations.byCoin[liq.symbol]) {
        STATE.liveData.liquidations.byCoin[liq.symbol] = { long: 0, short: 0 };
    }
    if (liq.isLongLiq) STATE.liveData.liquidations.byCoin[liq.symbol].long += liq.value;
    else STATE.liveData.liquidations.byCoin[liq.symbol].short += liq.value;
    
    // Track big liquidations
    if (liq.value > 500000) {
        STATE.liveData.liquidations.lastBigLiq = liq;
        showWhaleAlert({
            type: 'LIQUIDATION',
            symbol: liq.symbol,
            side: liq.isLongLiq ? 'LONG REKT' : 'SHORT REKT',
            amount: liq.value,
            price: liq.price
        });
    }
    
    // Recalculate totals
    calculateLiquidationTotals();
    updateLiveDataBar();
}

function calculateLiquidationTotals() {
    const now = Date.now();
    const fiveMinAgo = now - 5 * 60 * 1000;
    const fifteenMinAgo = now - 15 * 60 * 1000;
    
    let long5m = 0, short5m = 0, long15m = 0, short15m = 0;
    
    for (const liq of STATE.liveData.liquidations.recent) {
        if (liq.time > fifteenMinAgo) {
            if (liq.isLongLiq) long15m += liq.value;
            else short15m += liq.value;
            
            if (liq.time > fiveMinAgo) {
                if (liq.isLongLiq) long5m += liq.value;
                else short5m += liq.value;
            }
        }
    }
    
    STATE.liveData.liquidations.longTotal5m = long5m;
    STATE.liveData.liquidations.shortTotal5m = short5m;
    STATE.liveData.liquidations.longTotal15m = long15m;
    STATE.liveData.liquidations.shortTotal15m = short15m;
    
    // Calculate bias
    const total5m = long5m + short5m;
    if (total5m > 100000) { // Only calculate if significant volume
        const shortRatio = short5m / total5m;
        if (shortRatio > 0.65) {
            STATE.liveData.liquidations.bias = 'BULLISH'; // Shorts getting rekt = bullish
            STATE.liveData.liquidations.biasStrength = Math.round(shortRatio * 100);
        } else if (shortRatio < 0.35) {
            STATE.liveData.liquidations.bias = 'BEARISH'; // Longs getting rekt = bearish
            STATE.liveData.liquidations.biasStrength = Math.round((1 - shortRatio) * 100);
        } else {
            STATE.liveData.liquidations.bias = 'NEUTRAL';
            STATE.liveData.liquidations.biasStrength = 50;
        }
    } else {
        STATE.liveData.liquidations.bias = 'NEUTRAL';
        STATE.liveData.liquidations.biasStrength = 50;
    }
    
    // Detect cascade
    STATE.liveData.liquidations.cascadeDetected = total5m > 5000000; // $5M in 5 min = cascade
}

function getLiqBiasForCoin(symbol) {
    const coinLiqs = STATE.liveData.liquidations.byCoin[symbol];
    if (!coinLiqs) return { bias: 'NEUTRAL', strength: 0 };
    
    const total = coinLiqs.long + coinLiqs.short;
    if (total < 10000) return { bias: 'NEUTRAL', strength: 0 };
    
    const shortRatio = coinLiqs.short / total;
    if (shortRatio > 0.6) return { bias: 'BULLISH', strength: Math.round(shortRatio * 100) };
    if (shortRatio < 0.4) return { bias: 'BEARISH', strength: Math.round((1 - shortRatio) * 100) };
    return { bias: 'NEUTRAL', strength: 50 };
}

// ═══════════════════════════════════════════════════════════════════════════════
// FEATURE 2: OPEN INTEREST DELTA TRACKING
// ═══════════════════════════════════════════════════════════════════════════════

let oiHistory = {}; // Store OI history for delta calculation

// fetchOpenInterest is defined above (line ~4563) with comprehensive analysis

async function updateAllOpenInterest() {
    try {
        // Fetch BTC and ETH OI
        const btcOI = await fetchOpenInterest('BTCUSDT');
        const ethOI = await fetchOpenInterest('ETHUSDT');
        
        if (btcOI) {
            STATE.liveData.openInterest.btc = btcOI;
        }
        if (ethOI) {
            STATE.liveData.openInterest.eth = ethOI;
        }
        
        // Calculate total trend
        if (btcOI && ethOI) {
            const avgChange = (btcOI.changePct + ethOI.changePct) / 2;
            STATE.liveData.openInterest.total.trend = avgChange > 1 ? 'RISING' : avgChange < -1 ? 'FALLING' : 'FLAT';
            STATE.liveData.openInterest.total.change5m = avgChange;
        }
        
        STATE.liveData.openInterest.lastUpdate = Date.now();
        updateLiveDataBar();
        
    } catch (e) {
        // Silent: OI update
    }
}

function getOIForCoin(symbol) {
    return STATE.liveData.openInterest.byCoin[symbol] || STATE.liveData.openInterest.btc;
}

// ═══════════════════════════════════════════════════════════════════════════════
// FEATURE 3: WHALE / LARGE TRADE DETECTION
// ═══════════════════════════════════════════════════════════════════════════════

let tradeWebSocket = null;
const WHALE_THRESHOLD = 100000; // $100K minimum

function initWhaleStream() {
    // Use the same WebSocket approach but for trades
    // Note: Bybit public trade stream for major coins
    
    try {
        console.log('🐋 Initializing Whale Detection...');
        
        // We'll poll large trades instead of WebSocket for reliability
        setInterval(checkForWhaleTrades, 10000); // Every 10 seconds
        
    } catch (e) {
        console.error('🐋 Failed to init whale stream:', e);
    }
}

async function checkForWhaleTrades() {
    try {
        // Check recent trades for BTC
        const response = await fetch(`${CONFIG.BYBIT_V5}/market/recent-trade?category=linear&symbol=BTCUSDT&limit=50`);
        const data = await response.json();
        
        if (data.retCode === 0 && data.result?.list) {
            const now = Date.now();
            
            for (const trade of data.result.list) {
                const tradeValue = parseFloat(trade.size) * parseFloat(trade.price);
                const tradeTime = parseInt(trade.time);
                
                // Only process recent trades (last 30 seconds) above threshold
                if (tradeValue >= WHALE_THRESHOLD && (now - tradeTime) < 30000) {
                    // Check if we already processed this trade
                    const tradeId = `${trade.execId || trade.time}_${trade.size}`;
                    const alreadyProcessed = STATE.liveData.whales.recent.some(w => w.id === tradeId);
                    
                    if (!alreadyProcessed) {
                        processWhaleTrade({
                            id: tradeId,
                            symbol: 'BTCUSDT',
                            side: trade.side,
                            size: parseFloat(trade.size),
                            price: parseFloat(trade.price),
                            value: tradeValue,
                            time: tradeTime,
                            isBuy: trade.side === 'Buy'
                        });
                    }
                }
            }
        }
    } catch (e) {
        // Silent fail - Whale check
    }
}

function processWhaleTrade(trade) {
    // Add to recent
    STATE.liveData.whales.recent.unshift(trade);
    if (STATE.liveData.whales.recent.length > 50) {
        STATE.liveData.whales.recent.pop();
    }
    
    // Update volume tracking
    const fiveMinAgo = Date.now() - 5 * 60 * 1000;
    let buy5m = 0, sell5m = 0;
    
    for (const w of STATE.liveData.whales.recent) {
        if (w.time > fiveMinAgo) {
            if (w.isBuy) buy5m += w.value;
            else sell5m += w.value;
        }
    }
    
    STATE.liveData.whales.buyVolume5m = buy5m;
    STATE.liveData.whales.sellVolume5m = sell5m;
    
    // Calculate bias
    const total = buy5m + sell5m;
    if (total > 500000) {
        const buyRatio = buy5m / total;
        if (buyRatio > 0.6) STATE.liveData.whales.bias = 'BUYING';
        else if (buyRatio < 0.4) STATE.liveData.whales.bias = 'SELLING';
        else STATE.liveData.whales.bias = 'NEUTRAL';
    }
    
    STATE.liveData.whales.lastWhale = trade;
    
    // Show alert for big whales
    if (trade.value >= 250000) { // $250K+ gets alert
        showWhaleAlert({
            type: 'WHALE',
            symbol: trade.symbol,
            side: trade.isBuy ? 'BUY' : 'SELL',
            amount: trade.value,
            price: trade.price
        });
    }
    
    updateLiveDataBar();
}

function showWhaleAlert(alert) {
    // Add to queue
    STATE.liveData.whales.alertQueue.push(alert);
    
    // Create popup
    const popup = document.createElement('div');
    popup.className = 'whale-alert-popup';
    popup.innerHTML = `
        <div style="display:flex;align-items:center">
            <span class="whale-icon">${alert.type === 'WHALE' ? '🐋' : '💀'}</span>
            <div class="whale-info">
                <span class="whale-coin">${alert.symbol} ${alert.side}</span>
                <span class="whale-details">@ $${formatPrice(alert.price)}</span>
            </div>
            <span class="whale-amount ${alert.side === 'BUY' || alert.side === 'SHORT REKT' ? 'buy' : 'sell'}">
                $${formatLargeNumber(alert.amount)}
            </span>
        </div>
    `;
    
    document.body.appendChild(popup);
    
    // Play sound if enabled
    if (STATE.alertSound) {
        try {
            const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2IkZmgnpmOgXJkWVBLR0dKT1dfaXN/iZKZnp+elI2BeG1iVk5JR0hMUlpkaHJ9h5CXnJ6dmpaOgndpXVNKRkVGSk9ZYmtye4WNk5eZl5KLgXZqXlNKRkRERktRWWJqc3yFjZKVlpSQiX50aF1TSkhFRUhLUVliand/ho2Sk5OQjIR6b2RaUUpHRUVITFJaY2t0fYWMkJKRjoqCeG5kWlFKR0VFR0tQV19nbHR8g4mNj46Lh391a2FXUEpGRERGSk5VXWVscnl/hYqMjIqGgHdtY1lRSkZEREZKTlReZWxze4GGioqKhoJ8dGpiWFFLR0VFR0tPVl5lbHJ5f4SHiYiGgn15cWlgWFBKRkRERkhMUVhfZmxzeX6Dhodd');
            audio.volume = 0.3;
            audio.play();
        } catch(e) {}
    }
    
    // Remove after 4 seconds
    setTimeout(() => {
        popup.style.animation = 'whaleSlideIn 0.3s ease-out reverse';
        setTimeout(() => popup.remove(), 300);
    }, 4000);
}

// ═══════════════════════════════════════════════════════════════════════════════
// FEATURE 4: FUNDING RATE TRACKER
// ═══════════════════════════════════════════════════════════════════════════════

async function fetchFundingRates() {
    try {
        // Fetch funding rates for major coins
        const coins = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'BNBUSDT', 'XRPUSDT'];
        const rates = {};
        let extremeCoins = [];
        
        for (const coin of coins) {
            try {
                const response = await fetch(`${CONFIG.BYBIT_V5}/market/tickers?category=linear&symbol=${coin}`);
                const data = await response.json();
                
                if (data.retCode === 0 && data.result?.list?.[0]) {
                    const ticker = data.result.list[0];
                    const rate = parseFloat(ticker.fundingRate) * 100 || 0;
                    const nextTime = parseInt(ticker.nextFundingTime) || 0;
                    
                    rates[coin] = {
                        rate: rate,
                        predicted: rate, // Could be enhanced with prediction logic
                        nextTime: nextTime,
                        countdown: formatCountdown(nextTime - Date.now())
                    };
                    
                    // Track extreme funding
                    if (Math.abs(rate) > 0.03) { // > 0.03% is elevated
                        extremeCoins.push({ coin, rate });
                    }
                }
                
                await new Promise(r => setTimeout(r, 100)); // Rate limit
            } catch (e) {
                // Silent fail - Funding fetch
            }
        }
        
        // Update state
        if (rates.BTCUSDT) STATE.liveData.funding.btc = rates.BTCUSDT;
        if (rates.ETHUSDT) STATE.liveData.funding.eth = rates.ETHUSDT;
        STATE.liveData.funding.byCoin = rates;
        STATE.liveData.funding.extremeCoins = extremeCoins;
        
        // Calculate average
        const allRates = Object.values(rates).map(r => r.rate);
        STATE.liveData.funding.average = allRates.length > 0 
            ? allRates.reduce((a, b) => a + b, 0) / allRates.length 
            : 0;
        
        STATE.liveData.funding.lastUpdate = Date.now();
        updateLiveDataBar();
        
    } catch (e) {
        // Silent: Funding update
    }
}

function formatCountdown(ms) {
    if (ms <= 0) return '00:00';
    const hours = Math.floor(ms / 3600000);
    const minutes = Math.floor((ms % 3600000) / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    if (hours > 0) return `${hours}h ${minutes}m`;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function getFundingForCoin(symbol) {
    return STATE.liveData.funding.byCoin[symbol] || STATE.liveData.funding.btc;
}

// ═══════════════════════════════════════════════════════════════════════════════
// LIVE DATA BAR UI UPDATE
// ═══════════════════════════════════════════════════════════════════════════════

function updateLiveDataBar() {
    const bar = document.getElementById('liveDataBar');
    if (!bar) return;
    
    const liq = STATE.liveData.liquidations;
    const oi = STATE.liveData.openInterest;
    const whale = STATE.liveData.whales;
    const funding = STATE.liveData.funding;
    
    // Format large numbers
    const fmtM = (v) => v >= 1000000 ? (v/1000000).toFixed(1) + 'M' : v >= 1000 ? (v/1000).toFixed(0) + 'K' : v.toFixed(0);
    
    // Determine classes
    const liqClass = liq.bias === 'BULLISH' ? 'bullish' : liq.bias === 'BEARISH' ? 'bearish' : 'neutral';
    const oiClass = oi.btc.trend === 'RISING' ? 'bullish' : oi.btc.trend === 'FALLING' ? 'bearish' : 'neutral';
    const whaleClass = whale.bias === 'BUYING' ? 'bullish' : whale.bias === 'SELLING' ? 'bearish' : 'neutral';
    const fundingClass = funding.btc.rate > 0.02 ? 'bullish' : funding.btc.rate < -0.02 ? 'bearish' : 'neutral';
    
    bar.innerHTML = `
        <div class="live-dot ${STATE.liveData.wsConnected ? '' : 'disconnected'}"></div>
        
        <div class="live-badge liq-badge ${liqClass} ${liq.cascadeDetected ? 'liq-cascade' : ''}">
            <span class="icon">💀</span>
            <span class="label">LIQS</span>
            <span class="value">
                <span class="liq-long">L:$${fmtM(liq.longTotal5m)}</span>
                <span class="liq-short">S:$${fmtM(liq.shortTotal5m)}</span>
            </span>
        </div>
        
        <div class="live-badge oi-badge ${oiClass}">
            <span class="icon">📊</span>
            <span class="label">OI</span>
            <span class="value ${oi.btc.trend === 'RISING' ? 'oi-up' : oi.btc.trend === 'FALLING' ? 'oi-down' : ''}">
                ${oi.btc.changePct > 0 ? '+' : ''}${oi.btc.changePct?.toFixed(1) || '0'}%
            </span>
            <div class="oi-bar">
                <div class="oi-bar-fill ${oi.btc.changePct >= 0 ? 'positive' : 'negative'}" 
                     style="width:${Math.min(100, Math.abs(oi.btc.changePct || 0) * 10)}%"></div>
            </div>
        </div>
        
        <div class="live-badge whale-badge ${whaleClass} ${whale.lastWhale && Date.now() - whale.lastWhale.time < 60000 ? 'active' : ''}">
            <span class="icon">🐋</span>
            <span class="label">WHALE</span>
            <span class="value">${whale.bias}</span>
        </div>
        
        <div class="live-badge funding-badge ${fundingClass}">
            <span class="icon">💰</span>
            <span class="label">FUND</span>
            <span class="value">${funding.btc.rate?.toFixed(3) || '0.000'}%</span>
            <span class="countdown">${funding.btc.countdown || '--:--'}</span>
        </div>
    `;
}

function formatLargeNumber(num) {
    if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(0) + 'K';
    return num.toFixed(0);
}

function formatPrice(price) {
    if (price >= 10000) return price.toFixed(0);
    if (price >= 100) return price.toFixed(1);
    if (price >= 1) return price.toFixed(2);
    return price.toFixed(4);
}

// ═══════════════════════════════════════════════════════════════════════════════
// GET LIVE DATA FOR SIGNAL CARD
// ═══════════════════════════════════════════════════════════════════════════════

function getLiveDataForSignal(symbol, direction) {
    const liqBias = getLiqBiasForCoin(symbol);
    const funding = getFundingForCoin(symbol);
    const oi = getOIForCoin(symbol);
    
    // Determine if live data supports or opposes signal direction
    let liqSupport = 'neutral';
    let fundingSupport = 'neutral';
    let oiSupport = 'neutral';
    
    // Liquidation: shorts rekt = bullish, longs rekt = bearish
    if (liqBias.bias === 'BULLISH' && direction === 'LONG') liqSupport = 'support';
    else if (liqBias.bias === 'BEARISH' && direction === 'SHORT') liqSupport = 'support';
    else if (liqBias.bias === 'BULLISH' && direction === 'SHORT') liqSupport = 'oppose';
    else if (liqBias.bias === 'BEARISH' && direction === 'LONG') liqSupport = 'oppose';
    
    // Funding: positive funding = more longs (bearish for longs due to cost)
    if (funding) {
        if (funding.rate > 0.03 && direction === 'SHORT') fundingSupport = 'support';
        else if (funding.rate < -0.03 && direction === 'LONG') fundingSupport = 'support';
        else if (funding.rate > 0.03 && direction === 'LONG') fundingSupport = 'oppose';
        else if (funding.rate < -0.03 && direction === 'SHORT') fundingSupport = 'oppose';
    }
    
    // OI: Rising OI = trend continuation, Falling OI = potential reversal
    if (oi) {
        if (oi.trend === 'RISING') oiSupport = 'support'; // Trend confirmation
        else if (oi.trend === 'FALLING') oiSupport = 'caution';
    }
    
    return {
        liq: liqBias,
        funding: funding,
        oi: oi,
        liqSupport,
        fundingSupport,
        oiSupport,
        whale: STATE.liveData.whales.bias
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// INITIALIZE ALL PHASE 1 FEATURES
// ═══════════════════════════════════════════════════════════════════════════════

function initPhase1LiveData() {
    console.log('🔥 Initializing Phase 1 Live Data System...');
    
    // Start liquidation stream
    initLiquidationStream();
    
    // Start whale detection
    initWhaleStream();
    
    // Initial data fetch
    updateAllOpenInterest();
    fetchFundingRates();
    
    // Set up periodic updates - ADD TO MANAGED INTERVALS
    if (!window.liveDataIntervals) window.liveDataIntervals = [];
    window.liveDataIntervals.push(setInterval(updateAllOpenInterest, 60000));   // OI every 1 min
    window.liveDataIntervals.push(setInterval(fetchFundingRates, 30000));       // Funding every 30 sec
    window.liveDataIntervals.push(setInterval(calculateLiquidationTotals, 5000)); // Recalc liqs every 5 sec
    
    // Update funding countdown every second
    window.liveDataIntervals.push(setInterval(() => {
        if (STATE.liveData.funding.btc.nextTime) {
            STATE.liveData.funding.btc.countdown = formatCountdown(STATE.liveData.funding.btc.nextTime - Date.now());
            updateLiveDataBar();
        }
    }, 1000));
    
    console.log('🔥 Phase 1 Live Data System READY!');
}

// ═══════════════════════════════════════════════════════════════════════════════
// 📊 PHASE 2: VOLUME PROFILE ANALYSIS
// ═══════════════════════════════════════════════════════════════════════════════

function calculateVolumeProfile(klines, numLevels = 24) {
    if (!klines || klines.length < 20) {
        return { poc: 0, valueAreaHigh: 0, valueAreaLow: 0, levels: [], hvnZones: [], lvnZones: [] };
    }
    
    // Find price range
    let highestHigh = 0;
    let lowestLow = Infinity;
    let totalVolume = 0;
    
    for (const k of klines) {
        if (k.high > highestHigh) highestHigh = k.high;
        if (k.low < lowestLow) lowestLow = k.low;
        totalVolume += k.volume;
    }
    
    const range = highestHigh - lowestLow;
    if (range <= 0) return { poc: klines[klines.length - 1].close, valueAreaHigh: highestHigh, valueAreaLow: lowestLow, levels: [] };
    
    const levelSize = range / numLevels;
    const levels = [];
    
    // Initialize levels
    for (let i = 0; i < numLevels; i++) {
        levels.push({
            priceHigh: highestHigh - (i * levelSize),
            priceLow: highestHigh - ((i + 1) * levelSize),
            priceMid: highestHigh - (i * levelSize) - (levelSize / 2),
            volume: 0,
            buyVolume: 0,
            sellVolume: 0,
            trades: 0
        });
    }
    
    // Distribute volume across levels
    for (const k of klines) {
        const candleRange = k.high - k.low;
        const isBullish = k.close > k.open;
        
        for (let i = 0; i < numLevels; i++) {
            const level = levels[i];
            
            // Check if candle touches this level
            if (k.high >= level.priceLow && k.low <= level.priceHigh) {
                // Calculate overlap
                const overlapHigh = Math.min(k.high, level.priceHigh);
                const overlapLow = Math.max(k.low, level.priceLow);
                const overlapPct = candleRange > 0 ? (overlapHigh - overlapLow) / candleRange : 1;
                
                const volAtLevel = k.volume * overlapPct;
                level.volume += volAtLevel;
                level.trades++;
                
                // Estimate buy/sell based on candle direction
                if (isBullish) {
                    level.buyVolume += volAtLevel * 0.6;
                    level.sellVolume += volAtLevel * 0.4;
                } else {
                    level.sellVolume += volAtLevel * 0.6;
                    level.buyVolume += volAtLevel * 0.4;
                }
            }
        }
    }
    
    // Find POC (Point of Control) - highest volume level
    let poc = levels[0];
    for (const level of levels) {
        if (level.volume > poc.volume) {
            poc = level;
        }
    }
    
    // Calculate Value Area (70% of volume)
    const sortedByVolume = [...levels].sort((a, b) => b.volume - a.volume);
    const targetVolume = totalVolume * 0.70;
    let accumulatedVolume = 0;
    const valueAreaLevels = [];
    
    for (const level of sortedByVolume) {
        if (accumulatedVolume < targetVolume) {
            valueAreaLevels.push(level);
            accumulatedVolume += level.volume;
        }
    }
    
    // Find VAH and VAL
    let valueAreaHigh = 0;
    let valueAreaLow = Infinity;
    for (const level of valueAreaLevels) {
        if (level.priceHigh > valueAreaHigh) valueAreaHigh = level.priceHigh;
        if (level.priceLow < valueAreaLow) valueAreaLow = level.priceLow;
    }
    
    // Identify HVN (High Volume Nodes) and LVN (Low Volume Nodes)
    const avgVolume = totalVolume / numLevels;
    const hvnZones = levels.filter(l => l.volume > avgVolume * 1.5).map(l => ({ price: l.priceMid, volume: l.volume, type: 'HVN' }));
    const lvnZones = levels.filter(l => l.volume < avgVolume * 0.5 && l.volume > 0).map(l => ({ price: l.priceMid, volume: l.volume, type: 'LVN' }));
    
    return {
        poc: poc.priceMid,
        pocVolume: poc.volume,
        valueAreaHigh,
        valueAreaLow,
        levels,
        hvnZones,
        lvnZones,
        totalVolume,
        avgVolume,
        range: { high: highestHigh, low: lowestLow }
    };
}

function analyzeVolumeProfileSignal(klines, currentPrice, direction) {
    const vp = calculateVolumeProfile(klines);
    
    if (!vp || !vp.poc) {
        return { valid: false, score: 0, factors: [], support: 'neutral' };
    }
    
    const factors = [];
    let score = 50;
    let support = 'neutral';
    
    const priceVsPOC = ((currentPrice - vp.poc) / vp.poc) * 100;
    const priceVsVAH = ((currentPrice - vp.valueAreaHigh) / vp.valueAreaHigh) * 100;
    const priceVsVAL = ((currentPrice - vp.valueAreaLow) / vp.valueAreaLow) * 100;
    
    // Check if price is at POC (strong support/resistance)
    if (Math.abs(priceVsPOC) < 0.5) {
        factors.push('📊 At POC (strong level)');
        score += 15;
    }
    
    // Check if price is at Value Area boundaries
    if (direction === 'LONG') {
        if (Math.abs(priceVsVAL) < 0.5) {
            factors.push('📊 At VAL (support)');
            score += 20;
            support = 'strong';
        } else if (currentPrice < vp.valueAreaLow) {
            factors.push('📊 Below Value Area');
            score += 10;
            support = 'support';
        } else if (currentPrice > vp.valueAreaHigh) {
            factors.push('⚠️ Above Value Area');
            score -= 10;
            support = 'caution';
        }
    } else { // SHORT
        if (Math.abs(priceVsVAH) < 0.5) {
            factors.push('📊 At VAH (resistance)');
            score += 20;
            support = 'strong';
        } else if (currentPrice > vp.valueAreaHigh) {
            factors.push('📊 Above Value Area');
            score += 10;
            support = 'support';
        } else if (currentPrice < vp.valueAreaLow) {
            factors.push('⚠️ Below Value Area');
            score -= 10;
            support = 'caution';
        }
    }
    
    // Check for LVN (fast move zones)
    const nearbyLVN = vp.lvnZones.find(z => Math.abs((currentPrice - z.price) / z.price) < 0.01);
    if (nearbyLVN) {
        factors.push('⚡ Near LVN (fast move zone)');
        score += 10;
    }
    
    // Check for HVN (accumulation zones)
    const nearbyHVN = vp.hvnZones.find(z => Math.abs((currentPrice - z.price) / z.price) < 0.01);
    if (nearbyHVN) {
        factors.push('🏦 Near HVN (accumulation)');
        score += 5;
    }
    
    return {
        valid: true,
        score: Math.min(100, Math.max(0, score)),
        factors,
        support,
        profile: vp,
        analysis: {
            priceVsPOC,
            priceVsVAH,
            priceVsVAL,
            inValueArea: currentPrice >= vp.valueAreaLow && currentPrice <= vp.valueAreaHigh
        }
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🌊 PHASE 3: ORDER FLOW LITE - AGGRESSION & ABSORPTION DETECTION
// ═══════════════════════════════════════════════════════════════════════════════

function analyzeOrderFlow(klines) {
    if (!klines || klines.length < 20) {
        return { delta: 0, aggression: 'NEUTRAL', absorption: false, imbalance: [], stackedBids: false, stackedAsks: false };
    }
    
    const recentKlines = klines.slice(-20);
    let buyPressure = 0;
    let sellPressure = 0;
    let absorptionCandles = 0;
    let imbalances = [];
    let consecutiveBuy = 0;
    let consecutiveSell = 0;
    let maxConsecBuy = 0;
    let maxConsecSell = 0;
    
    for (let i = 0; i < recentKlines.length; i++) {
        const k = recentKlines[i];
        const body = Math.abs(k.close - k.open);
        const upperWick = k.high - Math.max(k.open, k.close);
        const lowerWick = Math.min(k.open, k.close) - k.low;
        const totalRange = k.high - k.low;
        const isBullish = k.close > k.open;
        
        // Estimate buy/sell pressure based on candle structure
        if (isBullish) {
            // Bullish candle - buying pressure
            const buyStrength = body / (totalRange || 1);
            buyPressure += k.volume * (0.5 + buyStrength * 0.5);
            sellPressure += k.volume * (0.5 - buyStrength * 0.5);
            
            consecutiveBuy++;
            consecutiveSell = 0;
            if (consecutiveBuy > maxConsecBuy) maxConsecBuy = consecutiveBuy;
        } else {
            // Bearish candle - selling pressure
            const sellStrength = body / (totalRange || 1);
            sellPressure += k.volume * (0.5 + sellStrength * 0.5);
            buyPressure += k.volume * (0.5 - sellStrength * 0.5);
            
            consecutiveSell++;
            consecutiveBuy = 0;
            if (consecutiveSell > maxConsecSell) maxConsecSell = consecutiveSell;
        }
        
        // Detect absorption (large wick with high volume, small body)
        const wickRatio = (upperWick + lowerWick) / (totalRange || 1);
        const bodyRatio = body / (totalRange || 1);
        const avgVol = recentKlines.reduce((s, c) => s + c.volume, 0) / recentKlines.length;
        
        if (wickRatio > 0.6 && bodyRatio < 0.3 && k.volume > avgVol * 1.5) {
            absorptionCandles++;
        }
        
        // Detect imbalance (3+ consecutive same direction with increasing volume)
        if (i >= 2) {
            const prev1 = recentKlines[i - 1];
            const prev2 = recentKlines[i - 2];
            const allBullish = isBullish && prev1.close > prev1.open && prev2.close > prev2.open;
            const allBearish = !isBullish && prev1.close < prev1.open && prev2.close < prev2.open;
            const volIncreasing = k.volume > prev1.volume && prev1.volume > prev2.volume;
            
            if ((allBullish || allBearish) && volIncreasing) {
                imbalances.push({
                    index: i,
                    direction: allBullish ? 'BUY' : 'SELL',
                    strength: 'STACKED'
                });
            }
        }
    }
    
    // Calculate delta
    const delta = buyPressure - sellPressure;
    const totalPressure = buyPressure + sellPressure;
    const deltaPercent = totalPressure > 0 ? (delta / totalPressure) * 100 : 0;
    
    // Determine aggression
    let aggression = 'NEUTRAL';
    if (deltaPercent > 20) aggression = 'STRONG_BUY';
    else if (deltaPercent > 10) aggression = 'BUY';
    else if (deltaPercent < -20) aggression = 'STRONG_SELL';
    else if (deltaPercent < -10) aggression = 'SELL';
    
    // Check for stacked imbalances
    const stackedBids = maxConsecBuy >= 3;
    const stackedAsks = maxConsecSell >= 3;
    
    return {
        delta,
        deltaPercent,
        buyPressure,
        sellPressure,
        aggression,
        absorption: absorptionCandles >= 2,
        absorptionCount: absorptionCandles,
        imbalance: imbalances,
        stackedBids,
        stackedAsks,
        maxConsecBuy,
        maxConsecSell
    };
}

function getOrderFlowSignal(klines, direction) {
    const of = analyzeOrderFlow(klines);
    
    let support = 'neutral';
    let score = 50;
    const factors = [];
    
    // Check aggression alignment
    if (direction === 'LONG') {
        if (of.aggression === 'STRONG_BUY') {
            support = 'strong';
            score += 25;
            factors.push('🌊 Strong Buy Aggression');
        } else if (of.aggression === 'BUY') {
            support = 'support';
            score += 15;
            factors.push('🌊 Buy Aggression');
        } else if (of.aggression === 'STRONG_SELL') {
            support = 'oppose';
            score -= 20;
            factors.push('⚠️ Strong Sell Aggression');
        } else if (of.aggression === 'SELL') {
            support = 'caution';
            score -= 10;
            factors.push('⚠️ Sell Aggression');
        }
        
        if (of.stackedBids) {
            score += 15;
            factors.push('📈 Stacked Buy Imbalance');
        }
    } else { // SHORT
        if (of.aggression === 'STRONG_SELL') {
            support = 'strong';
            score += 25;
            factors.push('🌊 Strong Sell Aggression');
        } else if (of.aggression === 'SELL') {
            support = 'support';
            score += 15;
            factors.push('🌊 Sell Aggression');
        } else if (of.aggression === 'STRONG_BUY') {
            support = 'oppose';
            score -= 20;
            factors.push('⚠️ Strong Buy Aggression');
        } else if (of.aggression === 'BUY') {
            support = 'caution';
            score -= 10;
            factors.push('⚠️ Buy Aggression');
        }
        
        if (of.stackedAsks) {
            score += 15;
            factors.push('📉 Stacked Sell Imbalance');
        }
    }
    
    // Absorption detection
    if (of.absorption) {
        factors.push('🛡️ Absorption Detected');
        score += 10;
    }
    
    return {
        score: Math.min(100, Math.max(0, score)),
        support,
        factors,
        flow: of
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🤖 PHASE 4: ML-LITE PATTERN RECOGNITION & WIN PROBABILITY
// ═══════════════════════════════════════════════════════════════════════════════

// Pattern memory (persisted)
let ML_PATTERN_DB = [];
const ML_MIN_PATTERNS = 20;

function initMLSystem() {
    try {
        const saved = localStorage.getItem('ml_pattern_db');
        if (saved) {
            ML_PATTERN_DB = JSON.parse(saved);
            console.log(`🤖 ML System loaded: ${ML_PATTERN_DB.length} patterns`);
        }
    } catch (e) {
        console.warn('ML init error:', e);
        ML_PATTERN_DB = [];
    }
}

function saveMLPatterns() {
    try {
        // Keep only last 1000 patterns
        if (ML_PATTERN_DB.length > 1000) {
            ML_PATTERN_DB = ML_PATTERN_DB.slice(-1000);
        }
        localStorage.setItem('ml_pattern_db', JSON.stringify(ML_PATTERN_DB));
    } catch (e) {
        console.warn('ML save error:', e);
    }
}

function extractSignalFeatures(signal, klines) {
    // Extract normalized features for pattern matching
    const features = {
        // Score features (normalized 0-1)
        zoneScore: (signal.scores?.zone || 0) / 100,
        smcScore: (signal.scores?.smc || 0) / 100,
        momentumScore: (signal.scores?.momentum || 0) / 100,
        totalScore: (signal.score || 0) / 100,
        
        // Direction (1 = LONG, 0 = SHORT)
        direction: signal.direction === 'LONG' ? 1 : 0,
        
        // Agreement (normalized)
        agreement: (signal.agreed || 0) / 3,
        
        // Timeframe bucket
        tfBucket: ['5', '15', '30'].includes(signal.tfRaw) ? 0 : 
                  signal.tfRaw === '60' ? 0.5 : 1,
        
        // Price position features
        rsi: 0.5,
        atrRatio: 0,
        volumeRatio: 0
    };
    
    // Extract from klines if available
    if (klines && klines.length > 0) {
        const closes = klines.slice(-14).map(k => k.close);
        const volumes = klines.slice(-20).map(k => k.volume);
        
        // Simple RSI approximation
        let gains = 0, losses = 0;
        for (let i = 1; i < closes.length; i++) {
            const change = closes[i] - closes[i-1];
            if (change > 0) gains += change;
            else losses -= change;
        }
        const rs = losses > 0 ? gains / losses : 100;
        features.rsi = Math.min(1, rs / (1 + rs));
        
        // Volume ratio
        const avgVol = volumes.reduce((a, b) => a + b, 0) / volumes.length;
        const lastVol = volumes[volumes.length - 1] || avgVol;
        features.volumeRatio = Math.min(1, lastVol / (avgVol * 2));
    }
    
    return features;
}

function calculateFeatureDistance(f1, f2) {
    // Euclidean distance between feature vectors
    let sum = 0;
    const weights = {
        zoneScore: 1.5,
        smcScore: 1.5,
        momentumScore: 1.0,
        totalScore: 2.0,
        direction: 3.0, // Direction is very important
        agreement: 1.5,
        tfBucket: 0.5,
        rsi: 0.8,
        volumeRatio: 0.5
    };
    
    for (const key in weights) {
        const diff = (f1[key] || 0) - (f2[key] || 0);
        sum += (diff * diff) * weights[key];
    }
    
    return Math.sqrt(sum);
}

function findSimilarPatterns(features, maxDistance = 0.5, limit = 20) {
    const similar = [];
    
    for (const pattern of ML_PATTERN_DB) {
        const distance = calculateFeatureDistance(features, pattern.features);
        if (distance <= maxDistance) {
            similar.push({ pattern, distance });
        }
    }
    
    // Sort by distance (closest first)
    similar.sort((a, b) => a.distance - b.distance);
    
    return similar.slice(0, limit);
}

function predictWinProbability(signal, klines) {
    if (ML_PATTERN_DB.length < ML_MIN_PATTERNS) {
        return {
            probability: 50,
            confidence: 'LOW',
            sampleSize: ML_PATTERN_DB.length,
            message: `Need ${ML_MIN_PATTERNS - ML_PATTERN_DB.length} more trades for prediction`
        };
    }
    
    const features = extractSignalFeatures(signal, klines);
    const similar = findSimilarPatterns(features);
    
    if (similar.length < 5) {
        return {
            probability: 50,
            confidence: 'LOW',
            sampleSize: similar.length,
            message: 'Not enough similar patterns'
        };
    }
    
    // Calculate win rate from similar patterns
    let wins = 0;
    let totalPnL = 0;
    let weightedWins = 0;
    let totalWeight = 0;
    
    for (const { pattern, distance } of similar) {
        const weight = 1 / (1 + distance); // Closer patterns have more weight
        totalWeight += weight;
        
        if (pattern.outcome === 'WIN') {
            wins++;
            weightedWins += weight;
        }
        totalPnL += pattern.pnl || 0;
    }
    
    const rawWinRate = (wins / similar.length) * 100;
    const weightedWinRate = (weightedWins / totalWeight) * 100;
    const avgPnL = totalPnL / similar.length;
    
    // Confidence based on sample size and consistency
    let confidence = 'LOW';
    if (similar.length >= 15 && Math.abs(weightedWinRate - 50) > 15) {
        confidence = 'HIGH';
    } else if (similar.length >= 10) {
        confidence = 'MEDIUM';
    }
    
    return {
        probability: Math.round(weightedWinRate),
        rawWinRate: Math.round(rawWinRate),
        confidence,
        sampleSize: similar.length,
        avgPnL: avgPnL.toFixed(2),
        suggestion: weightedWinRate >= 60 ? 'FAVORABLE' : 
                   weightedWinRate <= 40 ? 'UNFAVORABLE' : 'NEUTRAL'
    };
}

function recordTradeOutcome(signal, outcome, pnl) {
    // Record trade for ML learning
    const features = extractSignalFeatures(signal, null);
    
    ML_PATTERN_DB.push({
        features,
        outcome, // 'WIN' or 'LOSS'
        pnl,
        timestamp: Date.now(),
        symbol: signal.symbol,
        tf: signal.tfRaw,
        direction: signal.direction,
        grade: signal.grade
    });
    
    saveMLPatterns();
    console.log(`🤖 ML: Recorded ${outcome} trade. Total patterns: ${ML_PATTERN_DB.length}`);
    
    // V10: Also record to Adaptive Learning system
    recordAdaptiveLearning(signal, outcome, pnl);
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🧠 V10 ADAPTIVE LEARNING - Records trade outcomes per coin/tf/direction
// ═══════════════════════════════════════════════════════════════════════════════

function recordAdaptiveLearning(signal, outcome, pnl) {
    try {
        const learningKey = `${signal.symbol}_${signal.tfRaw || signal.tf}_${signal.direction}`;
        
        // Load existing data
        let learningData = {};
        const saved = localStorage.getItem('bs_learning_v10');
        if (saved) {
            learningData = JSON.parse(saved);
        }
        
        // Initialize if new
        if (!learningData[learningKey]) {
            learningData[learningKey] = {
                wins: 0,
                losses: 0,
                trades: 0,
                totalPnl: 0,
                avgPnl: 0,
                lastTrade: null,
                history: []
            };
        }
        
        const data = learningData[learningKey];
        
        // Update stats
        data.trades++;
        if (outcome === 'WIN') {
            data.wins++;
        } else {
            data.losses++;
        }
        data.totalPnl += pnl || 0;
        data.avgPnl = data.totalPnl / data.trades;
        data.lastTrade = Date.now();
        
        // Keep last 50 trades in history
        data.history.push({
            outcome,
            pnl,
            timestamp: Date.now()
        });
        if (data.history.length > 50) {
            data.history.shift();
        }
        
        // Save back
        localStorage.setItem('bs_learning_v10', JSON.stringify(learningData));
        
        const winRate = ((data.wins / data.trades) * 100).toFixed(0);
        console.log(`🧠 V10 Learning: ${learningKey} - ${winRate}% WR (${data.trades} trades)`);
        
    } catch (e) {
        console.warn('Adaptive learning save error:', e);
    }
}

// Get learning stats for display
function getLearningStats() {
    try {
        const saved = localStorage.getItem('bs_learning_v10');
        if (!saved) return { total: 0, combos: [] };
        
        const learningData = JSON.parse(saved);
        const combos = [];
        let totalTrades = 0;
        
        for (const [key, data] of Object.entries(learningData)) {
            if (data.trades >= 5) {
                const [symbol, tf, dir] = key.split('_');
                const winRate = (data.wins / data.trades * 100).toFixed(0);
                combos.push({
                    key,
                    symbol: symbol.replace('USDT', ''),
                    tf,
                    direction: dir,
                    winRate: parseFloat(winRate),
                    trades: data.trades,
                    avgPnl: data.avgPnl.toFixed(2),
                    status: winRate >= 60 ? 'GOOD' : winRate >= 50 ? 'OK' : 'BAD'
                });
                totalTrades += data.trades;
            }
        }
        
        // Sort by trades (most traded first)
        combos.sort((a, b) => b.trades - a.trades);
        
        return { total: totalTrades, combos };
    } catch (e) {
        return { total: 0, combos: [] };
    }
}

// Clear learning data (reset)
function clearLearningData() {
    if (confirm('Clear all learning data? This cannot be undone.')) {
        localStorage.removeItem('bs_learning_v10');
        alert('Learning data cleared. Scanner will start fresh.');
        console.log('🧠 V10 Learning data cleared');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🎯 PHASE 2-4 COMBINED: ADVANCED SIGNAL ANALYSIS
// ═══════════════════════════════════════════════════════════════════════════════

function getAdvancedAnalysis(signal, klines) {
    const result = {
        volumeProfile: null,
        orderFlow: null,
        mlPrediction: null,
        combinedScore: 0,
        confidence: 'LOW',
        factors: [],
        warnings: []
    };
    
    try {
        // Phase 2: Volume Profile
        result.volumeProfile = analyzeVolumeProfileSignal(klines, signal.price, signal.direction);
        if (result.volumeProfile.valid) {
            result.factors.push(...result.volumeProfile.factors);
        }
        
        // Phase 3: Order Flow
        result.orderFlow = getOrderFlowSignal(klines, signal.direction);
        result.factors.push(...result.orderFlow.factors);
        
        // Phase 4: ML Prediction
        result.mlPrediction = predictWinProbability(signal, klines);
        if (result.mlPrediction.confidence !== 'LOW') {
            if (result.mlPrediction.suggestion === 'FAVORABLE') {
                result.factors.push(`🤖 ML: ${result.mlPrediction.probability}% win rate`);
            } else if (result.mlPrediction.suggestion === 'UNFAVORABLE') {
                result.warnings.push(`⚠️ ML: Only ${result.mlPrediction.probability}% win rate`);
            }
        }
        
        // Calculate combined score
        const vpScore = result.volumeProfile?.score || 50;
        const ofScore = result.orderFlow?.score || 50;
        const mlScore = result.mlPrediction?.probability || 50;
        
        // Weighted combination
        result.combinedScore = Math.round(
            (vpScore * 0.30) +
            (ofScore * 0.35) +
            (mlScore * 0.35)
        );
        
        // Determine overall confidence
        const supports = [
            result.volumeProfile?.support,
            result.orderFlow?.support,
            result.mlPrediction?.suggestion === 'FAVORABLE' ? 'support' : 
            result.mlPrediction?.suggestion === 'UNFAVORABLE' ? 'oppose' : 'neutral'
        ];
        
        const strongSupports = supports.filter(s => s === 'strong' || s === 'support').length;
        const opposes = supports.filter(s => s === 'oppose' || s === 'caution').length;
        
        if (strongSupports >= 2 && opposes === 0) {
            result.confidence = 'HIGH';
        } else if (strongSupports >= 1 && opposes <= 1) {
            result.confidence = 'MEDIUM';
        } else {
            result.confidence = 'LOW';
        }
        
    } catch (e) {
        console.warn('Advanced analysis error:', e);
    }
    
    return result;
}

// Initialize ML on load
initMLSystem();

// ═══════════════════════════════════════════════════════════════════════════════
// V10.3 STRUCTURE ENGINE (FROM QUANTUM CHART)
// ═══════════════════════════════════════════════════════════════════════════════

const StructureEngine = {
    
    // Find swing points for trendline detection
    findSwings: function(klines, period) {
        const swings = { highs: [], lows: [] };
        if (!klines || klines.length < period * 2 + 1) return swings;
        
        for (let i = period; i < klines.length - period; i++) {
            let isHigh = true, isLow = true;
            
            for (let j = 1; j <= period; j++) {
                if (klines[i].high <= klines[i - j].high || klines[i].high <= klines[i + j].high) isHigh = false;
                if (klines[i].low >= klines[i - j].low || klines[i].low >= klines[i + j].low) isLow = false;
            }
            
            if (isHigh) swings.highs.push({ idx: i, price: klines[i].high, time: klines[i].time });
            if (isLow) swings.lows.push({ idx: i, price: klines[i].low, time: klines[i].time });
        }
        
        return swings;
    },
    
    // Build liquidity channel from OBs, zones, and swings
    buildChannel: function(klines, orderBlocks, zones) {
        const result = { isValid: false, upper: null, lower: null, midline: 0, widthPct: 0, score: 0 };
        if (!klines || klines.length < 50) return result;
        
        const currentPrice = klines[klines.length - 1].close;
        const cfg = CONFIG.STRUCTURE.channel;
        
        // Collect all potential boundaries
        const upperBoundaries = [];
        const lowerBoundaries = [];
        
        // Add OBs as boundaries (highest priority)
        if (orderBlocks && orderBlocks.length > 0) {
            orderBlocks.forEach(ob => {
                if (ob.type === 'bear' && ob.bottom > currentPrice) {
                    upperBoundaries.push({ price: ob.bottom, type: 'ob', score: cfg.boundaryScores.ob });
                } else if (ob.type === 'bull' && ob.top < currentPrice) {
                    lowerBoundaries.push({ price: ob.top, type: 'ob', score: cfg.boundaryScores.ob });
                }
            });
        }
        
        // Add zones as boundaries
        if (zones && zones.length > 0) {
            zones.forEach(z => {
                if (z.high > currentPrice) {
                    upperBoundaries.push({ price: z.high, type: 'zone', score: cfg.boundaryScores.zone });
                }
                if (z.low < currentPrice) {
                    lowerBoundaries.push({ price: z.low, type: 'zone', score: cfg.boundaryScores.zone });
                }
            });
        }
        
        // Add swing points as boundaries (lowest priority)
        const swings = this.findSwings(klines, 5);
        swings.highs.slice(-5).forEach(s => {
            if (s.price > currentPrice) {
                upperBoundaries.push({ price: s.price, type: 'swing', score: cfg.boundaryScores.swing });
            }
        });
        swings.lows.slice(-5).forEach(s => {
            if (s.price < currentPrice) {
                lowerBoundaries.push({ price: s.price, type: 'swing', score: cfg.boundaryScores.swing });
            }
        });
        
        // Get best boundaries (closest with highest score)
        upperBoundaries.sort((a, b) => a.price - b.price); // Closest first
        lowerBoundaries.sort((a, b) => b.price - a.price); // Closest first (highest)
        
        const upper = upperBoundaries[0];
        const lower = lowerBoundaries[0];
        
        if (!upper || !lower) return result;
        
        const width = upper.price - lower.price;
        const widthPct = width / currentPrice;
        
        // Validate channel width
        if (widthPct < cfg.minWidth || widthPct > cfg.maxWidth) return result;
        
        result.isValid = true;
        result.upper = upper;
        result.lower = lower;
        result.midline = (upper.price + lower.price) / 2;
        result.widthPct = widthPct;
        result.score = upper.score + lower.score;
        
        return result;
    },
    
    // Detect trendlines
    detectTrendlines: function(klines) {
        const result = { bull: [], bear: [], score: 0 };
        if (!klines || klines.length < 30) return result;
        
        const cfg = CONFIG.STRUCTURE.trendlines;
        
        // Check each swing period
        cfg.swingPeriods.forEach(period => {
            const swings = this.findSwings(klines, period);
            
            // Bullish trendlines (connecting lows)
            if (swings.lows.length >= 2) {
                for (let i = 0; i < swings.lows.length - 1; i++) {
                    for (let j = i + 1; j < swings.lows.length; j++) {
                        const p1 = swings.lows[i];
                        const p2 = swings.lows[j];
                        
                        // Must be ascending
                        if (p2.price > p1.price) {
                            const slope = (p2.price - p1.price) / (p2.idx - p1.idx);
                            let touches = 2;
                            
                            // Count additional touches
                            swings.lows.forEach(s => {
                                if (s.idx !== p1.idx && s.idx !== p2.idx) {
                                    const expectedPrice = p1.price + slope * (s.idx - p1.idx);
                                    if (Math.abs(s.price - expectedPrice) / expectedPrice < 0.005) {
                                        touches++;
                                    }
                                }
                            });
                            
                            if (touches >= cfg.minTouches) {
                                result.bull.push({ p1, p2, slope, touches, period });
                            }
                        }
                    }
                }
            }
            
            // Bearish trendlines (connecting highs)
            if (swings.highs.length >= 2) {
                for (let i = 0; i < swings.highs.length - 1; i++) {
                    for (let j = i + 1; j < swings.highs.length; j++) {
                        const p1 = swings.highs[i];
                        const p2 = swings.highs[j];
                        
                        // Must be descending
                        if (p2.price < p1.price) {
                            const slope = (p2.price - p1.price) / (p2.idx - p1.idx);
                            let touches = 2;
                            
                            swings.highs.forEach(s => {
                                if (s.idx !== p1.idx && s.idx !== p2.idx) {
                                    const expectedPrice = p1.price + slope * (s.idx - p1.idx);
                                    if (Math.abs(s.price - expectedPrice) / expectedPrice < 0.005) {
                                        touches++;
                                    }
                                }
                            });
                            
                            if (touches >= cfg.minTouches) {
                                result.bear.push({ p1, p2, slope, touches, period });
                            }
                        }
                    }
                }
            }
        });
        
        // Sort by touches and keep top N
        result.bull.sort((a, b) => b.touches - a.touches);
        result.bear.sort((a, b) => b.touches - a.touches);
        result.bull = result.bull.slice(0, cfg.maxLines);
        result.bear = result.bear.slice(0, cfg.maxLines);
        
        // Calculate score
        result.score = (result.bull.length + result.bear.length) * 10;
        result.bull.forEach(t => result.score += t.touches * 5);
        result.bear.forEach(t => result.score += t.touches * 5);
        
        return result;
    },
    
    // Detect compression (low volatility)
    detectCompression: function(klines) {
        const result = { isCompressed: false, atr: 0, avgAtr: 0, ratio: 1 };
        if (!klines || klines.length < 30) return result;
        
        const cfg = CONFIG.STRUCTURE.compression;
        const atrValues = [];
        
        for (let i = 1; i < klines.length; i++) {
            const tr = Math.max(
                klines[i].high - klines[i].low,
                Math.abs(klines[i].high - klines[i - 1].close),
                Math.abs(klines[i].low - klines[i - 1].close)
            );
            atrValues.push(tr);
        }
        
        // Current ATR (last 14 periods)
        const recentATR = atrValues.slice(-cfg.atrPeriod);
        result.atr = recentATR.reduce((a, b) => a + b, 0) / recentATR.length;
        
        // Average ATR (full period)
        result.avgAtr = atrValues.reduce((a, b) => a + b, 0) / atrValues.length;
        
        result.ratio = result.atr / result.avgAtr;
        result.isCompressed = result.ratio < cfg.compressionThreshold;
        result.isExpanding = result.ratio > cfg.expansionThreshold;
        
        return result;
    },
    
    // Calculate channel bias (premium/discount/equilibrium)
    calcBias: function(currentPrice, channel) {
        if (!channel || !channel.isValid) return { bias: 'NEUTRAL', position: 0.5, score: 0 };
        
        const cfg = CONFIG.STRUCTURE.bias;
        const range = channel.upper.price - channel.lower.price;
        const position = (currentPrice - channel.lower.price) / range;
        
        let bias = 'EQUILIBRIUM';
        let score = 0;
        
        if (position >= cfg.premiumZone) {
            bias = 'PREMIUM';
            score = -10; // Bearish bias
        } else if (position <= cfg.discountZone) {
            bias = 'DISCOUNT';
            score = 10; // Bullish bias
        } else if (Math.abs(position - 0.5) <= cfg.equilibriumTolerance) {
            bias = 'EQUILIBRIUM';
            score = 0;
        }
        
        return { bias, position, score };
    },
    
    // Main analysis function
    analyze: function(klines, orderBlocks, zones) {
        const result = {
            channel: null,
            trendlines: { bull: [], bear: [] },
            compression: { isCompressed: false },
            bias: 'NEUTRAL',
            biasPosition: 0.5,
            gatePass: true,
            score: 0,
            factors: []
        };
        
        if (!klines || klines.length < 50) return result;
        if (!CONFIG.STRUCTURE.enabled) return result;
        
        const currentPrice = klines[klines.length - 1].close;
        
        // 1. Build channel
        result.channel = this.buildChannel(klines, orderBlocks, zones);
        if (result.channel.isValid) {
            result.score += result.channel.score;
            result.factors.push('Channel ' + (result.channel.widthPct * 100).toFixed(1) + '%');
        }
        
        // 2. Detect trendlines
        result.trendlines = this.detectTrendlines(klines);
        result.score += result.trendlines.score;
        if (result.trendlines.bull.length > 0) result.factors.push('Bull TL x' + result.trendlines.bull.length);
        if (result.trendlines.bear.length > 0) result.factors.push('Bear TL x' + result.trendlines.bear.length);
        
        // 3. Detect compression
        result.compression = this.detectCompression(klines);
        if (result.compression.isCompressed) {
            result.score += 15;
            result.factors.push('Compressed');
        }
        
        // 4. Calculate bias
        const biasResult = this.calcBias(currentPrice, result.channel);
        result.bias = biasResult.bias;
        result.biasPosition = biasResult.position;
        result.score += Math.abs(biasResult.score);
        if (result.bias !== 'EQUILIBRIUM') result.factors.push(result.bias);
        
        // 5. Structure Gate Check
        const gate = CONFIG.STRUCTURE.gate;
        if (gate.enabled) {
            let gatePass = true;
            
            if (gate.requireChannel && !result.channel.isValid) {
                gatePass = false;
            }
            
            if (gate.requireTrendlineOrZone) {
                const hasTrendline = result.trendlines.bull.length > 0 || result.trendlines.bear.length > 0;
                const hasZone = zones && zones.length > 0;
                if (!hasTrendline && !hasZone) {
                    gatePass = false;
                }
            }
            
            result.gatePass = gatePass;
        }
        
        result.score = Math.min(100, result.score);
        return result;
    },
    
    // Check if direction aligns with structure bias
    checkBiasAlignment: function(direction, bias) {
        if (bias === 'EQUILIBRIUM' || bias === 'NEUTRAL') return true;
        if (direction === 'LONG' && bias === 'DISCOUNT') return true;
        if (direction === 'SHORT' && bias === 'PREMIUM') return true;
        return false;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// END STRUCTURE ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

// MASTER SIGNAL ANALYSIS - Combines all three engines (V1 ULTIMATE)
async function analyzeSignal(symbol, tf) {
    try {
        // Fetch klines
        const klines = await fetchKlines(symbol, tf, 200);
        if (!klines || klines.length < 100) return null;
        
        const currentPrice = safeNum(klines[klines.length - 1].close, 0);
        if (currentPrice === 0) return null;
        
        const atr = safeNum(calcATR(klines), currentPrice * 0.02);
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V19 ULTRA RED DNA - LIQUIDITY ANALYSIS FIRST (MASTER GATE)
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // We need direction first for liquidity analysis, so do quick direction check
        let prelimDirection = null;
        
        // Quick momentum check for preliminary direction
        const closes = klines.map(k => k.close);
        const ema9 = calcEMA(closes, 9);
        const ema21 = calcEMA(closes, 21);
        const lastEma9 = ema9[ema9.length - 1];
        const lastEma21 = ema21[ema21.length - 1];
        
        if (currentPrice > lastEma9 && lastEma9 > lastEma21) {
            prelimDirection = 'LONG';
        } else if (currentPrice < lastEma9 && lastEma9 < lastEma21) {
            prelimDirection = 'SHORT';
        }
        
        // LIQUIDITY ANALYSIS - Check for both directions if no clear prelim direction
        let liquidityLong = null;
        let liquidityShort = null;
        let liquidityResult = null;
        
        if (CONFIG.LIQUIDITY && CONFIG.LIQUIDITY.enabled) {
            try {
                // Analyze liquidity for LONG (BSL pools)
                liquidityLong = await performLiquidityAnalysis(klines, symbol, tf, currentPrice, 'LONG');
                
                // Analyze liquidity for SHORT (SSL pools)
                liquidityShort = await performLiquidityAnalysis(klines, symbol, tf, currentPrice, 'SHORT');
                
                // MASTER GATE: If liquidity engine requires pool but neither direction has one
                if (CONFIG.LIQUIDITY.masterGate.enabled && CONFIG.LIQUIDITY.masterGate.requirePool) {
                    const hasLongPool = liquidityLong && liquidityLong.hasPool;
                    const hasShortPool = liquidityShort && liquidityShort.hasPool;
                    
                    if (!hasLongPool && !hasShortPool) {
                        // No liquidity pools found - block signal
                        console.log(`🔴 V19 BLOCKED: ${symbol} ${tf} - NO_LIQUIDITY_POOL`);
                        return null;
                    }
                    
                    // Check regime block (applies to both directions)
                    if (liquidityLong && liquidityLong.blocked && liquidityLong.blockReason === 'REGIME_CHOP') {
                        console.log(`🔴 V19 BLOCKED: ${symbol} ${tf} - REGIME_CHOP`);
                        return null;
                    }
                }
                
                // Determine which liquidity result to use based on preliminary direction
                // or choose the one with better setup
                if (prelimDirection === 'LONG' && liquidityLong && liquidityLong.hasPool) {
                    liquidityResult = liquidityLong;
                } else if (prelimDirection === 'SHORT' && liquidityShort && liquidityShort.hasPool) {
                    liquidityResult = liquidityShort;
                } else {
                    // Choose better setup
                    const longScore = liquidityLong?.hasSweep ? 2 : (liquidityLong?.hasPool ? 1 : 0);
                    const shortScore = liquidityShort?.hasSweep ? 2 : (liquidityShort?.hasPool ? 1 : 0);
                    
                    if (longScore >= shortScore && liquidityLong?.hasPool) {
                        liquidityResult = liquidityLong;
                        prelimDirection = 'LONG';
                    } else if (liquidityShort?.hasPool) {
                        liquidityResult = liquidityShort;
                        prelimDirection = 'SHORT';
                    }
                }
                
            } catch (liqErr) {
                console.warn('Liquidity analysis error:', liqErr.message);
            }
        }
        
        // Run all three analyses with safety wrappers
        let zoneAnalysis = { score: 0, direction: null, factors: [], warnings: [], details: {} };
        let smcAnalysis = { score: 0, direction: null, factors: [], warnings: [], details: {} };
        let momentumAnalysis = { score: 0, direction: null, factors: [], warnings: [], details: {} };
        let candlePatterns = { patterns: [], currentCandle: null, behavior: null, strength: 0 };
        
        try {
            zoneAnalysis = await performZoneAnalysis(klines, symbol, tf, currentPrice) || zoneAnalysis;
        } catch (e) { console.warn('Zone analysis error:', e.message); }
        
        try {
            smcAnalysis = performSMCAnalysis(klines, tf) || smcAnalysis;
        } catch (e) { console.warn('SMC analysis error:', e.message); }
        
        try {
            momentumAnalysis = performMomentumAnalysis(klines) || momentumAnalysis;
        } catch (e) { console.warn('Momentum analysis error:', e.message); }
        
        try {
            candlePatterns = analyzeCandlePatterns(klines) || candlePatterns;
        } catch (e) { console.warn('Candle patterns error:', e.message); }
        
        // 📐 V10.3 STRUCTURE ENGINE ANALYSIS (FROM QUANTUM CHART)
        let structureAnalysis = { channel: null, trendlines: { bull: [], bear: [] }, compression: { isCompressed: false }, bias: 'NEUTRAL', gatePass: true, score: 0, factors: [] };
        try {
            const smcOBsForStructure = safeGet(smcAnalysis, 'details.orderBlocks', { bullish: [], bearish: [] });
            const allOBsForStructure = [...safeArr(smcOBsForStructure.bullish), ...safeArr(smcOBsForStructure.bearish)];
            const zonesForStructure = safeGet(zoneAnalysis, 'details.zones', []);
            structureAnalysis = StructureEngine.analyze(klines, allOBsForStructure, zonesForStructure) || structureAnalysis;
        } catch (strErr) {
            console.warn('Structure analysis error:', strErr.message);
        }
        
        // 🎯 GP/OTE ANALYSIS - Advanced Fibonacci Zones (with safety wrap)
        let gpoteAnalysis = { valid: false, score: 0 };
        try {
            const smcOBs = safeGet(smcAnalysis, 'details.orderBlocks', { bullish: [], bearish: [] });
            const smcFVGs = safeGet(smcAnalysis, 'details.fvg', { bullish: [], bearish: [] });
            // Flatten OBs and FVGs for GP/OTE confluence check
            const allOBs = [...safeArr(smcOBs.bullish), ...safeArr(smcOBs.bearish)];
            const allFVGs = [...safeArr(smcFVGs.bullish), ...safeArr(smcFVGs.bearish)];
            gpoteAnalysis = analyzeGPOTE(klines, allOBs, allFVGs) || gpoteAnalysis;
        } catch (gpErr) {
            console.warn('GP/OTE analysis skipped:', gpErr.message);
        }
        
        // Determine primary direction (voting system)
        let votes = { LONG: 0, SHORT: 0 };
        
        // Track individual engine directions for agreement display
        const candleDir = candlePatterns.patternSignal === 'BULLISH' ? 'LONG' : 
                          candlePatterns.patternSignal === 'BEARISH' ? 'SHORT' : 'NEUTRAL';
        const engineDirections = {
            zone: zoneAnalysis.direction,
            smc: smcAnalysis.direction,
            momentum: momentumAnalysis.direction,
            candle: candleDir,
            structure: structureAnalysis.bias === 'DISCOUNT' ? 'LONG' : structureAnalysis.bias === 'PREMIUM' ? 'SHORT' : 'NEUTRAL'
        };
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V19 DIRECTION DECISION - LIQUIDITY-FIRST APPROACH
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // STEP 1: Get HTF Bias FIRST (this is the KING for trend)
        // We need to know the trend before deciding direction
        let htfDirection = null;
        let htfBias = { aligned: 0, total: 0, score: 50 };
        
        try {
            // Quick HTF check using the entry TF's higher timeframes
            const htfMap = { '5': '60', '15': '60', '30': '240', '60': '240', '240': 'D', 'D': 'D' };
            const htfTF = htfMap[tf] || '240';
            const htfKlines = await fetchKlines(symbol, htfTF, 50);
            
            if (htfKlines && htfKlines.length >= 20) {
                const htfCloses = htfKlines.map(k => k.close);
                const htfEma9 = calcEMA(htfCloses, 9);
                const htfEma21 = calcEMA(htfCloses, 21);
                const htfPrice = htfCloses[htfCloses.length - 1];
                
                // HTF Trend: EMA alignment
                if (htfPrice > htfEma9[htfEma9.length - 1] && htfEma9[htfEma9.length - 1] > htfEma21[htfEma21.length - 1]) {
                    htfDirection = 'LONG';
                    htfBias.score = 75;
                } else if (htfPrice < htfEma9[htfEma9.length - 1] && htfEma9[htfEma9.length - 1] < htfEma21[htfEma21.length - 1]) {
                    htfDirection = 'SHORT';
                    htfBias.score = 75;
                }
            }
        } catch (e) { console.warn('HTF check error:', e.message); }
        
        // STEP 2: V19 DIRECTION DECISION - Liquidity + HTF Combined
        let direction = null;
        
        // V19: If liquidity has a sweep, that's our primary signal
        if (liquidityResult && liquidityResult.hasSweep) {
            // Liquidity sweep detected - this is the trigger
            direction = liquidityResult === liquidityLong ? 'LONG' : 'SHORT';
            
            // BUT check if HTF strongly opposes
            if (htfDirection && htfDirection !== direction) {
                // HTF opposes liquidity sweep - check strength
                const htfPct = htfBias.total > 0 ? (htfBias.aligned / htfBias.total) * 100 : 50;
                if (htfPct >= 70) {
                    // Very strong HTF opposition - block
                    console.log(`🔴 V19: ${symbol} ${tf} - Liquidity sweep but strong HTF opposes`);
                    return null;
                }
                // Moderate opposition - proceed with caution (liquidity wins but note warning)
            }
        }
        // V19: If liquidity has pool but no sweep, check HTF for direction confirmation
        else if (liquidityResult && liquidityResult.hasPool) {
            // Pool exists but no sweep - use HTF to confirm direction
            if (htfDirection) {
                // Check if liquidity pool aligns with HTF
                const poolDirection = liquidityResult === liquidityLong ? 'LONG' : 'SHORT';
                if (poolDirection === htfDirection) {
                    direction = htfDirection;
                } else {
                    // Pool and HTF conflict - skip
                    return null;
                }
            } else {
                // No HTF direction - use pool direction with zone/smc confirmation
                const poolDirection = liquidityResult === liquidityLong ? 'LONG' : 'SHORT';
                if (zoneAnalysis.direction === poolDirection || smcAnalysis.direction === poolDirection) {
                    direction = poolDirection;
                }
            }
        }
        // V19: Fallback to old logic if liquidity engine disabled or no pools
        else if (htfDirection) {
            direction = htfDirection;
            
            // STEP 3: Zone must support (or at least not oppose)
            if (zoneAnalysis.direction && zoneAnalysis.direction !== htfDirection) {
                // Zone opposes HTF - SKIP (don't trade against the trend)
                if (zoneAnalysis.score >= 60) {
                    // Strong zone against trend = no trade
                    return null;
                }
                // Weak zone against trend = proceed with caution (HTF wins)
            }
        }
        // If no HTF direction, fall back to Zone + confirmation
        else if (zoneAnalysis.direction && zoneAnalysis.score >= 50) {
            direction = zoneAnalysis.direction;
            // Need at least momentum to confirm
            if (momentumAnalysis.direction && momentumAnalysis.direction !== direction) {
                if (momentumAnalysis.score >= 60) return null; // Strong opposing momentum
            }
        }
        // Last resort: strong momentum with SMC
        else if (momentumAnalysis.direction && momentumAnalysis.score >= 60) {
            if (smcAnalysis.direction === momentumAnalysis.direction) {
                direction = momentumAnalysis.direction;
            }
        }
        
        if (!direction) return null;
        
        // Count how many engines agree with final direction
        let agreed = 0;
        if (zoneAnalysis.direction === direction) agreed++;
        if (smcAnalysis.direction === direction) agreed++;
        if (momentumAnalysis.direction === direction) agreed++;
        if (htfDirection === direction) agreed++;
        
        // Full HTF analysis for display
        htfBias = await analyzeHTFBias(symbol, tf, direction);
        htfBias.htfDirection = htfDirection;
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V1 ULTIMATE - NEW ENGINE INTEGRATIONS
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // 1. SEQUENCE VALIDATION (now with direction)
        const sequenceResult = validateSequence(smcAnalysis, zoneAnalysis, candlePatterns, klines, direction);
        
        // 2. PATTERN-AT-LEVEL CHECK (now with direction)
        const patternAtLevel = checkPatternAtLevel(candlePatterns, zoneAnalysis, smcAnalysis, currentPrice, direction);
        
        // 3. REJECTION SCORE
        const rejectionScore = calculateRejectionScore(klines, zoneAnalysis, smcAnalysis, direction);
        
        // 4. CONFLICT DETECTOR (Enhanced)
        const conflictResult = detectEngineConflicts(zoneAnalysis, smcAnalysis, momentumAnalysis, candlePatterns);
        
        // 5. ZONE OVERRIDE CHECK
        const zoneOverride = checkZoneOverride(zoneAnalysis, smcAnalysis, momentumAnalysis, direction, currentPrice);
        
        // 6. TRAP DETECTION (from candle patterns)
        // FIX #3: Improved trap detection logic
        // Bull Trap = Price broke up but will reverse down (traps longs)
        // Bear Trap = Price broke down but will reverse up (traps shorts)
        const trapPotential = candlePatterns.behavior?.trapPotential || 'LOW';
        const trapDetection = {
            isTrap: trapPotential === 'HIGH',
            type: trapPotential === 'HIGH' ? 
                  (direction === 'LONG' ? 'Bull Trap Risk' : 'Bear Trap Risk') : 'None',
            confidence: trapPotential === 'HIGH' ? 'HIGH' : 
                       trapPotential === 'MEDIUM' ? 'MEDIUM' : 'LOW',
            // Clear warning message
            warning: trapPotential === 'HIGH' ? 
                    `⚠️ HIGH ${direction === 'LONG' ? 'BULL' : 'BEAR'} TRAP RISK - ${direction} position may get trapped!` :
                    trapPotential === 'MEDIUM' ?
                    `⚠️ MEDIUM trap risk detected` : null
        };
        
        // 7. CHECK MANDATORY RULES (V18: Now includes direction for momentum check)
        const rulesResult = checkMandatoryRules(
            zoneAnalysis, smcAnalysis, momentumAnalysis, 
            htfBias, conflictResult, zoneOverride, trapDetection, direction
        );
        
        // V18: HARD BLOCKS - Rules are GATES, not warnings
        if (rulesResult.blocked) {
            console.log(`🚫 V18 BLOCKED: ${symbol} ${tf} ${direction} - ${rulesResult.blockReason}`);
            return null; // Signal blocked by mandatory rules
        }
        
        // 8. RULE 5 CHECK - V18: Already handled in checkMandatoryRules
        // V18: Rule 5 momentum check is now handled in checkMandatoryRules above
        // Kept for backward compatibility display only
        const momDir = momentumAnalysis.direction || 'NEUTRAL';
        const momOpposing = (direction === 'LONG' && momDir === 'SHORT') || 
                           (direction === 'SHORT' && momDir === 'LONG');
        
        // V18: controlBuyers/controlSellers SCORING BONUS
        let controlBonus = 0;
        let controlConflict = false;
        const controlBuyers = candlePatterns?.controlBuyers || false;
        const controlSellers = candlePatterns?.controlSellers || false;
        
        if (direction === 'LONG') {
            if (controlBuyers) {
                controlBonus = 10; // Buyers in control for LONG = good
            } else if (controlSellers) {
                controlBonus = -15; // Sellers in control for LONG = conflict!
                controlConflict = true;
            }
        } else if (direction === 'SHORT') {
            if (controlSellers) {
                controlBonus = 10; // Sellers in control for SHORT = good
            } else if (controlBuyers) {
                controlBonus = -15; // Buyers in control for SHORT = conflict!
                controlConflict = true;
            }
        }
        
        // V18: No longer blocks, just tracked
        const shouldSkip = false; // rulesResult.blocked already handled above
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V19 SCORING - LIQUIDITY-FIRST WITH CAPPED BONUSES
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // Check volume confirmation
        const avgVolume = klines.slice(-20).reduce((sum, k) => sum + k.volume, 0) / 20;
        const currentVolume = klines[klines.length - 1].volume;
        const volumeConfirmed = currentVolume > avgVolume * 1.2;
        
        // Prepare HTF data for V19 scoring
        const htfPct = htfBias.total > 0 ? (htfBias.aligned / htfBias.total) * 100 : 50;
        const htfAligned = htfDirection === direction;
        const htfOpposes = htfDirection && htfDirection !== direction;
        
        // Prepare Momentum data for V19 scoring
        // momDir and momOpposes already declared above at line 16984
        const momentumForScoring = {
            direction: momDir,
            score: momentumAnalysis.score || 0,
            opposing: momOpposing
        };
        
        // Prepare HTF data for V19 scoring
        const htfForScoring = {
            aligned: htfAligned,
            opposing: htfOpposes,
            pct: htfPct
        };
        
        // V19: Use new scoring system if liquidity is enabled and has pool
        let totalScore = 0;
        let v19ScoreResult = null;
        
        if (CONFIG.LIQUIDITY && CONFIG.LIQUIDITY.enabled && liquidityResult && liquidityResult.hasPool) {
            // Use V19 scoring with liquidity-first approach
            v19ScoreResult = calculateV19Score(
                liquidityResult,
                smcAnalysis,
                zoneAnalysis,
                momentumForScoring,
                htfForScoring
            );
            totalScore = v19ScoreResult.finalScore;
            
            console.log(`📊 V19 Score: ${symbol} ${tf} ${direction} = ${totalScore} (Base:${v19ScoreResult.baseScore} +Bonus:${v19ScoreResult.bonuses} -Penalty:${v19ScoreResult.penalties})`);
        } else {
            // Fallback to old scoring if liquidity disabled or no pool
            // V9.6 SMART MATRIX - DYNAMIC ADAPTIVE WEIGHTING
            let smartMatrix = null;
            let smartMatrixScore = null;
            try {
                smartMatrix = calculateSmartMatrix(zoneAnalysis, smcAnalysis, momentumAnalysis, klines);
                smartMatrixScore = applySmartMatrixScore(
                    zoneAnalysis.score || 0,
                    smcAnalysis.score || 0,
                    momentumAnalysis.score || 0,
                    smartMatrix
                );
            } catch (smErr) {
                console.warn('Smart Matrix error:', smErr.message);
                smartMatrix = {
                    weights: { zone: 35, smc: 35, momentum: 30 },
                    regime: { regime: 'UNKNOWN', confidence: 0 },
                    agreement: { agreement: 'NONE', bonus: 1.0 },
                    dominant: 'BALANCED',
                    display: 'Z:35% S:35% M:30%'
                };
            }
            
            // Calculate ULTIMATE score
            const ultimateScore = calculateUltimateScore(
                sequenceResult, rejectionScore, htfBias, momentumAnalysis, volumeConfirmed
            );
            
            // Use ULTIMATE score as total score
            totalScore = ultimateScore.final;
            
            // V19: CAP TOTAL BONUSES TO +15 MAX
            let totalBonuses = 0;
            let bonusBreakdown = [];
            
            // Pattern-at-level bonus
            if (patternAtLevel.bonus > 0) {
                totalBonuses += patternAtLevel.bonus;
                bonusBreakdown.push(`Pattern +${patternAtLevel.bonus}`);
            }
            
            // V10.3: Structure Engine bonus/penalty
            if (structureAnalysis && structureAnalysis.score > 0) {
                const structBonus = Math.min(10, structureAnalysis.score * 0.15);
                totalBonuses += structBonus;
                bonusBreakdown.push(`Struct +${structBonus.toFixed(0)}`);
                
                // Alignment bonus
                if ((direction === 'LONG' && structureAnalysis.bias === 'DISCOUNT') ||
                    (direction === 'SHORT' && structureAnalysis.bias === 'PREMIUM')) {
                    totalBonuses += 5;
                    bonusBreakdown.push('Align +5');
                }
                
                // Compression bonus
                if (structureAnalysis.compression?.isCompressed) {
                    totalBonuses += 3;
                    bonusBreakdown.push('Compress +3');
                }
            }
            
            // GP/OTE bonus
            if (gpoteAnalysis.valid && gpoteAnalysis.isOptimalEntry) {
                const gpBonus = gpoteAnalysis.score * 0.3;
                totalBonuses += gpBonus;
                bonusBreakdown.push(`GP/OTE +${gpBonus.toFixed(0)}`);
            }
            
            // V19: CAP BONUSES AT 15
            const cappedBonuses = Math.min(totalBonuses, 15);
            totalScore += cappedBonuses;
            
            // V19: SUBTRACTIVE PENALTIES
            // HTF Penalty (weak alignment 40-60%)
            if (htfPct >= 40 && htfPct < 60) {
                totalScore -= 10;
            }
            
            // HTF Opposes (stronger penalty)
            if (htfOpposes) {
                totalScore -= 15;
            }
            
            // Momentum opposes but not blocked (40-59 score)
            if (momOpposing && momentumAnalysis.score >= 40 && momentumAnalysis.score < 60) {
                totalScore -= 10;
            }
            
            // Penalty for opposing structure
            if (structureAnalysis && 
                ((direction === 'LONG' && structureAnalysis.bias === 'PREMIUM') ||
                 (direction === 'SHORT' && structureAnalysis.bias === 'DISCOUNT'))) {
                totalScore -= 5;
            }
            
            // Apply conflict penalty
            if (conflictResult.hasConflict && !shouldSkip) {
                totalScore -= conflictResult.conflictCount * 5; // Reduced from 10
            }
            
            console.log(`📊 V18+ Score: ${symbol} ${tf} ${direction} = ${totalScore} (Capped bonuses: ${cappedBonuses}/${totalBonuses.toFixed(0)})`);
        }
        
        // Ensure score is within bounds
        totalScore = Math.max(0, Math.min(100, Math.round(totalScore)));
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V19 VOLUME MODE GATE - Volume required for PERFECT
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // If no volume confirmed and score would be PERFECT, cap at STRONG
        if (!volumeConfirmed && totalScore >= 90) {
            totalScore = 85; // Cap at high STRONG
            console.log(`📊 V19: ${symbol} ${tf} - No volume, capped from PERFECT to STRONG`);
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V5.1 SELF-LEARNING ADJUSTMENT
        // ═══════════════════════════════════════════════════════════════════════════════
        let learningData = { adj: 0, confidence: 'N/A', winRate: 0, total: 0 };
        try {
            // Create temp signal for pattern matching
            const tempSignal = { 
                tfRaw: tf, 
                direction, 
                scores: { zone: zoneAnalysis.score, smc: smcAnalysis.score }
            };
            learningData = SelfLearning.getAdjustment(tempSignal);
            // V19: Learning adjustment also capped
            const learningAdj = Math.min(learningData.adj, 10); // Cap at +10
            totalScore += learningAdj;
            totalScore = Math.max(0, Math.min(100, Math.round(totalScore)));
        } catch (e) { console.warn('Learning adjustment error:', e); }
        
        // If rules say NO_TRADE, cap the score (V5.1: removed SKIP cap)
        if (rulesResult.verdict === 'NO_TRADE') {
            totalScore = Math.min(totalScore, 30); // Cap at BREWING
        }
        // V5.1: SKIP no longer caps score, just adds warnings
        
        // Determine grade (V1 ULTIMATE thresholds: 90/75/60/45)
        let grade, status;
        if (totalScore >= CONFIG.GRADES.PERFECT) {
            grade = 'PERFECT';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.STRONG) {
            grade = 'STRONG';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.VALID) {
            grade = 'VALID';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.HEATING) {
            grade = 'HEATING';
            status = 'early';
        } else {
            grade = 'BREWING';
            status = 'early';
        }
        
        // V19: Determine signal mode based on liquidity status
        let signalMode = 'GRADE'; // Default to grade-based
        if (liquidityResult && liquidityResult.hasPool) {
            signalMode = determineSignalMode(
                liquidityResult.hasPool,
                liquidityResult.hasSweep,
                liquidityResult.sweepConfirmed,
                liquidityResult.hasVolume || volumeConfirmed,
                totalScore
            );
        }
        
        // Calculate trade levels using SMART TRADE SYSTEM (with safety)
        const adxVal = safeNum(safeGet(momentumAnalysis, 'details.adx.adx', 25), 25);
        
        let smartLevels;
        try {
            smartLevels = calculateSmartTradeLevels(
                currentPrice, 
                direction, 
                atr, 
                klines, 
                safeObj(zoneAnalysis.details), 
                safeObj(smcAnalysis.details), 
                momentumAnalysis,
                candlePatterns
            );
        } catch (levelsErr) {
            console.warn('Smart levels calculation error:', levelsErr.message);
            // Fallback to basic levels
            const fallbackSL = direction === 'LONG' ? currentPrice * 0.98 : currentPrice * 1.02;
            const fallbackTP1 = direction === 'LONG' ? currentPrice * 1.02 : currentPrice * 0.98;
            const fallbackTP2 = direction === 'LONG' ? currentPrice * 1.04 : currentPrice * 0.96;
            const fallbackTP3 = direction === 'LONG' ? currentPrice * 1.06 : currentPrice * 0.94;
            smartLevels = {
                entry: { market: { price: currentPrice } },
                limitEntry: currentPrice,
                limitType: 'MARKET',
                limitConfidence: 50,
                sl: { price: fallbackSL },
                tp1: { price: fallbackTP1 },
                tp2: { price: fallbackTP2 },
                tp3: { price: fallbackTP3 },
                rr: 2.0,
                limitRR: 2.0,
                risk: Math.abs(currentPrice - fallbackSL),
                reward: Math.abs(fallbackTP2 - currentPrice),
                riskPct: 2.0
            };
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // 🎯 V18 ULTIMATE: SWEEP + ENTRY + SL + TP SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // Detect market regime for adaptive pullback
        const marketRegime = (momentumAnalysis.details?.adx?.adx > 25) ? 'TRENDING' : 'RANGING';
        
        // Get ultimate entry plan (sweep detection + surviving SL + 2 TPs + adaptive pullback)
        let ultimateEntryPlan = null;
        try {
            ultimateEntryPlan = getUltimateEntryPlan(
                direction,
                klines,
                gpoteAnalysis,
                atr,
                symbol,
                tf,
                marketRegime
            );
        } catch (uepErr) {
            console.warn('Ultimate entry plan error:', uepErr.message);
        }
        
        // Use ultimate plan for levels if available and valid
        let finalEntry, finalSL, finalTP1, finalTP2, entryType, usePullback, pullbackInfo;
        
        if (ultimateEntryPlan && ultimateEntryPlan.canEnter && ultimateEntryPlan.entry && ultimateEntryPlan.sl && ultimateEntryPlan.tp1 && ultimateEntryPlan.tp2) {
            finalEntry = ultimateEntryPlan.entry.price;
            finalSL = ultimateEntryPlan.sl.price;
            finalTP1 = ultimateEntryPlan.tp1.price;
            finalTP2 = ultimateEntryPlan.tp2.price;
            entryType = ultimateEntryPlan.type; // SNIPER or ZONE
            usePullback = ultimateEntryPlan.pullback?.enabled ?? false;
            pullbackInfo = ultimateEntryPlan.pullback || { enabled: false, reason: 'Default' };
        } else {
            // Fallback to smart levels
            finalEntry = safeNum(safeGet(smartLevels, 'entry.market.price', currentPrice), currentPrice);
            finalSL = safeNum(safeGet(smartLevels, 'sl.price', currentPrice * 0.98), currentPrice * 0.98);
            finalTP1 = safeNum(safeGet(smartLevels, 'tp1.price', currentPrice * 1.02), currentPrice * 1.02);
            finalTP2 = safeNum(safeGet(smartLevels, 'tp2.price', currentPrice * 1.04), currentPrice * 1.04);
            entryType = 'STANDARD';
            usePullback = true;
            pullbackInfo = { enabled: true, reason: 'Default' };
        }
        
        // Build levels object with backward compatibility (with null safety)
        const levels = {
            entry: finalEntry,
            limitEntry: safeNum(smartLevels.limitEntry, currentPrice),
            limitType: smartLevels.limitType || 'MARKET',
            limitConfidence: safeNum(smartLevels.limitConfidence, 50),
            sl: finalSL,
            tp1: finalTP1,
            tp2: finalTP2,
            tp3: safeNum(safeGet(smartLevels, 'tp3.price', currentPrice * 1.06), currentPrice * 1.06),
            rr: safeNum(smartLevels.rr, 2.0),
            limitRR: safeNum(smartLevels.limitRR, 2.0),
            risk: Math.abs(finalEntry - finalSL),
            reward: Math.abs(finalTP2 - finalEntry),
            riskPct: (Math.abs(finalEntry - finalSL) / finalEntry * 100).toFixed(2),
            // 🎯 V18 ULTIMATE DATA
            entryType: entryType,
            usePullback: usePullback,
            pullbackInfo: pullbackInfo,
            ultimatePlan: ultimateEntryPlan,
            // NEW SMART DATA
            smart: smartLevels
        };
        
        // 🏦 FETCH INSTITUTIONAL DATA (Funding, OI, L/S Ratio)
        let instData = null;
        let instAnalysis = null;
        try {
            instData = await fetchInstitutionalData(symbol, currentPrice);
            instAnalysis = analyzeInstitutionalData(instData, direction);
        } catch(e) {
            console.log('Institutional data fetch skipped:', e.message);
        }
        
        // Combine all factors (MUST be declared BEFORE using)
        const allFactors = [
            ...zoneAnalysis.factors,
            ...smcAnalysis.factors,
            ...momentumAnalysis.factors
        ];
        
        // Add V1 ULTIMATE factors
        if (sequenceResult.completed >= 4) {
            allFactors.push(`Sequence ${sequenceResult.completed}/6 (${sequenceResult.quality})`);
        }
        if (patternAtLevel.atLevel) {
            allFactors.push(patternAtLevel.details);
        }
        if (rejectionScore.score >= 60) {
            allFactors.push(`Rejection Score ${rejectionScore.score}/100 (${rejectionScore.quality})`);
        }
        if (zoneOverride.eligible) {
            allFactors.push('Zone Override Active');
        }
        
        // 🎯 Add GP/OTE factors
        if (gpoteAnalysis && gpoteAnalysis.valid) {
            if (gpoteAnalysis.isInGP) {
                allFactors.push('🎯 IN Golden Pocket');
            } else if (gpoteAnalysis.isInOTE) {
                allFactors.push('📍 IN OTE Zone');
            } else if (gpoteAnalysis.position && gpoteAnalysis.position.GP && gpoteAnalysis.position.GP.status === 'NEAR') {
                allFactors.push('🎯 Near GP');
            }
            // Add confluence factors
            if (gpoteAnalysis.confluence && gpoteAnalysis.confluence.hasConfluence && gpoteAnalysis.confluence.factors) {
                gpoteAnalysis.confluence.factors.forEach(f => {
                    if (f && f.text) allFactors.push(f.text);
                });
            }
            // Add sweep factor
            if (gpoteAnalysis.sweep && gpoteAnalysis.sweep.swept && gpoteAnalysis.sweep.description) {
                allFactors.push('💧 ' + gpoteAnalysis.sweep.description);
            }
        }
        
        const allWarnings = [
            ...zoneAnalysis.warnings,
            ...smcAnalysis.warnings,
            ...momentumAnalysis.warnings
        ];
        
        // Add V1 ULTIMATE warnings
        if (conflictResult.hasConflict) {
            allWarnings.push(...conflictResult.conflicts);
        }
        if (!rulesResult.allPassed) {
            allWarnings.push(...rulesResult.violations);
        }
        if (sequenceResult.completed < 4) {
            allWarnings.push(`Sequence incomplete: ${sequenceResult.completed}/6`);
        }
        if (!patternAtLevel.atLevel && candlePatterns.patterns?.length > 0) {
            allWarnings.push('Pattern not at key level');
        }
        if (rejectionScore.score < 40 && rejectionScore.score > 0) {
            allWarnings.push(`Weak rejection: ${rejectionScore.score}/100`);
        }
        // Add trap warning if exists
        if (trapDetection.warning) {
            allWarnings.push(trapDetection.warning);
        }
        
        // Add institutional factors if available (AFTER declaration)
        if (instAnalysis && instAnalysis.factors) {
            allFactors.push(...instAnalysis.factors);
        }
        if (instAnalysis && instAnalysis.warnings) {
            allWarnings.push(...instAnalysis.warnings);
        }
        
        return {
            symbol,
            tf: CONFIG.TF_LABELS[tf] || tf,
            tfRaw: tf,
            price: currentPrice,
            direction,
            grade,
            status,
            score: totalScore,
            agreed,  // How many engines agreed (2 or 3)
            engineDirections,  // Individual engine directions
            // ═══════════════════════════════════════════════════════════════════════════════
            // V19 ULTRA RED DNA - LIQUIDITY DATA
            // ═══════════════════════════════════════════════════════════════════════════════
            liquidity: liquidityResult,
            signalMode: signalMode,  // CONFIRMED / LIMIT / CAUTION / WATCH / GRADE
            v19Score: v19ScoreResult,
            hasLiquiditySweep: liquidityResult?.hasSweep || false,
            hasLiquidityPool: liquidityResult?.hasPool || false,
            regime: liquidityResult?.regime || null,
            scores: {
                zone: Math.round(zoneAnalysis.score),
                smc: Math.round(smcAnalysis.score),
                momentum: Math.round(momentumAnalysis.score),
                htf: htfBias.score,
                institutional: instAnalysis ? instAnalysis.score : 0,
                // V1 ULTIMATE scores
                sequence: sequenceResult.score,
                rejection: rejectionScore.score,
                patternAtLevel: patternAtLevel.bonus
            },
            // V5.1 SELF-LEARNING DATA
            learning: learningData,
            // V1 ULTIMATE - Score breakdown
            ultimateScore: typeof ultimateScore !== 'undefined' ? ultimateScore : null,
            zone: zoneAnalysis,
            smc: smcAnalysis,
            momentum: momentumAnalysis,
            candlePatterns: candlePatterns,
            htf: htfBias,
            levels,
            // 🏦 Institutional Data
            institutional: instData,
            instAnalysis: instAnalysis,
            factors: allFactors,
            warnings: allWarnings,
            conflicts: conflictResult.conflicts,
            atr,
            // ═══════════════════════════════════════════════════════════════════════════════
            // V1 ULTIMATE - NEW DATA
            // ═══════════════════════════════════════════════════════════════════════════════
            v1Ultimate: {
                sequence: sequenceResult,
                patternAtLevel: patternAtLevel,
                rejectionScore: rejectionScore,
                conflictDetector: conflictResult,
                zoneOverride: zoneOverride,
                trapDetection: trapDetection,
                rulesCheck: rulesResult,
                scoreBreakdown: typeof ultimateScore !== 'undefined' && ultimateScore ? ultimateScore.breakdown : null
            },
            // ═══════════════════════════════════════════════════════════════════════════════
            // V10.3 STRUCTURE ENGINE (FROM QUANTUM CHART)
            // ═══════════════════════════════════════════════════════════════════════════════
            structure: structureAnalysis,
            structureGatePass: structureAnalysis.gatePass,
            // ═══════════════════════════════════════════════════════════════════════════════
            // V9.6 SMART MATRIX - DYNAMIC ADAPTIVE WEIGHTING
            // ═══════════════════════════════════════════════════════════════════════════════
            smartMatrix: typeof smartMatrix !== 'undefined' ? smartMatrix : null,
            smartMatrixScore: typeof smartMatrixScore !== 'undefined' ? smartMatrixScore : null,
            // 🎯 GP/OTE Analysis - Advanced Fibonacci Zones
            gpote: gpoteAnalysis,
            // Coin Relative Strength (RS) vs BTC - calculated on the fly
            coinRS: await calculateCoinRS(symbol, klines),
            // ═══════════════════════════════════════════════════════════════════════════════
            // V9.8 ADVANCED ANALYSIS - VOLUME PROFILE + ORDER FLOW + ML
            // ═══════════════════════════════════════════════════════════════════════════════
            advanced: (() => {
                try {
                    return getAdvancedAnalysis({ symbol, tfRaw: tf, direction, price: currentPrice, score: totalScore, scores: { zone: zoneAnalysis.score, smc: smcAnalysis.score, momentum: momentumAnalysis.score }, agreed, grade }, klines);
                } catch(e) { return null; }
            })(),
            // ═══════════════════════════════════════════════════════════════════════════════
            // 🎯 V18 ULTIMATE: ENTRY SYSTEM
            // ═══════════════════════════════════════════════════════════════════════════════
            ultimateEntry: {
                type: entryType,  // SNIPER, ZONE, or STANDARD
                canEnter: ultimateEntryPlan?.canEnter || true,
                quality: ultimateEntryPlan?.quality || 50,
                reason: ultimateEntryPlan?.reason || 'Standard entry',
                sweepData: ultimateEntryPlan?.sweepData || null,
                pullback: {
                    enabled: usePullback,
                    reason: pullbackInfo?.reason || '',
                    sizing: ultimateEntryPlan?.entry?.sizing || { entry1: 100, entry2: 0 },
                    stats: ultimateEntryPlan?.pullbackStats || null
                },
                sl: {
                    price: finalSL,
                    reason: ultimateEntryPlan?.sl?.reason || 'Standard',
                    survivalRate: ultimateEntryPlan?.sl?.survivalRate || 70
                },
                tp1: ultimateEntryPlan?.tp1 || { price: finalTP1, reason: '1.5R', closePercent: 50 },
                tp2: ultimateEntryPlan?.tp2 || { price: finalTP2, reason: '3R', closePercent: 50 },
                marketRegime: marketRegime
            }
        };
        
    } catch (error) {
        console.error(`Analysis error for ${symbol} ${tf}:`, error);
        return null;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MULTI-AI PROVIDER SYSTEM (v13 UPGRADE)
// ═══════════════════════════════════════════════════════════════════════════════

// Call Groq AI
async function callGroqAI(prompt) {
    console.log('🚀 Trying Groq AI...');
    
    // Get all valid keys to try
    const validKeys = GROQ_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.groq[item.index]);
    
    if (validKeys.length === 0) {
        console.log('❌ No Groq keys available');
        return null;
    }
    
    // Try each key until one works
    for (let attempt = 0; attempt < validKeys.length; attempt++) {
        const keyItem = validKeys[(currentGroqKeyIndex + attempt) % validKeys.length];
        const apiKey = keyItem.key;
        
        console.log(`🔑 Trying Groq Key #${keyItem.index + 1} (attempt ${attempt + 1}/${validKeys.length})`);
        
        try {
            const response = await fetch(CONFIG.GROQ_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + apiKey
                },
                body: JSON.stringify({
                    model: STATE.aiModel || 'llama-3.3-70b-versatile',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.3,
                    max_tokens: 2000
                })
            });
            
            if (response.status === 429) {
                console.log(`⏳ Groq Key #${keyItem.index + 1} rate limited, trying next key...`);
                KEY_STATUS.groq[keyItem.index] = false;  // Mark as temporarily failed
                continue;  // Try next key
            }
            
            const data = await response.json();
            if (data.error) {
                console.warn(`❌ Groq Key #${keyItem.index + 1} error:`, data.error.message);
                // Auth errors (invalid key) - mark as failed and try next
                if (data.error.code === 'invalid_api_key' || data.error.type === 'invalid_request_error') {
                    KEY_STATUS.groq[keyItem.index] = false;
                }
                continue;  // Try next key
            }
            
            if (data.choices && data.choices[0] && data.choices[0].message) {
                console.log(`✅ Groq Key #${keyItem.index + 1} success!`);
                KEY_STATUS.groq[keyItem.index] = true;  // Mark as working
                currentGroqKeyIndex = (currentGroqKeyIndex + attempt + 1) % validKeys.length;  // Update rotation
                return parseAIResponse(data.choices[0].message.content);
            }
        } catch (error) {
            console.error(`❌ Groq Key #${keyItem.index + 1} request failed:`, error);
            continue;  // Try next key
        }
    }
    
    console.log('❌ All Groq keys exhausted');
    return null;
}

// Call DeepSeek AI
async function callDeepSeekAI(prompt) {
    console.log('🚀 Trying DeepSeek AI...');
    
    // Get all valid keys to try
    const validKeys = DEEPSEEK_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.deepseek[item.index]);
    
    if (validKeys.length === 0) {
        console.log('❌ No DeepSeek keys available');
        return null;
    }
    
    // Try each key until one works
    for (let attempt = 0; attempt < validKeys.length; attempt++) {
        const keyItem = validKeys[(currentDeepSeekKeyIndex + attempt) % validKeys.length];
        const apiKey = keyItem.key;
        
        console.log(`🔑 Trying DeepSeek Key #${keyItem.index + 1} (attempt ${attempt + 1}/${validKeys.length})`);
        
        try {
            const response = await fetch(CONFIG.DEEPSEEK_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + apiKey
                },
                body: JSON.stringify({
                    model: 'deepseek-chat',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.3,
                    max_tokens: 2000
                })
            });
            
            if (response.status === 429) {
                console.log(`⏳ DeepSeek Key #${keyItem.index + 1} rate limited, trying next key...`);
                KEY_STATUS.deepseek[keyItem.index] = false;
                continue;  // Try next key
            }
            
            const data = await response.json();
            if (data.error) {
                console.warn(`❌ DeepSeek Key #${keyItem.index + 1} error:`, data.error.message);
                continue;  // Try next key
            }
            
            if (data.choices && data.choices[0] && data.choices[0].message) {
                console.log(`✅ DeepSeek Key #${keyItem.index + 1} success!`);
                KEY_STATUS.deepseek[keyItem.index] = true;
                currentDeepSeekKeyIndex = (currentDeepSeekKeyIndex + attempt + 1) % validKeys.length;
                return parseAIResponse(data.choices[0].message.content);
            }
        } catch (error) {
            console.error(`❌ DeepSeek Key #${keyItem.index + 1} request failed:`, error);
            continue;  // Try next key
        }
    }
    
    console.log('❌ All DeepSeek keys exhausted');
    return null;
}

// Call Gemini AI
async function callGeminiAI(prompt) {
    console.log('🚀 Trying Gemini AI...');
    
    // Get all valid keys to try
    const validKeys = GEMINI_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.gemini[item.index]);
    
    if (validKeys.length === 0) {
        console.log('❌ No Gemini keys available');
        return null;
    }
    
    // Models to try in order
    const models = [
        'gemini-2.0-flash',
        'gemini-1.5-flash',
        'gemini-1.5-flash-latest'
    ];
    
    // Try each key
    for (let keyAttempt = 0; keyAttempt < validKeys.length; keyAttempt++) {
        const keyItem = validKeys[(currentGeminiKeyIndex + keyAttempt) % validKeys.length];
        const apiKey = keyItem.key;
        
        console.log(`🔑 Trying Gemini Key #${keyItem.index + 1} (key ${keyAttempt + 1}/${validKeys.length})`);
        
        // Try each model with this key
        for (const model of models) {
            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                console.log(`🧠 Trying Gemini ${model}...`);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 2000
                        }
                    })
                });
                
                if (response.status === 429) {
                    console.log(`⏳ Gemini ${model} rate limited, trying next model...`);
                    continue;  // Try next model
                }
                
                if (response.status === 404) {
                    console.log(`⚠️ Model ${model} not found, trying next model...`);
                    continue;  // Try next model
                }
                
                const data = await response.json();
                if (data.error) {
                    console.warn(`❌ Gemini ${model} error:`, data.error.message);
                    // Auth errors mean key is bad, try next key
                    if (data.error.code === 400 || data.error.code === 401 || data.error.code === 403) {
                        KEY_STATUS.gemini[keyItem.index] = false;
                        break;  // Break to try next key
                    }
                    continue;  // Try next model
                }
                
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    console.log(`✅ Gemini ${model} with Key #${keyItem.index + 1} success!`);
                    KEY_STATUS.gemini[keyItem.index] = true;
                    currentGeminiKeyIndex = (currentGeminiKeyIndex + keyAttempt + 1) % validKeys.length;
                    // Update CONFIG to remember working model
                    CONFIG.GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
                    return parseAIResponse(data.candidates[0].content.parts[0].text);
                }
            } catch (error) {
                console.error(`❌ Gemini ${model} request failed:`, error);
                continue;  // Try next model
            }
        }
        // All models failed with this key, try next key
        console.log(`⚠️ All models failed with Key #${keyItem.index + 1}, trying next key...`);
    }
    
    console.log('❌ All Gemini keys and models exhausted');
    return null;
}

// Multi-AI with Auto-Failover (v13 Feature)
async function callMultiAI(prompt) {
    // NOTE: Lock is managed by caller (getAIAnalysis) - DO NOT double-lock here
    console.log('🧠 Multi-AI System Starting...');
    
    try {
        // Try Groq first (free, fast)
        let result = await callGroqAI(prompt);
        if (result) {
            result.aiProvider = 'Groq';
            return result;
        }
        
        // Fallback to DeepSeek (paid, best value)
        result = await callDeepSeekAI(prompt);
        if (result) {
            result.aiProvider = 'DeepSeek';
            return result;
        }
        
        // Final fallback to Gemini (free backup)
        result = await callGeminiAI(prompt);
        if (result) {
            result.aiProvider = 'Gemini';
            return result;
        }
        
        console.error('❌ All AI providers failed');
        toast('All AI providers unavailable', 'error');
        return null;
    } catch (e) {
        console.error('❌ Multi-AI error:', e);
        return null;
    }
}

// Legacy function for backwards compatibility
async function callAI(prompt) {
    return await callMultiAI(prompt);
}

function parseAIResponse(text) {
    console.log('🔄 Parsing AI response...');
    try {
        // Clean up response
        let clean = text.replace(/```json/gi, '').replace(/```/g, '').trim();
        const match = clean.match(/\{[\s\S]*\}/);
        
        if (match) {
            console.log('📋 Found JSON in response');
            const parsed = JSON.parse(match[0]);
            console.log('✅ JSON parsed successfully');
            console.log('📊 Parsed fields:', Object.keys(parsed).join(', '));
            
            return {
                // Core fields
                myDirection: parsed.myDirection || null,
                agreesWithScanner: parsed.agreesWithScanner !== undefined ? parsed.agreesWithScanner : true,
                confidence: Math.min(100, Math.max(0, parsed.confidence || 50)),
                verdict: ['NO_TRADE', 'TAKE', 'SKIP', 'WAIT'].includes(parsed.verdict) ? parsed.verdict : 'WAIT',
                entryType: parsed.entryType || 'NONE',
                
                // Rules check
                rulesCheck: parsed.rulesCheck || null,
                
                // Summary
                executiveSummary: parsed.executiveSummary || '',
                whyDisagree: parsed.whyDisagree || null,
                reasoning: parsed.executiveSummary || 'Analysis complete',
                
                // Confluence Counter
                confluenceCounter: parsed.confluenceCounter || null,
                
                // Trap Detection
                trapDetection: parsed.trapDetection || null,
                
                // Entry Timing
                entryTiming: parsed.entryTiming || null,
                
                // Zone Analysis
                zoneAnalysis: parsed.zoneAnalysis || null,
                
                // SMC Analysis
                smcAnalysis: parsed.smcAnalysis || null,
                
                // Momentum Analysis
                momentumAnalysis: parsed.momentumAnalysis || null,
                
                // Trade Plan (includes add-ons, leverage, size)
                tradePlan: parsed.tradePlan || null,
                
                // Risk Assessment
                riskAssessment: parsed.riskAssessment || null,
                
                // Action Plan
                actionPlan: parsed.actionPlan || null,
                
                // Legacy fields (keep for backward compatibility)
                candlePatternAnalysis: parsed.candlePatternAnalysis || null,
                leverageRecommendation: parsed.leverageRecommendation || null,
                professionalNotes: parsed.professionalNotes || '',
                marketContext: parsed.marketContext || '',
                tradeManagement: parsed.tradeManagement || null,
                risks: Array.isArray(parsed.risks) ? parsed.risks : [],
                suggestions: Array.isArray(parsed.suggestions) ? parsed.suggestions : [],
                leverageAdvice: parsed.leverageAdvice || '',
                
                // Saved Trade AI fields (for progress updates)
                commentary: parsed.commentary || null,
                recommendation: parsed.recommendation || null,
                moveSlToBE: parsed.moveSlToBE || false,
                warnings: Array.isArray(parsed.warnings) ? parsed.warnings : []
            };
        } else {
            console.warn('⚠️ No JSON found in response');
            console.log('📄 Raw text:', text.substring(0, 500));
        }
    } catch (e) {
        console.error('❌ AI parse error:', e);
        console.log('📄 Failed text:', text.substring(0, 500));
    }
    
    // Default response when parsing fails
    return {
        myDirection: null,
        agreesWithScanner: true,
        confidence: 50,
        verdict: 'WAIT',
        entryType: 'NONE',
        rulesCheck: null,
        reasoning: 'Could not parse AI response',
        executiveSummary: '',
        whyDisagree: null,
        confluenceCounter: null,
        trapDetection: null,
        entryTiming: null,
        zoneAnalysis: null,
        smcAnalysis: null,
        momentumAnalysis: null,
        tradePlan: null,
        riskAssessment: null,
        actionPlan: null,
        candlePatternAnalysis: null,
        leverageRecommendation: null,
        professionalNotes: '',
        marketContext: '',
        tradeManagement: null,
        risks: [],
        suggestions: [],
        leverageAdvice: '',
        // Saved Trade AI fields
        commentary: null,
        recommendation: null,
        moveSlToBE: false,
        warnings: []
    };
}

async function getAIAnalysis(signal) {
    if (!signal || !STATE.aiKey) return null;
    
    // SAFETY: Prevent concurrent AI calls
    if (STATE.aiCallInProgress) {
        console.warn('⚠️ AI call already in progress');
        toast('AI analysis in progress...', 'warning');
        return null;
    }
    
    STATE.aiCallInProgress = true;
    
    try {
        // Safe helper functions to prevent undefined errors
        const sf = (val, decimals = 2) => {
            if (val === undefined || val === null || isNaN(val)) return 'N/A';
            return Number(val).toFixed(decimals);
        };
        const ss = (val, fallback = 'N/A') => val !== undefined && val !== null ? val : fallback;
        
        // Safe object access
        const levels = signal.levels || {};
        const smc = signal.smc || {};
        const smcD = smc.details || {};
        const zone = signal.zone || {};
        const zoneD = zone.details || {};
        const mom = signal.momentum || {};
        const momD = mom.details || {};
        const htf = signal.htf || {};
        const scores = signal.scores || {};
        const candle = signal.candlePatterns || {};
        const candleC = candle.currentCandle || {};
        const candleB = candle.behavior || {};
        
        // Pre-calculate engine directions (treat score < 30 as NEUTRAL)
        const zoneDir = scores.zone >= 30 ? (zone.direction || 'NEUTRAL') : 'NEUTRAL';
        const smcDir = scores.smc >= 30 ? (smc.direction || 'NEUTRAL') : 'NEUTRAL';
        const momDir = scores.momentum >= 30 ? (mom.direction || 'NEUTRAL') : 'NEUTRAL';
        const candleDir = candle.patternSignal || 'NEUTRAL';
        
        // Count directions
        const dirs = [zoneDir, smcDir, momDir, candleDir];
        const longCount = dirs.filter(d => d === 'LONG' || d === 'BULLISH').length;
        const shortCount = dirs.filter(d => d === 'SHORT' || d === 'BEARISH').length;
        const neutralCount = dirs.filter(d => d === 'NEUTRAL' || d === null).length;
        
        // Pre-calculate conflicts
        const conflicts = [];
        if (zoneDir !== 'NEUTRAL' && zoneDir !== signal.direction) conflicts.push('Zone opposes scanner');
        if (smcDir !== 'NEUTRAL' && smcDir !== signal.direction) conflicts.push('SMC opposes scanner');
        if (momDir !== 'NEUTRAL' && momDir !== signal.direction) conflicts.push('Momentum opposes scanner');
        if (candleDir !== 'NEUTRAL' && candleDir !== signal.direction && candleDir !== 'BULLISH' && candleDir !== 'BEARISH') conflicts.push('Candle pattern opposes');
        
        // Pre-calculate rule violations
    const ruleViolations = [];
    if (scores.smc < 20) ruleViolations.push('RULE 1 VIOLATED: SMC < 20 (score: ' + scores.smc + ') → NO_TRADE');
    if (scores.smc >= 20 && scores.smc < 30) ruleViolations.push('RULE 2 WARNING: SMC < 30 (score: ' + scores.smc + ') → SKIP unless Zone Override');
    if (conflicts.length >= 2) ruleViolations.push('RULE 3 VIOLATED: 2+ engines conflict → SKIP');
    if (neutralCount >= 3) ruleViolations.push('RULE 4 WARNING: 2+ engines NEUTRAL → WAIT');
    if (momDir !== 'NEUTRAL' && momDir !== signal.direction && scores.momentum >= 50) ruleViolations.push('RULE 5 VIOLATED: Strong momentum opposes → SKIP');
    const htfPct = htf.total > 0 ? (htf.aligned / htf.total) * 100 : 0;
    if (htfPct < 50) ruleViolations.push('RULE 6 VIOLATED: HTF < 50% (' + htfPct.toFixed(0) + '%) → SKIP');
    
    // Check Zone Override eligibility
    const supportDist = zoneD.nearestSupport ? Math.abs(signal.price - zoneD.nearestSupport.price) / signal.price * 100 : 999;
    const resistDist = zoneD.nearestResistance ? Math.abs(signal.price - zoneD.nearestResistance.price) / signal.price * 100 : 999;
    const atSupport = supportDist <= 1;
    const atResistance = resistDist <= 1;
    const zoneOverrideEligible = scores.zone >= 75 && 
        ((signal.direction === 'LONG' && atSupport && (zoneD.nearestSupport?.touches || 0) >= 3) ||
         (signal.direction === 'SHORT' && atResistance && (zoneD.nearestResistance?.touches || 0) >= 3)) &&
        !(momDir !== 'NEUTRAL' && momDir !== signal.direction && scores.momentum >= 60);
    
    const prompt = `You are an INDEPENDENT institutional crypto trading analyst. You must form YOUR OWN opinion.

═══════════════════════════════════════════════════════════════════════════════
⚠️ CRITICAL: YOU ARE INDEPENDENT - DO NOT BLINDLY FOLLOW SCANNER
═══════════════════════════════════════════════════════════════════════════════

The scanner has suggested a direction. But YOU must:
1. Analyze ALL raw data independently
2. Form YOUR OWN direction based on evidence
3. DISAGREE with scanner if data doesn't support it
4. Follow the MANDATORY RULES below

═══════════════════════════════════════════════════════════════════════════════
MANDATORY RULES (YOU MUST FOLLOW - NO EXCEPTIONS)
═══════════════════════════════════════════════════════════════════════════════

RULE 1: SMC < 20 → NO_TRADE (unless Zone Override applies)
RULE 2: SMC < 30 → SKIP (unless Zone Override applies)
RULE 3: 2+ engines oppose scanner direction → SKIP
RULE 4: 2+ engines NEUTRAL (no direction) → WAIT
RULE 5: Momentum opposes scanner AND momentum score ≥ 50 → SKIP
RULE 6: HTF alignment < 50% → SKIP
RULE 7: Trap detected with HIGH confidence → NO_TRADE

ZONE OVERRIDE (Exception to Rules 1-2):
Can override IF ALL of these are true:
✓ Zone Score ≥ 75
✓ Price within 1% of zone
✓ Zone has 3+ touches
✓ Zone direction matches scanner
✓ Momentum NOT strongly opposing (score < 60 if opposing)

═══════════════════════════════════════════════════════════════════════════════
PRE-CALCULATED RULE CHECK (by scanner)
═══════════════════════════════════════════════════════════════════════════════
${ruleViolations.length > 0 ? '🚨 VIOLATIONS DETECTED:\n' + ruleViolations.map(r => '• ' + r).join('\n') : '✅ No rule violations detected'}

Zone Override Eligible: ${zoneOverrideEligible ? 'YES ✅' : 'NO ❌'}
${zoneOverrideEligible ? '→ Zone Override allows entry despite weak SMC' : ''}

═══════════════════════════════════════════════════════════════════════════════
ENGINE DIRECTIONS (Score < 30 = Treated as NEUTRAL)
═══════════════════════════════════════════════════════════════════════════════
┌──────────────┬───────────┬────────┬─────────────────────────────┐
│ Engine       │ Direction │ Score  │ Status                      │
├──────────────┼───────────┼────────┼─────────────────────────────┤
│ Zone         │ ${zoneDir.padEnd(9)} │ ${String(scores.zone || 0).padEnd(6)} │ ${scores.zone >= 30 ? 'Reliable' : '⚠️ Weak (ignored)'} │
│ SMC          │ ${smcDir.padEnd(9)} │ ${String(scores.smc || 0).padEnd(6)} │ ${scores.smc >= 30 ? 'Reliable' : scores.smc < 20 ? '⛔ Critical' : '⚠️ Weak'} │
│ Momentum     │ ${momDir.padEnd(9)} │ ${String(scores.momentum || 0).padEnd(6)} │ ${scores.momentum >= 30 ? 'Reliable' : '⚠️ Weak (ignored)'} │
│ Candle       │ ${candleDir.padEnd(9)} │ ${String(candle.strength || 0).padEnd(6)} │ ${candle.strength >= 30 ? 'Reliable' : 'Weak'} │
└──────────────┴───────────┴────────┴─────────────────────────────┘

Scanner Direction: ${signal.direction}
Agreement: LONG=${longCount} | SHORT=${shortCount} | NEUTRAL=${neutralCount}
Conflicts: ${conflicts.length > 0 ? conflicts.join(', ') : 'None'}

═══════════════════════════════════════════════════════════════════════════════
SIGNAL DATA
═══════════════════════════════════════════════════════════════════════════════
Asset: ${ss(signal.symbol)}
Timeframe: ${ss(signal.tf)}
Current Price: $${ss(signal.price)}
Overall Grade: ${ss(signal.grade)} (${ss(signal.score, 0)}/100)
Warnings: ${signal.warnings?.length > 0 ? signal.warnings.join(', ') : 'None'}

═══════════════════════════════════════════════════════════════════════════════
ZONE DATA
═══════════════════════════════════════════════════════════════════════════════
Zone Score: ${scores.zone}/100
Zone Status: ${ss(zone.status)} ${atSupport ? '🎯 AT SUPPORT!' : atResistance ? '🎯 AT RESISTANCE!' : ''}

Support: ${zoneD.nearestSupport ? '$' + sf(zoneD.nearestSupport.price, 4) + ' (Strength: ' + (zoneD.nearestSupport.strength || 'N/A') + ', Touches: ' + (zoneD.nearestSupport.touches || 'N/A') + ', Distance: ' + sf(supportDist, 2) + '%)' : 'N/A'}
Resistance: ${zoneD.nearestResistance ? '$' + sf(zoneD.nearestResistance.price, 4) + ' (Strength: ' + (zoneD.nearestResistance.strength || 'N/A') + ', Touches: ' + (zoneD.nearestResistance.touches || 'N/A') + ', Distance: ' + sf(resistDist, 2) + '%)' : 'N/A'}

═══════════════════════════════════════════════════════════════════════════════
SMC DATA
═══════════════════════════════════════════════════════════════════════════════
SMC Score: ${scores.smc}/100 ${scores.smc < 20 ? '⛔ CRITICAL - NO STRUCTURE' : scores.smc < 30 ? '⚠️ WEAK' : ''}
Structure: ${smcD.structure ? ss(smcD.structure.trend) : 'N/A'}
Trigger: ${ss(smc.trigger, 'None')}
Order Blocks: ${smcD.orderBlocks ? 'Bull: ' + (smcD.orderBlocks.bullish?.length || 0) + ' Bear: ' + (smcD.orderBlocks.bearish?.length || 0) : 'N/A'}
FVGs: ${smcD.fvg ? 'Bull: ' + (smcD.fvg.bullish?.length || 0) + ' Bear: ' + (smcD.fvg.bearish?.length || 0) : 'N/A'}

═══════════════════════════════════════════════════════════════════════════════
MOMENTUM DATA
═══════════════════════════════════════════════════════════════════════════════
Momentum Score: ${scores.momentum}/100
Momentum Direction: ${momDir} ${momDir !== 'NEUTRAL' && momDir !== signal.direction ? '⚠️ OPPOSES SCANNER!' : ''}
RSI: ${momD.rsi ? sf(momD.rsi.value, 1) + ' (' + ss(momD.rsi.trend) + ')' : 'N/A'}
MACD: ${momD.macd ? ss(momD.macd.trend) + (momD.macd.crossover ? ' ' + momD.macd.crossover : '') : 'N/A'}
StochRSI: ${momD.stochRSI ? 'K:' + sf(momD.stochRSI.k, 1) + ' D:' + sf(momD.stochRSI.d, 1) : 'N/A'}

═══════════════════════════════════════════════════════════════════════════════
CANDLE PATTERN DATA
═══════════════════════════════════════════════════════════════════════════════
Current Candle: ${ss(candleC.type, 'Unknown')}
Pattern Signal: ${candleDir} ${candleDir !== 'NEUTRAL' && candleDir !== signal.direction ? '⚠️ OPPOSES SCANNER!' : ''}
Patterns: ${candle.patterns?.length > 0 ? candle.patterns.map(p => p.name + ' (' + p.signal + ')').join(', ') : 'None'}
Who's In Control: ${ss(candleB.control, 'Unknown')}
controlBuyers: ${candle.controlBuyers ? 'TRUE ✅' : 'FALSE'}
controlSellers: ${candle.controlSellers ? 'TRUE ✅' : 'FALSE'}
Trap Potential: ${ss(candleB.trapPotential, 'Low')}
${signal.v1Ultimate?.trapDetection?.warning ? '🚨 ' + signal.v1Ultimate.trapDetection.warning : ''}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - SEQUENCE VALIDATION (NEW!)
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Sequence State: ${signal.v1Ultimate.sequence.state}
Sequence Score: ${signal.v1Ultimate.sequence.score}/100
Steps Completed: ${signal.v1Ultimate.sequence.completed}/${signal.v1Ultimate.sequence.total}
Sequence Quality: ${signal.v1Ultimate.sequence.quality}

Steps:
• Sweep: ${signal.v1Ultimate.sequence.steps.sweep ? '✅' : '❌'}
• BOS/CHoCH: ${signal.v1Ultimate.sequence.steps.bos ? '✅' : '❌'}
• FVG: ${signal.v1Ultimate.sequence.steps.fvg ? '✅' : '❌'}
• Order Block: ${signal.v1Ultimate.sequence.steps.ob ? '✅' : '❌'}
• Pullback to POI: ${signal.v1Ultimate.sequence.steps.pullback ? '✅' : '❌'}
• Pattern at POI: ${signal.v1Ultimate.sequence.steps.pattern ? '✅' : '❌'}
` : 'Sequence data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - PATTERN-AT-LEVEL (NEW!)
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Pattern at Level: ${signal.v1Ultimate.patternAtLevel.atLevel ? 'YES ✅' : 'NO ❌'}
Level Type: ${signal.v1Ultimate.patternAtLevel.levelType}
Distance: ${signal.v1Ultimate.patternAtLevel.distancePercent?.toFixed(2) || 'N/A'}%
Bonus Points: +${signal.v1Ultimate.patternAtLevel.bonus}
Details: ${signal.v1Ultimate.patternAtLevel.details}
` : 'Pattern-at-Level data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - REJECTION SCORE (NEW!)
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Rejection Score: ${signal.v1Ultimate.rejectionScore.score}/100
Rejection Quality: ${signal.v1Ultimate.rejectionScore.quality}

Breakdown:
• Wick Touch: +${signal.v1Ultimate.rejectionScore.breakdown.wickTouch}
• Body Closed: +${signal.v1Ultimate.rejectionScore.breakdown.bodyClosed}
• Wick Ratio: +${signal.v1Ultimate.rejectionScore.breakdown.wickRatio}
• Volume Confirm: +${signal.v1Ultimate.rejectionScore.breakdown.volumeConfirm}
• Follow Through: +${signal.v1Ultimate.rejectionScore.breakdown.followThrough}
` : 'Rejection Score data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - ZONE OVERRIDE STATUS
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Zone Override Eligible: ${signal.v1Ultimate.zoneOverride.eligible ? 'YES ✅' : 'NO ❌'}
Conditions Passed: ${signal.v1Ultimate.zoneOverride.passed}/${signal.v1Ultimate.zoneOverride.required}
Reason: ${signal.v1Ultimate.zoneOverride.reason}
` : 'Zone Override data not available'}

═══════════════════════════════════════════════════════════════════════════════
V10.3 STRUCTURE ENGINE (Quantum Chart Integration)
═══════════════════════════════════════════════════════════════════════════════
${signal.structure ? `
Structure Score: ${signal.structure.score}/100
Structure Gate: ${signal.structureGatePass ? 'PASS ✅' : 'FAIL ❌'}

• Channel: ${signal.structure.channel?.isValid ? 'VALID (' + (signal.structure.channel.widthPct * 100).toFixed(1) + '% width)' : 'NO CHANNEL'}
• Trendlines: Bull: ${signal.structure.trendlines?.bull?.length || 0} | Bear: ${signal.structure.trendlines?.bear?.length || 0}
• Compression: ${signal.structure.compression?.isCompressed ? 'YES (ready to expand)' : signal.structure.compression?.isExpanding ? 'EXPANDING' : 'NO'}
• Bias: ${signal.structure.bias || 'NEUTRAL'} ${signal.structure.bias === 'DISCOUNT' && signal.direction === 'LONG' ? '✅ ALIGNED' : signal.structure.bias === 'PREMIUM' && signal.direction === 'SHORT' ? '✅ ALIGNED' : signal.structure.bias === 'EQUILIBRIUM' ? '⚖️ NEUTRAL' : '⚠️ CHECK'}
• Position: ${((signal.structure.biasPosition || 0.5) * 100).toFixed(0)}% of channel (0%=bottom, 100%=top)
• Factors: ${signal.structure.factors?.join(', ') || 'None'}
` : 'Structure data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - SCORE BREAKDOWN
═══════════════════════════════════════════════════════════════════════════════
${signal.ultimateScore ? `
FINAL SCORE: ${signal.score}/100

Components:
• Sequence (40%): ${signal.ultimateScore.breakdown.sequence.raw} → ${signal.ultimateScore.breakdown.sequence.weighted}
• Rejection (25%): ${signal.ultimateScore.breakdown.rejection.raw} → ${signal.ultimateScore.breakdown.rejection.weighted}
• HTF (15%): ${signal.ultimateScore.breakdown.htf.raw} → ${signal.ultimateScore.breakdown.htf.weighted}
• Momentum (10%): ${signal.ultimateScore.breakdown.momentum.raw} → ${signal.ultimateScore.breakdown.momentum.weighted}
• Volume (10%): ${signal.ultimateScore.breakdown.volume.raw} → ${signal.ultimateScore.breakdown.volume.weighted}
` : 'Score breakdown not available'}

═══════════════════════════════════════════════════════════════════════════════
HTF BIAS
═══════════════════════════════════════════════════════════════════════════════
${htf.bias ? Object.entries(htf.bias).map(([t, b]) => t + ':' + b).join(' | ') : 'N/A'}
Alignment: ${ss(htf.aligned, 0)}/${ss(htf.total, 0)} (${htfPct.toFixed(0)}%) ${htfPct < 50 ? '⚠️ BELOW 50%!' : ''}

═══════════════════════════════════════════════════════════════════════════════
MARKET ENVIRONMENT (Global Conditions)
═══════════════════════════════════════════════════════════════════════════════
${signal.environment ? `
Environment Score: ${signal.environment.score}/100 (${signal.environment.verdict})

• BTC Trend: ${STATE.environment.btcTrend?.direction || 'N/A'} ${(signal.direction === 'LONG' && STATE.environment.btcTrend?.direction === 'BULLISH') || (signal.direction === 'SHORT' && STATE.environment.btcTrend?.direction === 'BEARISH') ? '✅ ALIGNED' : STATE.environment.btcTrend?.direction === 'FLAT' ? '⚠️ FLAT' : '❌ CONFLICTS'}
• BTC.D Trend: ${STATE.environment.btcDominance?.trend || 'N/A'} ${(signal.direction === 'LONG' && STATE.environment.btcDominance?.trend === 'FALLING') || (signal.direction === 'SHORT' && STATE.environment.btcDominance?.trend === 'RISING') ? '✅ FAVORABLE' : STATE.environment.btcDominance?.trend === 'FLAT' ? '⚠️ NEUTRAL' : '❌ UNFAVORABLE'}
• DXY: ${STATE.environment.dxy?.value?.toFixed(1) || 'N/A'} ${STATE.environment.dxy?.trend || 'N/A'} ${STATE.environment.dxy?.trend === 'FALLING' ? '✅ GOOD' : STATE.environment.dxy?.trend === 'RISING' ? '⚠️ RISK-OFF' : ''}
• BTC Structure: ${STATE.environment.btcStructure?.status || 'N/A'} ${STATE.environment.btcStructure?.status === 'INTACT' ? '✅' : STATE.environment.btcStructure?.status === 'BROKEN_DOWN' && signal.direction === 'LONG' ? '❌ DANGEROUS' : '⚠️'}
• BTC RSI: ${STATE.environment.btcRSI?.value || 'N/A'} (${STATE.environment.btcRSI?.status || 'N/A'}) ${STATE.environment.btcRSI?.status === 'HEALTHY' ? '✅' : '⚠️ EXTENDED'}
• Funding: ${STATE.environment.funding?.rate ? (STATE.environment.funding.rate * 100).toFixed(3) + '%' : 'N/A'} (${STATE.environment.funding?.status || 'N/A'}) ${STATE.environment.funding?.status === 'EXTREME' && ((signal.direction === 'LONG' && STATE.environment.funding?.rate > 0) || (signal.direction === 'SHORT' && STATE.environment.funding?.rate < 0)) ? '❌ EXTREME AGAINST' : STATE.environment.funding?.status === 'NORMAL' ? '✅' : '⚠️'}

ENVIRONMENT VERDICT: ${signal.environment.verdict} ${signal.environment.verdict === 'GO' ? '✅ Favorable for ' + signal.direction : signal.environment.verdict === 'CAUTION' ? '⚠️ Proceed with caution' : signal.environment.verdict === 'RISKY' ? '🟠 High risk' : '❌ Unfavorable'}
` : 'Environment data not available'}

YOU MUST FACTOR ENVIRONMENT INTO YOUR DECISION:
• If Environment is NO-GO and signal is otherwise valid → WAIT or SKIP
• If Environment conflicts (BTC against direction) → Reduce confidence
• If Funding is EXTREME against direction → Strong caution or SKIP

═══════════════════════════════════════════════════════════════════════════════
SCANNER TRADE LEVELS (for reference)
═══════════════════════════════════════════════════════════════════════════════
Entry: $${sf(levels.entry, 4)}
SL: $${sf(levels.sl, 4)} (${ss(levels.riskPct)}%)
TP1: $${sf(levels.tp1, 4)} | TP2: $${sf(levels.tp2, 4)} | TP3: $${sf(levels.tp3, 4)}
R:R = 1:${ss(levels.rr)}

═══════════════════════════════════════════════════════════════════════════════
YOUR TASK
═══════════════════════════════════════════════════════════════════════════════

STEP 1: Form YOUR OWN direction based on engine data (ignore scanner initially)
STEP 2: Check if any MANDATORY RULES are violated
STEP 3: If Zone Override applies, you may proceed despite weak SMC
STEP 4: Compare YOUR direction with scanner - agree or disagree
STEP 5: Give final verdict: NO_TRADE / SKIP / WAIT / TAKE

ADD-ON LEVELS RULE (CRITICAL):
• For LONG: Add-on levels must be BELOW entry (buy dips)
• For SHORT: Add-on levels must be ABOVE entry (sell rips)

ENTRY TYPE:
• ZONE ENTRY (at strong zone, before confirmation): 50% size, 3-5x leverage
• CONFIRMED ENTRY (all engines agree): 100% size, 5-10x leverage

Respond ONLY with this JSON:
{
  "myDirection": "LONG" or "SHORT" or "NO_TRADE",
  "agreesWithScanner": true or false,
  "confidence": 0-100,
  "verdict": "NO_TRADE" or "SKIP" or "WAIT" or "TAKE",
  "entryType": "ZONE_ENTRY" or "CONFIRMED" or "NONE",
  "rulesCheck": {
    "smcRule": "PASS/FAIL - explanation",
    "conflictRule": "PASS/FAIL - explanation",
    "htfRule": "PASS/FAIL - explanation",
    "zoneOverride": "APPLIED/NOT_NEEDED/NOT_ELIGIBLE"
  },
  "executiveSummary": "2-3 sentences explaining your decision",
  "whyDisagree": "if you disagree with scanner, explain why (or null)",
  "confluenceCounter": {
    "alignedFactors": ["factor1", "factor2"],
    "conflictingFactors": ["conflict1", "conflict2"],
    "score": "X aligned vs Y conflicting"
  },
  "trapDetection": {
    "isTrap": true or false,
    "trapType": "None/Bull Trap/Bear Trap/Fakeout",
    "warning": "explanation"
  },
  "entryTiming": {
    "timing": "OPTIMAL/GOOD/SUBOPTIMAL/TOO_LATE",
    "recommendation": "Enter now/Wait for pullback/Skip"
  },
  "zoneAnalysis": {
    "quality": "Strong/Moderate/Weak/None",
    "pricePosition": "At Support/At Resistance/Mid-range"
  },
  "smcAnalysis": {
    "validity": "Valid/Weak/Invalid",
    "assessment": "your assessment"
  },
  "momentumAnalysis": {
    "direction": "Bullish/Bearish/Neutral",
    "alignsWithTrade": true or false
  },
  "tradePlan": {
    "entry": "price or NONE",
    "sl": "price",
    "tp1": "price",
    "tp2": "price",
    "tp3": "price",
    "addOnLevels": ["price1 - reason", "price2 - reason"],
    "positionSize": "50% or 100%",
    "leverage": "Xx-Xx"
  },
  "environmentAssessment": {
    "agrees": true or false,
    "concerns": ["concern1", "concern2"],
    "recommendation": "How environment affects this trade"
  },
  "riskAssessment": {
    "level": "Low/Medium/High/Extreme",
    "risks": ["risk1", "risk2"],
    "invalidation": "price that kills the trade"
  },
  "actionPlan": {
    "action": "what to do now",
    "conditions": "conditions to meet",
    "avoid": "what NOT to do"
  }
}`;

        return await callMultiAI(prompt);
    } finally {
        // SAFETY: Always release AI lock
        STATE.aiCallInProgress = false;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// V18: CONSENSUS ENGINE - Merge Scanner + AI levels for best entry
// ═══════════════════════════════════════════════════════════════════════════════
function buildConsensus(signal, aiResult) {
    if (!aiResult || !signal) return null;
    
    const consensus = {
        direction: null,
        confidence: 0,
        entry: null,
        sl: null,
        tp1: null,
        tp2: null,
        tp3: null,
        source: 'NONE',
        agreement: false,
        reasoning: []
    };
    
    // Check if AI agrees with scanner direction
    const aiDir = aiResult.myDirection;
    const scannerDir = signal.direction;
    
    if (aiDir === scannerDir) {
        consensus.agreement = true;
        consensus.direction = scannerDir;
        consensus.confidence = Math.round((signal.score + (aiResult.confidence || 50)) / 2);
        consensus.source = 'BOTH_AGREE';
        consensus.reasoning.push('Scanner and AI agree on direction');
        
        // Merge levels - take the better of each
        const scannerLevels = signal.levels || {};
        const aiLevels = aiResult.tradePlan || {};
        
        // Entry: Use average or scanner if AI doesn't provide
        const scannerEntry = parseFloat(scannerLevels.entry) || signal.price;
        const aiEntry = parseFloat(aiLevels.entry) || scannerEntry;
        consensus.entry = (scannerEntry + aiEntry) / 2;
        
        // SL: Use the TIGHTER (closer to entry) SL for better risk management
        const scannerSL = parseFloat(scannerLevels.sl);
        const aiSL = parseFloat(aiLevels.sl);
        if (scannerSL && aiSL) {
            if (scannerDir === 'LONG') {
                consensus.sl = Math.max(scannerSL, aiSL); // Higher SL = tighter for LONG
            } else {
                consensus.sl = Math.min(scannerSL, aiSL); // Lower SL = tighter for SHORT
            }
            consensus.reasoning.push('Using tighter SL from AI/Scanner');
        } else {
            consensus.sl = scannerSL || aiSL;
        }
        
        // TP: Use scanner TPs (AI might only have one)
        consensus.tp1 = parseFloat(scannerLevels.tp1) || parseFloat(aiLevels.tp1);
        consensus.tp2 = parseFloat(scannerLevels.tp2) || parseFloat(aiLevels.tp2);
        consensus.tp3 = parseFloat(scannerLevels.tp3) || parseFloat(aiLevels.tp3);
        
    } else if (aiDir === 'NO_TRADE') {
        consensus.direction = null;
        consensus.source = 'AI_REJECTED';
        consensus.confidence = 0;
        consensus.reasoning.push(`AI rejected: ${aiResult.executiveSummary || 'No reason given'}`);
        
    } else {
        // AI disagrees with scanner
        consensus.agreement = false;
        consensus.source = 'DISAGREE';
        consensus.reasoning.push(`AI says ${aiDir}, Scanner says ${scannerDir}`);
        consensus.reasoning.push(aiResult.whyDisagree || 'AI disagrees with scanner direction');
        
        // Use AI's direction if AI confidence is higher
        if ((aiResult.confidence || 0) > signal.score) {
            consensus.direction = aiDir;
            consensus.confidence = aiResult.confidence;
            consensus.reasoning.push('Using AI direction (higher confidence)');
        } else {
            consensus.direction = scannerDir;
            consensus.confidence = signal.score;
            consensus.reasoning.push('Using Scanner direction (higher confidence)');
        }
    }
    
    return consensus;
}

// ═══════════════════════════════════════════════════════════════════════════════
// SCANNER ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

async function runScanner() {
    // 🛡️ HARDENING: Check if we can scan (error pause check)
    if (typeof Hardening !== 'undefined' && !Hardening.canScan()) {
        const stats = Hardening.getErrorStats();
        console.warn(`🛑 Scanning paused. Resume in ${Math.ceil(stats.resumeIn/1000)}s`);
        return;
    }
    
    // 🛡️ HARDENING: Acquire mutex lock
    if (typeof Hardening !== 'undefined') {
        const gotLock = await Hardening.acquireScanLock(5000);
        if (!gotLock) {
            console.warn('⚠️ Could not acquire scan lock');
            return;
        }
    }
    
    // SAFETY: Prevent concurrent scans
    if (STATE.scanInProgress) {
        console.warn('⚠️ Scan already in progress');
        toast('Scan already running...', 'warning');
        if (typeof Hardening !== 'undefined') Hardening.releaseScanLock();
        return;
    }
    
    if (!STATE.scanning) {
        if (typeof Hardening !== 'undefined') Hardening.releaseScanLock();
        return;
    }
    
    STATE.scanInProgress = true;  // Lock
    
    try {
        // 🛡️ HARDENING: Run memory cleanup
        if (typeof Hardening !== 'undefined') Hardening.cleanup();
        
        // UPDATE ENVIRONMENT FIRST
        await updateEnvironment();
        
        // Store previous signals for comparison (for status badges)
        STATE.previousSignals = [...STATE.signals];
        
        const signals = [];
        const filteredSignals = [];  // Signals blocked by environment
        
        let coins = CONFIG.COINS.length > 0 ? CONFIG.COINS : CONFIG.ALL_COINS.slice(0, STATE.coinCount);
        
        // SAFETY: Limit max coins per scan
        const maxCoins = CONFIG.SAFETY?.MAX_COINS_PER_SCAN || 300;
        if (coins.length > maxCoins) {
            console.warn(`⚠️ Limiting coins from ${coins.length} to ${maxCoins}`);
            toast(`⚠️ Coin limit: Scanning ${maxCoins} of ${coins.length} selected coins`, 'warning');
            coins = coins.slice(0, maxCoins);
        }
        
        let timeframes;
        
        if (STATE.mode === 'SCALP') {
            timeframes = CONFIG.TF_SCALP;
        } else if (STATE.mode === 'SWING') {
            timeframes = CONFIG.TF_SWING;
        } else {
            timeframes = CONFIG.TF_ALL;
        }
        
        // Filter by enabled timeframes from settings
        timeframes = timeframes.filter(tf => STATE.tfEnabled[tf]);
        
        if (timeframes.length === 0) {
            toast('No timeframes enabled! Enable at least one in Settings.', 'error');
            STATE.scanning = false;
            STATE.scanInProgress = false;
            document.getElementById('scanBtn').className = 'btn';
            document.getElementById('scanIcon').textContent = '●';
            return;
        }
        
        const total = coins.length * timeframes.length;
        let current = 0;
        
        // Track previous signal count for alerts
        const prevSignalCount = STATE.signals.length;
        
        STATE.scanProgress = { current: 0, total, coin: '', tf: '' };
        
        for (const coin of coins) {
            if (!STATE.scanning) break;
            
            for (const tf of timeframes) {
                if (!STATE.scanning) break;
                
                current++;
                STATE.scanProgress = {
                    current,
                    total,
                    coin: coin.replace('USDT', ''),
                    tf: CONFIG.TF_LABELS[tf] || tf
                };
                
                updateScanStatus();
                
                try {
                    const signal = await analyzeSignal(coin, tf);
                    
                    // 🛡️ HARDENING: Record success (reset error counter)
                    if (typeof Hardening !== 'undefined') Hardening.recordSuccess();
                    
                    if (signal) {
                        // 🛡️ HARDENING: Log signal for forward testing
                        if (typeof Hardening !== 'undefined') {
                            signal.hardeningId = Hardening.logSignal(signal, coin, tf);
                        }
                        
                        // Add environment data to signal (pass signal for RS/HTF)
                        const envResult = calculateEnvironmentScore(signal.direction, signal);
                        signal.environment = {
                            score: envResult.score,
                            verdict: envResult.verdict,
                            details: envResult.details,
                            icons: getEnvIcons(signal)
                        };
                        
                        // 🧠 APPLY INTELLIGENT BRAIN
                        const brainResult = applyIntelligentBrain(signal, signals);
                        signal.brain = brainResult;
                        
                        // Check if brain blocked the signal
                        if (brainResult.blocked) {
                            signal.filterReason = brainResult.blockReason;
                            signal.brainBlocked = true;
                            filteredSignals.push(signal);
                            continue;  // Skip to next signal
                        }
                        
                        // Apply brain modifications
                        if (brainResult.intent) {
                            signal.intent = brainResult.intent.intent;
                            signal.intentConfidence = brainResult.intent.confidence;
                        }
                        
                        if (brainResult.modifiedLevels) {
                            signal.intentLevels = brainResult.modifiedLevels;
                        }
                        
                        if (brainResult.positionSize) {
                            signal.smartPosition = brainResult.positionSize;
                        }
                        
                        if (brainResult.pattern && brainResult.pattern.patternData) {
                            signal.patternHistory = brainResult.pattern;
                        }
                        
                        // Add brain warnings to signal
                        if (brainResult.warnings && brainResult.warnings.length > 0) {
                            signal.brainWarnings = brainResult.warnings;
                        }
                        
                        // Adjust score based on brain
                        signal.originalScore = signal.score;
                        signal.score = brainResult.adjustedConfidence;
                        
                        // Check if signal should be filtered
                        const filterResult = shouldFilterSignal(signal);
                        if (filterResult.filter) {
                            // Add to filtered list instead
                            signal.filterReason = filterResult.reason;
                            filteredSignals.push(signal);
                        } else {
                            signals.push(signal);
                        }
                    }
                } catch (e) {
                    console.error(`Scan error ${coin} ${tf}:`, e);
                    
                    // 🛡️ HARDENING: Record error
                    if (typeof Hardening !== 'undefined') {
                        const shouldPause = Hardening.recordError(`${coin} ${tf}: ${e.message}`);
                        if (shouldPause) {
                            // Break out of scan loop if paused
                            break;
                        }
                    }
                }
                
                await sleep(CONFIG.SCAN_DELAY);
            }
        }
        
        // Sort by score descending
        signals.sort((a, b) => b.score - a.score);
        
        // Check for new high-grade signals and trigger alert
        const gradeOrder = ['PERFECT', 'STRONG', 'VALID', 'HEATING', 'BREWING'];
        const alertGradeIdx = gradeOrder.indexOf(STATE.alertGrade);
        
        // Get previous signal keys for comparison
        const prevSignalKeys = new Set(STATE.signals.map(s => `${s.symbol}-${s.tf}-${s.direction}`));
        
        const newHighGradeSignals = signals.filter(sig => {
            const sigGradeIdx = gradeOrder.indexOf(sig.grade);
            const isQualifying = sigGradeIdx <= alertGradeIdx && sigGradeIdx >= 0;
            const sigKey = `${sig.symbol}-${sig.tf}-${sig.direction}`;
            const isNew = !prevSignalKeys.has(sigKey);
            return isQualifying && isNew;
        });
        
        // Trigger alert if we have new qualifying signals
        if (newHighGradeSignals.length > 0) {
            console.log('🔔 New qualifying signal found:', newHighGradeSignals[0].symbol);
            triggerAlert(newHighGradeSignals[0]);
        }
        
        // SAFETY: Limit signals array size
        const maxSignals = CONFIG.SAFETY?.MAX_SIGNALS || 500;
        if (signals.length > maxSignals) {
            console.warn(`⚠️ Limiting signals from ${signals.length} to ${maxSignals}`);
            signals.splice(maxSignals);
        }
        
        STATE.signals = signals;
        STATE.filteredSignals = filteredSignals;
        STATE.filteredCount = filteredSignals.length;
        STATE.selected = null;
        STATE.current = null;
        STATE.aiResult = null;
        
        updateSignalList();
        updateCounts();
        updateMainPanel();
        
        // V10.3: Update structure bar with first signal's structure
        if (signals.length > 0 && signals[0].structure) {
            updateStructureBar(signals[0].structure);
        }
        
        const filteredMsg = filteredSignals.length > 0 ? ` (${filteredSignals.length} filtered)` : '';
        toast(`Scan complete: ${signals.length} signals${filteredMsg}`, 'success');
        
        // Auto-update saved trades with live prices
        updateAllSavedTradesLive();
        
        // Set progress bar to green (complete)
        setScanComplete();
        
        // Auto-rescan using configured interval
        if (STATE.scanning) {
            // SAFETY: Enforce minimum scan interval
            const minInterval = CONFIG.SAFETY?.MIN_SCAN_INTERVAL_MS || 30000;
            const interval = Math.max(STATE.scanInterval, minInterval);
            
            // Reset progress bar before next scan
            setTimeout(() => {
                resetScanProgress();
                runScanner();
            }, interval);
        }
        
    } catch (scanError) {
        console.error('🛑 Scan error:', scanError);
        toast('Scan error - retrying...', 'error');
        
        // Still try to auto-rescan even after error
        if (STATE.scanning) {
            setTimeout(() => {
                resetScanProgress();
                runScanner();
            }, 30000); // Retry after 30 seconds on error
        }
    } finally {
        // SAFETY: Always release scan lock
        STATE.scanInProgress = false;
        
        // 🛡️ HARDENING: Release mutex
        if (typeof Hardening !== 'undefined') Hardening.releaseScanLock();
    }
}

function updateScanStatus() {
    const el = document.getElementById('signalList');
    if (!el) return;
    
    const p = STATE.scanProgress;
    const pct = p.total > 0 ? Math.round((p.current / p.total) * 100) : 0;
    
    // Update progress bar (background scan - don't hide signals!)
    const progressBar = document.getElementById('scanProgressBar');
    const progressFill = document.getElementById('scanProgressFill');
    const progressText = document.getElementById('scanProgressText');
    const progressPct = document.getElementById('scanProgressPct');
    
    if (progressBar && STATE.scanning && p.total > 0) {
        progressBar.classList.add('active');
        if (progressFill) {
            progressFill.style.width = pct + '%';
            progressFill.classList.add('scanning');
        }
        if (progressText) {
            progressText.innerHTML = `<span class="scan-text-glow">🔄 ${p.coin}</span> <span class="scan-text-amber">${p.tf}</span>`;
        }
        if (progressPct) {
            progressPct.innerHTML = `<span class="scan-text-amber">${p.current}/${p.total}</span>`;
        }
    } else if (progressBar) {
        progressBar.classList.remove('active');
        if (progressFill) progressFill.classList.remove('scanning');
    }
    
    // Only show loading if NO signals yet (first scan)
    if (STATE.signals.length === 0 && el) {
        el.innerHTML = `
            <div class="empty">
                <div class="rainbow-circle-container">
                    <div class="rainbow-circle-ring"></div>
                    <div class="rainbow-circle-inner">
                        <div class="rainbow-circle-coin">${p.coin || 'Loading'}</div>
                        <div class="rainbow-circle-tf">${p.tf || '...'}</div>
                        <div class="rainbow-circle-pct">${pct}%</div>
                        <div class="rainbow-circle-count">${p.current}/${p.total}</div>
                    </div>
                </div>
            </div>
        `;
    }
    // Otherwise, signals stay visible during rescan!
}

// ═══════════════════════════════════════════════════════════════════════════════
// UI RENDERING
// ═══════════════════════════════════════════════════════════════════════════════

function updateSignalList() {
    try {
        const el = document.getElementById('signalList');
        if (!el) return;
        
        let filtered = [...safeArr(STATE.signals)];
        
        // V11-CLEAN: Apply direction tab filter FIRST
        if (STATE.directionTab) {
            filtered = filtered.filter(s => s && s.direction === STATE.directionTab);
        }
        
        // Apply status filter
        if (STATE.filter === 'perfect') {
            filtered = filtered.filter(s => s && s.grade === 'PERFECT');
        } else if (STATE.filter === 'ready') {
            filtered = filtered.filter(s => s && s.status === 'ready');
        } else if (STATE.filter === 'early') {
            filtered = filtered.filter(s => s && s.status === 'early');
        }
        
        // Apply stats bar filter
        if (STATE.statsFilter === 'cream') {
            filtered = filtered.filter(s => s && isCreamSignal(s));
        } else if (STATE.statsFilter === 'perfect') {
            filtered = filtered.filter(s => s && s.grade === 'PERFECT');
        } else if (STATE.statsFilter === 'long') {
            filtered = filtered.filter(s => s && s.direction === 'LONG');
        } else if (STATE.statsFilter === 'short') {
            filtered = filtered.filter(s => s && s.direction === 'SHORT');
        } else if (STATE.statsFilter === 'agree3') {
            filtered = filtered.filter(s => s && s.agreed === 3);
        }
        
        // V11-CLEAN: Update direction counts after filtering
        if (typeof updateDirectionCounts === 'function') {
            updateDirectionCounts();
        }
        
        if (filtered.length === 0) {
            el.innerHTML = `
                <div class="empty">
                    <div class="empty-icon" style="font-size:36px;color:var(--amber)">📊</div>
                    <div style="color:var(--text2)">${STATE.scanning ? 'Scanning...' : `No ${STATE.directionTab || ''} signals found`}</div>
                </div>
            `;
            return;
        }
        
        el.innerHTML = filtered.map((sig, idx) => {
            try {
                if (!sig || !sig.symbol) return '';
                
                // SAFETY: Get direction first before anything else
                const sigDirection = sig.direction || 'LONG';
                const sigGrade = sig.grade || 'BREWING';
                const sigScore = safeNum(sig.score, 0);
                const sigPrice = safeNum(sig.price, 0);
                const sigLevels = safeObj(sig.levels);
                const sigScores = safeObj(sig.scores);
                const sigEngineDirections = safeObj(sig.engineDirections);
                const sigAgreed = safeNum(sig.agreed, 0);
                
                // FIX: Find index by matching symbol AND tf to avoid -1 issues
                const realIdx = STATE.signals.findIndex(s => s && s.symbol === sig.symbol && s.tf === sig.tf);
                if (realIdx === -1) {
                    console.warn('Signal not found in STATE.signals:', sig.symbol, sig.tf);
                }
                const isActive = STATE.selected === realIdx;
                const isScalp = ['5m', '15m', '30m', '1H'].includes(sig.tf);
                const htfOk = sig.htf && sig.htf.aligned >= 2;
                const agreementColor = sig.agreed === 3 ? 'var(--long)' : 'var(--amber)';
                const fullAgreeClass = sig.agreed === 3 ? 'full-agree' : '';
                const gradeClass = 'grade-' + sigGrade.toLowerCase();
                
                // Check if CREAM signal
                const isCream = isCreamSignal(sig);
                const creamBadge = isCream ? '<span style="color:#00ffcc;font-weight:700;text-shadow:0 0 8px #00ffcc;margin-left:4px">💎</span>' : '';
                
                // Calculate status badge (compare with previous scan)
                let statusBadge = '';
                const sigKey = sig.symbol + '_' + sig.tf;
                const prevSig = STATE.previousSignals.find(p => p.symbol === sig.symbol && p.tf === sig.tf);
                
                if (!prevSig) {
                    statusBadge = '<span class="status-badge new">🆕 NEW</span>';
                } else {
                    const scoreDiff = sigScore - safeNum(prevSig.score, 0);
                    if (scoreDiff >= 5) {
                        statusBadge = `<span class="status-badge up">⬆️+${scoreDiff}</span>`;
                    } else if (scoreDiff <= -5) {
                        statusBadge = `<span class="status-badge down">⬇️${scoreDiff}</span>`;
                    }
                }
                
                // Generate environment icons if available (with safety)
                let envIconsHtml = '';
                try {
                    if (sig.environment) {
                        envIconsHtml = generateEnvIconsHtml(sig);
                    }
                } catch (e) {
                    console.warn('Env icons error:', e.message);
                }
                
                return `
                    <div class="signal-card ${sigDirection.toLowerCase()} ${gradeClass} ${fullAgreeClass} ${isActive ? 'active' : ''}" 
                         onclick="selectSignalBySymbol('${sig.symbol}','${sig.tf}')"${isCream ? ' style="border:2px solid #00ffcc;box-shadow:0 0 12px rgba(0,255,204,0.3)"' : ''}>
                <div class="signal-top">
                    <div class="signal-pair">
                        ${sig.symbol.replace('USDT', '')}${creamBadge}
                        <span class="dir-tag ${sigDirection.toLowerCase()}">${sigDirection}</span>
                        <span class="tf-tag">${sig.tf}</span>
                        <span style="font-size:11px;color:${agreementColor};font-weight:700">${sigAgreed}/3</span>
                        ${htfOk ? '<span style="font-size:11px;color:var(--cyan)">HTF✓</span>' : ''}
                        ${statusBadge}
                    </div>
                    <span class="grade ${sigGrade.toLowerCase()}">${sigGrade}</span>
                </div>
                <div class="signal-meta">
                    <span>📊 ${sigScore}</span>
                    <span>💰 $${fmtPrice(sigPrice)}</span>
                    <span>R:R 1:${safeFixed(sigLevels.rr, 2)}</span>
                </div>
                <div class="signal-scores">
                    <span class="score-tag ${scoreClass(sigScores.zone)}" title="Zone: ${sigEngineDirections.zone || 'N/A'}">Z:${safeNum(sigScores.zone, 0)}${sigEngineDirections.zone === sigDirection ? '✓' : ''}</span>
                    <span class="score-tag ${scoreClass(sigScores.smc)}" title="SMC: ${sigEngineDirections.smc || 'N/A'}">S:${safeNum(sigScores.smc, 0)}${sigEngineDirections.smc === sigDirection ? '✓' : ''}</span>
                    <span class="score-tag ${scoreClass(sigScores.momentum)}" title="Momentum: ${sigEngineDirections.momentum || 'N/A'}">M:${safeNum(sigScores.momentum, 0)}${sigEngineDirections.momentum === sigDirection ? '✓' : ''}</span>
                    <span class="score-tag" style="color:var(--cyan)">H:${safeNum(sigScores.htf, 0)}</span>
                </div>
                ${sig.smartMatrix ? `
                <div class="smart-matrix">
                    <span class="regime-badge ${(sig.smartMatrix.regime?.regime || 'unknown').toLowerCase()}">${sig.smartMatrix.regime?.regime || '?'}</span>
                    <span class="weights"><span class="w-zone">Z:${sig.smartMatrix.weights?.zone || 33}%</span> <span class="w-smc">S:${sig.smartMatrix.weights?.smc || 33}%</span> <span class="w-mom">M:${sig.smartMatrix.weights?.momentum || 34}%</span></span>
                    <span class="dominant ${(sig.smartMatrix.dominant || 'balanced').toLowerCase()}-lead">${sig.smartMatrix.dominant || 'BAL'}</span>
                    <span class="agreement ${(sig.smartMatrix.agreement?.agreement || 'none').toLowerCase()}">${sig.smartMatrix.agreement?.count || 0}/3</span>
                </div>
                ` : ''}
                ${sig.smartBrain ? `
                <div class="smart-brain" style="display:flex;gap:4px;flex-wrap:wrap;margin-top:4px;padding:6px 8px;background:rgba(0,212,255,0.08);border-radius:4px;font-size:10px;border:1px solid rgba(0,212,255,0.2)">
                    <span style="color:var(--cyan);font-weight:600" title="Brain Score (0-100)">🧠${sig.smartBrain.brainScore || 0}</span>
                    <span title="Coin Personality: ${sig.smartBrain.personalityDesc || ''}" style="color:${sig.smartBrain.personality === 'MEME' ? 'var(--short)' : sig.smartBrain.personality === 'KING' ? 'var(--gold)' : sig.smartBrain.personality === 'BLUECHIP' ? 'var(--cyan)' : 'var(--text-dim)'}">🎭${sig.smartBrain.personality || '?'}</span>
                    <span title="Price position in range (${sig.smartBrain.positionThresholds || ''})" style="color:${sig.smartBrain.pricePosition < 35 ? 'var(--long)' : sig.smartBrain.pricePosition > 65 ? 'var(--short)' : 'var(--text-dim)'}">📍${sig.smartBrain.pricePosition}%</span>
                    <span title="Market trend" style="color:${sig.smartBrain.marketTrend === 'UPTREND' ? 'var(--long)' : sig.smartBrain.marketTrend === 'DOWNTREND' ? 'var(--short)' : 'var(--text-dim)'}">${sig.smartBrain.marketTrend === 'UPTREND' ? '📈' : sig.smartBrain.marketTrend === 'DOWNTREND' ? '📉' : '↔️'}</span>
                    <span title="Rejection type" style="color:var(--gold)">${sig.smartBrain.rejectionType || '?'}</span>
                    <span title="Volume (zone threshold: ${sig.smartBrain.zoneThreshold || '?'})" style="color:${sig.smartBrain.volumeStrength === 'HIGH' ? 'var(--long)' : sig.smartBrain.volumeStrength === 'LOW' ? 'var(--short)' : 'var(--text-dim)'}">V:${sig.smartBrain.volRatio}x</span>
                    ${sig.smartBrain.liquiditySweep ? '<span style="color:var(--gold)" title="Liquidity sweep detected - institutional entry">💀SWEEP</span>' : ''}
                    <span title="HTF bias" style="color:${sig.smartBrain.htfConflict ? 'var(--short)' : sig.smartBrain.htfBias === 'BULLISH' ? 'var(--long)' : sig.smartBrain.htfBias === 'BEARISH' ? 'var(--short)' : 'var(--text-dim)'}">HTF:${sig.smartBrain.htfBias?.charAt(0) || '?'}${sig.smartBrain.htfConflict ? '⚠️' : ''}</span>
                </div>
                ` : ''}
                ${sig.structure ? `
                <div class="signal-structure">
                    ${sig.structure.channel?.isValid ? `<span class="str-tag channel"><span class="icon">📊</span>CH ${(sig.structure.channel.widthPct * 100).toFixed(1)}%</span>` : ''}
                    ${sig.structure.trendlines?.bull?.length > 0 ? `<span class="str-tag trendline"><span class="icon">📈</span>TL↑${sig.structure.trendlines.bull.length}</span>` : ''}
                    ${sig.structure.trendlines?.bear?.length > 0 ? `<span class="str-tag trendline"><span class="icon">📉</span>TL↓${sig.structure.trendlines.bear.length}</span>` : ''}
                    ${sig.structure.compression?.isCompressed ? `<span class="str-tag compression"><span class="icon">🔄</span>COMP</span>` : ''}
                    ${sig.structure.bias && sig.structure.bias !== 'NEUTRAL' && sig.structure.bias !== 'EQUILIBRIUM' ? `<span class="str-tag bias"><span class="icon">🎯</span>${sig.structure.bias}</span>` : ''}
                    <span class="str-tag ${sig.structureGatePass ? 'gate-pass' : 'gate-fail'}"><span class="icon">${sig.structureGatePass ? '✅' : '⚠️'}</span>GATE</span>
                </div>
                ` : ''}
                ${(() => {
                    try {
                        const liveInfo = getLiveDataForSignal(sig.symbol, sigDirection);
                        const liqClass = liveInfo.liqSupport === 'support' ? 'liq-bullish' : liveInfo.liqSupport === 'oppose' ? 'liq-bearish' : '';
                        const oiClass = liveInfo.oiSupport === 'support' ? 'oi-rising' : liveInfo.oiSupport === 'caution' ? 'oi-falling' : '';
                        const fundClass = liveInfo.fundingSupport === 'support' ? 'funding-pos' : liveInfo.fundingSupport === 'oppose' ? 'funding-neg' : '';
                        const whaleClass = (liveInfo.whale === 'BUYING' && sigDirection === 'LONG') || (liveInfo.whale === 'SELLING' && sigDirection === 'SHORT') ? 'whale-buy' : '';
                        return `
                        <div class="signal-live-data">
                            ${liveInfo.liq.bias !== 'NEUTRAL' ? `<span class="live-tag ${liqClass}">💀 ${liveInfo.liq.bias}</span>` : ''}
                            ${liveInfo.oi?.trend && liveInfo.oi.trend !== 'FLAT' ? `<span class="live-tag ${oiClass}">📊 OI ${liveInfo.oi.trend}</span>` : ''}
                            ${liveInfo.whale !== 'NEUTRAL' ? `<span class="live-tag ${whaleClass}">🐋 ${liveInfo.whale}</span>` : ''}
                            ${liveInfo.funding?.rate && Math.abs(liveInfo.funding.rate) > 0.02 ? `<span class="live-tag ${fundClass}">💰 ${liveInfo.funding.rate.toFixed(3)}%</span>` : ''}
                        </div>
                        `;
                    } catch(e) { return ''; }
                })()}
                ${(() => {
                    try {
                        if (!sig.advanced) return '';
                        const adv = sig.advanced;
                        const vp = adv.volumeProfile;
                        const of = adv.orderFlow;
                        const ml = adv.mlPrediction;
                        
                        let vpTag = '';
                        if (vp && vp.valid && vp.factors.length > 0) {
                            const vpClass = vp.support === 'strong' ? 'at-val' : vp.support === 'support' ? 'vp-tag' : 'at-vah';
                            vpTag = `<span class="adv-tag vp-tag ${vpClass}"><span class="icon">📊</span>${vp.support === 'strong' ? 'VP✓' : 'VP'}</span>`;
                        }
                        
                        let ofTag = '';
                        if (of && of.flow) {
                            const ofClass = of.support === 'strong' ? 'buy-aggro' : of.support === 'oppose' ? 'sell-aggro' : 'of-tag';
                            const ofLabel = of.flow.aggression.replace('STRONG_', '').replace('_', ' ');
                            ofTag = `<span class="adv-tag of-tag ${ofClass}"><span class="icon">🌊</span>${ofLabel}</span>`;
                            if (of.flow.absorption) {
                                ofTag += `<span class="adv-tag of-tag absorption"><span class="icon">🛡️</span>ABS</span>`;
                            }
                        }
                        
                        let mlTag = '';
                        if (ml && ml.confidence !== 'LOW') {
                            const mlClass = ml.suggestion === 'FAVORABLE' ? 'favorable' : ml.suggestion === 'UNFAVORABLE' ? 'unfavorable' : 'ml-tag';
                            mlTag = `<span class="adv-tag ml-tag ${mlClass}"><span class="icon">🤖</span>${ml.probability}%</span>`;
                        }
                        
                        const confClass = adv.confidence.toLowerCase();
                        const scoreClass = adv.combinedScore >= 65 ? 'high' : adv.combinedScore >= 50 ? 'medium' : 'low';
                        
                        if (!vpTag && !ofTag && !mlTag) return '';
                        
                        return `
                        <div class="signal-advanced">
                            ${vpTag}${ofTag}${mlTag}
                            <span class="conf-badge ${confClass}">${adv.confidence}</span>
                            <div class="adv-score-ring ${scoreClass}">${adv.combinedScore}</div>
                        </div>
                        `;
                    } catch(e) { return ''; }
                })()}
                ${envIconsHtml}
            </div>
        `;
            } catch (cardErr) {
                console.warn('Signal card error:', cardErr.message);
                return '';
            }
        }).filter(html => html !== '').join('');
    } catch (listError) {
        console.error('🛡️ Signal list error:', listError);
        const el = document.getElementById('signalList');
        if (el) {
            el.innerHTML = '<div class="empty"><div style="color:var(--amber)">⚠️ List error - refreshing...</div></div>';
        }
    }
}

function updateCounts() {
    try {
        let filtered = [...safeArr(STATE.signals)];
        
        if (STATE.mode === 'SCALP') {
            filtered = filtered.filter(s => s && ['5m', '15m', '30m', '1H'].includes(s.tf));
        } else if (STATE.mode === 'SWING') {
            filtered = filtered.filter(s => s && ['1H', '4H', '1D'].includes(s.tf));
        }
        
        // Update filter counts (with null checks)
        const elAll = document.getElementById('cAll');
        const elPerfect = document.getElementById('cPerfect');
        const elReady = document.getElementById('cReady');
        const elEarly = document.getElementById('cEarly');
        
        if (elAll) elAll.textContent = filtered.length;
        if (elPerfect) elPerfect.textContent = filtered.filter(s => s && s.grade === 'PERFECT').length;
        if (elReady) elReady.textContent = filtered.filter(s => s && s.status === 'ready').length;
        if (elEarly) elEarly.textContent = filtered.filter(s => s && s.status === 'early').length;
        
        // Update dashboard stats bar (with null checks)
        const elTotal = document.getElementById('statTotal');
        const elCream = document.getElementById('statCream');
        const elStatPerfect = document.getElementById('statPerfect');
        const elStatLong = document.getElementById('statLong');
        const elStatShort = document.getElementById('statShort');
        const elStatAgree = document.getElementById('statFullAgree');
        
        if (elTotal) elTotal.textContent = filtered.length;
        if (elCream) elCream.textContent = filtered.filter(s => s && isCreamSignal(s)).length;
        if (elStatPerfect) elStatPerfect.textContent = filtered.filter(s => s && s.grade === 'PERFECT').length;
        if (elStatLong) elStatLong.textContent = filtered.filter(s => s && s.direction === 'LONG').length;
        if (elStatShort) elStatShort.textContent = filtered.filter(s => s && s.direction === 'SHORT').length;
        if (elStatAgree) elStatAgree.textContent = filtered.filter(s => s && s.agreed === 3).length;
    } catch (countsError) {
        console.warn('Update counts error:', countsError.message);
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// CREAM SIGNAL DETECTION (Ultimate Signal - All conditions perfect)
// ═══════════════════════════════════════════════════════════════════════════════

function isCreamSignal(signal) {
    if (!signal) return false;
    
    const env = STATE.environment || {};
    const dir = signal.direction;
    
    // Criteria 1: Engine Score >= 85
    if (signal.score < 85) return false;
    
    // Criteria 2: Full Agreement (3/3)
    if (signal.agreed !== 3) return false;
    
    // Criteria 3: BTC Trend aligned
    const btcTrend = env.btcTrend?.direction || 'FLAT';
    if (dir === 'LONG' && btcTrend !== 'BULLISH' && btcTrend !== 'FLAT') return false;
    if (dir === 'SHORT' && btcTrend !== 'BEARISH' && btcTrend !== 'FLAT') return false;
    
    // Criteria 4: BTC.D favorable
    const btcDTrend = env.btcDominance?.trend || 'FLAT';
    if (dir === 'LONG' && btcDTrend === 'RISING') return false;  // Bad for alts going long
    if (dir === 'SHORT' && btcDTrend === 'FALLING') return false; // Bad for shorting alts
    
    // Criteria 5: Environment Score >= 80 (GO verdict)
    const envScore = signal.environment?.score || 0;
    if (envScore < 80) return false;
    
    // Criteria 6: HTF Alignment >= 75%
    if (signal.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 0;
        if (htfPct < 75) return false;
    }
    
    // Criteria 7: BTC Structure intact
    const struct = env.btcStructure?.status || 'UNKNOWN';
    if (struct !== 'INTACT') return false;
    
    // Criteria 8: OI confirms direction (NOT a squeeze)
    const oiInterp = STATE.openInterest?.interpretation || 'NEUTRAL';
    if (oiInterp === 'SQUEEZE' || oiInterp === 'LIQUIDATION') return false;
    
    // All criteria passed = CREAM 💎
    return true;
}

function updateMainPanel() {
    // Debug: updateMainPanel
    try {
        const el = document.getElementById('mainPanel');
        if (!el) {
            console.error('❌ mainPanel element not found!');
            return;
        }
        
        if (!STATE.current) {
            // Debug: No signal
            el.innerHTML = `
                <div class="empty">
                    <div class="empty-icon">👈</div>
                    <div>Select a signal to view details</div>
                </div>
            `;
            return;
        }
        
        const sig = STATE.current;
        const ai = STATE.aiResult;
        
        console.log('🟢 Rendering signal:', sig.symbol, sig.direction);
        
        // Safety: Ensure sig has required properties
        if (!sig.symbol || !sig.direction) {
            console.error('❌ Invalid signal data - missing symbol or direction');
            el.innerHTML = '<div class="empty"><div>Invalid signal data</div></div>';
            return;
        }
        
        // FIX: Define sigDirection EARLY to avoid "Cannot access before initialization" error
        const sigDirection = sig.direction || 'LONG';
        
        // FIX: Saved Trade Comparison Banner (when viewing saved trade with fresh rescan)
        let savedComparisonHtml = '';
        if (sig.savedTrade) {
            const st = sig.savedTrade;
            // FIX: Safe division with null check
            const priceDiff = safeFixed(safePct(sig.price - (st.savedEntry || 0), st.savedEntry || 1), 2);
            const priceDirection = sig.price > st.savedEntry ? '📈' : sig.price < st.savedEntry ? '📉' : '➡️';
            const gradeChanged = sig.grade !== st.savedGrade;
            const dirChanged = sig.direction !== st.savedDirection;
            
            savedComparisonHtml = `
                <div style="background:linear-gradient(135deg, var(--purple-dim), var(--cyan-dim));border:2px solid var(--purple);border-radius:10px;padding:12px;margin-bottom:12px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                        <span style="font-size:13px;font-weight:700;color:var(--purple)">📌 SAVED TRADE COMPARISON</span>
                        <span style="font-size:10px;color:var(--text3)">Saved ${new Date(st.savedAt).toLocaleString()}</span>
                    </div>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:10px">
                    <div style="background:var(--bg3);border-radius:6px;padding:8px">
                        <div style="font-size:10px;color:var(--text3);margin-bottom:4px">📸 WHEN SAVED</div>
                        <div style="font-size:12px;color:var(--text)">Entry: $${st.savedEntry?.toFixed(4) || 'N/A'}</div>
                        <div style="font-size:11px;color:var(--text2)">Grade: <span style="color:var(--${st.savedGrade === 'PERFECT' ? 'long' : st.savedGrade === 'STRONG' ? 'cyan' : 'amber'})">${st.savedGrade}</span> (${st.savedScore})</div>
                        <div style="font-size:11px;color:var(--text2)">Dir: ${st.savedDirection}</div>
                    </div>
                    <div style="background:var(--bg3);border-radius:6px;padding:8px">
                        <div style="font-size:10px;color:var(--text3);margin-bottom:4px">📊 NOW (FRESH)</div>
                        <div style="font-size:12px;color:var(--text)">Price: $${sig.price?.toFixed(4) || 'N/A'} ${priceDirection}</div>
                        <div style="font-size:11px;color:var(--text2)">Grade: <span style="color:var(--${sig.grade === 'PERFECT' ? 'long' : sig.grade === 'STRONG' ? 'cyan' : 'amber'})">${sig.grade}</span> (${sig.score}) ${gradeChanged ? '⚠️' : '✅'}</div>
                        <div style="font-size:11px;color:var(--text2)">Dir: ${sig.direction} ${dirChanged ? '🔄 CHANGED!' : '✅'}</div>
                    </div>
                </div>
                
                <div style="display:flex;justify-content:space-between;font-size:11px;padding-top:8px;border-top:1px solid var(--border)">
                    <span style="color:var(--text3)">Price moved: <span style="color:${priceDiff >= 0 ? 'var(--long)' : 'var(--short)'};">${priceDiff >= 0 ? '+' : ''}${priceDiff}%</span></span>
                    ${dirChanged ? '<span style="color:var(--short);font-weight:700">⚠️ DIRECTION CHANGED!</span>' : ''}
                    ${gradeChanged ? '<span style="color:var(--amber)">Grade changed</span>' : '<span style="color:var(--long)">✓ Signal stable</span>'}
                </div>
            </div>
        `;
    }
    
    // HTF Box - with null safety
    const sigHtf = sig.htf || { aligned: 0, total: 0, bias: {} };
    const htfHtml = `
        <div class="htf-box">
            <div class="htf-title">📈 HTF Bias (${sigHtf.aligned || 0}/${sigHtf.total || 0} Aligned)</div>
            <div class="htf-grid">
                ${Object.entries(sigHtf.bias || {}).map(([tf, bias]) => `
                    <div class="htf-item">
                        <div class="htf-label">${tf}</div>
                        <div class="htf-value ${bias === 'BULLISH' ? 'bull' : bias === 'BEARISH' ? 'bear' : 'neutral'}">${bias}</div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    // 🎯 GP/OTE Display - Advanced Fibonacci Zones
    let gpoteHtml = '';
    try {
        if (sig.gpote && sig.gpote.valid) {
            gpoteHtml = generateGPOTEDisplay(sig.gpote, false);
        }
    } catch (gpoteErr) {
        console.warn('GP/OTE display error:', gpoteErr);
        gpoteHtml = '';
    }
    
    // AI Section - Expandable with Comprehensive Independent Analysis
    let aiHtml;
    if (ai) {
        const verdictClass = ai.verdict === 'TAKE' ? 'take' : ai.verdict === 'NO_TRADE' ? 'skip' : ai.verdict === 'SKIP' ? 'skip' : 'wait';
        const barColor = ai.verdict === 'TAKE' ? 'var(--long)' : (ai.verdict === 'SKIP' || ai.verdict === 'NO_TRADE') ? 'var(--short)' : 'var(--amber)';
        const agreementColor = ai.agreesWithScanner ? 'var(--long)' : 'var(--short)';
        const agreementText = ai.agreesWithScanner ? '✓ AGREES' : '✗ DISAGREES';
        const aiDirectionColor = ai.myDirection === 'LONG' ? 'var(--long)' : ai.myDirection === 'SHORT' ? 'var(--short)' : 'var(--text3)';
        const entryTypeColor = ai.entryType === 'ZONE_ENTRY' ? 'var(--gold)' : ai.entryType === 'CONFIRMED' ? 'var(--long)' : 'var(--text3)';
        
        // Helper to format nested objects safely
        const formatObj = (obj, color) => {
            if (!obj) return '';
            if (typeof obj === 'string') return '<div style="font-size:12px;color:var(--text2)">' + obj + '</div>';
            return '<div style="font-size:12px;color:var(--text2)">' + 
                Object.entries(obj).filter(([k,v]) => v && v !== 'N/A').map(([k,v]) => {
                    const label = k.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                    if (Array.isArray(v)) return '<div style="margin-bottom:4px"><b>' + label + ':</b> ' + v.join(', ') + '</div>';
                    return '<div style="margin-bottom:4px"><b>' + label + ':</b> ' + v + '</div>';
                }).join('') + '</div>';
        };
        
        // Get risks array (handles both old and new format)
        const getRisks = () => {
            if (ai.riskAssessment && ai.riskAssessment.risks && ai.riskAssessment.risks.length) return ai.riskAssessment.risks;
            if (ai.riskAssessment && ai.riskAssessment.primaryRisks && ai.riskAssessment.primaryRisks.length) return ai.riskAssessment.primaryRisks;
            if (ai.risks && ai.risks.length) return ai.risks;
            return [];
        };
        
        // Get summary (handles both formats)
        const getSummary = () => ai.executiveSummary || ai.reasoning || '';
        
        // Get leverage info from tradePlan or legacy field
        const getLeverage = () => {
            if (ai.tradePlan && (ai.tradePlan.leverage || ai.tradePlan.positionSize)) {
                return { leverage: ai.tradePlan.leverage, size: ai.tradePlan.positionSize };
            }
            return ai.leverageRecommendation || ai.leverageAdvice || null;
        };
        
        aiHtml = `
            <div class="ai-section">
                <div class="ai-header" onclick="toggleAIExpand()" style="cursor:pointer">
                    <span class="ai-title">🤖 AI Independent Analysis</span>
                    <div style="display:flex;align-items:center;gap:8px">
                        <span class="ai-verdict ${verdictClass}">${ai.verdict}</span>
                        <span style="font-size:14px">${STATE.aiExpanded ? '▼' : '▶'}</span>
                    </div>
                </div>
                
                <div class="ai-bar"><div class="ai-fill" style="width:${ai.confidence}%;background:${barColor}"></div></div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                    <span style="font-size:12px">Confidence: <b>${ai.confidence}%</b></span>
                    <span style="font-size:11px;color:${agreementColor};font-weight:700">${agreementText} with Scanner</span>
                </div>
                
                <div style="display:flex;gap:8px;margin-bottom:10px">
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px">
                        <div style="font-size:11px;color:var(--text3)">Scanner Says</div>
                        <div style="font-size:14px;font-weight:700;color:${sig.direction === 'LONG' ? 'var(--long)' : 'var(--short)'}">${sig.direction}</div>
                    </div>
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px;border:1px solid ${aiDirectionColor}">
                        <div style="font-size:11px;color:var(--text3)">AI Says</div>
                        <div style="font-size:14px;font-weight:700;color:${aiDirectionColor}">${ai.myDirection || 'N/A'}</div>
                    </div>
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px;border:1px solid ${entryTypeColor}">
                        <div style="font-size:11px;color:var(--text3)">Entry Type</div>
                        <div style="font-size:12px;font-weight:700;color:${entryTypeColor}">${ai.entryType === 'ZONE_ENTRY' ? '🎯 ZONE' : ai.entryType === 'CONFIRMED' ? '✅ CONFIRMED' : '❌ NONE'}</div>
                    </div>
                </div>
                
                ${!ai.agreesWithScanner && ai.whyDisagree ? '<div style="background:var(--short-dim);border:1px solid var(--short);border-radius:6px;padding:10px;margin-bottom:10px"><div style="font-size:11px;color:var(--short);font-weight:700;margin-bottom:4px">⚠️ WHY AI DISAGREES:</div><div style="font-size:12px;color:var(--text2)">' + ai.whyDisagree + '</div></div>' : ''}
                
                ${ai.rulesCheck ? '<div style="background:var(--bg4);border-radius:6px;padding:10px;margin-bottom:10px"><div style="font-size:11px;color:var(--cyan);font-weight:700;margin-bottom:6px">📋 RULES CHECK:</div><div style="font-size:11px;color:var(--text2)">' + Object.entries(ai.rulesCheck).map(([rule, result]) => '<div style="margin-bottom:2px"><b>' + rule + ':</b> ' + result + '</div>').join('') + '</div></div>' : ''}
                
                <div class="ai-text" style="background:var(--bg4);padding:10px;border-radius:6px;border-left:3px solid ${barColor}">${getSummary()}</div>
                
                <div id="aiExpandedContent" style="display:${STATE.aiExpanded ? 'block' : 'none'};margin-top:12px;border-top:1px solid var(--border);padding-top:12px">
                    
                    ${STATE.aiDisplayMode === 'detailed' ? `
                    <!-- DETAILED MODE: 13 Sections -->
                    
                    ${ai.confluenceCounter ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--cyan)"><div style="font-size:11px;color:var(--cyan);font-weight:700;margin-bottom:6px">🎯 CONFLUENCE COUNTER</div>' + formatObj(ai.confluenceCounter, 'cyan') + '</div>' : ''}
                    
                    ${ai.trapDetection ? '<div style="margin-bottom:12px;background:' + (ai.trapDetection.isTrap ? 'var(--short-dim)' : 'var(--bg4)') + ';padding:10px;border-radius:6px;border:1px solid ' + (ai.trapDetection.isTrap ? 'var(--short)' : 'var(--long)') + '"><div style="font-size:11px;color:' + (ai.trapDetection.isTrap ? 'var(--short)' : 'var(--long)') + ';font-weight:700;margin-bottom:6px">' + (ai.trapDetection.isTrap ? '⚠️ TRAP DETECTED!' : '✅ NO TRAP DETECTED') + '</div>' + formatObj(ai.trapDetection, ai.trapDetection.isTrap ? 'short' : 'long') + '</div>' : ''}
                    
                    ${ai.entryTiming ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--amber)"><div style="font-size:11px;color:var(--amber);font-weight:700;margin-bottom:6px">⏰ ENTRY TIMING</div>' + formatObj(ai.entryTiming, 'amber') + '</div>' : ''}
                    
                    ${ai.candlePatternAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:6px">🕯️ CANDLE & PATTERNS</div>' + formatObj(ai.candlePatternAnalysis, 'gold') + '</div>' : ''}
                    
                    ${ai.zoneAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:6px">📍 ZONE ANALYSIS</div>' + formatObj(ai.zoneAnalysis, 'gold') + '</div>' : ''}
                    
                    ${ai.smcAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">🎯 SMC ANALYSIS</div>' + formatObj(ai.smcAnalysis, 'purple') + '</div>' : ''}
                    
                    ${ai.momentumAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--blue);font-weight:700;margin-bottom:6px">⚡ MOMENTUM ANALYSIS</div>' + formatObj(ai.momentumAnalysis, 'blue') + '</div>' : ''}
                    
                    ${ai.tradePlan ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">💰 TRADE PLAN</div>' + formatObj(ai.tradePlan, 'long') + '</div>' : ''}
                    
                    ${(ai.riskAssessment || getRisks().length > 0) ? '<div style="margin-bottom:12px;background:var(--short-dim);padding:10px;border-radius:6px;border:1px solid var(--short)"><div style="font-size:11px;color:var(--short);font-weight:700;margin-bottom:6px">⚠️ RISK ASSESSMENT</div>' + (ai.riskAssessment ? formatObj(ai.riskAssessment, 'short') : '<div style="font-size:12px;color:var(--text2)">' + getRisks().map(r => '• ' + r).join('<br>') + '</div>') + '</div>' : ''}
                    
                    ${getLeverage() ? '<div style="margin-bottom:12px;background:var(--amber-dim);border:1px solid var(--amber);border-radius:6px;padding:10px"><div style="font-size:11px;color:var(--amber);font-weight:700;margin-bottom:6px">⚡ LEVERAGE & SIZING</div>' + formatObj(getLeverage(), 'amber') + '</div>' : ''}
                    
                    ${ai.actionPlan ? '<div style="margin-bottom:12px;background:linear-gradient(135deg,var(--long-dim),var(--cyan-dim));padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">🎯 ACTION PLAN</div>' + formatObj(ai.actionPlan, 'long') + '</div>' : ''}
                    
                    ${ai.professionalNotes ? '<div style="background:var(--bg4);padding:10px;border-radius:6px;border-left:3px solid var(--purple)"><div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">📝 PRO NOTES</div><div style="font-size:12px;color:var(--text2);font-style:italic">' + ai.professionalNotes + '</div></div>' : ''}
                    
                    ` : `
                    <!-- COMPACT MODE: 6 Grouped Sections -->
                    
                    <div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--cyan)">
                        <div style="font-size:11px;color:var(--cyan);font-weight:700;margin-bottom:6px">📊 VERDICT & CONFLUENCE</div>
                        ${ai.confluenceCounter ? formatObj(ai.confluenceCounter, 'cyan') : ''}
                        ${ai.entryTiming ? '<div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border)">' + formatObj(ai.entryTiming, 'amber') + '</div>' : ''}
                    </div>
                    
                    ${(ai.trapDetection || ai.riskAssessment || getRisks().length > 0) ? '<div style="margin-bottom:12px;background:var(--short-dim);padding:10px;border-radius:6px;border:1px solid var(--short)"><div style="font-size:11px;color:var(--short);font-weight:700;margin-bottom:6px">⚠️ WARNINGS & RISKS</div>' + (ai.trapDetection ? formatObj(ai.trapDetection, 'short') : '') + (ai.riskAssessment ? '<div style="margin-top:8px">' + formatObj(ai.riskAssessment, 'short') + '</div>' : '') + '</div>' : ''}
                    
                    <div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px">
                        <div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">🔍 TECHNICAL ANALYSIS</div>
                        ${ai.zoneAnalysis ? '<div style="margin-bottom:6px"><b style="color:var(--gold)">Zone:</b> ' + (typeof ai.zoneAnalysis === 'object' ? (ai.zoneAnalysis.zoneQuality || 'N/A') + ' - ' + (ai.zoneAnalysis.pricePosition || 'N/A') : ai.zoneAnalysis) + '</div>' : ''}
                        ${ai.smcAnalysis ? '<div style="margin-bottom:6px"><b style="color:var(--purple)">SMC:</b> ' + (typeof ai.smcAnalysis === 'object' ? (ai.smcAnalysis.structureValidity || 'N/A') + ' - ' + (ai.smcAnalysis.orderBlockQuality || 'N/A') : ai.smcAnalysis) + '</div>' : ''}
                        ${ai.momentumAnalysis ? '<div><b style="color:var(--blue)">Momentum:</b> ' + (typeof ai.momentumAnalysis === 'object' ? (ai.momentumAnalysis.trendStrength || 'N/A') + ' - ' + (ai.momentumAnalysis.entryTiming || 'N/A') : ai.momentumAnalysis) + '</div>' : ''}
                    </div>
                    
                    ${ai.candlePatternAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:6px">🕯️ PRICE ACTION</div>' + formatObj(ai.candlePatternAnalysis, 'gold') + '</div>' : ''}
                    
                    ${(ai.tradePlan || getLeverage()) ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">💰 TRADE SETUP</div>' + (ai.tradePlan ? formatObj(ai.tradePlan, 'long') : '') + (getLeverage() ? '<div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border)">' + formatObj(getLeverage(), 'amber') + '</div>' : '') + '</div>' : ''}
                    
                    ${ai.actionPlan ? '<div style="margin-bottom:12px;background:linear-gradient(135deg,var(--long-dim),var(--cyan-dim));padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">🎯 ACTION PLAN</div>' + formatObj(ai.actionPlan, 'long') + '</div>' : ''}
                    `}
                    
                </div>
                
                <div style="display:flex;gap:8px;margin-top:10px">
                    <button class="btn" onclick="toggleAIExpand()" style="flex:1">${STATE.aiExpanded ? '▲ Collapse' : '▼ Expand Details'}</button>
                    <button class="btn" onclick="askAI()" style="flex:1">🔄 Refresh AI</button>
                </div>
            </div>
        `;
    } else {
        aiHtml = `
            <div class="ai-section" style="text-align:center;padding:20px">
                <div style="font-size:32px;margin-bottom:8px">🧠</div>
                <div style="font-size:13px;font-weight:600;margin-bottom:4px">Independent AI Analysis</div>
                <div style="font-size:12px;color:var(--text2);margin-bottom:12px">AI will analyze raw data and give its own opinion</div>
                <button class="ai-btn" onclick="askAI()">🧠 Ask Multi-AI</button>
            </div>
        `;
    }
    
    // Analysis Grid - with null safety
    const sigZone = safeObj(sig.zone);
    const sigZoneDetails = safeObj(sigZone.details);
    const sigSmc = safeObj(sig.smc);
    const sigSmcDetails = safeObj(sigSmc.details);
    const sigMomentum = safeObj(sig.momentum);
    const sigMomentumDetails = safeObj(sigMomentum.details);
    const sigScoresLocal = safeObj(sig.scores);
    const sigZoneFactors = safeArr(sigZone.factors);
    const sigSmcFactors = safeArr(sigSmc.factors);
    const sigMomentumFactors = safeArr(sigMomentum.factors);
    
    const analysisHtml = `
        <div class="analysis-grid">
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">📍 Zone Analysis</span>
                    <span class="analysis-score" style="background:${scoreColor(sigScoresLocal.zone)}20;color:${scoreColor(sigScoresLocal.zone)}">${safeNum(sigScoresLocal.zone, 0)}</span>
                </div>
                ${sigZoneDetails.nearestSupport ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Support</span>
                        <span class="analysis-value">$${fmtPrice(sigZoneDetails.nearestSupport.price)}</span>
                    </div>
                ` : ''}
                ${sigZoneDetails.nearestResistance ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Resistance</span>
                        <span class="analysis-value">$${fmtPrice(sigZoneDetails.nearestResistance.price)}</span>
                    </div>
                ` : ''}
                <div class="analysis-row">
                    <span class="analysis-label">Status</span>
                    <span class="analysis-value">${sigZone.status || 'N/A'}</span>
                </div>
                <div class="factor-list">
                    ${sigZoneFactors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
            
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">🎯 SMC Analysis</span>
                    <span class="analysis-score" style="background:${scoreColor(sigScoresLocal.smc)}20;color:${scoreColor(sigScoresLocal.smc)}">${safeNum(sigScoresLocal.smc, 0)}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">Structure</span>
                    <span class="analysis-value">${sigSmcDetails.trend || 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">P/D Zone</span>
                    <span class="analysis-value">${sigSmcDetails.pdZone ? sigSmcDetails.pdZone.zone : 'N/A'}</span>
                </div>
                ${sigSmc.trigger ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Trigger</span>
                        <span class="analysis-value" style="color:var(--gold)">${sigSmc.trigger}</span>
                    </div>
                ` : ''}
                <div class="factor-list">
                    ${sigSmcFactors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
            
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">📈 Momentum</span>
                    <span class="analysis-score" style="background:${scoreColor(sigScoresLocal.momentum)}20;color:${scoreColor(sigScoresLocal.momentum)}">${safeNum(sigScoresLocal.momentum, 0)}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">RSI</span>
                    <span class="analysis-value">${sigMomentumDetails.rsi ? safeFixed(sigMomentumDetails.rsi.value, 1) : 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">ADX</span>
                    <span class="analysis-value">${sigMomentumDetails.adx ? safeFixed(sigMomentumDetails.adx.adx, 1) : 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">MACD</span>
                    <span class="analysis-value">${sigMomentumDetails.macd ? sigMomentumDetails.macd.trend : 'N/A'}</span>
                </div>
                <div class="factor-list">
                    ${sigMomentumFactors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
        </div>
    `;
    
    // Warnings - with null safety
    const sigWarnings = safeArr(sig.warnings);
    const warningsHtml = sigWarnings.length > 0 ? `
        <div style="background:var(--amber-dim);border:1px solid var(--amber);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="font-size:11px;color:var(--amber);font-weight:600;margin-bottom:4px">⚠️ Warnings</div>
            <div style="font-size:12px;color:var(--amber)">${sigWarnings.join(' • ')}</div>
        </div>
    ` : '';
    
    // Smart Trade Data - with null safety
    const sigLevelsLocal = safeObj(sig.levels);
    const smart = safeObj(sigLevelsLocal.smart);
    const entryData = safeObj(smart.entry);
    const slData = safeObj(smart.sl);
    const tp1Data = safeObj(smart.tp1);
    const tp2Data = safeObj(smart.tp2);
    const tp3Data = safeObj(smart.tp3);
    const marketGrade = safeObj(safeGet(entryData, 'market.grade', {}));
    const pb1 = entryData.pullback1;
    const pb2 = entryData.pullback2;
    
    // 🎯 V18 ULTIMATE Entry Data
    const ultimateEntry = safeObj(sig.ultimateEntry);
    const entryType = ultimateEntry.type || sigLevelsLocal.entryType || 'STANDARD';
    const entryTypeColors = {
        'SNIPER': { bg: 'var(--long)', text: 'var(--bg1)', icon: '🎯', label: 'SNIPER' },
        'ZONE': { bg: 'var(--purple)', text: 'var(--bg1)', icon: '📍', label: 'ZONE' },
        'STANDARD': { bg: 'var(--text3)', text: 'var(--bg1)', icon: '📊', label: 'STANDARD' },
        'WAIT': { bg: 'var(--amber)', text: 'var(--bg1)', icon: '⏳', label: 'WAIT' }
    };
    const entryTypeStyle = entryTypeColors[entryType] || entryTypeColors['STANDARD'];
    const pullbackEnabled = ultimateEntry.pullback?.enabled ?? sigLevelsLocal.usePullback ?? true;
    const survivalRate = ultimateEntry.sl?.survivalRate || 70;
    
    // Entry Grade Color
    const gradeColors = {
        'A+': 'var(--long)', 'A': 'var(--long)', 
        'B+': 'var(--cyan)', 'B': 'var(--cyan)',
        'C': 'var(--amber)', 'D': 'var(--short)'
    };
    const gradeColor = gradeColors[marketGrade.grade] || 'var(--text2)';
    
    // 🎯 V18 ULTIMATE Entry Type Badge
    const ultimateEntryHtml = `
        <div style="background:linear-gradient(135deg, ${entryTypeStyle.bg}22 0%, var(--bg3) 100%);border:2px solid ${entryTypeStyle.bg};border-radius:10px;padding:14px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                <div style="display:flex;align-items:center;gap:8px">
                    <span style="font-size:20px">${entryTypeStyle.icon}</span>
                    <span style="font-size:14px;font-weight:800;color:${entryTypeStyle.bg}">${entryTypeStyle.label} ENTRY</span>
                </div>
                <span style="font-size:11px;padding:4px 10px;border-radius:20px;background:${entryTypeStyle.bg};color:${entryTypeStyle.text};font-weight:700">${ultimateEntry.quality || 50}% Quality</span>
            </div>
            <div style="font-size:11px;color:var(--text2);margin-bottom:10px;padding:8px;background:var(--bg4);border-radius:6px">
                ${ultimateEntry.reason || 'Standard entry'}
            </div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
                <div style="text-align:center;padding:8px;background:var(--bg4);border-radius:6px">
                    <div style="font-size:9px;color:var(--text3)">PULLBACK</div>
                    <div style="font-size:12px;font-weight:700;color:${pullbackEnabled ? 'var(--purple)' : 'var(--text3)'}">${pullbackEnabled ? '✅ YES' : '❌ NO'}</div>
                    <div style="font-size:8px;color:var(--text3)">${ultimateEntry.pullback?.reason || ''}</div>
                </div>
                <div style="text-align:center;padding:8px;background:var(--bg4);border-radius:6px">
                    <div style="font-size:9px;color:var(--text3)">SL SURVIVAL</div>
                    <div style="font-size:12px;font-weight:700;color:${survivalRate >= 85 ? 'var(--long)' : survivalRate >= 70 ? 'var(--amber)' : 'var(--short)'}">${survivalRate}%</div>
                    <div style="font-size:8px;color:var(--text3)">${ultimateEntry.sl?.reason || ''}</div>
                </div>
                <div style="text-align:center;padding:8px;background:var(--bg4);border-radius:6px">
                    <div style="font-size:9px;color:var(--text3)">REGIME</div>
                    <div style="font-size:12px;font-weight:700;color:${ultimateEntry.marketRegime === 'TRENDING' ? 'var(--cyan)' : 'var(--purple)'}">${ultimateEntry.marketRegime || 'N/A'}</div>
                </div>
            </div>
            ${ultimateEntry.sweepData?.swept ? `
            <div style="margin-top:10px;padding:8px;background:var(--long-dim);border:1px solid var(--long);border-radius:6px">
                <div style="font-size:10px;color:var(--long);font-weight:600">💀 SWEEP DETECTED</div>
                <div style="font-size:11px;color:var(--text)">${ultimateEntry.sweepData.sweepType} swept at $${fmtPrice(ultimateEntry.sweepData.sweepLevel)} (${ultimateEntry.sweepData.candlesAgo || 1} candles ago)</div>
            </div>
            ` : ''}
        </div>
    `;
    
    // Smart Entry Plan HTML
    const smartEntryHtml = `
        ${ultimateEntryHtml}
        <div style="background:var(--bg4);border:1px solid var(--cyan);border-radius:8px;padding:12px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                <span style="font-size:12px;font-weight:700;color:var(--cyan)">🧠 SMART ENTRY PLAN</span>
                <span style="font-size:11px;padding:3px 8px;border-radius:4px;background:${gradeColor};color:var(--bg1);font-weight:700">${marketGrade.grade || 'B'} GRADE</span>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid var(--border);margin-bottom:8px">
                <span style="font-size:11px;color:var(--text3)">Entry Decision:</span>
                <span style="font-size:12px;font-weight:600;color:var(--cyan)">${entryData.decision || 'MARKET'}</span>
            </div>
            <div style="display:grid;grid-template-columns:${pb2 ? 'repeat(3,1fr)' : pb1 ? 'repeat(2,1fr)' : '1fr'};gap:8px">
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--cyan)">
                    <div style="font-size:10px;color:var(--text3)">MARKET (${entryData.market?.size || '25%'})</div>
                    <div style="font-size:13px;font-weight:700;color:var(--cyan)">$${fmtPrice(sigLevelsLocal.entry || sig.price)}</div>
                    <div style="font-size:10px;color:${gradeColor}">Grade: ${marketGrade.grade || 'B'}</div>
                </div>
                ${pb1 ? `
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--purple)">
                    <div style="font-size:10px;color:var(--text3)">PULLBACK 1 (${pb1.size || '50%'})</div>
                    <div style="font-size:13px;font-weight:700;color:var(--purple)">$${fmtPrice(pb1.price)}</div>
                    <div style="font-size:9px;color:var(--purple)">${pb1.reason || 'OB'} • ${sigDirection === 'LONG' ? '-' : '+'}${pb1.distPct || 0}%</div>
                    <div style="font-size:10px;color:${gradeColors[pb1.grade?.grade] || 'var(--text3)'}">Grade: ${pb1.grade?.grade || 'B+'}</div>
                </div>
                ` : ''}
                ${pb2 ? `
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--purple)">
                    <div style="font-size:10px;color:var(--text3)">PULLBACK 2 (${pb2.size || '25%'})</div>
                    <div style="font-size:13px;font-weight:700;color:var(--purple)">$${fmtPrice(pb2.price)}</div>
                    <div style="font-size:9px;color:var(--purple)">${pb2.reason || 'FVG'} • ${sigDirection === 'LONG' ? '-' : '+'}${pb2.distPct || 0}%</div>
                    <div style="font-size:10px;color:${gradeColors[pb2.grade?.grade] || 'var(--text3)'}">Grade: ${pb2.grade?.grade || 'A'}</div>
                </div>
                ` : ''}
            </div>
            ${entryData.avgEntry ? `
            <div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border);display:flex;justify-content:space-between">
                <span style="font-size:10px;color:var(--text3)">Avg Entry (if all fill):</span>
                <span style="font-size:11px;font-weight:600;color:var(--text)">$${fmtPrice(entryData.avgEntry)}</span>
            </div>
            ` : ''}
        </div>
    `;
    
    // Smart SL HTML
    const smartSLHtml = `
        <div style="background:var(--short-dim);border:1px solid var(--short);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                <span style="font-size:11px;font-weight:600;color:var(--short)">🛑 SMART STOP LOSS</span>
                <span style="font-size:12px;font-weight:700;color:var(--short)">$${fmtPrice(sigLevelsLocal.sl || 0)} (${slData.riskPct || sigLevelsLocal.riskPct || '?'}%)</span>
            </div>
            <div style="font-size:10px;color:var(--text2)">${slData.reason || 'Structure-based'}</div>
            ${slData.trapAvoided ? `<div style="font-size:10px;color:var(--long);margin-top:4px">✅ Liquidity trap avoided</div>` : ''}
        </div>
    `;
    
    // Smart TPs HTML - Direction-aware colors
    const tpColor = sigDirection === 'LONG' ? 'var(--long)' : 'var(--short)';
    const tpBgColor = sigDirection === 'LONG' ? 'var(--long-dim)' : 'var(--short-dim)';
    const tpSign = sigDirection === 'LONG' ? '+' : '-';
    
    // Safe calculations for TP distances
    const safeEntry = sigLevelsLocal.entry || sig.price || 1;
    const safeTp1 = sigLevelsLocal.tp1 || safeEntry;
    const safeTp2 = sigLevelsLocal.tp2 || safeEntry;
    const safeTp3 = sigLevelsLocal.tp3 || safeEntry;
    
    const smartTPsHtml = `
        <div style="background:${tpBgColor};border:1px solid ${tpColor};border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="font-size:11px;font-weight:600;color:${tpColor};margin-bottom:8px">🎯 SMART TAKE PROFITS</div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px">
                <div style="background:var(--bg3);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">TP1</div>
                    <div style="font-size:12px;font-weight:700;color:${tpColor}">$${fmtPrice(safeTp1)}</div>
                    <div style="font-size:9px;color:${tpColor}">${tpSign}${tp1Data.distPct || ((Math.abs(safeTp1 - safeEntry) / safeEntry) * 100).toFixed(2)}%</div>
                    <div style="font-size:9px;color:var(--text2)">${tp1Data.probability || 70}% prob</div>
                    <div style="font-size:8px;color:var(--text3)">${tp1Data.reason || 'Liquidity'}</div>
                </div>
                <div style="background:var(--bg3);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">TP2</div>
                    <div style="font-size:12px;font-weight:700;color:${tpColor}">$${fmtPrice(safeTp2)}</div>
                    <div style="font-size:9px;color:${tpColor}">${tpSign}${tp2Data.distPct || ((Math.abs(safeTp2 - safeEntry) / safeEntry) * 100).toFixed(2)}%</div>
                    <div style="font-size:9px;color:var(--text2)">${tp2Data.probability || 55}% prob</div>
                    <div style="font-size:8px;color:var(--text3)">${tp2Data.reason || 'OB Target'}</div>
                </div>
                <div style="background:var(--bg3);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">TP3</div>
                    <div style="font-size:12px;font-weight:700;color:${tpColor}">$${fmtPrice(safeTp3)}</div>
                    <div style="font-size:9px;color:${tpColor}">${tpSign}${tp3Data.distPct || ((Math.abs(safeTp3 - safeEntry) / safeEntry) * 100).toFixed(2)}%</div>
                    <div style="font-size:9px;color:var(--text2)">${tp3Data.probability || 40}% prob</div>
                    <div style="font-size:8px;color:var(--text3)">${tp3Data.reason || 'HTF Level'}</div>
                </div>
            </div>
            <div style="margin-top:8px;display:flex;justify-content:space-between;padding-top:8px;border-top:1px solid var(--border)">
                <span style="font-size:10px;color:var(--text3)">R:R from Avg Entry:</span>
                <span style="font-size:11px;font-weight:700;color:${tpColor}">1:${sigLevelsLocal.rr || '?'}</span>
            </div>
        </div>
    `;
    
    // Leverage & Sizing HTML
    const leverageHtml = `
        <div style="background:var(--bg4);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="font-size:11px;font-weight:600;color:var(--gold);margin-bottom:8px">⚡ LEVERAGE & SIZING</div>
            <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px">
                <div style="text-align:center">
                    <div style="font-size:10px;color:var(--text3)">Safe Leverage</div>
                    <div style="font-size:14px;font-weight:700;color:var(--long)">${marketGrade.leverage?.safe || 5}x</div>
                </div>
                <div style="text-align:center">
                    <div style="font-size:10px;color:var(--text3)">Max Leverage</div>
                    <div style="font-size:14px;font-weight:700;color:var(--amber)">${marketGrade.leverage?.max || 10}x</div>
                </div>
            </div>
            <div style="margin-top:8px;text-align:center">
                <span style="font-size:10px;color:var(--text3)">Confidence: </span>
                <span style="font-size:11px;font-weight:600;color:${gradeColor}">${marketGrade.confidence || 'MEDIUM'}</span>
            </div>
        </div>
    `;
    
    // 🏦 Institutional Data HTML
    const inst = sig.institutional || {};
    const instA = sig.instAnalysis || {};
    const funding = inst.funding || {};
    const oi = inst.openInterest || {};
    const lsRatio = inst.longShortRatio || {};
    const squeeze = inst.squeezeRisk;
    const liqLevels = inst.liquidationLevels || {};
    
    // Institutional bias color
    const instBiasColor = inst.institutionalBias === 'BULLISH' ? 'var(--long)' :
                         inst.institutionalBias === 'BEARISH' ? 'var(--short)' :
                         inst.institutionalBias === 'SLIGHTLY_BULLISH' ? 'var(--cyan)' :
                         inst.institutionalBias === 'SLIGHTLY_BEARISH' ? 'var(--amber)' : 'var(--text2)';
    
    // Recommendation color
    const recColor = instA.recommendation === 'STRONG_CONFIRM' ? 'var(--long)' :
                    instA.recommendation === 'CONFIRM' ? 'var(--cyan)' :
                    instA.recommendation === 'AVOID' ? 'var(--short)' :
                    instA.recommendation === 'CAUTION' ? 'var(--amber)' : 'var(--text2)';
    
    const institutionalHtml = inst.funding ? `
        <div style="background:linear-gradient(135deg, var(--bg4) 0%, rgba(147, 112, 219, 0.1) 100%);border:1px solid var(--purple);border-radius:8px;padding:12px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                <span style="font-size:12px;font-weight:700;color:var(--purple)">🏦 INSTITUTIONAL DATA</span>
                <span style="font-size:11px;padding:3px 8px;border-radius:4px;background:${instBiasColor};color:var(--bg1);font-weight:700">${inst.institutionalBias || 'NEUTRAL'}</span>
            </div>
            
            <!-- Funding Rate -->
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px">
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">FUNDING RATE</div>
                    <div style="font-size:13px;font-weight:700;color:${parseFloat(funding.rate || 0) > 0 ? 'var(--short)' : parseFloat(funding.rate || 0) < 0 ? 'var(--long)' : 'var(--text)'}">${funding.ratePercent || '0.00'}%</div>
                    <div style="font-size:8px;color:var(--text3)">${funding.signal || ''}</div>
                </div>
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">OPEN INTEREST</div>
                    <div style="font-size:13px;font-weight:700;color:${parseFloat(oi.change4h || 0) > 0 ? 'var(--long)' : 'var(--short)'}">${oi.change4h || '0'}%</div>
                    <div style="font-size:8px;color:var(--text3)">${oi.trend || 'STABLE'}</div>
                </div>
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">L/S RATIO</div>
                    <div style="font-size:13px;font-weight:700;color:${parseFloat(lsRatio.buyRatio || 50) > 55 ? 'var(--long)' : parseFloat(lsRatio.sellRatio || 50) > 55 ? 'var(--short)' : 'var(--text)'}">${lsRatio.buyRatio || '50'}%L</div>
                    <div style="font-size:8px;color:var(--text3)">${lsRatio.dominance || 'BALANCED'}</div>
                </div>
            </div>
            
            <!-- Squeeze Alert -->
            ${squeeze ? `
            <div style="background:${squeeze.type === 'LONG_SQUEEZE' ? 'var(--short-dim)' : 'var(--long-dim)'};border:1px solid ${squeeze.type === 'LONG_SQUEEZE' ? 'var(--short)' : 'var(--long)'};border-radius:6px;padding:8px;margin-bottom:10px">
                <div style="display:flex;justify-content:space-between;align-items:center">
                    <span style="font-size:11px;font-weight:700;color:${squeeze.type === 'LONG_SQUEEZE' ? 'var(--short)' : 'var(--long)'}">
                        ${squeeze.type === 'LONG_SQUEEZE' ? '🔻 LONG SQUEEZE RISK' : '🚀 SHORT SQUEEZE RISK'}
                    </span>
                    <span style="font-size:10px;padding:2px 6px;border-radius:3px;background:${squeeze.probability === 'HIGH' ? 'var(--short)' : 'var(--amber)'};color:var(--bg1);font-weight:600">${squeeze.probability}</span>
                </div>
                <div style="font-size:9px;color:var(--text2);margin-top:4px">${squeeze.reason}</div>
                <div style="font-size:9px;color:var(--text3);margin-top:2px">Trigger: $${fmtPrice(squeeze.trigger)}</div>
            </div>
            ` : ''}
            
            <!-- Liquidation Levels -->
            ${liqLevels.magnetLong ? `
            <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:8px">
                <div style="background:var(--short-dim);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--short)">LONG LIQⓁ MAGNET</div>
                    <div style="font-size:11px;font-weight:700;color:var(--short)">$${fmtPrice(liqLevels.magnetLong)}</div>
                    <div style="font-size:8px;color:var(--text3)">20x lev cluster</div>
                </div>
                <div style="background:var(--long-dim);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--long)">SHORT LIQ MAGNET</div>
                    <div style="font-size:11px;font-weight:700;color:var(--long)">$${fmtPrice(liqLevels.magnetShort)}</div>
                    <div style="font-size:8px;color:var(--text3)">20x lev cluster</div>
                </div>
            </div>
            ` : ''}
            
            <!-- Institutional Recommendation -->
            <div style="display:flex;justify-content:space-between;align-items:center;padding-top:8px;border-top:1px solid var(--border)">
                <span style="font-size:10px;color:var(--text3)">Inst. Recommendation:</span>
                <span style="font-size:11px;font-weight:700;color:${recColor}">${instA.recommendation || 'NEUTRAL'} (${instA.score > 0 ? '+' : ''}${instA.score || 0})</span>
            </div>
        </div>
    ` : `
        <div style="background:var(--bg4);border:1px dashed var(--border);border-radius:8px;padding:12px;margin-bottom:12px;text-align:center">
            <span style="font-size:11px;color:var(--text3)">🏦 Institutional data loading...</span>
        </div>
    `;
    
    // Trade Levels (legacy format for compatibility)
    const tradeHtml = `
        <div class="trade-section">
            <div class="trade-title">📊 Trade Levels</div>
            ${smartEntryHtml}
            ${smartSLHtml}
            ${smartTPsHtml}
            ${leverageHtml}
            ${institutionalHtml}
            <div class="trade-meta">
                <span class="rr-tag">Market R:R 1:${sigLevelsLocal.rr || '?'} | Limit R:R 1:${sigLevelsLocal.limitRR || '?'}</span>
                <button class="tv-btn" onclick="openTradingView('${sig.symbol}', '${sig.tfRaw}')">📊 TradingView</button>
                <button class="save-btn" onclick="saveTrade()">💾 Save Trade</button>
            </div>
        </div>
    `;
    
    // Agreement Box
    const zoneAgree = sig.engineDirections.zone === sig.direction;
    const smcAgree = sig.engineDirections.smc === sig.direction;
    const momAgree = sig.engineDirections.momentum === sig.direction;
    // Use direction-appropriate color: GREEN for LONG, RED for SHORT
    const dirColor = sig.direction === 'LONG' ? 'var(--long)' : 'var(--short)';
    const agreementColor = sig.agreed === 3 ? dirColor : 'var(--amber)';
    
    const agreementHtml = `
        <div style="background:var(--bg4);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                <span style="font-size:11px;color:var(--text2)">🎯 Engine Agreement</span>
                <span style="font-size:14px;font-weight:700;color:${agreementColor}">${sig.agreed}/3 Agree</span>
            </div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px">
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${zoneAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">ZONE</div>
                    <div style="font-size:12px;font-weight:700;color:${zoneAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.zone || 'N/A'}</div>
                    <div style="font-size:11px;color:${zoneAgree ? dirColor : 'var(--text3)'}">${zoneAgree ? '✓ Agrees' : '✗ Differs'}</div>
                </div>
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${smcAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">SMC</div>
                    <div style="font-size:12px;font-weight:700;color:${smcAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.smc || 'N/A'}</div>
                    <div style="font-size:11px;color:${smcAgree ? dirColor : 'var(--text3)'}">${smcAgree ? '✓ Agrees' : '✗ Differs'}</div>
                </div>
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${momAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">MOMENTUM</div>
                    <div style="font-size:12px;font-weight:700;color:${momAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.momentum || 'N/A'}</div>
                    <div style="font-size:11px;color:${momAgree ? dirColor : 'var(--text3)'}">${momAgree ? '✓ Agrees' : '✗ Differs'}</div>
                </div>
            </div>
        </div>
    `;
    
    // Environment Panel HTML
    const envPanelHtml = sig.environment ? generateEnvPanelHtml(sig) : '';
    
    // Awareness Panel HTML (Session + News)
    const awarenessHtml = generateAwarenessHtml();
    
    // Safe property access for header (sigDirection already defined above)
    const sigGrade = sig.grade || 'VALID';
    const sigTf = sig.tf || '1H';
    const sigLevels = sig.levels || {};
    
    el.innerHTML = `
        <div class="detail-box">
            <div class="detail-header">
                <div class="detail-title">
                    <span class="detail-pair">${sig.symbol.replace('USDT', '')}</span>
                    <span class="dir-tag ${sigDirection.toLowerCase()}" style="font-size:12px;padding:4px 10px">${sigDirection}</span>
                    <span class="grade ${sigGrade.toLowerCase()}" style="font-size:11px;padding:4px 10px">${sigGrade}</span>
                    <span class="tf-tag" style="font-size:12px">${sigTf}</span>
                </div>
                <div class="detail-price">
                    <div class="detail-price-label">Current Price</div>
                    <div class="detail-price-value">$${fmtPrice(sig.price)}</div>
                </div>
            </div>
            ${savedComparisonHtml}
            ${awarenessHtml}
            ${envPanelHtml}
            ${agreementHtml}
            ${htfHtml}
            ${gpoteHtml}
            ${aiHtml}
            ${warningsHtml}
            ${analysisHtml}
            ${tradeHtml}
        </div>
    `;
    console.log('🟢 Main panel rendered successfully!');
    } catch (panelError) {
        console.error('🛡️ Panel update error:', panelError);
        console.error('Stack:', panelError.stack);
        console.error('Signal data:', STATE.current);
        const el = document.getElementById('mainPanel');
        if (el) {
            el.innerHTML = '<div class="empty"><div style="color:var(--amber)">⚠️ Display error - check console (F12)</div><div style="color:var(--text3);font-size:11px;margin-top:8px">' + panelError.message + '</div></div>';
        }
        toast('Panel display error', 'error');
    }
}

function getFactorClass(factor) {
    const bullish = ['↑', 'Bull', 'Support', 'Discount', 'OS', 'MACD+', 'OBV+', 'Golden', '+'];
    const bearish = ['↓', 'Bear', 'Resist', 'Premium', 'OB', 'MACD-', 'OBV-', 'Death', '-'];
    
    for (const b of bullish) {
        if (factor.includes(b)) return 'bull';
    }
    for (const s of bearish) {
        if (factor.includes(s)) return 'bear';
    }
    return '';
}


// ═══════════════════════════════════════════════════════════════════════════════
// 💾 ENHANCED SAVED TRADES SYSTEM v2.0
// ═══════════════════════════════════════════════════════════════════════════════

// Status constants
const TRADE_STATUS = {
    STRONG_PROFIT: { label: 'STRONG PROFIT', emoji: '🚀', class: 'strong-profit' },
    IN_PROFIT: { label: 'IN PROFIT', emoji: '✅', class: 'in-profit' },
    TP1_HIT: { label: 'TP1 HIT!', emoji: '🎯', class: 'tp-hit' },
    TP2_HIT: { label: 'TP2 HIT!', emoji: '🎯🎯', class: 'tp-hit' },
    TP3_HIT: { label: 'TP3 HIT!', emoji: '🏆', class: 'tp-hit' },
    NEAR_ENTRY: { label: 'NEAR ENTRY', emoji: '⏳', class: 'near-entry' },
    SMALL_LOSS: { label: 'SMALL LOSS', emoji: '⚠️', class: 'small-loss' },
    AT_RISK: { label: 'AT RISK', emoji: '🔴', class: 'at-risk' },
    STOPPED_OUT: { label: 'STOPPED OUT', emoji: '💀', class: 'stopped-out' },
    LOADING: { label: 'LOADING', emoji: '⏳', class: 'loading' }
};

// ═══════════════════════════════════════════════════════════════════════════════
// TRADINGVIEW INTEGRATION - Open chart in TradingView (Basic Plan Compatible)
// ═══════════════════════════════════════════════════════════════════════════════

function openTradingView(symbol, tf) {
    // Convert scanner timeframe to TradingView format
    const tvTimeframes = {
        '1': '1',
        '3': '3',
        '5': '5',
        '15': '15',
        '30': '30',
        '60': '60',
        '120': '120',
        '240': '240',
        'D': 'D',
        '1D': 'D',
        'W': 'W',
        '1W': 'W'
    };
    
    const tvTF = tvTimeframes[tf] || '15';
    
    // Clean symbol (remove USDT suffix variations)
    const cleanSymbol = symbol.replace('USDT', '').replace('PERP', '');
    
    // Build TradingView URL - BYBIT perpetual futures
    // Format: BYBIT:BTCUSDT.P for perpetuals
    const tvSymbol = `BYBIT:${cleanSymbol}USDT.P`;
    
    // TradingView public chart URL (works on Basic/Free plan)
    const url = `https://www.tradingview.com/chart/?symbol=${tvSymbol}&interval=${tvTF}`;
    
    // Open in new tab
    window.open(url, '_blank');
    
    toast(`Opening ${cleanSymbol} ${tvTF} on TradingView...`, 'success');
}

// Save current signal to saved trades - ENHANCED
function saveTrade() {
    try {
    const sig = STATE.current;
    if (!sig) {
        toast('No signal selected!', 'error');
        return;
    }
    
    // Check if already saved
    const exists = STATE.savedTrades.find(t => 
        t.symbol === sig.symbol && t.tf === sig.tf && t.direction === sig.direction
    );
    
    if (exists) {
        toast('Trade already saved!', 'warning');
        return;
    }
    
    // Enhanced saved trade structure
    const savedTrade = {
        id: Date.now(),
        symbol: sig.symbol,
        tf: sig.tf,
        tfRaw: sig.tfRaw,
        direction: sig.direction,
        
        // ORIGINAL DATA (never changes) - with null safety
        original: {
            price: sig.price,
            entry: sig.levels?.entry || sig.price,
            sl: sig.levels?.sl || 0,
            tp1: sig.levels?.tp1 || 0,
            tp2: sig.levels?.tp2 || 0,
            tp3: sig.levels?.tp3 || 0,
            rr: sig.levels?.rr || '?',
            riskPct: sig.levels?.riskPct || '?',
            grade: sig.grade || 'VALID',
            score: sig.score || 0,
            agreed: sig.agreed || 0,
            factors: sig.factors ? sig.factors.slice(0, 5) : [],
            warnings: sig.warnings ? sig.warnings.slice(0, 3) : [],
            smart: sig.levels?.smart || null,
            institutional: sig.institutional,
            instAnalysis: sig.instAnalysis,
            zone: sig.zone,
            smc: sig.smc,
            momentum: sig.momentum,
            candlePatterns: sig.candlePatterns
        },
        
        // LIVE DATA (updates every scan)
        live: {
            currentPrice: sig.price,
            pnlAbsolute: 0,
            pnlPercent: 0,
            distanceToSL: 0,
            distanceToTP1: 0,
            distanceToTP2: 0,
            distanceToTP3: 0,
            progressPercent: 0,
            status: 'NEAR_ENTRY',
            structureValid: true,
            newPatterns: [],
            lastUpdated: Date.now()
        },
        
        // AI INTERPRETATION
        ai: {
            commentary: null,
            recommendation: null,
            moveSlToBE: false,
            warnings: [],
            confidence: 0,
            lastUpdated: null
        },
        
        savedAt: Date.now(),
        savedAtStr: new Date().toLocaleString()
    };
    
    // Calculate initial live data
    updateSavedTradeLiveData(savedTrade, sig.price);
    
    STATE.savedTrades.unshift(savedTrade);
    
    if (STATE.savedTrades.length > 50) {
        STATE.savedTrades = STATE.savedTrades.slice(0, 50);
    }
    
    saveSavedTrades();
    updateSavedTradesListEnhanced();
    
    toast(`💾 Saved ${sig.symbol.replace('USDT', '')} ${sig.direction}!`, 'success');
    } catch (e) {
        console.error('saveTrade error:', e);
        toast('Error saving trade: ' + e.message, 'error');
    }
}

// Update live data for a saved trade
function updateSavedTradeLiveData(trade, currentPrice) {
    const orig = trade.original || trade;
    const isLong = trade.direction === 'LONG';
    
    // Protect against division by zero
    const entryPrice = orig.entry || 1;
    const currentP = currentPrice || entryPrice;
    
    const pnlAbsolute = isLong ? currentP - entryPrice : entryPrice - currentP;
    const pnlPercent = entryPrice > 0 ? (pnlAbsolute / entryPrice) * 100 : 0;
    
    const distanceToSL = currentP > 0 ? Math.abs(currentP - (orig.sl || 0)) / currentP * 100 : 0;
    const distanceToTP1 = currentP > 0 ? Math.abs((orig.tp1 || 0) - currentP) / currentP * 100 : 0;
    const distanceToTP2 = currentP > 0 ? Math.abs((orig.tp2 || 0) - currentP) / currentP * 100 : 0;
    const distanceToTP3 = currentP > 0 ? Math.abs((orig.tp3 || 0) - currentP) / currentP * 100 : 0;
    
    const totalDistance = Math.abs((orig.tp1 || 0) - entryPrice);
    const coveredDistance = isLong 
        ? Math.max(0, currentP - entryPrice)
        : Math.max(0, entryPrice - currentP);
    const progressPercent = totalDistance > 0 ? Math.min(100, (coveredDistance / totalDistance) * 100) : 0;
    
    // Determine status
    let status = 'NEAR_ENTRY';
    
    if (isLong && currentPrice <= orig.sl) status = 'STOPPED_OUT';
    else if (!isLong && currentPrice >= orig.sl) status = 'STOPPED_OUT';
    else if (isLong && currentPrice >= orig.tp3) status = 'TP3_HIT';
    else if (!isLong && currentPrice <= orig.tp3) status = 'TP3_HIT';
    else if (isLong && currentPrice >= orig.tp2) status = 'TP2_HIT';
    else if (!isLong && currentPrice <= orig.tp2) status = 'TP2_HIT';
    else if (isLong && currentPrice >= orig.tp1) status = 'TP1_HIT';
    else if (!isLong && currentPrice <= orig.tp1) status = 'TP1_HIT';
    else if (pnlPercent >= 2) status = 'STRONG_PROFIT';
    else if (pnlPercent > 0.3) status = 'IN_PROFIT';
    else if (pnlPercent >= -0.5) status = 'NEAR_ENTRY';
    else if (pnlPercent >= -1.5) status = 'SMALL_LOSS';
    else status = 'AT_RISK';
    
    // 🧠 PATTERN MEMORY: Record result when trade completes (only once)
    const prevStatus = trade.live?.status;
    const finalStatuses = ['TP1_HIT', 'TP2_HIT', 'TP3_HIT', 'STOPPED_OUT'];
    const isNewFinalStatus = finalStatuses.includes(status) && !finalStatuses.includes(prevStatus);
    
    if (isNewFinalStatus && !trade.resultRecorded) {
        const isWin = status.includes('TP');
        const result = isWin ? 'WIN' : 'LOSS';
        
        // Record to Pattern Memory Brain
        try {
            recordPatternResult({
                symbol: trade.symbol,
                tf: trade.tf,
                direction: trade.direction,
                grade: trade.grade,
                score: trade.score || 0,
                scores: trade.original?.scores || {},
                intent: trade.intent || 'UNKNOWN',
                pnl: pnlPercent
            }, result);
            
            // Record to Drawdown Tracker
            recordTradeResult(isWin, pnlPercent);
            
            console.log(`🧠 Brain learned: ${trade.symbol} ${trade.tf} = ${result} (${pnlPercent.toFixed(2)}%)`);
        } catch (e) {
            console.warn('Pattern recording error:', e);
        }
        
        // Mark as recorded so we don't record again
        trade.resultRecorded = true;
    }
    
    trade.live = {
        currentPrice,
        pnlAbsolute,
        pnlPercent,
        distanceToSL,
        distanceToTP1,
        distanceToTP2,
        distanceToTP3,
        progressPercent,
        status,
        structureValid: trade.live?.structureValid ?? true,
        newPatterns: trade.live?.newPatterns ?? [],
        lastUpdated: Date.now()
    };
    
    return trade;
}

// Fetch current price for saved trade - BINANCE API
async function fetchCurrentPriceForSaved(symbol) {
    try {
        const url = `${CONFIG.BYBIT_V5}/market/tickers?category=linear&symbol=${symbol}`;
        const data = await fetchJSON(url);
        if (data?.price) {
            return parseFloat(data.price);
        }
    } catch (e) {
        console.error(`Failed to fetch price for ${symbol}:`, e);
    }
    return null;
}

// Update all saved trades with live data
async function updateAllSavedTradesLive() {
    if (STATE.savedTrades.length === 0) return;
    
    console.log('📊 Updating saved trades live data...');
    
    for (const trade of STATE.savedTrades) {
        const currentPrice = await fetchCurrentPriceForSaved(trade.symbol);
        if (currentPrice) {
            updateSavedTradeLiveData(trade, currentPrice);
        }
    }
    
    saveSavedTrades();
    updateSavedTradesListEnhanced();
    console.log('✅ Saved trades updated');
}

// Refresh single saved trade
async function refreshSavedTrade(tradeId) {
    const trade = STATE.savedTrades.find(t => t.id === tradeId);
    if (!trade) return;
    
    toast(`🔄 Refreshing ${trade.symbol.replace('USDT', '')}...`, 'info');
    
    const currentPrice = await fetchCurrentPriceForSaved(trade.symbol);
    if (currentPrice) {
        updateSavedTradeLiveData(trade, currentPrice);
        saveSavedTrades();
        updateSavedTradesListEnhanced();
        toast(`✅ ${trade.symbol.replace('USDT', '')} updated!`, 'success');
    } else {
        toast(`❌ Failed to update`, 'error');
    }
}

// Get AI interpretation for saved trade
async function getAITradeInterpretation(tradeId) {
    const trade = STATE.savedTrades.find(t => t.id === tradeId);
    if (!trade) return;
    
    if (!STATE.aiKey) {
        toast('AI not configured. Add API key in settings.', 'warning');
        return;
    }
    
    // SAFETY: Prevent concurrent AI calls
    if (STATE.aiCallInProgress) {
        toast('AI analysis in progress...', 'warning');
        return;
    }
    
    STATE.aiCallInProgress = true;
    toast(`🤖 Getting AI analysis...`, 'info');
    
    try {
    const orig = trade.original || trade;
    const live = trade.live || {};
    const statusInfo = TRADE_STATUS[live.status] || TRADE_STATUS.LOADING;
    const hoursSinceSaved = ((Date.now() - trade.savedAt) / (1000 * 60 * 60)).toFixed(1);
    
    const prompt = `You are monitoring an ACTIVE crypto futures trade. Provide a brief progress update.

TRADE: ${trade.symbol} ${trade.direction} (${trade.tf})
Saved: ${hoursSinceSaved} hours ago

ORIGINAL:
- Entry: $${fmtPrice(orig.entry)} | SL: $${fmtPrice(orig.sl)} (${orig.riskPct}%)
- TP1: $${fmtPrice(orig.tp1)} | TP2: $${fmtPrice(orig.tp2)} | TP3: $${fmtPrice(orig.tp3)}
- Grade: ${orig.grade} (${orig.score}/100) | R:R: 1:${orig.rr}

CURRENT:
- Price: $${fmtPrice(live.currentPrice)} | P&L: ${live.pnlPercent >= 0 ? '+' : ''}${(live.pnlPercent || 0).toFixed(2)}%
- Status: ${statusInfo.label} | Progress to TP1: ${(live.progressPercent || 0).toFixed(0)}%
- Distance to SL: ${(live.distanceToSL || 0).toFixed(2)}% | to TP1: ${(live.distanceToTP1 || 0).toFixed(2)}%

TASK: Provide 2-3 sentence update on progress, concerns, and if SL should move to breakeven.

Respond ONLY with JSON:
{
    "commentary": "Your analysis here",
    "recommendation": "HOLD" or "TAKE_PROFIT" or "MOVE_SL_TO_BE" or "EXIT",
    "moveSlToBE": true/false,
    "warnings": [],
    "confidence": 0-100
}`;

        const response = await callMultiAI(prompt);
        
        if (response) {
            trade.ai = {
                commentary: response.commentary || response.executiveSummary || 'Analysis complete.',
                recommendation: response.recommendation || 'HOLD',
                moveSlToBE: response.moveSlToBE || false,
                warnings: response.warnings || [],
                confidence: response.confidence || 50,
                lastUpdated: Date.now()
            };
            
            saveSavedTrades();
            updateSavedTradesListEnhanced();
            toast(`🤖 AI analysis complete!`, 'success');
        } else {
            toast(`❌ AI analysis failed`, 'error');
        }
    } catch (e) {
        console.error('AI interpretation error:', e);
        toast(`❌ AI analysis failed`, 'error');
    } finally {
        // SAFETY: Always release AI lock
        STATE.aiCallInProgress = false;
    }
}

// Delete saved trade
function deleteSavedTrade(id) {
    STATE.savedTrades = STATE.savedTrades.filter(t => t.id !== id);
    saveSavedTrades();
    updateSavedTradesListEnhanced();
    toast('Trade deleted', 'success');
}

// View saved trade details
async function viewSavedTrade(id) {
    const trade = STATE.savedTrades.find(t => t.id === id);
    if (!trade) {
        toast('Trade not found', 'error');
        return;
    }
    
    // Get original data (handles both old and new format)
    const orig = trade.original || trade;
    
    // First check if signal exists in current scan results
    const matchingSignal = STATE.signals.find(s => 
        s.symbol === trade.symbol && s.tfRaw === trade.tfRaw
    );
    
    if (matchingSignal) {
        // Signal exists in current scan - use it directly
        // Add saved trade comparison data
        matchingSignal.savedTrade = {
            savedAt: trade.savedAt,
            savedEntry: orig.entry,
            savedSL: orig.sl,
            savedTP1: orig.tp1,
            savedTP2: orig.tp2,
            savedTP3: orig.tp3,
            savedDirection: trade.direction,
            savedGrade: orig.grade,
            savedScore: orig.score
        };
        selectSignal(STATE.signals.indexOf(matchingSignal));
        toast(`✅ ${trade.symbol} - Live data loaded`, 'success');
    } else {
        // Signal NOT in current scan - RESCAN to get full analysis
        toast(`🔄 Rescanning ${trade.symbol} ${trade.tf}...`, '');
        
        try {
            // Run full analysis on this specific coin/timeframe
            const freshSignal = await analyzeSignal(trade.symbol, trade.tfRaw);
            
            if (freshSignal) {
                // Add saved trade data for comparison
                freshSignal.savedTrade = {
                    savedAt: trade.savedAt,
                    savedEntry: orig.entry,
                    savedSL: orig.sl,
                    savedTP1: orig.tp1,
                    savedTP2: orig.tp2,
                    savedTP3: orig.tp3,
                    savedDirection: trade.direction,
                    savedGrade: orig.grade,
                    savedScore: orig.score
                };
                
                // Add to signals array temporarily so selectSignal works
                STATE.signals.unshift(freshSignal);
                
                // Limit signals array size (SAFETY)
                if (STATE.signals.length > 500) {
                    STATE.signals = STATE.signals.slice(0, 500);
                }
                
                // Select and display
                STATE.selected = 0;
                STATE.current = freshSignal;
                STATE.aiResult = null;  // Clear old AI result
                updateMainPanel();
                updateSignalList();
                
                // Auto-scroll to main panel on mobile
                const mainPanel = document.getElementById('mainPanel');
                if (mainPanel && window.innerWidth < 900) {
                    setTimeout(() => {
                        mainPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                }
                
                toast(`✅ ${trade.symbol} - Fresh analysis loaded!`, 'success');
            } else {
                // Analysis failed - show saved data as fallback
                displaySavedTradeDetailEnhanced(trade);
                toast(`⚠️ Could not fetch live data - showing saved`, 'warning');
                
                // Auto-scroll to main panel on mobile
                const mainPanel = document.getElementById('mainPanel');
                if (mainPanel && window.innerWidth < 900) {
                    setTimeout(() => {
                        mainPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                }
            }
        } catch (e) {
            console.error('Rescan error:', e);
            displaySavedTradeDetailEnhanced(trade);
            toast(`❌ Rescan failed - showing saved data`, 'error');
        }
    }
}


// ═══════════════════════════════════════════════════════════════════════════════
// TRADE TRACKING
// ═══════════════════════════════════════════════════════════════════════════════

function trackTrade() {
    if (!STATE.current) {
        toast('No signal selected!', 'error');
        return;
    }
    
    const sig = STATE.current;
    
    // Check if already tracking
    const exists = STATE.trades.find(t => t.symbol === sig.symbol && t.tf === sig.tf);
    if (exists) {
        toast('Already tracking this trade!', 'warning');
        return;
    }
    
    const trade = {
        id: Date.now(),
        symbol: sig.symbol,
        tf: sig.tf,
        direction: sig.direction,
        grade: sig.grade || 'VALID',
        entry: sig.levels?.entry || sig.price,
        sl: sig.levels?.sl || 0,
        tp1: sig.levels?.tp1 || 0,
        tp2: sig.levels?.tp2 || 0,
        tp3: sig.levels?.tp3 || 0,
        rr: sig.levels?.rr || '?',
        currentPrice: sig.price,
        tp1Hit: false,
        tp2Hit: false,
        tp3Hit: false,
        slHit: false,
        timestamp: new Date().toISOString()
    };
    
    STATE.trades.push(trade);
    saveTrades();
    updateTradeList();
    
    toast(`📌 Tracking ${sig.symbol.replace('USDT', '')} ${sig.direction}!`, 'success');
}

function closeTrade(id) {
    const trade = STATE.trades.find(t => t.id === id);
    if (trade) {
        // Save to history before removing
        trade.closedAt = Date.now();
        trade.status = 'closed';
        
        // Calculate P&L if we have prices
        if (trade.currentPrice && trade.entry) {
            const pnlPercent = trade.direction === 'LONG' 
                ? ((trade.currentPrice - trade.entry) / trade.entry) * 100
                : ((trade.entry - trade.currentPrice) / trade.entry) * 100;
            trade.pnlPercent = pnlPercent.toFixed(2);
        }
        
        // Add to history
        STATE.tradeHistory = STATE.tradeHistory || [];
        STATE.tradeHistory.unshift(trade);
        
        // Keep only last 100 trades
        if (STATE.tradeHistory.length > 100) {
            STATE.tradeHistory = STATE.tradeHistory.slice(0, 100);
        }
        
        saveTradeHistory();
    }
    
    STATE.trades = STATE.trades.filter(t => t.id !== id);
    saveTrades();
    updateTradeList();
    toast('Trade closed & saved to history', 'success');
}

// Save trade history
function saveTradeHistory() {
    safeStorageSet('bybit_scanner_trade_history', STATE.tradeHistory || []);
}

// Load trade history
function loadTradeHistory() {
    const saved = safeStorageGet('bybit_scanner_trade_history', []);
    STATE.tradeHistory = Array.isArray(saved) ? saved : [];
}

// Get trade stats from history
function getTradeStats() {
    const history = STATE.tradeHistory || [];
    const total = history.length;
    const profitable = history.filter(t => parseFloat(t.pnlPercent || 0) > 0).length;
    const losing = history.filter(t => parseFloat(t.pnlPercent || 0) < 0).length;
    const winRate = total > 0 ? ((profitable / total) * 100).toFixed(1) : 0;
    
    let totalPnL = 0;
    history.forEach(t => {
        if (t.pnlPercent) totalPnL += parseFloat(t.pnlPercent);
    });
    
    return { profitable, losing, total, winRate, totalPnL: totalPnL.toFixed(2) };
}

function saveTrades() {
    safeStorageSet('bybit_scanner_trades', STATE.trades);
}

function loadTrades() {
    const saved = safeStorageGet('bybit_scanner_trades', []);
    STATE.trades = Array.isArray(saved) ? saved : [];
    // Also load history
    loadTradeHistory();
    // Also load saved trades
    loadSavedTrades();
}

// Display saved trade detail - Enhanced with 3 rows
function displaySavedTradeDetailEnhanced(trade) {
    const el = document.getElementById('mainPanel');
    const orig = trade.original || trade;
    const live = trade.live || {};
    const ai = trade.ai || {};
    
    const statusInfo = TRADE_STATUS[live.status] || TRADE_STATUS.LOADING;
    const pnlClass = (live.pnlPercent || 0) >= 0 ? 'profit' : 'loss';
    const statusBg = statusInfo.class.includes('profit') || statusInfo.class.includes('tp') ? 'var(--long-dim)' : 
                     statusInfo.class.includes('risk') || statusInfo.class.includes('stop') ? 'var(--short-dim)' : 'var(--amber-dim)';
    const statusBorder = statusInfo.class.includes('profit') || statusInfo.class.includes('tp') ? 'var(--long)' : 
                        statusInfo.class.includes('risk') || statusInfo.class.includes('stop') ? 'var(--short)' : 'var(--amber)';
    
    el.innerHTML = `
        <div class="detail-box">
            <div class="detail-header">
                <div class="detail-title">
                    <span class="detail-pair">${trade.symbol.replace('USDT', '')}</span>
                    <span class="dir-tag ${trade.direction.toLowerCase()}">${trade.direction}</span>
                    <span class="grade-badge ${(orig.grade || 'valid').toLowerCase()}">${orig.grade || 'VALID'}</span>
                    <span style="font-size:10px;color:var(--amber);margin-left:8px">💾 SAVED</span>
                </div>
                <div class="detail-sub">
                    <span>📊 ${trade.tf}</span>
                    <span>💯 Score: ${(orig.score || 0).toFixed(0)}</span>
                </div>
            </div>
            
            <!-- STATUS BANNER -->
            <div style="background:${statusBg};border:1px solid ${statusBorder};border-radius:6px;padding:12px;margin-bottom:12px;text-align:center">
                <div style="font-size:24px;margin-bottom:4px">${statusInfo.emoji}</div>
                <div style="font-size:14px;font-weight:700;color:${statusBorder}">${statusInfo.label}</div>
                <div style="font-size:20px;font-weight:700;margin-top:4px;color:${pnlClass === 'profit' ? 'var(--long)' : 'var(--short)'}">
                    ${(live.pnlPercent || 0) >= 0 ? '+' : ''}${(live.pnlPercent || 0).toFixed(2)}%
                </div>
                <div style="font-size:11px;color:var(--text3);margin-top:4px">
                    Current: $${fmtPrice(live.currentPrice || orig.entry)} | Saved: ${trade.savedAtStr}
                </div>
            </div>
            
            <!-- PROGRESS BAR -->
            <div style="background:var(--bg3);border-radius:6px;padding:12px;margin-bottom:12px">
                <div style="font-size:11px;color:var(--text3);margin-bottom:8px">📈 Progress to TP1</div>
                <div style="position:relative;height:30px;background:var(--bg4);border-radius:15px;overflow:visible;margin-bottom:8px">
                    <div style="position:absolute;left:0;top:0;height:100%;width:${Math.max(0, Math.min(100, live.progressPercent || 0))}%;
                                background:linear-gradient(90deg, ${pnlClass === 'profit' ? 'var(--long-dim), var(--long)' : 'var(--short), var(--short-dim)'});
                                border-radius:15px;transition:width 0.5s"></div>
                    <div style="position:absolute;left:0%;top:50%;transform:translate(-50%,-50%);background:var(--cyan);color:#000;font-size:9px;font-weight:700;padding:2px 6px;border-radius:3px;z-index:2">Entry</div>
                    <div style="position:absolute;left:100%;top:50%;transform:translate(-50%,-50%);background:var(--long);color:#000;font-size:9px;font-weight:700;padding:2px 6px;border-radius:3px;z-index:2">TP1</div>
                </div>
                <div style="display:flex;justify-content:space-between;font-size:10px;color:var(--text3)">
                    <span>🛑 SL: ${(live.distanceToSL || 0).toFixed(1)}% away</span>
                    <span>${(live.progressPercent || 0).toFixed(0)}% complete</span>
                    <span>🎯 TP1: ${(live.distanceToTP1 || 0).toFixed(1)}% away</span>
                </div>
            </div>
            
            <!-- ORIGINAL LEVELS -->
            <div style="background:var(--bg3);border-radius:6px;padding:12px;margin-bottom:12px">
                <div style="font-size:11px;color:var(--text3);margin-bottom:8px">📸 Original Trade Levels</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px">
                    <div style="background:var(--bg4);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--cyan)">
                        <div style="font-size:10px;color:var(--text3)">ENTRY</div>
                        <div style="font-size:13px;font-weight:700;color:var(--cyan)">$${fmtPrice(orig.entry)}</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--short)">
                        <div style="font-size:10px;color:var(--text3)">STOP LOSS</div>
                        <div style="font-size:13px;font-weight:700;color:var(--short)">$${fmtPrice(orig.sl)}</div>
                        <div style="font-size:9px;color:var(--short)">${orig.riskPct || '?'}%</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--long)">
                        <div style="font-size:10px;color:var(--text3)">R:R</div>
                        <div style="font-size:13px;font-weight:700;color:var(--long)">1:${orig.rr || '?'}</div>
                    </div>
                </div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
                    <div style="background:var(--bg4);border-radius:4px;padding:6px;text-align:center">
                        <div style="font-size:9px;color:var(--text3)">TP1</div>
                        <div style="font-size:11px;font-weight:600;color:var(--long)">$${fmtPrice(orig.tp1)}</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:4px;padding:6px;text-align:center">
                        <div style="font-size:9px;color:var(--text3)">TP2</div>
                        <div style="font-size:11px;font-weight:600;color:var(--long)">$${fmtPrice(orig.tp2)}</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:4px;padding:6px;text-align:center">
                        <div style="font-size:9px;color:var(--text3)">TP3</div>
                        <div style="font-size:11px;font-weight:600;color:var(--long)">$${fmtPrice(orig.tp3)}</div>
                    </div>
                </div>
            </div>
            
            <!-- AI INTERPRETATION -->
            <div style="background:linear-gradient(90deg, rgba(168,85,247,0.1) 0%, var(--bg3) 100%);border-radius:6px;padding:12px;margin-bottom:12px;border-left:3px solid var(--purple)">
                <div style="font-size:11px;color:var(--purple);margin-bottom:8px;font-weight:600">🤖 AI Interpretation</div>
                ${ai.commentary ? `
                    <div style="font-size:12px;color:var(--text);line-height:1.5;margin-bottom:8px">${ai.commentary}</div>
                    ${ai.recommendation ? `<div style="display:inline-block;padding:4px 10px;background:var(--purple-dim);border:1px solid var(--purple);border-radius:4px;font-size:10px;font-weight:600;color:var(--purple)">📋 ${ai.recommendation}</div>` : ''}
                    ${ai.moveSlToBE ? `<div style="margin-top:8px;padding:6px 10px;background:var(--long-dim);border:1px solid var(--long);border-radius:4px;font-size:11px;color:var(--long)">💡 Consider moving SL to breakeven ($${fmtPrice(orig.entry)})</div>` : ''}
                    ${ai.warnings?.length > 0 ? `<div style="margin-top:8px;padding:6px 10px;background:var(--amber-dim);border:1px solid var(--amber);border-radius:4px;font-size:11px;color:var(--amber)">⚠️ ${ai.warnings.join(' • ')}</div>` : ''}
                    <div style="font-size:9px;color:var(--text3);margin-top:8px">Last AI update: ${ai.lastUpdated ? new Date(ai.lastUpdated).toLocaleString() : 'Never'}</div>
                ` : `
                    <div style="text-align:center;padding:10px">
                        <div style="color:var(--text3);font-size:11px;margin-bottom:8px">No AI analysis yet</div>
                        <button onclick="getAITradeInterpretation(${trade.id})" style="padding:8px 16px;background:var(--purple-dim);border:1px solid var(--purple);color:var(--purple);border-radius:4px;font-size:11px;font-weight:600;cursor:pointer">🤖 Get AI Analysis</button>
                    </div>
                `}
            </div>
            
            ${orig.factors?.length > 0 ? `
            <div style="background:var(--bg3);border-radius:6px;padding:10px;margin-bottom:12px">
                <div style="font-size:11px;color:var(--text2);margin-bottom:6px">✅ Original Factors</div>
                <div style="display:flex;flex-wrap:wrap;gap:4px">${orig.factors.map(f => `<span style="font-size:10px;padding:3px 6px;background:var(--long-dim);color:var(--long);border-radius:3px">${f}</span>`).join('')}</div>
            </div>` : ''}
            
            <div style="display:flex;gap:8px;margin-top:12px">
                <button class="btn" onclick="refreshSavedTrade(${trade.id})" style="flex:1;background:var(--cyan-dim);border-color:var(--cyan);color:var(--cyan)">🔄 Refresh</button>
                <button class="btn" onclick="getAITradeInterpretation(${trade.id})" style="flex:1;background:var(--purple-dim);border-color:var(--purple);color:var(--purple)">🤖 AI</button>
            </div>
            <div style="display:flex;gap:8px;margin-top:8px">
                <button class="btn" onclick="rescanSavedTrade('${trade.symbol}', '${trade.tfRaw}')" style="flex:2;background:var(--long-dim);border-color:var(--long);color:var(--long)">📊 Full Rescan</button>
                <button class="btn" onclick="deleteSavedTrade(${trade.id})" style="flex:1;background:var(--short-dim);border-color:var(--short);color:var(--short)">🗑️</button>
            </div>
        </div>`;
    
    // Auto-scroll to main panel on mobile
    if (el && window.innerWidth < 900) {
        setTimeout(() => {
            el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);
    }
}

// Rescan saved trade
async function rescanSavedTrade(symbol, tf) {
    toast(`📊 Scanning ${symbol}...`, 'info');
    try {
        const result = await analyzeSignal(symbol, tf);
        if (result) {
            const existingIdx = STATE.signals.findIndex(s => s.symbol === symbol && s.tf === result.tf);
            if (existingIdx >= 0) STATE.signals[existingIdx] = result;
            else STATE.signals.unshift(result);
            STATE.current = result;
            STATE.aiResult = null; // Clear old AI result
            updateMainPanel();
            updateSignalList();
            toast(`✅ ${symbol} rescanned!`, 'success');
        } else {
            toast(`No signal for ${symbol}`, 'warning');
        }
    } catch (e) {
        console.error('Rescan error:', e);
        toast('Rescan failed', 'error');
    }
}

// Update saved trades list - Enhanced with 3 rows
function updateSavedTradesListEnhanced() {
    // V11-CLEAN: Update direction tab saved counts
    if (typeof updateDirectionCounts === 'function') {
        updateDirectionCounts();
    }
    
    // V11-CLEAN: Update both direction dropdowns if they're open
    if (STATE.directionDropdownOpen?.LONG) {
        updateSavedTradesDropdown('LONG');
    }
    if (STATE.directionDropdownOpen?.SHORT) {
        updateSavedTradesDropdown('SHORT');
    }
    
    // Legacy savedList update for backward compatibility
    const el = document.getElementById('savedList');
    const countEl = document.getElementById('savedCount');
    if (el && countEl) {
        countEl.textContent = STATE.savedTrades.length;
        
        if (STATE.savedTrades.length === 0) {
            el.innerHTML = `<div class="saved-empty"><div class="saved-empty-icon">💾</div><div class="saved-empty-text">No saved trades yet</div></div>`;
        } else {
            el.innerHTML = `<button class="saved-refresh-all" onclick="updateAllSavedTradesLive()">🔄 Refresh All Prices</button>` +
                STATE.savedTrades.map(trade => renderSavedTradeCardEnhanced(trade)).join('');
        }
    }
}

// Render single saved trade card with 3 rows
function renderSavedTradeCardEnhanced(trade) {
    const orig = trade.original || trade;
    const live = trade.live || { currentPrice: orig.price || orig.entry, pnlPercent: 0, progressPercent: 0, status: 'LOADING' };
    const ai = trade.ai || {};
    
    const statusInfo = TRADE_STATUS[live.status] || TRADE_STATUS.LOADING;
    const pnlClass = (live.pnlPercent || 0) >= 0 ? 'profit' : 'loss';
    
    const hoursAgo = Math.floor((Date.now() - trade.savedAt) / (1000 * 60 * 60));
    const timeAgo = hoursAgo < 1 ? 'Just now' : hoursAgo < 24 ? `${hoursAgo}h ago` : `${Math.floor(hoursAgo / 24)}d ago`;
    
    // FIX: Make header clickable to open full analysis
    return `
        <div class="saved-card-enhanced ${trade.direction.toLowerCase()}">
            <div class="saved-card-header" onclick="viewSavedTrade(${trade.id})" style="cursor:pointer" title="Click for full analysis">
                <div class="saved-card-pair">
                    ${trade.symbol.replace('USDT', '')}
                    <span class="saved-card-dir ${trade.direction.toLowerCase()}">${trade.direction}</span>
                    <span style="font-size:10px;color:var(--text3)">${trade.tf}</span>
                    <span style="font-size:9px;color:var(--cyan);margin-left:4px">📊 Tap for details</span>
                </div>
                <div class="saved-status-badge ${statusInfo.class}">${statusInfo.emoji} ${statusInfo.label}</div>
            </div>
            
            <!-- ROW 1: ORIGINAL -->
            <div class="saved-row original">
                <div class="saved-row-label"><span class="emoji">📸</span> SAVED</div>
                <div class="saved-original-grid">
                    <div class="saved-original-item"><div class="label">Entry</div><div class="value entry">$${fmtPrice(orig.entry)}</div></div>
                    <div class="saved-original-item"><div class="label">SL</div><div class="value sl">$${fmtPrice(orig.sl)}</div></div>
                    <div class="saved-original-item"><div class="label">TP1</div><div class="value tp">$${fmtPrice(orig.tp1)}</div></div>
                    <div class="saved-original-item"><div class="label">R:R</div><div class="value rr">1:${orig.rr}</div></div>
                </div>
            </div>
            
            <!-- ROW 2: LIVE -->
            <div class="saved-row live">
                <div class="saved-row-label"><span class="emoji">📊</span> LIVE</div>
                <div class="saved-live-header">
                    <div class="saved-live-price">$${fmtPrice(live.currentPrice)}</div>
                    <div class="saved-live-pnl ${pnlClass}">${(live.pnlPercent || 0) >= 0 ? '+' : ''}${(live.pnlPercent || 0).toFixed(2)}%</div>
                </div>
                <div class="saved-progress-container">
                    <div class="saved-progress-bar">
                        <div class="saved-progress-fill ${pnlClass}" style="width:${Math.max(0, Math.min(100, live.progressPercent || 0))}%"></div>
                    </div>
                    <div class="saved-progress-labels">
                        <span>SL: ${(live.distanceToSL || 0).toFixed(1)}%</span>
                        <span>${(live.progressPercent || 0).toFixed(0)}% to TP1</span>
                        <span>TP1: ${(live.distanceToTP1 || 0).toFixed(1)}%</span>
                    </div>
                </div>
            </div>
            
            <!-- ROW 3: AI -->
            <div class="saved-row ai">
                <div class="saved-row-label"><span class="emoji">🤖</span> AI</div>
                ${ai.commentary ? `
                    <div class="saved-ai-commentary">${ai.commentary}</div>
                    ${ai.moveSlToBE ? '<div class="saved-ai-suggestion">💡 Move SL to BE</div>' : ''}
                ` : `<div class="saved-ai-loading"><button class="saved-ai-btn" onclick="getAITradeInterpretation(${trade.id})">🤖 Get AI</button></div>`}
            </div>
            
            <div class="saved-card-actions">
                <button class="saved-action-btn refresh" onclick="refreshSavedTrade(${trade.id})" title="Refresh live data">🔄</button>
                <button class="saved-action-btn details" onclick="viewSavedTrade(${trade.id})" title="Full analysis">📊</button>
                <button class="saved-action-btn delete" onclick="deleteSavedTrade(${trade.id})" title="Delete">🗑️</button>
            </div>
            <div class="saved-last-updated">Saved ${timeAgo}</div>
        </div>`;
}

function formatTimeAgo(timestamp) {
    const seconds = Math.floor((Date.now() - timestamp) / 1000);
    if (seconds < 60) return 'just now';
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
    return `${Math.floor(seconds / 86400)}d ago`;
}

function saveSavedTrades() {
    try {
        // SAFETY: Limit saved trades before saving
        const maxTrades = CONFIG.SAFETY?.MAX_SAVED_TRADES || 50;
        if (STATE.savedTrades.length > maxTrades) {
            STATE.savedTrades = STATE.savedTrades.slice(0, maxTrades);
        }
        
        const data = JSON.stringify(STATE.savedTrades);
        
        // SAFETY: Check storage size (2MB limit)
        const maxSize = (CONFIG.SAFETY?.MAX_STORAGE_MB || 2) * 1024 * 1024;
        if (data.length > maxSize) {
            console.warn('⚠️ Storage data too large, truncating...');
            // Keep only half the trades
            STATE.savedTrades = STATE.savedTrades.slice(0, Math.floor(maxTrades / 2));
        }
        
        safeStorageSet('bybit_scanner_saved_trades', STATE.savedTrades);
    } catch (e) {
        console.error('Failed to save:', e);
        // SAFETY: If storage full, clear old data
        if (e.name === 'QuotaExceededError') {
            console.warn('⚠️ Storage full, clearing old trades...');
            STATE.savedTrades = STATE.savedTrades.slice(0, 10);
            safeStorageSet('bybit_scanner_saved_trades', STATE.savedTrades);
        }
    }
}

function loadSavedTrades() {
    const saved = safeStorageGet('bybit_scanner_saved_trades', []);
    STATE.savedTrades = Array.isArray(saved) ? saved : [];
    STATE.savedTrades = STATE.savedTrades.map(trade => {
        if (!trade.original) {
            return {
                ...trade,
                original: { price: trade.price, entry: trade.entry, sl: trade.sl, tp1: trade.tp1, tp2: trade.tp2, tp3: trade.tp3, rr: trade.rr, riskPct: trade.riskPct, grade: trade.grade, score: trade.score, agreed: trade.agreed, factors: trade.factors, warnings: trade.warnings },
                live: { currentPrice: trade.price || trade.entry, pnlPercent: 0, progressPercent: 0, status: 'LOADING', lastUpdated: null },
                ai: { commentary: null, lastUpdated: null }
            };
        }
        return trade;
    });
    updateSavedTradesListEnhanced();
}

function toggleSavedTrades() {
    const list = document.getElementById('savedList');
    const toggle = document.getElementById('savedToggle');
    if (list.style.display === 'none') { list.style.display = 'block'; toggle.classList.add('open'); }
    else { list.style.display = 'none'; toggle.classList.remove('open'); }
}

function updateSavedTradesList() { updateSavedTradesListEnhanced(); }

async function updateTradePrices() {
    for (const trade of STATE.trades) {
        try {
            const url = `${CONFIG.BYBIT_V5}/market/tickers?category=linear&symbol=${trade.symbol}`;
            const data = await fetchJSON(url);
            
            if (data && data.price) {
                trade.currentPrice = parseFloat(data.price);
                
                // Check TP/SL hits
                if (trade.direction === 'LONG') {
                    if (trade.currentPrice >= trade.tp1) trade.tp1Hit = true;
                    if (trade.currentPrice >= trade.tp2) trade.tp2Hit = true;
                    if (trade.currentPrice >= trade.tp3) trade.tp3Hit = true;
                    if (trade.currentPrice <= trade.sl) trade.slHit = true;
                } else {
                    if (trade.currentPrice <= trade.tp1) trade.tp1Hit = true;
                    if (trade.currentPrice <= trade.tp2) trade.tp2Hit = true;
                    if (trade.currentPrice <= trade.tp3) trade.tp3Hit = true;
                    if (trade.currentPrice >= trade.sl) trade.slHit = true;
                }
            }
        } catch (e) {
            console.error(`Failed to update price for ${trade.symbol}:`, e);
        }
    }
    
    saveTrades();
    updateTradeList();
}

function updateTradeList() {
    const el = document.getElementById('activeList');
    const countEl = document.getElementById('activeCount');
    
    // Guard against missing elements (if Active Trades section removed)
    if (!el || !countEl) return;
    
    countEl.textContent = STATE.trades.length;
    
    if (STATE.trades.length === 0) {
        el.innerHTML = '<div style="text-align:center;color:var(--text3);font-size:12px;padding:8px">No active trades</div>';
        return;
    }
    
    el.innerHTML = STATE.trades.map(trade => {
        // SAFETY: Guard against undefined values
        const entry = trade.entry || 1;
        const currentPrice = trade.currentPrice || entry;
        const pnl = trade.direction === 'LONG' 
            ? ((currentPrice - entry) / entry) * 100
            : ((entry - currentPrice) / entry) * 100;
        
        const safePnl = isNaN(pnl) ? 0 : pnl;
        const pnlClass = safePnl >= 0 ? 'profit' : 'loss';
        
        return `
            <div class="active-card ${(trade.direction || 'LONG').toLowerCase()}">
                <div class="active-top">
                    <div class="active-pair">
                        ${(trade.symbol || 'UNKNOWN').replace('USDT', '')}
                        <span class="dir-tag ${(trade.direction || 'LONG').toLowerCase()}">${trade.direction || 'LONG'}</span>
                    </div>
                    <span class="active-pnl ${pnlClass}">${safePnl >= 0 ? '+' : ''}${safePnl.toFixed(2)}%</span>
                </div>
                <div class="active-levels">
                    <div class="active-level">
                        <div class="active-level-label">Entry</div>
                        <div class="active-level-value" style="color:var(--cyan)">$${fmtPrice(trade.entry)}</div>
                    </div>
                    <div class="active-level ${trade.slHit ? 'stopped' : ''}">
                        <div class="active-level-label">SL</div>
                        <div class="active-level-value" style="color:var(--short)">$${fmtPrice(trade.sl)}</div>
                    </div>
                    <div class="active-level ${trade.tp1Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP1</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp1)}</div>
                    </div>
                    <div class="active-level ${trade.tp2Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP2</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp2)}</div>
                    </div>
                    <div class="active-level ${trade.tp3Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP3</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp3)}</div>
                    </div>
                </div>
                <div class="active-meta">
                    <span>${trade.grade} • ${trade.tf} • R:R 1:${trade.rr}</span>
                    <button class="close-btn" onclick="closeTrade(${trade.id})">✕ Close</button>
                </div>
            </div>
        `;
    }).join('');
}

// ═══════════════════════════════════════════════════════════════════════════════
// EVENT HANDLERS
// ═══════════════════════════════════════════════════════════════════════════════

function selectSignal(idx) {
    console.log('🔵 selectSignal called with idx:', idx);
    try {
        // Validate index
        if (idx < 0 || idx >= STATE.signals.length) {
            console.warn('Invalid signal index:', idx, 'signals length:', STATE.signals.length);
            toast('Invalid signal index', 'error');
            return;
        }
        
        const signal = STATE.signals[idx];
        if (!signal) {
            console.warn('Signal at index is null/undefined:', idx);
            toast('Signal not found', 'error');
            return;
        }
        
        console.log('🔵 Signal found:', signal.symbol, signal.direction, signal.tf);
        STATE.selected = idx;
        
        // Safe deep copy with fallback
        try {
            STATE.current = JSON.parse(JSON.stringify(signal));
        } catch (copyError) {
            console.warn('Deep copy failed, using shallow copy:', copyError);
            STATE.current = { ...signal };
        }
        
        STATE.aiResult = null;
        
        console.log('🔵 Updating signal list...');
        try {
            updateSignalList();
        } catch (listErr) {
            console.error('Signal list update failed:', listErr);
        }
        
        console.log('🔵 Updating main panel...');
        try {
            updateMainPanel();
        } catch (panelErr) {
            console.error('Main panel update failed:', panelErr);
            toast('Panel render error: ' + panelErr.message, 'error');
        }
        
        console.log('🔵 Selection complete!');
        
        // Auto-scroll to main panel on mobile
        const mainPanel = document.getElementById('mainPanel');
        if (mainPanel && window.innerWidth < 900) {
            setTimeout(() => {
                mainPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
        }
    } catch (selectError) {
        console.error('❌ Select signal error:', selectError);
        console.error('Stack:', selectError.stack);
        STATE.current = null;
        toast('Error: ' + selectError.message, 'error');
    }
}

// NEW: Select signal by symbol and timeframe (more reliable than index)
function selectSignalBySymbol(symbol, tf) {
    console.log('🔵 selectSignalBySymbol called:', symbol, tf);
    try {
        const idx = STATE.signals.findIndex(s => s && s.symbol === symbol && s.tf === tf);
        if (idx === -1) {
            console.warn('Signal not found:', symbol, tf);
            toast('Signal not found', 'error');
            return;
        }
        selectSignal(idx);
    } catch (e) {
        console.error('selectSignalBySymbol error:', e);
        toast('Selection error', 'error');
    }
}

function toggleScan() {
    STATE.scanning = !STATE.scanning;
    
    const btn = document.getElementById('scanBtn');
    const icon = document.getElementById('scanIcon');
    
    if (STATE.scanning) {
        btn.className = 'btn scanning';
        icon.textContent = '◉';
        resetScanProgress(); // Show rainbow progress bar immediately
        runScanner();
    } else {
        btn.className = 'btn';
        icon.textContent = '●';
    }
}

function setMode(mode) {
    STATE.mode = mode;
    STATE.selected = null;
    STATE.current = null;
    STATE.aiResult = null;
    
    document.getElementById('modeAll').className = 'mode-btn' + (mode === 'ALL' ? ' active' : '');
    document.getElementById('modeScalp').className = 'mode-btn' + (mode === 'SCALP' ? ' active' : '');
    document.getElementById('modeSwing').className = 'mode-btn' + (mode === 'SWING' ? ' active' : '');
    
    updateSignalList();
    updateCounts();
    updateMainPanel();
}

function setFilter(filter) {
    STATE.filter = filter;
    
    document.getElementById('filterAll').className = 'filter-btn' + (filter === 'all' ? ' active' : '');
    document.getElementById('filterPerfect').className = 'filter-btn' + (filter === 'perfect' ? ' active' : '');
    document.getElementById('filterReady').className = 'filter-btn' + (filter === 'ready' ? ' active' : '');
    document.getElementById('filterEarly').className = 'filter-btn' + (filter === 'early' ? ' active' : '');
    
    updateSignalList();
}

// AI Display Mode toggle (Detailed vs Compact)
function setAIDisplayMode(mode) {
    STATE.aiDisplayMode = mode;
    
    // Update button styles
    const detailedBtn = document.getElementById('aiModeDetailed');
    const compactBtn = document.getElementById('aiModeCompact');
    
    if (detailedBtn && compactBtn) {
        if (mode === 'detailed') {
            detailedBtn.style.background = 'var(--purple)';
            detailedBtn.style.color = 'white';
            compactBtn.style.background = 'var(--bg4)';
            compactBtn.style.color = 'var(--text2)';
        } else {
            compactBtn.style.background = 'var(--purple)';
            compactBtn.style.color = 'white';
            detailedBtn.style.background = 'var(--bg4)';
            detailedBtn.style.color = 'var(--text2)';
        }
    }
    
    // Re-render main panel if AI result exists
    if (STATE.aiResult) {
        updateMainPanel();
    }
    
    // Save to localStorage
    safeStorageSet('bybit_scanner_ai_display_mode', mode);
    
    toast('AI Display: ' + (mode === 'detailed' ? 'Detailed (13 sections)' : 'Compact (6 sections)'), 'success');
}

async function askAI() {
    console.log('🤖 askAI() called');
    
    if (!STATE.current) {
        console.warn('⚠️ No signal selected');
        toast('Select a signal first!', 'error');
        return;
    }
    
    console.log('📊 Current signal:', STATE.current.symbol, STATE.current.tf);
    
    if (!STATE.aiKey) {
        console.warn('⚠️ No API key configured');
        toast('Configure API key in Settings!', 'warning');
        showSettings();
        return;
    }
    
    console.log('🔑 API Key present:', STATE.aiKey.substring(0, 15) + '...');
    toast('🧠 Multi-AI Analyzing...', 'warning');
    
    try {
        const result = await getAIAnalysis(STATE.current);
        console.log('📦 AI Result:', result);
        
        if (result) {
            STATE.aiResult = result;
            STATE.aiExpanded = false; // Start collapsed
            updateMainPanel();
            
            const aiDot = document.getElementById('aiDot');
            const aiStatus = document.getElementById('aiStatus');
            if (aiDot) aiDot.className = 'ai-dot on';
            if (aiStatus) aiStatus.textContent = 'AI: ' + result.verdict;
            
            toast(`${result.aiProvider || 'AI'}: ${result.verdict} (${result.confidence}%)`, 'success');
        } else {
            console.error('❌ AI result is null');
            toast('AI analysis failed', 'error');
        }
    } catch (error) {
        console.error('❌ askAI error:', error);
        toast('AI error: ' + error.message, 'error');
    }
}

function toggleAIExpand() {
    STATE.aiExpanded = !STATE.aiExpanded;
    const content = document.getElementById('aiExpandedContent');
    if (content) {
        content.style.display = STATE.aiExpanded ? 'block' : 'none';
    }
    updateMainPanel();
}

// ═══════════════════════════════════════════════════════════════════════════════
// SETTINGS
// ═══════════════════════════════════════════════════════════════════════════════

function showSettings() {
    document.getElementById('settingsModal').className = 'modal-bg show';
    
    // Load all 11 API keys into input fields
    document.getElementById('groqKey1').value = GROQ_KEYS[0] || '';
    document.getElementById('groqKey2').value = GROQ_KEYS[1] || '';
    document.getElementById('groqKey3').value = GROQ_KEYS[2] || '';
    document.getElementById('groqKey4').value = GROQ_KEYS[3] || '';
    document.getElementById('groqKey5').value = GROQ_KEYS[4] || '';
    
    // Load Groq ON/OFF toggles
    document.getElementById('groqKey1On').checked = KEY_ENABLED.groq[0];
    document.getElementById('groqKey2On').checked = KEY_ENABLED.groq[1];
    document.getElementById('groqKey3On').checked = KEY_ENABLED.groq[2];
    document.getElementById('groqKey4On').checked = KEY_ENABLED.groq[3];
    document.getElementById('groqKey5On').checked = KEY_ENABLED.groq[4];
    
    document.getElementById('deepseekKey1').value = DEEPSEEK_KEYS[0] || '';
    document.getElementById('deepseekKey1On').checked = KEY_ENABLED.deepseek[0];
    
    document.getElementById('geminiKey1').value = GEMINI_KEYS[0] || '';
    document.getElementById('geminiKey2').value = GEMINI_KEYS[1] || '';
    document.getElementById('geminiKey3').value = GEMINI_KEYS[2] || '';
    document.getElementById('geminiKey4').value = GEMINI_KEYS[3] || '';
    document.getElementById('geminiKey5').value = GEMINI_KEYS[4] || '';
    
    // Load Gemini ON/OFF toggles
    document.getElementById('geminiKey1On').checked = KEY_ENABLED.gemini[0];
    document.getElementById('geminiKey2On').checked = KEY_ENABLED.gemini[1];
    document.getElementById('geminiKey3On').checked = KEY_ENABLED.gemini[2];
    document.getElementById('geminiKey4On').checked = KEY_ENABLED.gemini[3];
    document.getElementById('geminiKey5On').checked = KEY_ENABLED.gemini[4];
    
    // Update key status indicators and grid
    for (let i = 0; i < 5; i++) updateKeyIndicator('groq', i, KEY_STATUS.groq[i]);
    updateKeyIndicator('deepseek', 0, KEY_STATUS.deepseek[0]);
    for (let i = 0; i < 5; i++) updateKeyIndicator('gemini', i, KEY_STATUS.gemini[i]);
    updateKeyStatusGrid();
    
    document.getElementById('aiModelSelect').value = STATE.aiModel;
    
    // Load timeframe toggles
    document.getElementById('tf5m').checked = STATE.tfEnabled['5'];
    document.getElementById('tf15m').checked = STATE.tfEnabled['15'];
    document.getElementById('tf30m').checked = STATE.tfEnabled['30'];
    document.getElementById('tf1h').checked = STATE.tfEnabled['60'];
    document.getElementById('tf4h').checked = STATE.tfEnabled['240'];
    document.getElementById('tf1d').checked = STATE.tfEnabled['D'];
    
    // Load scan interval
    document.getElementById('scanInterval').value = STATE.scanInterval;
    
    // Load alert settings
    document.getElementById('alertSound').checked = STATE.alertSound;
    document.getElementById('alertVibrate').checked = STATE.alertVibrate;
    document.getElementById('alertGrade').value = STATE.alertGrade;
    
    // Load telegram settings - ADVANCED
    document.getElementById('telegramEnabled').checked = STATE.telegramEnabled;
    document.getElementById('telegramToken').value = STATE.telegramToken;
    document.getElementById('telegramChatId').value = STATE.telegramChatId;
    document.getElementById('telegramMinGrade').value = STATE.telegramMinGrade;
    document.getElementById('telegramCooldown').value = STATE.telegramCooldown;
    document.getElementById('telegramDetailed').checked = STATE.telegramDetailed;
    document.getElementById('telegramCream').checked = STATE.telegramCream;
    document.getElementById('telegramTPAlerts').checked = STATE.telegramTPAlerts;
    document.getElementById('telegramSLAlerts').checked = STATE.telegramSLAlerts;
    document.getElementById('telegramDailySummary').checked = STATE.telegramDailySummary;
    document.getElementById('telegramQuietStart').value = STATE.telegramQuietStart || '';
    document.getElementById('telegramQuietEnd').value = STATE.telegramQuietEnd || '';
    updateTelegramStats();
    
    // Load risk settings
    document.getElementById('riskAccount').value = STATE.riskAccount;
    document.getElementById('riskPercent').value = STATE.riskPercent;
    document.getElementById('riskLeverage').value = STATE.riskLeverage;
    document.getElementById('riskMaxPosition').value = STATE.riskMaxPosition;
    
    // Load weight settings
    document.getElementById('weightZone').value = CONFIG.WEIGHTS.zone * 100;
    document.getElementById('weightSMC').value = CONFIG.WEIGHTS.smc * 100;
    document.getElementById('weightMomentum').value = CONFIG.WEIGHTS.momentum * 100;
    updateWeightDisplay();
    
    // Load theme
    document.getElementById('oledTheme').checked = STATE.oledTheme;
    
    // Load timezone
    const tzSelect = document.getElementById('userTimezone');
    if (tzSelect) {
        tzSelect.value = STATE.awareness?.timezone || 'Australia/Melbourne';
        tzSelect.onchange = updateTimezonePreview;
    }
    updateTimezonePreview();
    
    // Render coin manager
    renderCoinManager();
    
    updateKeyStatus();
}

function hideSettings() {
    document.getElementById('settingsModal').className = 'modal-bg';
}

function updateKeyStatus() {
    const el = document.getElementById('keyStatus');
    const groqCount = GROQ_KEYS.filter(k => k && k.length > 5).length;
    const deepseekCount = DEEPSEEK_KEYS.filter(k => k && k.length > 5).length;
    const geminiCount = GEMINI_KEYS.filter(k => k && k.length > 5).length;
    const total = groqCount + deepseekCount + geminiCount;
    
    if (total > 0) {
        el.className = 'key-status valid';
        el.textContent = `✅ ${total}/11 API Keys configured (Groq: ${groqCount}, DeepSeek: ${deepseekCount}, Gemini: ${geminiCount})`;
    } else {
        el.className = 'key-status invalid';
        el.textContent = '❌ No API Key configured';
    }
}

function toggleKeyVis() {
    // Toggle visibility for all 11 key inputs
    const keyInputs = [
        'groqKey1', 'groqKey2', 'groqKey3', 'groqKey4', 'groqKey5',
        'deepseekKey1',
        'geminiKey1', 'geminiKey2', 'geminiKey3', 'geminiKey4', 'geminiKey5'
    ];
    const firstInput = document.getElementById('groqKey1');
    const newType = firstInput.type === 'password' ? 'text' : 'password';
    keyInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.type = newType;
    });
}

function clearKey() {
    // Clear all 11 key inputs
    const keyInputs = [
        'groqKey1', 'groqKey2', 'groqKey3', 'groqKey4', 'groqKey5',
        'deepseekKey1',
        'geminiKey1', 'geminiKey2', 'geminiKey3', 'geminiKey4', 'geminiKey5'
    ];
    keyInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '';
    });
    
    // Clear arrays
    GROQ_KEYS.fill('');
    DEEPSEEK_KEYS.fill('');
    GEMINI_KEYS.fill('');
    
    STATE.aiKey = '';
    STATE.deepseekKey = '';
    STATE.geminiKey = '';
    
    safeStorageRemove('bybit_scanner_groq_keys');
    safeStorageRemove('bybit_scanner_deepseek_keys');
    safeStorageRemove('bybit_scanner_gemini_keys');
    safeStorageRemove('bybit_scanner_key');
    safeStorageRemove('bybit_scanner_deepseek');
    safeStorageRemove('bybit_scanner_gemini');
    
    updateKeyStatus();
    toast('All API keys cleared', 'warning');
}

async function testKey() {
    await testAllKeys();
}

// Test single Groq key
async function testSingleGroqKey(key) {
    if (!key || key.length < 10) return false;
    try {
        const response = await fetch(CONFIG.GROQ_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
            body: JSON.stringify({ model: 'llama-3.3-70b-versatile', messages: [{ role: 'user', content: 'Hi' }], max_tokens: 5 })
        });
        return response.ok || response.status === 429;
    } catch (e) { return false; }
}

// Test single DeepSeek key
async function testSingleDeepSeekKey(key) {
    if (!key || key.length < 10) return false;
    try {
        const response = await fetch(CONFIG.DEEPSEEK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
            body: JSON.stringify({ model: 'deepseek-chat', messages: [{ role: 'user', content: 'Hi' }], max_tokens: 5 })
        });
        return response.ok || response.status === 429;
    } catch (e) { return false; }
}

// Test single Gemini key
async function testSingleGeminiKey(key) {
    if (!key || key.length < 10) {
        console.log('❌ Gemini key too short or empty');
        return false;
    }
    
    // Gemini keys should start with AIza
    if (!key.startsWith('AIza')) {
        console.log('❌ Gemini key should start with AIza, got:', key.substring(0, 10));
        return false;
    }
    
    // Try primary model first, then fallback
    const models = [
        'gemini-2.0-flash',
        'gemini-1.5-flash',
        'gemini-1.5-flash-latest'
    ];
    
    for (const model of models) {
        try {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;
            console.log(`🔌 Testing Gemini key with ${model}:`, key.substring(0, 15) + '...');
            
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    contents: [{ parts: [{ text: 'Say OK' }] }], 
                    generationConfig: { maxOutputTokens: 5 } 
                })
            });
            
            console.log(`📡 Gemini ${model} response status:`, response.status);
            
            if (response.ok) {
                console.log(`✅ Gemini key WORKS with ${model}!`);
                // Update CONFIG to use working model
                CONFIG.GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
                return true;
            } else if (response.status === 429) {
                console.log(`⚠️ Gemini ${model} rate limited but key is valid`);
                CONFIG.GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
                return true; // Key is valid, just rate limited
            } else if (response.status === 404) {
                console.log(`⚠️ Model ${model} not found, trying next...`);
                continue; // Try next model
            } else {
                const errorData = await response.json().catch(() => ({}));
                console.log(`❌ Gemini ${model} error:`, errorData.error?.message || response.status);
                // If it's an auth error, the key is bad - don't try other models
                if (response.status === 400 || response.status === 401 || response.status === 403) {
                    return false;
                }
                continue; // Try next model for other errors
            }
        } catch (e) { 
            console.error(`❌ Gemini ${model} network error:`, e.message);
            continue; // Try next model on network error
        }
    }
    
    console.log('❌ All Gemini models failed');
    return false;
}

// Update key status indicator
function updateKeyIndicator(provider, index, status) {
    const id = `${provider}Key${index + 1}Status`;
    const el = document.getElementById(id);
    if (el) {
        if (status === true) el.textContent = '✅';
        else if (status === false) el.textContent = '❌';
        else el.textContent = '⚪';
    }
}

// Update key status grid
function updateKeyStatusGrid() {
    const slots = document.querySelectorAll('#keyStatusGrid .key-slot');
    if (slots.length !== 11) return;
    
    // Groq keys (0-4)
    for (let i = 0; i < 5; i++) {
        const hasKey = GROQ_KEYS[i] && GROQ_KEYS[i].length > 5;
        const enabled = KEY_ENABLED.groq[i];
        const status = KEY_STATUS.groq[i];
        let cls = 'key-slot empty';
        let icon = '⚪';
        
        if (hasKey) {
            if (!enabled) { cls = 'key-slot off'; icon = '⏸️'; }
            else if (status === true) { cls = 'key-slot active'; icon = '✅'; }
            else if (status === false) { cls = 'key-slot error'; icon = '❌'; }
            else { cls = 'key-slot empty'; icon = '🟢'; }
        }
        
        slots[i].className = cls;
        slots[i].querySelector('.key-slot-icon').textContent = icon;
    }
    
    // DeepSeek (5)
    {
        const hasKey = DEEPSEEK_KEYS[0] && DEEPSEEK_KEYS[0].length > 5;
        const enabled = KEY_ENABLED.deepseek[0];
        const status = KEY_STATUS.deepseek[0];
        let cls = 'key-slot empty';
        let icon = '⚪';
        
        if (hasKey) {
            if (!enabled) { cls = 'key-slot off'; icon = '⏸️'; }
            else if (status === true) { cls = 'key-slot active'; icon = '✅'; }
            else if (status === false) { cls = 'key-slot error'; icon = '❌'; }
            else { cls = 'key-slot empty'; icon = '🔵'; }
        }
        
        slots[5].className = cls;
        slots[5].querySelector('.key-slot-icon').textContent = icon;
    }
    
    // Gemini keys (6-10)
    for (let i = 0; i < 5; i++) {
        const hasKey = GEMINI_KEYS[i] && GEMINI_KEYS[i].length > 5;
        const enabled = KEY_ENABLED.gemini[i];
        const status = KEY_STATUS.gemini[i];
        let cls = 'key-slot empty';
        let icon = '⚪';
        
        if (hasKey) {
            if (!enabled) { cls = 'key-slot off'; icon = '⏸️'; }
            else if (status === true) { cls = 'key-slot active'; icon = '✅'; }
            else if (status === false) { cls = 'key-slot error'; icon = '❌'; }
            else { cls = 'key-slot empty'; icon = '🟣'; }
        }
        
        slots[6 + i].className = cls;
        slots[6 + i].querySelector('.key-slot-icon').textContent = icon;
    }
}

// Test ALL keys
async function testAllKeys() {
    toast('🔌 Testing all API keys...', 'warning');
    
    let working = 0;
    let tested = 0;
    
    // Test Groq keys
    for (let i = 0; i < 5; i++) {
        const key = document.getElementById(`groqKey${i+1}`).value.trim();
        GROQ_KEYS[i] = key;
        KEY_ENABLED.groq[i] = document.getElementById(`groqKey${i+1}On`).checked;
        
        if (key && key.length > 5 && KEY_ENABLED.groq[i]) {
            updateKeyIndicator('groq', i, null);
            const result = await testSingleGroqKey(key);
            KEY_STATUS.groq[i] = result;
            updateKeyIndicator('groq', i, result);
            if (result) working++;
            tested++;
        }
    }
    
    // Test DeepSeek key
    {
        const key = document.getElementById('deepseekKey1').value.trim();
        DEEPSEEK_KEYS[0] = key;
        KEY_ENABLED.deepseek[0] = document.getElementById('deepseekKey1On').checked;
        
        if (key && key.length > 5 && KEY_ENABLED.deepseek[0]) {
            updateKeyIndicator('deepseek', 0, null);
            const result = await testSingleDeepSeekKey(key);
            KEY_STATUS.deepseek[0] = result;
            updateKeyIndicator('deepseek', 0, result);
            if (result) working++;
            tested++;
        }
    }
    
    // Test Gemini keys
    for (let i = 0; i < 5; i++) {
        const keyInput = document.getElementById(`geminiKey${i+1}`);
        const toggleInput = document.getElementById(`geminiKey${i+1}On`);
        
        if (!keyInput) {
            console.error(`Missing geminiKey${i+1} input`);
            continue;
        }
        
        const key = keyInput.value.trim();
        GEMINI_KEYS[i] = key;
        KEY_ENABLED.gemini[i] = toggleInput ? toggleInput.checked : true;
        
        console.log(`Gemini Key ${i+1}: ${key ? key.substring(0,10) + '...' : 'empty'}, enabled: ${KEY_ENABLED.gemini[i]}`);
        
        if (key && key.length > 5 && KEY_ENABLED.gemini[i]) {
            updateKeyIndicator('gemini', i, null);
            const result = await testSingleGeminiKey(key);
            console.log(`Gemini Key ${i+1} test result: ${result}`);
            KEY_STATUS.gemini[i] = result;
            updateKeyIndicator('gemini', i, result);
            if (result) working++;
            tested++;
        }
    }
    
    updateKeyStatusGrid();
    updateKeyStatus();
    
    const aiDot = document.getElementById('aiDot');
    const aiStatus = document.getElementById('aiStatus');
    
    if (working > 0) {
        toast(`✅ ${working}/${tested} keys working!`, 'success');
        if (aiDot) aiDot.className = 'ai-dot on';
        if (aiStatus) aiStatus.textContent = 'AI: Ready';
    } else if (tested > 0) {
        toast(`❌ 0/${tested} keys working`, 'error');
        if (aiDot) aiDot.className = 'ai-dot error';
        if (aiStatus) aiStatus.textContent = 'AI: Error';
    } else {
        toast('⚠️ No keys to test', 'warning');
    }
}

function saveSettings() {
    console.log('💾 saveSettings() called');
    
    // Save all 11 API keys
    // Groq Keys (5)
    GROQ_KEYS[0] = document.getElementById('groqKey1').value.trim();
    GROQ_KEYS[1] = document.getElementById('groqKey2').value.trim();
    GROQ_KEYS[2] = document.getElementById('groqKey3').value.trim();
    GROQ_KEYS[3] = document.getElementById('groqKey4').value.trim();
    GROQ_KEYS[4] = document.getElementById('groqKey5').value.trim();
    
    // Save Groq ON/OFF toggles
    KEY_ENABLED.groq[0] = document.getElementById('groqKey1On').checked;
    KEY_ENABLED.groq[1] = document.getElementById('groqKey2On').checked;
    KEY_ENABLED.groq[2] = document.getElementById('groqKey3On').checked;
    KEY_ENABLED.groq[3] = document.getElementById('groqKey4On').checked;
    KEY_ENABLED.groq[4] = document.getElementById('groqKey5On').checked;
    
    // DeepSeek Key (1)
    DEEPSEEK_KEYS[0] = document.getElementById('deepseekKey1').value.trim();
    KEY_ENABLED.deepseek[0] = document.getElementById('deepseekKey1On').checked;
    
    // Gemini Keys (5)
    GEMINI_KEYS[0] = document.getElementById('geminiKey1').value.trim();
    GEMINI_KEYS[1] = document.getElementById('geminiKey2').value.trim();
    GEMINI_KEYS[2] = document.getElementById('geminiKey3').value.trim();
    GEMINI_KEYS[3] = document.getElementById('geminiKey4').value.trim();
    GEMINI_KEYS[4] = document.getElementById('geminiKey5').value.trim();
    
    // Save Gemini ON/OFF toggles
    KEY_ENABLED.gemini[0] = document.getElementById('geminiKey1On').checked;
    KEY_ENABLED.gemini[1] = document.getElementById('geminiKey2On').checked;
    KEY_ENABLED.gemini[2] = document.getElementById('geminiKey3On').checked;
    KEY_ENABLED.gemini[3] = document.getElementById('geminiKey4On').checked;
    KEY_ENABLED.gemini[4] = document.getElementById('geminiKey5On').checked;
    
    // Set STATE keys for backward compatibility
    STATE.aiKey = GROQ_KEYS[0];
    STATE.deepseekKey = DEEPSEEK_KEYS[0];
    STATE.geminiKey = GEMINI_KEYS[0];
    STATE.aiModel = document.getElementById('aiModelSelect').value;
    
    // Count only ENABLED keys
    const groqCount = GROQ_KEYS.filter((k, i) => k && KEY_ENABLED.groq[i]).length;
    const geminiCount = GEMINI_KEYS.filter((k, i) => k && KEY_ENABLED.gemini[i]).length;
    const deepseekCount = DEEPSEEK_KEYS.filter((k, i) => k && KEY_ENABLED.deepseek[i]).length;
    
    console.log('💾 Keys captured:', {
        groq: groqCount + ' keys enabled',
        deepseek: deepseekCount + ' keys enabled',
        gemini: geminiCount + ' keys enabled',
        total: groqCount + deepseekCount + geminiCount + ' of 11 enabled'
    });
    
    // Update grid
    updateKeyStatusGrid();
    
    // Save timeframe toggles
    STATE.tfEnabled['5'] = document.getElementById('tf5m').checked;
    STATE.tfEnabled['15'] = document.getElementById('tf15m').checked;
    STATE.tfEnabled['30'] = document.getElementById('tf30m').checked;
    STATE.tfEnabled['60'] = document.getElementById('tf1h').checked;
    STATE.tfEnabled['240'] = document.getElementById('tf4h').checked;
    STATE.tfEnabled['D'] = document.getElementById('tf1d').checked;
    
    // Save scan interval
    STATE.scanInterval = parseInt(document.getElementById('scanInterval').value);
    
    // Save alert settings
    STATE.alertSound = document.getElementById('alertSound').checked;
    STATE.alertVibrate = document.getElementById('alertVibrate').checked;
    STATE.alertGrade = document.getElementById('alertGrade').value;
    
    // Save telegram settings
    // Save telegram settings - ADVANCED
    STATE.telegramEnabled = document.getElementById('telegramEnabled').checked;
    STATE.telegramToken = document.getElementById('telegramToken').value.trim();
    STATE.telegramChatId = document.getElementById('telegramChatId').value.trim();
    STATE.telegramMinGrade = document.getElementById('telegramMinGrade').value;
    STATE.telegramCooldown = parseInt(document.getElementById('telegramCooldown').value) || 5;
    STATE.telegramDetailed = document.getElementById('telegramDetailed').checked;
    STATE.telegramCream = document.getElementById('telegramCream').checked;
    STATE.telegramTPAlerts = document.getElementById('telegramTPAlerts').checked;
    STATE.telegramSLAlerts = document.getElementById('telegramSLAlerts').checked;
    STATE.telegramDailySummary = document.getElementById('telegramDailySummary').checked;
    STATE.telegramQuietStart = document.getElementById('telegramQuietStart').value || null;
    STATE.telegramQuietEnd = document.getElementById('telegramQuietEnd').value || null;
    
    // Save risk settings
    STATE.riskAccount = parseFloat(document.getElementById('riskAccount').value) || 1000;
    STATE.riskPercent = parseFloat(document.getElementById('riskPercent').value) || 2;
    STATE.riskLeverage = parseInt(document.getElementById('riskLeverage').value) || 10;
    STATE.riskMaxPosition = parseFloat(document.getElementById('riskMaxPosition').value) || 500;
    
    // Save weights
    CONFIG.WEIGHTS.zone = parseInt(document.getElementById('weightZone').value) / 100;
    CONFIG.WEIGHTS.smc = parseInt(document.getElementById('weightSMC').value) / 100;
    CONFIG.WEIGHTS.momentum = parseInt(document.getElementById('weightMomentum').value) / 100;
    
    // Save theme
    STATE.oledTheme = document.getElementById('oledTheme').checked;
    applyTheme();
    
    // Save timezone
    STATE.awareness.timezone = document.getElementById('userTimezone').value;
    
    // BUG FIX #2: Using safe localStorage functions
    // Save all 11 API keys
    safeStorageSet('bybit_scanner_groq_keys', GROQ_KEYS);
    safeStorageSet('bybit_scanner_deepseek_keys', DEEPSEEK_KEYS);
    safeStorageSet('bybit_scanner_gemini_keys', GEMINI_KEYS);
    
    // Save KEY_ENABLED states
    safeStorageSet('bybit_scanner_key_enabled', KEY_ENABLED);
    
    // Keep old keys for backward compatibility
    safeStorageSet('bybit_scanner_key', STATE.aiKey);
    safeStorageSet('bybit_scanner_model', STATE.aiModel);
    safeStorageSet('bybit_scanner_deepseek', STATE.deepseekKey);
    safeStorageSet('bybit_scanner_gemini', STATE.geminiKey);
    
    safeStorageSet('bybit_scanner_tf', STATE.tfEnabled);
    safeStorageSet('bybit_scanner_interval', STATE.scanInterval);
    safeStorageSet('bybit_scanner_alert_sound', STATE.alertSound);
    safeStorageSet('bybit_scanner_alert_vibrate', STATE.alertVibrate);
    safeStorageSet('bybit_scanner_alert_grade', STATE.alertGrade);
    safeStorageSet('bybit_scanner_telegram_enabled', STATE.telegramEnabled);
    safeStorageSet('bybit_scanner_telegram_token', STATE.telegramToken);
    safeStorageSet('bybit_scanner_telegram_chat', STATE.telegramChatId);
    // Advanced Telegram settings
    safeStorageSet('bybit_scanner_telegram_min_grade', STATE.telegramMinGrade);
    safeStorageSet('bybit_scanner_telegram_cooldown', STATE.telegramCooldown);
    safeStorageSet('bybit_scanner_telegram_detailed', STATE.telegramDetailed);
    safeStorageSet('bybit_scanner_telegram_cream', STATE.telegramCream);
    safeStorageSet('bybit_scanner_telegram_tp_alerts', STATE.telegramTPAlerts);
    safeStorageSet('bybit_scanner_telegram_sl_alerts', STATE.telegramSLAlerts);
    safeStorageSet('bybit_scanner_telegram_daily', STATE.telegramDailySummary);
    safeStorageSet('bybit_scanner_telegram_quiet_start', STATE.telegramQuietStart);
    safeStorageSet('bybit_scanner_telegram_quiet_end', STATE.telegramQuietEnd);
    safeStorageSet('bybit_scanner_risk_account', STATE.riskAccount);
    safeStorageSet('bybit_scanner_risk_percent', STATE.riskPercent);
    safeStorageSet('bybit_scanner_risk_leverage', STATE.riskLeverage);
    safeStorageSet('bybit_scanner_risk_max', STATE.riskMaxPosition);
    safeStorageSet('bybit_scanner_weights', CONFIG.WEIGHTS);
    safeStorageSet('bybit_scanner_oled', STATE.oledTheme);
    safeStorageSet('bybit_scanner_coins', CONFIG.COINS);
    safeStorageSet('bybit_scanner_coin_count', STATE.coinCount);
    safeStorageSet('bybit_scanner_timezone', STATE.awareness.timezone);
    console.log('💾 Settings saved to localStorage successfully!');
    
    const totalKeys = GROQ_KEYS.filter((k, i) => k && KEY_ENABLED.groq[i]).length + 
                     DEEPSEEK_KEYS.filter((k, i) => k && KEY_ENABLED.deepseek[i]).length + 
                     GEMINI_KEYS.filter((k, i) => k && KEY_ENABLED.gemini[i]).length;
    if (totalKeys > 0) {
        const aiDot = document.getElementById('aiDot');
        const aiStatus = document.getElementById('aiStatus');
        if (aiDot) aiDot.className = 'ai-dot on';
        if (aiStatus) aiStatus.textContent = 'AI: ' + totalKeys + '/11 enabled';
    }
    
    updateKeyStatus();
    hideSettings();
    toast('Settings saved! ' + totalKeys + ' API keys configured.', 'success');
}

function loadSettings() {
    // BUG FIX #2: Using safe localStorage functions
    // Load all 11 API keys
    const savedGroqKeys = safeStorageGet('bybit_scanner_groq_keys', null);
    const savedDeepseekKeys = safeStorageGet('bybit_scanner_deepseek_keys', null);
    const savedGeminiKeys = safeStorageGet('bybit_scanner_gemini_keys', null);
    
    if (savedGroqKeys && Array.isArray(savedGroqKeys)) {
        savedGroqKeys.forEach((k, i) => { if (i < 5) GROQ_KEYS[i] = k || ''; });
    }
    if (savedDeepseekKeys && Array.isArray(savedDeepseekKeys)) {
        savedDeepseekKeys.forEach((k, i) => { if (i < 1) DEEPSEEK_KEYS[i] = k || ''; });
    }
    if (savedGeminiKeys && Array.isArray(savedGeminiKeys)) {
        savedGeminiKeys.forEach((k, i) => { if (i < 5) GEMINI_KEYS[i] = k || ''; });
    }
    
    // Load KEY_ENABLED states
    const savedKeyEnabled = safeStorageGet('bybit_scanner_key_enabled', null);
    if (savedKeyEnabled) {
        if (savedKeyEnabled.groq) KEY_ENABLED.groq = savedKeyEnabled.groq;
        if (savedKeyEnabled.deepseek) KEY_ENABLED.deepseek = savedKeyEnabled.deepseek;
        if (savedKeyEnabled.gemini) KEY_ENABLED.gemini = savedKeyEnabled.gemini;
    }
    
    // Backward compatibility - load old single keys if no array saved
    if (!savedGroqKeys) {
        const oldKey = safeStorageGet('bybit_scanner_key', '');
        if (oldKey) GROQ_KEYS[0] = oldKey;
    }
    if (!savedDeepseekKeys) {
        const oldKey = safeStorageGet('bybit_scanner_deepseek', '');
        if (oldKey) DEEPSEEK_KEYS[0] = oldKey;
    }
    if (!savedGeminiKeys) {
        const oldKey = safeStorageGet('bybit_scanner_gemini', '');
        if (oldKey) GEMINI_KEYS[0] = oldKey;
    }
    
    // Set STATE for backward compatibility
    STATE.aiKey = GROQ_KEYS[0] || DEFAULT_KEY;
    STATE.deepseekKey = DEEPSEEK_KEYS[0] || '';
    STATE.geminiKey = GEMINI_KEYS[0] || '';
    STATE.aiModel = safeStorageGet('bybit_scanner_model', 'llama-3.3-70b-versatile');
    
    // Load AI Display Mode
    STATE.aiDisplayMode = safeStorageGet('bybit_scanner_ai_display_mode', 'detailed');
    
    const groqCount = GROQ_KEYS.filter((k, i) => k && KEY_ENABLED.groq[i]).length;
    const geminiCount = GEMINI_KEYS.filter((k, i) => k && KEY_ENABLED.gemini[i]).length;
    const deepseekCount = DEEPSEEK_KEYS.filter((k, i) => k && KEY_ENABLED.deepseek[i]).length;
    
    console.log('🔑 Keys loaded:', {
        groq: groqCount + ' keys enabled',
        deepseek: deepseekCount + ' keys enabled',
        gemini: geminiCount + ' keys enabled',
        total: groqCount + deepseekCount + geminiCount + ' of 11 enabled'
    });
    
    // Load timeframe toggles
    const savedTf = safeStorageGet('bybit_scanner_tf', null);
    if (savedTf) {
        STATE.tfEnabled = savedTf;
    }
    
    // Load scan interval
    const savedInterval = safeStorageGet('bybit_scanner_interval', null);
    if (savedInterval) STATE.scanInterval = parseInt(savedInterval);
    
    // Load alert settings
    const savedSound = safeStorageGet('bybit_scanner_alert_sound', null);
    const savedVibrate = safeStorageGet('bybit_scanner_alert_vibrate', null);
    const savedGrade = safeStorageGet('bybit_scanner_alert_grade', null);
    
    if (savedSound !== null) STATE.alertSound = savedSound === true || savedSound === 'true';
    if (savedVibrate !== null) STATE.alertVibrate = savedVibrate === true || savedVibrate === 'true';
    if (savedGrade) STATE.alertGrade = savedGrade;
    
    // Load telegram settings
    const telegramEnabledVal = safeStorageGet('bybit_scanner_telegram_enabled', false);
    STATE.telegramEnabled = telegramEnabledVal === true || telegramEnabledVal === 'true';
    STATE.telegramToken = safeStorageGet('bybit_scanner_telegram_token', '');
    STATE.telegramChatId = safeStorageGet('bybit_scanner_telegram_chat', '');
    // Advanced Telegram settings
    STATE.telegramMinGrade = safeStorageGet('bybit_scanner_telegram_min_grade', 'STRONG');
    STATE.telegramCooldown = parseInt(safeStorageGet('bybit_scanner_telegram_cooldown', 5)) || 5;
    const tgDetailed = safeStorageGet('bybit_scanner_telegram_detailed', true);
    STATE.telegramDetailed = tgDetailed === true || tgDetailed === 'true';
    const tgCream = safeStorageGet('bybit_scanner_telegram_cream', true);
    STATE.telegramCream = tgCream === true || tgCream === 'true';
    const tgTP = safeStorageGet('bybit_scanner_telegram_tp_alerts', true);
    STATE.telegramTPAlerts = tgTP === true || tgTP === 'true';
    const tgSL = safeStorageGet('bybit_scanner_telegram_sl_alerts', true);
    STATE.telegramSLAlerts = tgSL === true || tgSL === 'true';
    const tgDaily = safeStorageGet('bybit_scanner_telegram_daily', false);
    STATE.telegramDailySummary = tgDaily === true || tgDaily === 'true';
    STATE.telegramQuietStart = safeStorageGet('bybit_scanner_telegram_quiet_start', null);
    STATE.telegramQuietEnd = safeStorageGet('bybit_scanner_telegram_quiet_end', null);
    
    // Load risk settings
    STATE.riskAccount = parseFloat(safeStorageGet('bybit_scanner_risk_account', 1000)) || 1000;
    STATE.riskPercent = parseFloat(safeStorageGet('bybit_scanner_risk_percent', 2)) || 2;
    STATE.riskLeverage = parseInt(safeStorageGet('bybit_scanner_risk_leverage', 10)) || 10;
    STATE.riskMaxPosition = parseFloat(safeStorageGet('bybit_scanner_risk_max', 500)) || 500;
    
    // Load weights
    const savedWeights = safeStorageGet('bybit_scanner_weights', null);
    if (savedWeights) {
        CONFIG.WEIGHTS = savedWeights;
    }
    
    // Load theme
    const oledVal = safeStorageGet('bybit_scanner_oled', false);
    STATE.oledTheme = oledVal === true || oledVal === 'true';
    applyTheme();
    
    // Load coins
    const savedCoins = safeStorageGet('bybit_scanner_coins', null);
    const savedCoinCount = safeStorageGet('bybit_scanner_coin_count', null);
    if (savedCoins && Array.isArray(savedCoins)) {
        CONFIG.COINS = savedCoins;
    } else {
        CONFIG.COINS = CONFIG.ALL_COINS.slice(0, 50);
    }
    if (savedCoinCount) STATE.coinCount = parseInt(savedCoinCount);
    
    // Load timezone
    if (!STATE.awareness) STATE.awareness = { timezone: 'auto', news: [] };
    STATE.awareness.timezone = safeStorageGet('bybit_scanner_timezone', 'Australia/Melbourne');
    
    if (STATE.aiKey || STATE.deepseekKey || STATE.geminiKey) {
        const aiDot = document.getElementById('aiDot');
        const aiStatus = document.getElementById('aiStatus');
        if (aiDot) aiDot.className = 'ai-dot on';
        if (aiStatus) aiStatus.textContent = 'AI: Ready';
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ALERT FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function triggerAlert(signal) {
    console.log('🔔 triggerAlert called for:', signal.symbol, signal.direction, signal.grade);
    
    // Play sound
    if (STATE.alertSound) {
        playAlertSound();
    }
    
    // Vibrate
    if (STATE.alertVibrate && navigator.vibrate) {
        navigator.vibrate([200, 100, 200, 100, 200]);
    }
    
    // Send Telegram alert
    if (STATE.telegramEnabled) {
        console.log('🔔 Telegram enabled, sending alert...');
        sendTelegramAlert(signal);
    } else {
        console.log('🔔 Telegram disabled, skipping telegram alert');
    }
    
    // Show notification toast
    toast(`🔔 ${signal.grade}: ${signal.symbol.replace('USDT', '')} ${signal.direction} on ${signal.tf}`, 'success');
}

function playAlertSound() {
    try {
        // Create audio context for alert beep
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        oscillator.frequency.value = 880; // A5 note
        oscillator.type = 'sine';
        gainNode.gain.value = 0.3;
        
        oscillator.start();
        
        // Beep pattern: beep-beep-beep
        setTimeout(() => { gainNode.gain.value = 0; }, 100);
        setTimeout(() => { gainNode.gain.value = 0.3; }, 150);
        setTimeout(() => { gainNode.gain.value = 0; }, 250);
        setTimeout(() => { gainNode.gain.value = 0.3; }, 300);
        setTimeout(() => { gainNode.gain.value = 0; }, 400);
        setTimeout(() => { oscillator.stop(); }, 450);
    } catch (e) {
        console.log('Audio not supported');
    }
}

function testAlert() {
    // FIX: Complete test signal with all required properties
    const testSignal = {
        symbol: 'BTCUSDT',
        direction: 'LONG',
        grade: 'PERFECT',
        tf: '1H',
        score: 95,
        agreed: 3,
        levels: {
            entry: 100000.00,
            sl: 98500.00,
            tp1: 101500.00,
            tp2: 103000.00,
            tp3: 105000.00,
            rr: '3.0'
        }
    };
    triggerAlert(testSignal);
}

// ═══════════════════════════════════════════════════════════════════════════════
// COIN MANAGER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function setCoinCount(count) {
    STATE.coinCount = count;
    CONFIG.COINS = CONFIG.ALL_COINS.slice(0, count);
    renderCoinManager();
    toast(`Set to Top ${count} coins`, 'success');
}

function addCoin() {
    const input = document.getElementById('addCoinInput');
    let coin = input.value.trim().toUpperCase();
    if (!coin) return;
    
    if (!coin.endsWith('USDT')) {
        coin = coin + 'USDT';
    }
    
    if (CONFIG.COINS.includes(coin)) {
        toast('Coin already in list!', 'warning');
        return;
    }
    
    CONFIG.COINS.push(coin);
    input.value = '';
    renderCoinManager();
    toast(`Added ${coin}`, 'success');
}

function removeCoin(coin) {
    CONFIG.COINS = CONFIG.COINS.filter(c => c !== coin);
    renderCoinManager();
}

function renderCoinManager() {
    const el = document.getElementById('coinManager');
    document.getElementById('coinCountDisplay').textContent = CONFIG.COINS.length;
    
    el.innerHTML = `<div class="coin-grid">${CONFIG.COINS.map(coin => `
        <div class="coin-chip">
            <span>${coin.replace('USDT', '')}</span>
            <span class="remove-coin" onclick="removeCoin('${coin}')">×</span>
        </div>
    `).join('')}</div>`;
}

// ═══════════════════════════════════════════════════════════════════════════════
// WEIGHT & THEME FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function updateWeightDisplay() {
    const zone = parseInt(document.getElementById('weightZone').value);
    const smc = parseInt(document.getElementById('weightSMC').value);
    const momentum = parseInt(document.getElementById('weightMomentum').value);
    
    document.getElementById('weightZoneVal').textContent = zone + '%';
    document.getElementById('weightSMCVal').textContent = smc + '%';
    document.getElementById('weightMomentumVal').textContent = momentum + '%';
    
    const total = zone + smc + momentum;
    const totalEl = document.getElementById('weightTotal');
    totalEl.textContent = total + '%';
    totalEl.style.color = total === 100 ? 'var(--long)' : 'var(--short)';
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENGINE LOCK SYSTEM - Prevents accidental changes when scrolling
// ═══════════════════════════════════════════════════════════════════════════════

const ENGINE_LOCKS = {
    zone: false,
    smc: false,
    momentum: false
};

function toggleEngineLock(engine) {
    ENGINE_LOCKS[engine] = !ENGINE_LOCKS[engine];
    updateLockUI(engine);
    saveLockState();
}

function updateLockUI(engine) {
    // Handle case sensitivity: 'smc' -> 'SMC', 'zone' -> 'Zone', 'momentum' -> 'Momentum'
    let idSuffix;
    if (engine === 'smc') {
        idSuffix = 'SMC';
    } else if (engine === 'zone') {
        idSuffix = 'Zone';
    } else if (engine === 'momentum') {
        idSuffix = 'Momentum';
    } else {
        idSuffix = engine.charAt(0).toUpperCase() + engine.slice(1);
    }
    
    const btn = document.getElementById('lock' + idSuffix);
    const slider = document.getElementById('weight' + idSuffix);
    const container = document.getElementById('slider' + idSuffix);
    
    if (ENGINE_LOCKS[engine]) {
        if (btn) {
            btn.textContent = '🔒';
            btn.classList.add('locked');
        }
        if (slider) slider.disabled = true;
        if (container) container.classList.add('locked');
    } else {
        if (btn) {
            btn.textContent = '🔓';
            btn.classList.remove('locked');
        }
        if (slider) slider.disabled = false;
        if (container) container.classList.remove('locked');
    }
}

function lockAllEngines() {
    ENGINE_LOCKS.zone = true;
    ENGINE_LOCKS.smc = true;
    ENGINE_LOCKS.momentum = true;
    updateLockUI('zone');
    updateLockUI('smc');
    updateLockUI('momentum');
    saveLockState();
    toast('🔒 All engines locked', 'success');
}

function unlockAllEngines() {
    ENGINE_LOCKS.zone = false;
    ENGINE_LOCKS.smc = false;
    ENGINE_LOCKS.momentum = false;
    updateLockUI('zone');
    updateLockUI('smc');
    updateLockUI('momentum');
    saveLockState();
    toast('🔓 All engines unlocked', 'success');
}

function saveLockState() {
    try {
        localStorage.setItem('bybit_scanner_engine_locks', JSON.stringify(ENGINE_LOCKS));
    } catch (e) {
        console.error('Failed to save lock state:', e);
    }
}

function loadLockState() {
    try {
        const saved = localStorage.getItem('bybit_scanner_engine_locks');
        if (saved) {
            const locks = JSON.parse(saved);
            ENGINE_LOCKS.zone = locks.zone || false;
            ENGINE_LOCKS.smc = locks.smc || false;
            ENGINE_LOCKS.momentum = locks.momentum || false;
        }
        updateLockUI('zone');
        updateLockUI('smc');
        updateLockUI('momentum');
    } catch (e) {
        console.error('Failed to load lock state:', e);
    }
}

function applyTheme() {
    if (STATE.oledTheme) {
        document.body.classList.add('oled');
    } else {
        document.body.classList.remove('oled');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ADVANCED TELEGRAM ALERT SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Update Telegram stats display
function updateTelegramStats() {
    const sent = document.getElementById('tgStatSent');
    const skipped = document.getElementById('tgStatSkipped');
    const errors = document.getElementById('tgStatErrors');
    if (sent) sent.textContent = STATE.telegramStats.sent;
    if (skipped) skipped.textContent = STATE.telegramStats.skipped;
    if (errors) errors.textContent = STATE.telegramStats.errors;
}

// Check if signal meets minimum grade
function meetsMinGrade(grade) {
    const gradeOrder = ['HEATING', 'VALID', 'STRONG', 'PERFECT'];
    const signalIndex = gradeOrder.indexOf(grade);
    const minIndex = gradeOrder.indexOf(STATE.telegramMinGrade);
    return signalIndex >= minIndex;
}

// Check quiet hours
function isQuietHours() {
    if (!STATE.telegramQuietStart || !STATE.telegramQuietEnd) return false;
    const hour = new Date().getHours();
    const start = parseInt(STATE.telegramQuietStart);
    const end = parseInt(STATE.telegramQuietEnd);
    if (start < end) return hour >= start && hour < end;
    return hour >= start || hour < end;
}

// Check cooldown for symbol
function checkTelegramCooldown(symbol, direction) {
    const key = `${symbol}_${direction}`;
    const lastSent = STATE.telegramCooldowns.get(key);
    const cooldownMs = STATE.telegramCooldown * 60 * 1000;
    if (lastSent && Date.now() - lastSent < cooldownMs) {
        return false;
    }
    return true;
}

// Set cooldown after sending
function setTelegramCooldown(symbol, direction) {
    const key = `${symbol}_${direction}`;
    STATE.telegramCooldowns.set(key, Date.now());
    // Clean old entries
    const cutoff = Date.now() - STATE.telegramCooldown * 60 * 1000 * 2;
    for (const [k, v] of STATE.telegramCooldowns) {
        if (v < cutoff) STATE.telegramCooldowns.delete(k);
    }
}

// Format price for Telegram
function fmtTgPrice(price, symbol) {
    if (!price || isNaN(price)) return 'N/A';
    if (symbol?.includes('BTC')) return price >= 1000 ? price.toLocaleString('en-US', {maximumFractionDigits: 0}) : price.toFixed(2);
    if (price >= 10000) return price.toLocaleString('en-US', {maximumFractionDigits: 0});
    if (price >= 1000) return price.toFixed(1);
    if (price >= 1) return price.toFixed(4);
    if (price >= 0.01) return price.toFixed(6);
    return price.toFixed(8);
}

// Build CREAM/PERFECT VIP alert
function buildCreamAlert(sig) {
    const coin = (sig.symbol || '').replace('USDT', '').replace(/[_*`]/g, '');
    const dir = sig.direction;
    const levels = sig.levels || {};
    
    return `💎💎💎 *CREAM SIGNAL* 💎💎💎

🏆 *${coin}/USDT* - *${dir}*

✨ *ALL CONDITIONS PERFECT:*
• Score: ${sig.score || 0}/100 ✅
• Grade: ${sig.grade} ✅
• Agreement: ${sig.agreed || 0}/3

💰 *TRADE SETUP:*
▶️ Entry: $${fmtTgPrice(levels.entry, sig.symbol)}
🛑 SL: $${fmtTgPrice(levels.sl, sig.symbol)}
🎯 TP1: $${fmtTgPrice(levels.tp1, sig.symbol)}
🎯 TP2: $${fmtTgPrice(levels.tp2, sig.symbol)}
🎯 TP3: $${fmtTgPrice(levels.tp3, sig.symbol)}

⚖️ R:R = 1:${levels.rr || 'N/A'}

⚡ *ACTION:* High confidence setup!

🔥 _BS Scanner V19 ULTRA_`;
}

// Build detailed alert
function buildDetailedAlert(sig) {
    const coin = (sig.symbol || '').replace('USDT', '').replace(/[_*`]/g, '');
    const dir = sig.direction;
    const dirEmoji = dir === 'LONG' ? '🟢' : '🔴';
    const gradeEmoji = sig.grade === 'PERFECT' ? '👑' : sig.grade === 'STRONG' ? '💪' : '✅';
    const levels = sig.levels || {};
    
    let msg = `${dirEmoji} *${sig.grade} SIGNAL* ${gradeEmoji}

📊 *${coin}/USDT* - ${dir}
⏱️ TF: ${sig.tf || 'N/A'}
📈 Score: ${sig.score || 0}/100
🎯 Agreement: ${sig.agreed || 0}/3

*Confluence:*`;
    
    if (sig.hasLiquiditySweep) msg += `\n💥 Liquidity Sweep`;
    if (sig.hasLiquidityPool) msg += `\n📍 Pool Found`;
    if (sig.regime?.regime === 'TREND') msg += `\n📈 Trending Market`;
    
    msg += `

*Trade Levels:*
▶️ Entry: $${fmtTgPrice(levels.entry, sig.symbol)}
🛑 SL: $${fmtTgPrice(levels.sl, sig.symbol)}
🎯 TP1: $${fmtTgPrice(levels.tp1, sig.symbol)}
🎯 TP2: $${fmtTgPrice(levels.tp2, sig.symbol)}
🎯 TP3: $${fmtTgPrice(levels.tp3, sig.symbol)}

⚖️ R:R = 1:${levels.rr || 'N/A'}

🔥 _BS Scanner V19 ULTRA_`;
    return msg;
}

// Build simple alert
function buildSimpleAlert(sig) {
    const coin = (sig.symbol || '').replace('USDT', '').replace(/[_*`]/g, '');
    const dir = sig.direction;
    const dirEmoji = dir === 'LONG' ? '🟢' : '🔴';
    const levels = sig.levels || {};
    
    return `${dirEmoji} *${sig.grade}* - ${coin} ${dir}

📍 Entry: $${fmtTgPrice(levels.entry, sig.symbol)}
🛑 SL: $${fmtTgPrice(levels.sl, sig.symbol)}
🎯 TP1: $${fmtTgPrice(levels.tp1, sig.symbol)}

Score: ${sig.score || 0} | TF: ${sig.tf || 'N/A'}`;
}

// Build TP hit alert
function buildTPHitAlert(sig, tpNum, hitPrice, profitPct) {
    const coin = (sig.symbol || '').replace('USDT', '').replace(/[_*`]/g, '');
    const dirEmoji = sig.direction === 'LONG' ? '🟢' : '🔴';
    const tpEmoji = tpNum === 1 ? '🎯' : tpNum === 2 ? '🎯🎯' : '🏆';
    
    return `${tpEmoji} *TP${tpNum} HIT!* ${tpEmoji}

${dirEmoji} *${coin}* ${sig.direction}
💰 Price: $${fmtTgPrice(hitPrice, sig.symbol)}
📈 Profit: *+${profitPct.toFixed(2)}%*

${tpNum === 1 ? '➡️ Move SL to breakeven!' : tpNum === 2 ? '➡️ Trail stop!' : '🎉 Full target!'}`;
}

// Build SL hit alert
function buildSLHitAlert(sig, hitPrice, lossPct) {
    const coin = (sig.symbol || '').replace('USDT', '').replace(/[_*`]/g, '');
    const dirEmoji = sig.direction === 'LONG' ? '🟢' : '🔴';
    
    return `🛑 *STOP LOSS HIT* 🛑

${dirEmoji} *${coin}* ${sig.direction}
💰 SL: $${fmtTgPrice(hitPrice, sig.symbol)}
📉 Loss: *${lossPct.toFixed(2)}%*

💡 Review and move on.`;
}

// Build daily summary
function buildDailySummary() {
    const all = STATE.signals || [];
    const perfect = all.filter(s => s.grade === 'PERFECT').length;
    const strong = all.filter(s => s.grade === 'STRONG').length;
    const longs = all.filter(s => s.direction === 'LONG').length;
    const shorts = all.filter(s => s.direction === 'SHORT').length;
    
    return `📊 *DAILY SUMMARY*

🔢 Total: ${all.length}
👑 Perfect: ${perfect}
💪 Strong: ${strong}

🟢 Longs: ${longs}
🔴 Shorts: ${shorts}

📱 Sent: ${STATE.telegramStats.sent}
⏭️ Skipped: ${STATE.telegramStats.skipped}

🔥 _BS Scanner V19 ULTRA_`;
}

// Main send function - ADVANCED
async function sendTelegramAlert(signal) {
    // Check if enabled
    if (!STATE.telegramEnabled) {
        STATE.telegramStats.skipped++;
        updateTelegramStats();
        return;
    }
    
    if (!STATE.telegramToken || !STATE.telegramChatId) {
        STATE.telegramStats.skipped++;
        updateTelegramStats();
        return;
    }
    
    // Check quiet hours
    if (isQuietHours()) {
        console.log('📱 Quiet hours active');
        STATE.telegramStats.skipped++;
        updateTelegramStats();
        return;
    }
    
    // Check minimum grade
    if (!meetsMinGrade(signal.grade)) {
        console.log(`📱 Grade ${signal.grade} below minimum ${STATE.telegramMinGrade}`);
        STATE.telegramStats.skipped++;
        updateTelegramStats();
        return;
    }
    
    // Check cooldown
    if (!checkTelegramCooldown(signal.symbol, signal.direction)) {
        console.log(`📱 Cooldown active for ${signal.symbol}`);
        STATE.telegramStats.skipped++;
        updateTelegramStats();
        return;
    }
    
    // Build message based on settings
    let message;
    if (STATE.telegramCream && (signal.grade === 'PERFECT' || signal.score >= 90)) {
        message = buildCreamAlert(signal);
    } else if (STATE.telegramDetailed) {
        message = buildDetailedAlert(signal);
    } else {
        message = buildSimpleAlert(signal);
    }
    
    // Send
    try {
        const url = `https://api.telegram.org/bot${STATE.telegramToken}/sendMessage`;
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: STATE.telegramChatId,
                text: message,
                parse_mode: 'Markdown'
            })
        });
        const data = await response.json();
        
        if (data.ok) {
            console.log(`📱 Telegram sent: ${signal.symbol} ${signal.direction}`);
            setTelegramCooldown(signal.symbol, signal.direction);
            STATE.telegramStats.sent++;
        } else {
            console.log('📱 Telegram error:', data.description);
            STATE.telegramStats.errors++;
        }
        updateTelegramStats();
    } catch(e) {
        console.log('📱 Telegram failed:', e.message);
        STATE.telegramStats.errors++;
        updateTelegramStats();
    }
}

// Send TP hit alert
async function sendTPAlert(sig, tpNum, hitPrice, profitPct) {
    if (!STATE.telegramEnabled || !STATE.telegramTPAlerts) return;
    if (!STATE.telegramToken || !STATE.telegramChatId) return;
    
    const message = buildTPHitAlert(sig, tpNum, hitPrice, profitPct);
    try {
        await fetch(`https://api.telegram.org/bot${STATE.telegramToken}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ chat_id: STATE.telegramChatId, text: message, parse_mode: 'Markdown' })
        });
    } catch(e) { console.log('TP alert failed:', e); }
}

// Send SL hit alert
async function sendSLAlert(sig, hitPrice, lossPct) {
    if (!STATE.telegramEnabled || !STATE.telegramSLAlerts) return;
    if (!STATE.telegramToken || !STATE.telegramChatId) return;
    
    const message = buildSLHitAlert(sig, hitPrice, lossPct);
    try {
        await fetch(`https://api.telegram.org/bot${STATE.telegramToken}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ chat_id: STATE.telegramChatId, text: message, parse_mode: 'Markdown' })
        });
    } catch(e) { console.log('SL alert failed:', e); }
}

// Send daily summary
async function sendDailySummaryAlert() {
    if (!STATE.telegramEnabled || !STATE.telegramDailySummary) return;
    if (!STATE.telegramToken || !STATE.telegramChatId) return;
    
    const message = buildDailySummary();
    try {
        await fetch(`https://api.telegram.org/bot${STATE.telegramToken}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ chat_id: STATE.telegramChatId, text: message, parse_mode: 'Markdown' })
        });
    } catch(e) { console.log('Daily summary failed:', e); }
}

// Test Telegram connection - ADVANCED
async function testTelegramAdvanced() {
    const token = document.getElementById('telegramToken').value.trim();
    const chatId = document.getElementById('telegramChatId').value.trim();
    
    if (!token || !chatId) {
        toast('Enter Bot Token and Chat ID first!', 'error');
        return;
    }
    
    if (!token.includes(':')) {
        toast('❌ Invalid token format! Should be like: 123456789:ABCdefGHI...', 'error');
        return;
    }
    
    toast('📱 Testing Telegram connection...', '');
    
    try {
        const msg = `🔔 *Test Alert*

✅ BS Scanner V19 ULTRA connected!

🚗 _Advanced Telegram System Active_`;
        const url = `https://api.telegram.org/bot${token}/sendMessage`;
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: chatId,
                text: msg,
                parse_mode: 'Markdown'
            })
        });
        const data = await response.json();
        if (data.ok) {
            toast('✅ Telegram test successful!', 'success');
            // Save on success
            STATE.telegramToken = token;
            STATE.telegramChatId = chatId;
        } else {
            toast('❌ Telegram error: ' + (data.description || 'Unknown'), 'error');
            STATE.telegramStats.errors++;
            updateTelegramStats();
        }
    } catch(e) {
        toast('❌ Connection failed: ' + e.message, 'error');
        STATE.telegramStats.errors++;
        updateTelegramStats();
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// V11-CLEAN: DIRECTION TABS SYSTEM (Replaces View Toggle & Mode Tabs)
// ═══════════════════════════════════════════════════════════════════════════════

function setDirectionTab(direction) {
    STATE.directionTab = direction;
    
    // Update tab active states
    document.getElementById('dirTabLong').className = 'dir-tab long' + (direction === 'LONG' ? ' active' : '');
    document.getElementById('dirTabShort').className = 'dir-tab short' + (direction === 'SHORT' ? ' active' : '');
    
    // Update signal list to show only this direction
    updateSignalList();
    updateDirectionCounts();
}

function toggleDirectionDropdown(direction, event) {
    if (event) event.stopPropagation();
    
    const isOpen = STATE.directionDropdownOpen[direction];
    
    // Close all dropdowns first
    STATE.directionDropdownOpen.LONG = false;
    STATE.directionDropdownOpen.SHORT = false;
    document.getElementById('savedDropdownLong').style.display = 'none';
    document.getElementById('savedDropdownShort').style.display = 'none';
    document.getElementById('dirLongArrow').className = 'dir-tab-arrow';
    document.getElementById('dirShortArrow').className = 'dir-tab-arrow';
    
    // Toggle the clicked one
    if (!isOpen) {
        STATE.directionDropdownOpen[direction] = true;
        const dropdownId = direction === 'LONG' ? 'savedDropdownLong' : 'savedDropdownShort';
        const arrowId = direction === 'LONG' ? 'dirLongArrow' : 'dirShortArrow';
        document.getElementById(dropdownId).style.display = 'block';
        document.getElementById(arrowId).className = 'dir-tab-arrow open';
        
        // Update saved trades list for this direction
        updateSavedTradesDropdown(direction);
    }
}

function updateDirectionCounts() {
    const signals = STATE.signals || [];
    const longCount = signals.filter(s => s && s.direction === 'LONG').length;
    const shortCount = signals.filter(s => s && s.direction === 'SHORT').length;
    
    document.getElementById('dirLongCount').textContent = longCount;
    document.getElementById('dirShortCount').textContent = shortCount;
    
    // Update saved counts
    const saved = STATE.savedTrades || [];
    const longSaved = saved.filter(t => t && t.direction === 'LONG').length;
    const shortSaved = saved.filter(t => t && t.direction === 'SHORT').length;
    
    document.getElementById('dirLongSaved').textContent = '💾' + longSaved;
    document.getElementById('dirShortSaved').textContent = '💾' + shortSaved;
}

function updateSavedTradesDropdown(direction) {
    const listId = direction === 'LONG' ? 'savedLongList' : 'savedShortList';
    const listEl = document.getElementById(listId);
    if (!listEl) return;
    
    const saved = (STATE.savedTrades || []).filter(t => t && t.direction === direction);
    
    if (saved.length === 0) {
        listEl.innerHTML = `<div class="saved-empty">No saved ${direction} trades</div>`;
        return;
    }
    
    listEl.innerHTML = saved.map((trade) => {
        const pnl = trade.live?.pnlPercent || trade.currentPnl || 0;
        const pnlClass = pnl >= 0 ? 'profit' : 'loss';
        const pnlText = (pnl >= 0 ? '+' : '') + pnl.toFixed(2) + '%';
        const entry = trade.original?.entry || trade.entry || 0;
        const status = trade.live?.status || 'LOADING';
        const statusEmoji = status === 'IN_PROFIT' || status === 'STRONG_PROFIT' ? '🟢' : 
                           status === 'AT_RISK' || status === 'STOPPED_OUT' ? '🔴' : 
                           status === 'TP_HIT' ? '🎯' : '⏳';
        
        return `
            <div class="saved-mini-card ${direction.toLowerCase()}" onclick="viewSavedTrade(${trade.id})">
                <span class="smc-pair">${trade.symbol?.replace('USDT', '') || 'N/A'}</span>
                <span class="smc-entry">$${formatPrice(entry)}</span>
                <span class="smc-pnl ${pnlClass}">${pnlText}</span>
                <span class="smc-status">${statusEmoji}</span>
                <div class="smc-actions">
                    <button class="smc-btn delete" onclick="event.stopPropagation();deleteSavedTrade(${trade.id})">✕</button>
                </div>
            </div>
        `;
    }).join('');
}

// Update direction tab click handler to also handle arrow clicks
document.addEventListener('DOMContentLoaded', function() {
    // Add click handlers for arrows
    setTimeout(() => {
        const longArrow = document.getElementById('dirLongArrow');
        const shortArrow = document.getElementById('dirShortArrow');
        
        if (longArrow) {
            longArrow.addEventListener('click', (e) => toggleDirectionDropdown('LONG', e));
        }
        if (shortArrow) {
            shortArrow.addEventListener('click', (e) => toggleDirectionDropdown('SHORT', e));
        }
        
        // Initialize counts
        updateDirectionCounts();
    }, 500);
});

// Legacy function for backward compatibility
function setView(view) {
    // V11-CLEAN: Heatmap removed, always list view
    updateSignalList();
}

function setModeDeprecated(mode) {
    // V11-CLEAN: Mode tabs removed, use direction tabs instead
    // This function kept for backward compatibility only
    console.log('V11-CLEAN: setMode deprecated, use setDirectionTab instead');
}

// Legacy selectSignalByKey for any remaining references
function selectSignalByKey(symbol, tf) {
    const idx = STATE.signals.findIndex(s => s.symbol === symbol && s.tf === tf);
    if (idx >= 0) {
        selectSignal(idx);
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// RISK CALCULATOR
// ═══════════════════════════════════════════════════════════════════════════════

function calculatePositionSize(signal) {
    if (!signal) return null;
    
    const account = STATE.riskAccount;
    const riskPct = STATE.riskPercent / 100;
    const leverage = STATE.riskLeverage;
    const maxPos = STATE.riskMaxPosition;
    
    const riskAmount = account * riskPct;
    const slDistance = Math.abs(signal.levels.entry - signal.levels.sl) / signal.levels.entry;
    
    let positionSize = riskAmount / slDistance;
    positionSize = Math.min(positionSize, maxPos);
    
    const margin = positionSize / leverage;
    
    return {
        positionSize: positionSize.toFixed(2),
        margin: margin.toFixed(2),
        riskAmount: riskAmount.toFixed(2),
        leverage: leverage
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// INITIALIZATION
// ═══════════════════════════════════════════════════════════════════════════════

async function init() {
    console.log('🚀 Bybit Scanner v9.5 Starting...');
    
    // Load saved data
    loadSettings();
    loadTrades();
    loadLockState();
    updateTradeList();
    
    // Restore panel states
    restoreBacktestState();
    restoreFlowState();
    
    // Fetch BTC price and all market data
    await fetchBTC();
    await fetchAllMarketData();
    
    // Fetch Open Interest data
    await fetchBTCOpenInterest();
    
    // Initialize environment system
    await updateEnvironment();
    
    // Fetch crypto news for awareness
    await fetchCryptoNews();
    
    // BUG FIX #4: Track intervals for cleanup
    if (!window.scannerIntervals) {
        window.scannerIntervals = [];
    }
    
    // Clear any existing intervals (prevents stacking on hot reload)
    window.scannerIntervals.forEach(id => clearInterval(id));
    window.scannerIntervals = [];
    
    // Start auto-refresh with tracked intervals
    window.scannerIntervals.push(setInterval(fetchBTC, 30000));
    window.scannerIntervals.push(setInterval(fetchAllMarketData, 60000));  // Update market badges every minute
    window.scannerIntervals.push(setInterval(updateTradePrices, 30000));
    window.scannerIntervals.push(setInterval(updateEnvironment, 60000));  // Update environment every minute
    window.scannerIntervals.push(setInterval(fetchBTCOpenInterest, 60000));  // Update OI every minute
    window.scannerIntervals.push(setInterval(fetchLiquidations, 120000)); // Update liquidations every 2 min
    window.scannerIntervals.push(setInterval(fetchCryptoNews, 3600000));  // Update news every hour
    
    // Start scanning
    STATE.scanning = true;
    document.getElementById('scanBtn').className = 'btn scanning';
    document.getElementById('scanIcon').textContent = '◉';
    
    // 🧠 Initialize Intelligent Brains
    initIntelligentBrains();
    
    // 🔥 Initialize Phase 1 Live Data System
    initPhase1LiveData();
    
    runScanner();
    
    console.log('🧠 BS Scanner V10.1 - Coin Personality + Adaptive Learning! Each coin is unique! 🔥');
}

// BUG FIX #4: Cleanup intervals on page unload
window.addEventListener('beforeunload', () => {
    if (window.scannerIntervals) {
        window.scannerIntervals.forEach(id => clearInterval(id));
    }
});

// Start when DOM is ready
document.addEventListener('DOMContentLoaded', init);

// ═══════════════════════════════════════════════════════════════════════════════
// PWA SERVICE WORKER (Offline Support + Install as App)
// ═══════════════════════════════════════════════════════════════════════════════

// Register Service Worker for PWA
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        // Create inline service worker
        const swCode = `
            const CACHE_NAME = 'bs-scanner-v1';
            const urlsToCache = ['/'];
            
            self.addEventListener('install', e => {
                e.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache)));
                self.skipWaiting();
            });
            
            self.addEventListener('fetch', e => {
                e.respondWith(
                    fetch(e.request).catch(() => caches.match(e.request))
                );
            });
            
            self.addEventListener('activate', e => {
                e.waitUntil(clients.claim());
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl).then(reg => {
            console.log('✅ PWA Service Worker registered');
        }).catch(err => {
            console.log('PWA registration skipped (local file)');
        });
    });
}

// PWA Install Prompt
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    console.log('📱 App can be installed! Use browser menu > Add to Home Screen');
});

// ═══════════════════════════════════════════════════════════════════════════════
// TRADE HISTORY FEATURE
// ═══════════════════════════════════════════════════════════════════════════════

function showTradeHistory() {
    const history = STATE.tradeHistory || [];
    const stats = getTradeStats();
    
    let historyItems = '';
    if (history.length === 0) {
        historyItems = '<div style="text-align:center;color:var(--text3);padding:20px">No trade history yet</div>';
    } else {
        history.forEach(t => {
            const pnl = parseFloat(t.pnlPercent || 0);
            const resultClass = pnl > 0 ? 'long' : pnl < 0 ? 'short' : 'text3';
            const resultIcon = pnl > 0 ? '✅' : pnl < 0 ? '❌' : '⏹️';
            const date = new Date(t.closedAt || t.timestamp).toLocaleDateString();
            const pnlStr = t.pnlPercent ? (pnl >= 0 ? '+' : '') + t.pnlPercent + '%' : '--';
            const dirClass = t.direction === 'LONG' ? 'long' : 'short';
            
            historyItems += '<div style="display:flex;align-items:center;gap:8px;padding:8px;background:var(--bg3);border-radius:6px;margin-bottom:6px;border-left:3px solid var(--' + resultClass + ')">' +
                '<span style="font-size:16px">' + resultIcon + '</span>' +
                '<div style="flex:1">' +
                    '<div style="font-weight:600;font-size:13px">' + t.symbol.replace('USDT', '') + ' <span style="color:var(--' + dirClass + ');font-size:11px">' + t.direction + '</span></div>' +
                    '<div style="font-size:10px;color:var(--text3)">' + t.tf + ' • ' + t.grade + ' • ' + date + '</div>' +
                '</div>' +
                '<div style="text-align:right">' +
                    '<div style="font-weight:700;color:var(--' + (pnl >= 0 ? 'long' : 'short') + ')">' + pnlStr + '</div>' +
                    '<div style="font-size:10px;color:var(--text3)">P&L</div>' +
                '</div>' +
            '</div>';
        });
    }
    
    const pnlColor = parseFloat(stats.totalPnL) >= 0 ? 'var(--long)' : 'var(--short)';
    const pnlSign = parseFloat(stats.totalPnL) >= 0 ? '+' : '';
    
    const modalHtml = '<div class="modal-bg show" id="historyModal" onclick="if(event.target.id===\'historyModal\')closeHistoryModal()">' +
        '<div class="modal" style="max-width:500px;max-height:80vh;overflow:hidden;display:flex;flex-direction:column">' +
            '<div class="modal-head">' +
                '<div class="modal-title">📊 Trade History</div>' +
                '<button class="modal-close" onclick="closeHistoryModal()">✕</button>' +
            '</div>' +
            '<div style="padding:12px;border-bottom:1px solid var(--border)">' +
                '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;text-align:center">' +
                    '<div style="background:var(--bg3);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:var(--gold)">' + stats.total + '</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Total</div>' +
                    '</div>' +
                    '<div style="background:var(--long-dim);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:var(--long)">' + stats.profitable + '</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Profit</div>' +
                    '</div>' +
                    '<div style="background:var(--short-dim);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:var(--short)">' + stats.losing + '</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Loss</div>' +
                    '</div>' +
                    '<div style="background:var(--bg3);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:' + pnlColor + '">' + pnlSign + stats.totalPnL + '%</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Total P&L</div>' +
                    '</div>' +
                '</div>' +
            '</div>' +
            '<div style="flex:1;overflow-y:auto;padding:12px">' + historyItems + '</div>' +
            '<div class="modal-foot">' +
                '<button class="btn" onclick="clearTradeHistory()">🗑️ Clear</button>' +
                '<button class="btn primary" onclick="closeHistoryModal()">Close</button>' +
            '</div>' +
        '</div>' +
    '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeHistoryModal() {
    const modal = document.getElementById('historyModal');
    if (modal) modal.remove();
}

function clearTradeHistory() {
    if (confirm('Are you sure you want to clear all trade history?')) {
        STATE.tradeHistory = [];
        saveTradeHistory();
        closeHistoryModal();
        showTradeHistory();
        toast('Trade history cleared', 'success');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════════════════════════
// ██████╗ ███████╗    ███████╗ ██████╗ █████╗ ███╗   ██╗███╗   ██╗███████╗██████╗     ██╗   ██╗ ██╗ ██╗
// ██╔══██╗██╔════╝    ██╔════╝██╔════╝██╔══██╗████╗  ██║████╗  ██║██╔════╝██╔══██╗    ██║   ██║███║███║
// ██████╔╝███████╗    ███████╗██║     ███████║██╔██╗ ██║██╔██╗ ██║█████╗  ██████╔╝    ██║   ██║╚██║╚██║
// ██╔══██╗╚════██║    ╚════██║██║     ██╔══██║██║╚██╗██║██║╚██╗██║██╔══╝  ██╔══██╗    ╚██╗ ██╔╝ ██║ ██║
// ██████╔╝███████║    ███████║╚██████╗██║  ██║██║ ╚████║██║ ╚████║███████╗██║  ██║     ╚████╔╝  ██║ ██║
// ╚═════╝ ╚══════╝    ╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝      ╚═══╝   ╚═╝ ╚═╝
// ULTIMATE BACKTEST ENGINE V11 - COMPLETE REWRITE
// ═══════════════════════════════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════════
// MASTER CONFIG - ALL COINS & TIMEFRAMES
// ═══════════════════════════════════════════════════════════════════════════════
const UB_CONFIG = {
    // ═══════════════════════════════════════════════════════════════════════════
    // 150 MOST LIQUID BYBIT PERPETUAL COINS (VERIFIED)
    // ═══════════════════════════════════════════════════════════════════════════
    ALL_COINS: [
        // TIER 1 - Ultra Liquid (10)
        'BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'BNBUSDT', 'XRPUSDT', 'ADAUSDT', 'AVAXUSDT', 'DOTUSDT', 'LINKUSDT',
        // TIER 2 - Major Alts (20)
        'MATICUSDT', 'LTCUSDT', 'ATOMUSDT', 'NEARUSDT', 'APTUSDT', 'ARBUSDT', 'OPUSDT', 'INJUSDT', 'SUIUSDT', 'SEIUSDT',
        'TIAUSDT', 'RUNEUSDT', 'FTMUSDT', 'SANDUSDT', 'MANAUSDT', 'GALAUSDT', 'AXSUSDT', 'ETCUSDT', 'FILUSDT', 'ICPUSDT',
        // TIER 3 - Mid Caps (30)
        'XLMUSDT', 'TRXUSDT', 'XMRUSDT', 'AAVEUSDT', 'UNIUSDT', 'MKRUSDT', 'SNXUSDT', 'COMPUSDT', 'CRVUSDT', 'LDOUSDT',
        'FETUSDT', 'AGIXUSDT', 'RNDRUSDT', 'BLURUSDT', 'CFXUSDT', 'STXUSDT', 'EGLDUSDT', 'KASUSDT', 'WLDUSDT', 'JUPUSDT',
        'PYTHUSDT', 'ONDOUSDT', 'ENAUSDT', 'PENDLEUSDT', 'STRKUSDT', 'ZKUSDT', 'WUSDT', 'ZETAUSDT', 'EIGENUSDT', 'MOVEUSDT',
        // TIER 4 - Gaming (NO MEMES)
        'ORDIUSDT', 'IMXUSDT', 'FLOWUSDT', 'ENJUSDT', 'CHZUSDT', 'APEUSDT', 'GMTUSDT', 'YGGUSDT', 'PIXELUSDT', 'PORTALUSDT', 'XAIUSDT',
        // TIER 5 - DeFi & Infrastructure (30)
        'SUSHIUSDT', '1INCHUSDT', 'DYDXUSDT', 'GMXUSDT', 'PERPUSDT', 'RADUSDT', 'UMAUSDT', 'BALUSDT', 'YFIUSDT',
        'KNCUSDT', 'ZRXUSDT', 'OGNUSDT', 'CELOUSDT', 'KSMUSDT', 'MINAUSDT', 'ROSEUSDT', 'QNTUSDT', 'OCEANUSDT', 'GRTUSDT',
        'ILVUSDT', 'API3USDT', 'BANDUSDT', 'STORJUSDT', 'SCUSDT', 'ARUSDT', 'HNTUSDT', 'IOTAUSDT', 'ZILUSDT', 'VETUSDT',
        // TIER 6 - Layer 2 & Scaling (20)
        'METISUSDT', 'MANTAUSDT', 'ALTUSDT', 'BLASTUSDT', 'MODEUSDT', 'SCROLLUSDT', 'LINEAUSDT', 'TAIKOUSDT', 'ZKSYNCUSDT', 'BELUSDT',
        'CELRUSDT', 'CTSIUSDT', 'SKLUSDT', 'BTTUSDT', 'GLMUSDT', 'RLCUSDT', 'ANKRUSDT', 'POWRUSDT', 'NMRUSDT', 'REQUSDT',
        // TIER 7 - AI & New Narratives (20)
        'TAOUSDT', 'ARKMUSDT', 'VIRTUSDT', 'AI16ZUSDT', 'GRIFFAINUSDT', 'FABORICUSDT', 'ACUSDT', 'NFPUSDT', 'AIUSDT', 'PHAUSDT',
        'RSRUSDT', 'TRUUSDT', 'ACEUSDT', 'DYMUSDT', 'MAVUSDT', 'NTRNUSDT', 'ASTRUSDT', 'MAGICUSDT', 'SAGAUSDT', 'VANRYUSDT'
    ],
    ALL_TFS: ['5', '15', '30', '60', '240', 'D'],
    ULTRA_TFS: ['5', '15', '30', '60', '240'], // 5m to 4H (no Daily for speed)
    TF_LABELS: { '5': '5m', '15': '15m', '30': '30m', '60': '1H', '240': '4H', 'D': '1D' },
    
    // DEFAULT SETTINGS (user can change)
    settings: {
        ultraCoins: 150,
        ultraTFs: ['5', '15', '30', '60', '240'],
        fastCoins: 20,
        fastTFs: ['60', '240'],
        deepCoins: 10,
        deepTFs: ['15', '60', '240'],
        minScore: 60,
        minTrades: 3,
        chopFilter: true,
        slippagePct: 0.1,
        paranoidMode: true
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 1: COST MODEL
// ═══════════════════════════════════════════════════════════════════════════════
const CostModel = {
    config: { makerFee: 0.0002, takerFee: 0.00055, baseSlippage: 0.0001 },
    getSpreadByTier(symbol) {
        const tier1 = ['BTCUSDT', 'ETHUSDT'];
        const tier2 = ['SOLUSDT', 'BNBUSDT', 'XRPUSDT'];
        if (tier1.includes(symbol)) return 0.00005;
        if (tier2.includes(symbol)) return 0.0001;
        return 0.0002;
    },
    calculateTotalCosts(entryPrice, exitPrice, size, symbol, isLimit = false) {
        const entryFee = entryPrice * size * (isLimit ? this.config.makerFee : this.config.takerFee);
        const exitFee = exitPrice * size * this.config.takerFee;
        return entryFee + exitFee;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 2: BACKTEST STATISTICS ENGINE
// ═══════════════════════════════════════════════════════════════════════════════
const BacktestStatistics = {
    calculate(trades, initialCapital = 10000) {
        if (!trades || trades.length === 0) return this.emptyStats();
        
        // Normalize trades - handle both netPnl and pnl formats
        const normalizedTrades = trades.map(t => ({
            ...t,
            netPnl: t.netPnl !== undefined ? t.netPnl : (t.pnl !== undefined ? t.pnl - 0.2 : 0)
        }));
        
        const wins = normalizedTrades.filter(t => t.netPnl > 0);
        const losses = normalizedTrades.filter(t => t.netPnl <= 0);
        const totalPnl = normalizedTrades.reduce((sum, t) => sum + t.netPnl, 0);
        const grossProfit = wins.reduce((sum, t) => sum + t.netPnl, 0);
        const grossLoss = Math.abs(losses.reduce((sum, t) => sum + t.netPnl, 0));
        
        let equity = initialCapital, peak = equity, maxDrawdown = 0, maxDrawdownPct = 0;
        const equityCurve = [{ equity, drawdown: 0 }];
        
        for (const trade of normalizedTrades) {
            equity += trade.netPnl;
            peak = Math.max(peak, equity);
            const dd = peak - equity;
            const ddPct = peak > 0 ? (dd / peak) * 100 : 0;
            maxDrawdown = Math.max(maxDrawdown, dd);
            maxDrawdownPct = Math.max(maxDrawdownPct, ddPct);
            equityCurve.push({ equity, drawdown: ddPct });
        }
        
        const returns = normalizedTrades.map(t => t.netPnl / initialCapital);
        const avgReturn = returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0;
        const stdDev = returns.length > 0 ? Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length) : 0;
        const riskFreeRate = 0.02 / 252;
        const sharpeRatio = stdDev > 0 ? ((avgReturn - riskFreeRate) / stdDev) * Math.sqrt(252) : 0;
        
        const negReturns = returns.filter(r => r < 0);
        const downsideDev = negReturns.length > 0 ? Math.sqrt(negReturns.reduce((sum, r) => sum + r * r, 0) / negReturns.length) : 0.001;
        const sortinoRatio = downsideDev > 0 ? ((avgReturn - riskFreeRate) / downsideDev) * Math.sqrt(252) : 0;
        const calmarRatio = maxDrawdownPct > 0 ? (totalPnl / initialCapital * 100) / maxDrawdownPct : 0;
        const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? 999 : 0;
        
        let maxConsecWins = 0, maxConsecLosses = 0, consecWins = 0, consecLosses = 0;
        for (const t of normalizedTrades) {
            if (t.netPnl > 0) { consecWins++; consecLosses = 0; maxConsecWins = Math.max(maxConsecWins, consecWins); }
            else { consecLosses++; consecWins = 0; maxConsecLosses = Math.max(maxConsecLosses, consecLosses); }
        }
        
        const avgWin = wins.length > 0 ? grossProfit / wins.length : 0;
        const avgLoss = losses.length > 0 ? grossLoss / losses.length : 0;
        const avgRR = avgLoss > 0 ? avgWin / avgLoss : 0;
        const winRate = normalizedTrades.length > 0 ? (wins.length / normalizedTrades.length) * 100 : 0;
        const expectancy = (winRate / 100 * avgWin) - ((100 - winRate) / 100 * avgLoss);
        
        return {
            totalTrades: normalizedTrades.length, wins: wins.length, losses: losses.length,
            winRate: winRate.toFixed(1), totalPnl: totalPnl.toFixed(2),
            totalPnlPct: ((totalPnl / initialCapital) * 100).toFixed(2),
            grossProfit: grossProfit.toFixed(2), grossLoss: grossLoss.toFixed(2),
            profitFactor: profitFactor.toFixed(2), maxDrawdown: maxDrawdown.toFixed(2),
            maxDrawdownPct: maxDrawdownPct.toFixed(2), sharpeRatio: sharpeRatio.toFixed(2),
            sortinoRatio: sortinoRatio.toFixed(2), calmarRatio: calmarRatio.toFixed(2),
            avgWin: avgWin.toFixed(2), avgLoss: avgLoss.toFixed(2), avgRR: avgRR.toFixed(2),
            expectancy: expectancy.toFixed(2), maxConsecWins, maxConsecLosses,
            equityCurve, finalEquity: equity.toFixed(2)
        };
    },
    emptyStats() {
        return { totalTrades: 0, wins: 0, losses: 0, winRate: '0', totalPnl: '0', totalPnlPct: '0',
            grossProfit: '0', grossLoss: '0', profitFactor: '0', maxDrawdown: '0', maxDrawdownPct: '0',
            sharpeRatio: '0', sortinoRatio: '0', calmarRatio: '0', avgWin: '0', avgLoss: '0',
            avgRR: '0', expectancy: '0', maxConsecWins: 0, maxConsecLosses: 0, equityCurve: [], finalEquity: '10000' };
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 2B: EV LEARNING ENGINE - V12 CORE INNOVATION
// ═══════════════════════════════════════════════════════════════════════════════
// This is the key insight: Score should be DERIVED from outcomes, not designed
// ═══════════════════════════════════════════════════════════════════════════════
const EVLearner = {
    // Storage
    outcomes: [],           // All signal/outcome pairs
    evBins: {},             // Learned EV per feature combo
    isBootstrapped: false,
    bootstrapStats: null,
    
    // Feature extraction from signal
    extractFeatures(signal) {
        if (!signal) return null;
        
        return {
            // Discretize continuous features into bins
            zoneStrengthBin: signal.zoneStrength >= 30 ? 'high' : signal.zoneStrength >= 15 ? 'medium' : 'low',
            confirmationsBin: signal.confirmations >= 5 ? 'high' : signal.confirmations >= 3 ? 'medium' : 'low',
            rsiBin: signal.rsiValue <= 30 ? 'oversold' : signal.rsiValue >= 70 ? 'overbought' : 'neutral',
            volSpike: signal.volSpike ? 'yes' : 'no',
            direction: signal.direction,
            grade: signal.grade,
            mode: signal.mode || 'UNKNOWN',
            hasLiqSweep: signal.confirmList?.includes('LiqSweep') ? 'yes' : 'no',
            hasDivergence: (signal.confirmList?.includes('BullDiv') || signal.confirmList?.includes('BearDiv')) ? 'yes' : 'no',
            rrBin: signal.rr >= 2.5 ? 'high' : signal.rr >= 1.5 ? 'medium' : 'low',
            slQualityBin: signal.slQuality >= 5 ? 'good' : signal.slQuality >= 0 ? 'ok' : 'poor',
            tpQualityBin: signal.tpQuality >= 5 ? 'good' : signal.tpQuality >= 0 ? 'ok' : 'poor'
        };
    },
    
    // Create bin key from features
    createBinKey(features) {
        if (!features) return 'unknown';
        return `${features.zoneStrengthBin}_${features.confirmationsBin}_${features.rsiBin}_${features.hasLiqSweep}_${features.direction}`;
    },
    
    // Store outcome
    recordOutcome(signal, outcome) {
        const features = this.extractFeatures(signal);
        if (!features || !outcome) return;
        
        this.outcomes.push({
            features,
            binKey: this.createBinKey(features),
            actualR: outcome.rr || 0,
            won: outcome.won || false,
            pnl: outcome.pnl || 0,
            timestamp: Date.now()
        });
    },
    
    // Learn EV from collected outcomes
    learnEV() {
        if (this.outcomes.length < 20) {
            console.warn('[EV LEARNER] Need at least 20 outcomes to learn, have:', this.outcomes.length);
            return false;
        }
        
        // Group by bin key
        const bins = {};
        for (const o of this.outcomes) {
            if (!bins[o.binKey]) {
                bins[o.binKey] = { outcomes: [], totalR: 0, wins: 0, count: 0 };
            }
            bins[o.binKey].outcomes.push(o);
            bins[o.binKey].totalR += o.actualR;
            bins[o.binKey].wins += o.won ? 1 : 0;
            bins[o.binKey].count++;
        }
        
        // Calculate EV per bin
        for (const [key, bin] of Object.entries(bins)) {
            bin.expectedR = bin.count > 0 ? bin.totalR / bin.count : 0;
            bin.winRate = bin.count > 0 ? (bin.wins / bin.count) * 100 : 0;
            bin.sampleSize = bin.count;
            
            // Kelly criterion for optimal sizing
            const p = bin.winRate / 100;
            const avgWin = bin.outcomes.filter(o => o.won).reduce((s, o) => s + o.actualR, 0) / Math.max(1, bin.wins);
            const avgLoss = Math.abs(bin.outcomes.filter(o => !o.won).reduce((s, o) => s + o.actualR, 0)) / Math.max(1, bin.count - bin.wins);
            bin.kellyFraction = avgLoss > 0 ? (p * avgWin - (1 - p) * avgLoss) / avgLoss : 0;
            bin.kellyFraction = Math.max(0, Math.min(0.25, bin.kellyFraction)); // Cap at 25%
        }
        
        this.evBins = bins;
        console.log(`[EV LEARNER] Learned EV for ${Object.keys(bins).length} bins from ${this.outcomes.length} outcomes`);
        return true;
    },
    
    // Get all EVs for percentile calculation
    getAllEVs() {
        return Object.values(this.evBins)
            .filter(b => b.sampleSize >= 5) // Only bins with enough data
            .map(b => b.expectedR)
            .sort((a, b) => a - b);
    },
    
    // Derive score from learned EV (percentile rank)
    getLearnedScore(signal) {
        const features = this.extractFeatures(signal);
        if (!features) return 50; // Default
        
        const binKey = this.createBinKey(features);
        const bin = this.evBins[binKey];
        
        if (!bin || bin.sampleSize < 3) {
            // Not enough data for this bin - use fallback
            return this.getFallbackScore(signal);
        }
        
        // Calculate percentile rank of this bin's EV
        const allEVs = this.getAllEVs();
        if (allEVs.length === 0) return 50;
        
        const rank = allEVs.filter(ev => ev < bin.expectedR).length;
        const percentile = (rank / allEVs.length) * 100;
        
        // Scale to 0-100 score
        return Math.round(percentile);
    },
    
    // Fallback scoring when no learned data
    getFallbackScore(signal) {
        if (!signal) return 40;
        
        // Use original formula as fallback
        let score = 40 + (signal.zoneStrength || 0) + ((signal.confirmations || 0) * 8);
        score += (signal.slQuality || 0) + (signal.tpQuality || 0);
        return Math.min(100, Math.max(0, Math.round(score)));
    },
    
    // Bootstrap from historical backtest
    async bootstrap(coins, timeframes, progressCallback) {
        console.log('[EV LEARNER] Starting bootstrap...');
        this.outcomes = [];
        
        const totalPairs = coins.length * timeframes.length;
        let completed = 0;
        let totalSignals = 0;
        let totalOutcomes = 0;
        
        for (const coin of coins) {
            for (const tf of timeframes) {
                completed++;
                const progress = Math.round((completed / totalPairs) * 100);
                
                if (progressCallback) {
                    progressCallback({
                        phase: 'collecting',
                        progress,
                        coin,
                        tf,
                        signals: totalSignals,
                        outcomes: totalOutcomes
                    });
                }
                
                try {
                    const candles = await fetchKlines(coin, tf, 1000);
                    if (!candles || candles.length < 150) continue;
                    
                    // Walk through history
                    for (let i = 100; i < candles.length - 20; i += 3) {
                        const slice = candles.slice(Math.max(0, i - 100), i);
                        if (!slice || slice.length < 100) continue;
                        
                        try {
                            // Get signal with WIDE gate (collect everything)
                            const signal = quickSignalCheck(slice, coin, tf);
                            if (!signal) continue;
                            totalSignals++;
                            
                            // Get outcome
                            const future = candles.slice(i + 1, i + 21);
                            if (!future || future.length < 5) continue;
                            
                            const outcome = simulateTradeOutcome(signal, future);
                            if (!outcome) continue;
                            
                            // Record for learning
                            this.recordOutcome(signal, outcome);
                            totalOutcomes++;
                            
                        } catch (e) { /* skip */ }
                    }
                    
                    // Small delay to prevent UI freeze
                    await new Promise(r => setTimeout(r, 10));
                    
                } catch (e) {
                    console.warn(`[EV LEARNER] Error fetching ${coin} ${tf}:`, e.message);
                }
            }
        }
        
        console.log(`[EV LEARNER] Collected ${totalOutcomes} outcomes from ${totalSignals} signals`);
        
        // Now learn EV
        if (progressCallback) {
            progressCallback({ phase: 'learning', progress: 100, signals: totalSignals, outcomes: totalOutcomes });
        }
        
        const learned = this.learnEV();
        
        if (learned) {
            this.isBootstrapped = true;
            
            // Calculate bootstrap stats
            const allEVs = this.getAllEVs();
            const binCount = Object.keys(this.evBins).length;
            const profitableBins = Object.values(this.evBins).filter(b => b.expectedR > 0).length;
            
            this.bootstrapStats = {
                totalOutcomes: this.outcomes.length,
                binCount,
                profitableBins,
                unprofitableBins: binCount - profitableBins,
                avgEV: allEVs.length > 0 ? (allEVs.reduce((a, b) => a + b, 0) / allEVs.length).toFixed(3) : 0,
                bestBinEV: allEVs.length > 0 ? allEVs[allEVs.length - 1].toFixed(3) : 0,
                worstBinEV: allEVs.length > 0 ? allEVs[0].toFixed(3) : 0,
                timestamp: Date.now()
            };
            
            console.log('[EV LEARNER] Bootstrap complete:', this.bootstrapStats);
        }
        
        return {
            success: learned,
            outcomes: totalOutcomes,
            signals: totalSignals,
            bins: Object.keys(this.evBins).length,
            stats: this.bootstrapStats
        };
    },
    
    // Get bin details for display
    getBinDetails() {
        return Object.entries(this.evBins)
            .map(([key, bin]) => ({
                binKey: key,
                expectedR: bin.expectedR.toFixed(3),
                winRate: bin.winRate.toFixed(1) + '%',
                sampleSize: bin.sampleSize,
                kelly: (bin.kellyFraction * 100).toFixed(1) + '%',
                grade: bin.expectedR >= 0.5 ? 'EXCELLENT' : bin.expectedR >= 0.2 ? 'GOOD' : bin.expectedR >= 0 ? 'MARGINAL' : 'AVOID'
            }))
            .sort((a, b) => parseFloat(b.expectedR) - parseFloat(a.expectedR));
    },
    
    // Save to localStorage
    save() {
        try {
            localStorage.setItem('evLearner_outcomes', JSON.stringify(this.outcomes.slice(-5000))); // Keep last 5000
            localStorage.setItem('evLearner_bins', JSON.stringify(this.evBins));
            localStorage.setItem('evLearner_stats', JSON.stringify(this.bootstrapStats));
            console.log('[EV LEARNER] Saved to localStorage');
        } catch (e) {
            console.warn('[EV LEARNER] Failed to save:', e.message);
        }
    },
    
    // Load from localStorage
    load() {
        try {
            const outcomes = localStorage.getItem('evLearner_outcomes');
            const bins = localStorage.getItem('evLearner_bins');
            const stats = localStorage.getItem('evLearner_stats');
            
            if (outcomes) this.outcomes = JSON.parse(outcomes);
            if (bins) this.evBins = JSON.parse(bins);
            if (stats) this.bootstrapStats = JSON.parse(stats);
            
            if (this.outcomes.length > 0 && Object.keys(this.evBins).length > 0) {
                this.isBootstrapped = true;
                console.log('[EV LEARNER] Loaded from localStorage:', this.outcomes.length, 'outcomes,', Object.keys(this.evBins).length, 'bins');
                return true;
            }
        } catch (e) {
            console.warn('[EV LEARNER] Failed to load:', e.message);
        }
        return false;
    },
    
    // Clear all learned data
    reset() {
        this.outcomes = [];
        this.evBins = {};
        this.isBootstrapped = false;
        this.bootstrapStats = null;
        localStorage.removeItem('evLearner_outcomes');
        localStorage.removeItem('evLearner_bins');
        localStorage.removeItem('evLearner_stats');
        console.log('[EV LEARNER] Reset complete');
    }
};

// Try to load saved EV data on startup
try { EVLearner.load(); } catch (e) { /* ignore */ }

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 2C: TRUTH FINDER - DIAGNOSTIC ENGINE
// ═══════════════════════════════════════════════════════════════════════════════
// This engine finds the REAL problem and the REAL winning configuration
// No more guessing - pure data-driven truth
// ═══════════════════════════════════════════════════════════════════════════════
const TruthFinder = {
    results: null,
    
    // Run comprehensive diagnostic
    async runDiagnostic(coins, timeframes, progressCallback) {
        console.log('[TRUTH FINDER] Starting comprehensive diagnostic...');
        
        const diagnosis = {
            timestamp: Date.now(),
            totalSignals: 0,
            totalTrades: 0,
            
            // Raw data collection
            allOutcomes: [],
            
            // By configuration
            byMinScore: {},      // { 30: {wins, losses, pnl}, 40: {...}, ... }
            byConfirmations: {}, // { 1: {...}, 2: {...}, ... }
            byZoneStrength: {},  // { low: {...}, medium: {...}, high: {...} }
            byTimeframe: {},     // { '15': {...}, '60': {...}, ... }
            byDirection: {},     // { LONG: {...}, SHORT: {...} }
            byGrade: {},         // { SNIPER: {...}, STRONG: {...}, ... }
            byRSI: {},           // { oversold: {...}, neutral: {...}, overbought: {...} }
            byVolume: {},        // { spike: {...}, normal: {...} }
            byLiqSweep: {},      // { yes: {...}, no: {...} }
            byRR: {},            // { low: {...}, medium: {...}, high: {...} }
            byCoinType: {},      // { major: {...}, alt: {...}, meme: {...} }
            byReason: {},        // { SL_HIT: {...}, TP_HIT: {...}, TIMEOUT: {...} }
            
            // Combination analysis
            bestCombinations: [],
            worstCombinations: [],
            
            // Final verdict
            verdict: null,
            recommendedConfig: null
        };
        
        const majorCoins = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT'];
        const memeCoins = ['DOGEUSDT', 'SHIBUSDT', 'PEPEUSDT', 'FLOKIUSDT', 'BONKUSDT'];
        
        const totalPairs = coins.length * timeframes.length;
        let completed = 0;
        
        // Collect ALL data first
        for (const coin of coins) {
            for (const tf of timeframes) {
                completed++;
                
                if (progressCallback) {
                    progressCallback({
                        phase: 'collecting',
                        progress: Math.round((completed / totalPairs) * 100),
                        coin,
                        tf,
                        signals: diagnosis.totalSignals
                    });
                }
                
                try {
                    const candles = await fetchKlines(coin, tf, 1000);
                    if (!candles || candles.length < 150) continue;
                    
                    // Determine coin type
                    const coinType = majorCoins.includes(coin) ? 'major' : 
                                     memeCoins.includes(coin) ? 'meme' : 'alt';
                    
                    // Walk through ALL history with NO FILTERS
                    for (let i = 100; i < candles.length - 20; i += 2) {
                        const slice = candles.slice(i - 100, i);
                        if (!slice || slice.length < 100) continue;
                        
                        try {
                            const signal = quickSignalCheck(slice, coin, tf);
                            if (!signal) continue;
                            
                            diagnosis.totalSignals++;
                            
                            const future = candles.slice(i + 1, i + 21);
                            if (!future || future.length < 5) continue;
                            
                            const outcome = simulateTradeOutcome(signal, future);
                            if (!outcome) continue;
                            
                            diagnosis.totalTrades++;
                            
                            // Store raw outcome with ALL metadata
                            const record = {
                                coin,
                                coinType,
                                timeframe: tf,
                                direction: signal.direction,
                                score: signal.score,
                                grade: signal.grade,
                                confirmations: signal.confirmations,
                                zoneStrength: signal.zoneStrength,
                                zoneTouches: signal.zoneTouches,
                                rsi: signal.rsiValue,
                                volSpike: signal.volSpike,
                                hasLiqSweep: signal.confirmList?.includes('LiqSweep'),
                                hasDivergence: signal.confirmList?.includes('BullDiv') || signal.confirmList?.includes('BearDiv'),
                                rr: signal.rr,
                                slQuality: signal.slQuality,
                                tpQuality: signal.tpQuality,
                                won: outcome.won,
                                pnl: outcome.pnl,
                                actualRR: outcome.rr,
                                reason: outcome.reason
                            };
                            
                            diagnosis.allOutcomes.push(record);
                            
                        } catch (e) { /* skip */ }
                    }
                    
                    await new Promise(r => setTimeout(r, 5));
                    
                } catch (e) {
                    console.warn(`[TRUTH FINDER] Error: ${coin} ${tf}:`, e.message);
                }
            }
        }
        
        console.log(`[TRUTH FINDER] Collected ${diagnosis.totalTrades} trades from ${diagnosis.totalSignals} signals`);
        
        if (diagnosis.allOutcomes.length < 50) {
            diagnosis.verdict = {
                status: 'INSUFFICIENT_DATA',
                message: 'Need at least 50 trades for diagnosis'
            };
            this.results = diagnosis;
            return diagnosis;
        }
        
        // Now analyze by every dimension
        if (progressCallback) {
            progressCallback({ phase: 'analyzing', progress: 100 });
        }
        
        // Helper to add to bucket
        const addToBucket = (bucket, key, record) => {
            if (!bucket[key]) bucket[key] = { trades: 0, wins: 0, totalPnl: 0, totalRR: 0 };
            bucket[key].trades++;
            if (record.won) bucket[key].wins++;
            bucket[key].totalPnl += record.pnl;
            bucket[key].totalRR += record.actualRR;
        };
        
        // Analyze each outcome
        for (const r of diagnosis.allOutcomes) {
            // By minScore threshold (test different thresholds)
            for (const threshold of [30, 40, 50, 55, 60, 65, 70, 75, 80, 85]) {
                if (r.score >= threshold) {
                    addToBucket(diagnosis.byMinScore, threshold, r);
                }
            }
            
            // By confirmations
            addToBucket(diagnosis.byConfirmations, r.confirmations, r);
            
            // By zone strength
            const zsBin = r.zoneStrength >= 30 ? 'high' : r.zoneStrength >= 15 ? 'medium' : 'low';
            addToBucket(diagnosis.byZoneStrength, zsBin, r);
            
            // By timeframe
            addToBucket(diagnosis.byTimeframe, r.timeframe, r);
            
            // By direction
            addToBucket(diagnosis.byDirection, r.direction, r);
            
            // By grade
            addToBucket(diagnosis.byGrade, r.grade, r);
            
            // By RSI
            const rsiBin = r.rsi <= 30 ? 'oversold' : r.rsi >= 70 ? 'overbought' : 'neutral';
            addToBucket(diagnosis.byRSI, rsiBin, r);
            
            // By volume
            addToBucket(diagnosis.byVolume, r.volSpike ? 'spike' : 'normal', r);
            
            // By liquidity sweep
            addToBucket(diagnosis.byLiqSweep, r.hasLiqSweep ? 'yes' : 'no', r);
            
            // By RR
            const rrBin = r.rr >= 2.5 ? 'high' : r.rr >= 1.5 ? 'medium' : 'low';
            addToBucket(diagnosis.byRR, rrBin, r);
            
            // By coin type
            addToBucket(diagnosis.byCoinType, r.coinType, r);
            
            // By outcome reason (NEW - shows WHY trades win/lose)
            addToBucket(diagnosis.byReason, r.reason || 'UNKNOWN', r);
        }
        
        // Calculate stats for each bucket
        const calcBucketStats = (bucket) => {
            for (const key of Object.keys(bucket)) {
                const b = bucket[key];
                b.winRate = b.trades > 0 ? (b.wins / b.trades) * 100 : 0;
                b.avgPnl = b.trades > 0 ? b.totalPnl / b.trades : 0;
                b.avgRR = b.trades > 0 ? b.totalRR / b.trades : 0;
                b.expectancy = b.winRate > 0 ? (b.winRate / 100 * b.avgRR) - ((100 - b.winRate) / 100 * 1) : 0;
            }
        };
        
        calcBucketStats(diagnosis.byMinScore);
        calcBucketStats(diagnosis.byConfirmations);
        calcBucketStats(diagnosis.byZoneStrength);
        calcBucketStats(diagnosis.byTimeframe);
        calcBucketStats(diagnosis.byDirection);
        calcBucketStats(diagnosis.byGrade);
        calcBucketStats(diagnosis.byRSI);
        calcBucketStats(diagnosis.byVolume);
        calcBucketStats(diagnosis.byLiqSweep);
        calcBucketStats(diagnosis.byRR);
        calcBucketStats(diagnosis.byCoinType);
        calcBucketStats(diagnosis.byReason);
        
        // Find BEST and WORST combinations
        const combinations = [];
        
        // Test key combinations
        for (const minScore of [40, 50, 60, 70]) {
            for (const dir of ['LONG', 'SHORT']) {
                for (const tf of Object.keys(diagnosis.byTimeframe)) {
                    const matching = diagnosis.allOutcomes.filter(r => 
                        r.score >= minScore && 
                        r.direction === dir && 
                        r.timeframe === tf
                    );
                    
                    if (matching.length >= 10) {
                        const wins = matching.filter(r => r.won).length;
                        const totalPnl = matching.reduce((s, r) => s + r.pnl, 0);
                        const avgRR = matching.reduce((s, r) => s + r.actualRR, 0) / matching.length;
                        
                        combinations.push({
                            config: `minScore=${minScore}, ${dir}, TF=${tf}`,
                            trades: matching.length,
                            wins,
                            winRate: (wins / matching.length) * 100,
                            totalPnl,
                            avgPnl: totalPnl / matching.length,
                            avgRR,
                            expectancy: ((wins / matching.length) * avgRR) - ((1 - wins / matching.length) * 1)
                        });
                    }
                }
            }
        }
        
        // Sort by expectancy
        combinations.sort((a, b) => b.expectancy - a.expectancy);
        diagnosis.bestCombinations = combinations.slice(0, 10);
        diagnosis.worstCombinations = combinations.slice(-10).reverse();
        
        // Generate verdict
        diagnosis.verdict = this.generateVerdict(diagnosis);
        diagnosis.recommendedConfig = this.getRecommendedConfig(diagnosis);
        
        this.results = diagnosis;
        console.log('[TRUTH FINDER] Diagnostic complete');
        
        return diagnosis;
    },
    
    generateVerdict(diagnosis) {
        const issues = [];
        const insights = [];
        
        // Check overall win rate
        const overallWins = diagnosis.allOutcomes.filter(r => r.won).length;
        const overallWinRate = (overallWins / diagnosis.allOutcomes.length) * 100;
        
        if (overallWinRate < 45) {
            issues.push(`❌ Overall win rate is ${overallWinRate.toFixed(1)}% (need 45%+)`);
        } else if (overallWinRate >= 55) {
            insights.push(`✅ Overall win rate is good: ${overallWinRate.toFixed(1)}%`);
        }
        
        // Check by minScore - find the sweet spot
        let bestThreshold = 40;
        let bestExpectancy = -999;
        for (const [threshold, stats] of Object.entries(diagnosis.byMinScore)) {
            if (stats.trades >= 20 && stats.expectancy > bestExpectancy) {
                bestExpectancy = stats.expectancy;
                bestThreshold = parseInt(threshold);
            }
        }
        
        if (bestExpectancy <= 0) {
            issues.push(`❌ No profitable minScore threshold found`);
        } else {
            insights.push(`✅ Best minScore threshold: ${bestThreshold} (expectancy: ${bestExpectancy.toFixed(3)})`);
        }
        
        // Check direction bias
        const longStats = diagnosis.byDirection['LONG'];
        const shortStats = diagnosis.byDirection['SHORT'];
        
        if (longStats && shortStats) {
            if (longStats.winRate > shortStats.winRate + 10) {
                insights.push(`📊 LONG signals perform better (${longStats.winRate.toFixed(1)}% vs ${shortStats.winRate.toFixed(1)}%)`);
            } else if (shortStats.winRate > longStats.winRate + 10) {
                insights.push(`📊 SHORT signals perform better (${shortStats.winRate.toFixed(1)}% vs ${longStats.winRate.toFixed(1)}%)`);
            }
        }
        
        // Check timeframe performance
        let bestTF = null;
        let bestTFExpectancy = -999;
        for (const [tf, stats] of Object.entries(diagnosis.byTimeframe)) {
            if (stats.trades >= 20 && stats.expectancy > bestTFExpectancy) {
                bestTFExpectancy = stats.expectancy;
                bestTF = tf;
            }
        }
        
        if (bestTF) {
            insights.push(`📊 Best timeframe: ${bestTF} (expectancy: ${bestTFExpectancy.toFixed(3)})`);
        }
        
        // Check if liquidity sweeps help
        const withSweep = diagnosis.byLiqSweep['yes'];
        const withoutSweep = diagnosis.byLiqSweep['no'];
        
        if (withSweep && withoutSweep) {
            if (withSweep.winRate > withoutSweep.winRate + 5) {
                insights.push(`✅ Liquidity sweeps improve win rate by ${(withSweep.winRate - withoutSweep.winRate).toFixed(1)}%`);
            } else if (withoutSweep.winRate > withSweep.winRate + 5) {
                issues.push(`⚠️ Liquidity sweep filter may be hurting performance`);
            }
        }
        
        // Check confirmations
        let bestConfirm = 3;
        let bestConfirmExp = -999;
        for (const [conf, stats] of Object.entries(diagnosis.byConfirmations)) {
            if (stats.trades >= 20 && stats.expectancy > bestConfirmExp) {
                bestConfirmExp = stats.expectancy;
                bestConfirm = parseInt(conf);
            }
        }
        insights.push(`📊 Optimal confirmations: ${bestConfirm} (expectancy: ${bestConfirmExp.toFixed(3)})`);
        
        // THE BIG QUESTION: Is the strategy profitable at all?
        const bestCombo = diagnosis.bestCombinations[0];
        if (!bestCombo || bestCombo.expectancy <= 0) {
            issues.push(`🚨 NO PROFITABLE CONFIGURATION FOUND - Strategy needs fundamental rework`);
        }
        
        return {
            status: issues.length === 0 ? 'HEALTHY' : issues.some(i => i.includes('🚨')) ? 'CRITICAL' : 'ISSUES_FOUND',
            overallWinRate: overallWinRate.toFixed(1),
            bestThreshold,
            bestExpectancy: bestExpectancy.toFixed(3),
            issues,
            insights
        };
    },
    
    getRecommendedConfig(diagnosis) {
        const best = diagnosis.bestCombinations[0];
        if (!best || best.expectancy <= 0) {
            return {
                status: 'NO_PROFITABLE_CONFIG',
                message: 'No profitable configuration exists in the data',
                suggestion: 'The scoring formula or trade simulation may need revision'
            };
        }
        
        // Parse best config
        const parts = best.config.split(', ');
        const minScore = parseInt(parts[0].split('=')[1]);
        const direction = parts[1];
        const tf = parts[2].split('=')[1];
        
        return {
            status: 'FOUND',
            minScore,
            direction,
            timeframe: tf,
            expectedWinRate: best.winRate.toFixed(1),
            expectedAvgRR: best.avgRR.toFixed(2),
            expectedExpectancy: best.expectancy.toFixed(3),
            sampleSize: best.trades
        };
    }
};


// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 3: K-FOLD CROSS VALIDATION
// ═══════════════════════════════════════════════════════════════════════════════
const KFoldCV = {
    async run(symbol, timeframe, candles, settings, k = 5) {
        if (!candles || candles.length < k * 100) return { error: 'Insufficient data for K-Fold', folds: k };
        
        const foldSize = Math.floor(candles.length / k);
        const foldResults = [];
        
        for (let i = 0; i < k; i++) {
            const testStart = i * foldSize;
            const testEnd = (i + 1) * foldSize;
            const testCandles = candles.slice(testStart, testEnd);
            
            const trades = [];
            for (let j = 80; j < testCandles.length - 20; j += 3) {
                const slice = testCandles.slice(Math.max(0, j - 80), j);
                if (!slice || slice.length < 100) continue;
                
                try {
                    const signal = quickSignalCheck(slice, symbol, timeframe);
                    if (!signal || signal.score < (settings?.minScore || 15)) continue;
                    
                    const futureSlice = testCandles.slice(j + 1, j + 21);
                    if (!futureSlice || futureSlice.length < 5) continue;
                    
                    const outcome = simulateTradeOutcome(signal, futureSlice);
                    if (outcome && typeof outcome.pnl === 'number') {
                        trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won });
                    }
                } catch (e) { /* skip bad signals */ }
            }
            
            const stats = BacktestStatistics.calculate(trades, 10000);
            foldResults.push({ fold: i + 1, trades: trades.length, winRate: parseFloat(stats.winRate) || 0, pnl: parseFloat(stats.totalPnl) || 0, sharpe: parseFloat(stats.sharpeRatio) || 0 });
        }
        
        const winRates = foldResults.map(f => f.winRate);
        const avgWinRate = winRates.length > 0 ? winRates.reduce((a, b) => a + b, 0) / k : 0;
        const winRateStdDev = winRates.length > 0 ? Math.sqrt(winRates.reduce((sum, w) => sum + Math.pow(w - avgWinRate, 2), 0) / k) : 0;
        const pnls = foldResults.map(f => f.pnl);
        const avgPnl = pnls.length > 0 ? pnls.reduce((a, b) => a + b, 0) / k : 0;
        const positiveCount = pnls.filter(p => p > 0).length;
        
        return {
            folds: foldResults,
            summary: {
                avgWinRate: avgWinRate.toFixed(1), winRateStdDev: winRateStdDev.toFixed(1),
                avgPnl: avgPnl.toFixed(2), positiveCount,
                isConsistent: winRateStdDev < 10 && positiveCount >= Math.ceil(k * 0.6),
                consistency: ((1 - Math.min(winRateStdDev, 100) / 100) * (positiveCount / k) * 100).toFixed(0)
            }
        };
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 4: WALK-FORWARD ANALYSIS
// ═══════════════════════════════════════════════════════════════════════════════
const WalkForwardAnalysis = {
    async run(symbol, timeframe, candles, optimizeWindow = 0.7, testWindow = 0.3, windows = 4) {
        if (!candles || candles.length < 400) return { error: 'Insufficient data', windows: [], efficiency: '0', rating: 'POOR' };
        
        const windowSize = Math.floor(candles.length / windows);
        const optimizeSize = Math.floor(windowSize * optimizeWindow);
        const testSize = Math.floor(windowSize * testWindow);
        
        const results = [];
        let totalInSample = 0, totalOutOfSample = 0;
        
        for (let w = 0; w < windows; w++) {
            const start = w * windowSize;
            const optimizeCandles = candles.slice(start, start + optimizeSize);
            const testCandles = candles.slice(start + optimizeSize, start + optimizeSize + testSize);
            
            if (optimizeCandles.length < 100 || testCandles.length < 50) continue;
            
            const inSampleTrades = await this.runSimpleBacktest(optimizeCandles, symbol, timeframe);
            const inSampleStats = BacktestStatistics.calculate(inSampleTrades, 10000);
            
            const outOfSampleTrades = await this.runSimpleBacktest(testCandles, symbol, timeframe);
            const outOfSampleStats = BacktestStatistics.calculate(outOfSampleTrades, 10000);
            
            totalInSample += parseFloat(inSampleStats.totalPnl) || 0;
            totalOutOfSample += parseFloat(outOfSampleStats.totalPnl) || 0;
            
            results.push({
                window: w + 1,
                inSample: { trades: inSampleTrades.length, pnl: inSampleStats.totalPnl, winRate: inSampleStats.winRate },
                outOfSample: { trades: outOfSampleTrades.length, pnl: outOfSampleStats.totalPnl, winRate: outOfSampleStats.winRate }
            });
        }
        
        const efficiency = totalInSample > 0 ? totalOutOfSample / totalInSample : 0;
        
        return {
            windows: results, totalInSample: totalInSample.toFixed(2), totalOutOfSample: totalOutOfSample.toFixed(2),
            efficiency: efficiency.toFixed(2), isRobust: efficiency >= 0.5 && totalOutOfSample > 0,
            rating: efficiency >= 0.7 ? 'EXCELLENT' : efficiency >= 0.5 ? 'GOOD' : efficiency >= 0.3 ? 'MODERATE' : 'POOR'
        };
    },
    async runSimpleBacktest(candles, symbol, timeframe) {
        const trades = [];
        let skippedChop = 0;
        
        if (!candles || candles.length < 100) return trades;
        
        for (let i = 100; i < candles.length - 20; i += 3) {
            const slice = candles.slice(Math.max(0, i - 80), i);
            if (!slice || slice.length < 100) continue;
            
            // PARANOID FIX: Skip signals in choppy conditions
            if (typeof isChoppy === 'function' && isChoppy(slice, 20)) {
                skippedChop++;
                continue;
            }
            
            try {
                const signal = quickSignalCheck(slice, symbol, timeframe);
                if (!signal || signal.score < 15) continue;
                
                const future = candles.slice(i + 1, i + 21);
                if (!future || future.length < 5) continue;
                
                const outcome = simulateTradeOutcome(signal, future);
                if (outcome && typeof outcome.pnl === 'number') {
                    trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won, reason: outcome.reason });
                }
            } catch (e) { /* skip */ }
        }
        return trades;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 5: MONTE CARLO SIMULATION - V12 FIXED
// ═══════════════════════════════════════════════════════════════════════════════
const MonteCarloSimulator = {
    run(trades, simulations = 1000, initialCapital = 10000) {
        // V12 FIX: Better error handling with detailed messages
        if (!trades) {
            console.error('[MONTE CARLO] No trades array provided');
            return this.errorResult('No trades provided');
        }
        
        if (!Array.isArray(trades)) {
            console.error('[MONTE CARLO] trades is not an array:', typeof trades);
            return this.errorResult('Invalid trades format');
        }
        
        if (trades.length < 10) {
            console.warn('[MONTE CARLO] Only ' + trades.length + ' trades, need 10+');
            return this.errorResult('Need at least 10 trades (have ' + trades.length + ')');
        }
        
        // V12 FIX: More robust trade normalization
        const tradeReturns = [];
        let invalidCount = 0;
        
        for (const t of trades) {
            let pnlValue = null;
            
            // Try multiple formats
            if (typeof t === 'number' && !isNaN(t)) {
                pnlValue = t;
            } else if (t && typeof t === 'object') {
                if (typeof t.netPnl === 'number' && !isNaN(t.netPnl)) {
                    pnlValue = t.netPnl;
                } else if (typeof t.pnl === 'number' && !isNaN(t.pnl)) {
                    pnlValue = t.pnl - 0.2; // Apply fee
                } else if (typeof t.rr === 'number' && !isNaN(t.rr)) {
                    // Convert RR to PnL (assume 1% risk)
                    pnlValue = t.rr * (initialCapital * 0.01);
                }
            }
            
            if (pnlValue !== null && isFinite(pnlValue)) {
                tradeReturns.push(pnlValue);
            } else {
                invalidCount++;
            }
        }
        
        console.log(`[MONTE CARLO] Normalized ${tradeReturns.length} trades, ${invalidCount} invalid`);
        
        if (tradeReturns.length < 10) {
            return this.errorResult('Only ' + tradeReturns.length + ' valid trades after normalization');
        }
        
        // V12 FIX: Use Fisher-Yates shuffle for proper randomization
        const shuffleArray = (arr) => {
            const result = [...arr];
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        };
        
        const results = [];
        
        for (let sim = 0; sim < simulations; sim++) {
            const shuffled = shuffleArray(tradeReturns);
            let equity = initialCapital;
            let peak = equity;
            let maxDD = 0;
            let maxDDPct = 0;
            
            for (const ret of shuffled) {
                equity += ret;
                
                // V12 FIX: Prevent negative equity from breaking calculations
                if (equity <= 0) {
                    equity = 0.01; // Near-zero to indicate ruin
                    maxDDPct = 100;
                    break;
                }
                
                peak = Math.max(peak, equity);
                const dd = peak - equity;
                const ddPct = peak > 0 ? (dd / peak) * 100 : 0;
                maxDD = Math.max(maxDD, dd);
                maxDDPct = Math.max(maxDDPct, ddPct);
            }
            
            const totalReturn = ((equity - initialCapital) / initialCapital) * 100;
            
            results.push({ 
                finalEquity: equity, 
                totalReturn: totalReturn,
                maxDrawdown: maxDDPct
            });
        }
        
        // V12 FIX: Sort results properly for percentile calculation
        results.sort((a, b) => a.totalReturn - b.totalReturn);
        
        // V12 FIX: Better percentile function with bounds checking
        const getPercentile = (arr, p) => {
            if (!arr || arr.length === 0) return 0;
            const idx = Math.min(Math.max(0, Math.floor(arr.length * p / 100)), arr.length - 1);
            return arr[idx];
        };
        
        const totalReturns = results.map(r => r.totalReturn);
        const finalEquities = results.map(r => r.finalEquity);
        const maxDDs = results.map(r => r.maxDrawdown).sort((a, b) => b - a); // Sort descending for DD
        
        const profitCount = results.filter(r => r.totalReturn > 0).length;
        const ruinCount = results.filter(r => r.finalEquity < initialCapital * 0.5).length;
        
        // V12 FIX: Calculate confidence intervals
        const mean = totalReturns.reduce((a, b) => a + b, 0) / totalReturns.length;
        const variance = totalReturns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / totalReturns.length;
        const stdDev = Math.sqrt(variance);
        
        return {
            simulations,
            tradeCount: tradeReturns.length,
            validTrades: tradeReturns.length,
            invalidTrades: invalidCount,
            
            // Percentiles
            percentile5: { 
                finalEquity: getPercentile(finalEquities, 5).toFixed(2), 
                totalReturn: getPercentile(totalReturns, 5).toFixed(2), 
                maxDrawdown: getPercentile(maxDDs, 5).toFixed(2)  // 5th percentile = worst 5%
            },
            percentile25: { 
                finalEquity: getPercentile(finalEquities, 25).toFixed(2), 
                totalReturn: getPercentile(totalReturns, 25).toFixed(2) 
            },
            median: { 
                finalEquity: getPercentile(finalEquities, 50).toFixed(2), 
                totalReturn: getPercentile(totalReturns, 50).toFixed(2), 
                maxDrawdown: getPercentile(maxDDs, 50).toFixed(2) 
            },
            percentile75: { 
                finalEquity: getPercentile(finalEquities, 75).toFixed(2), 
                totalReturn: getPercentile(totalReturns, 75).toFixed(2) 
            },
            percentile95: { 
                finalEquity: getPercentile(finalEquities, 95).toFixed(2), 
                totalReturn: getPercentile(totalReturns, 95).toFixed(2), 
                maxDrawdown: getPercentile(maxDDs, 95).toFixed(2)  // 95th = best case DD
            },
            
            // Probabilities
            profitProbability: ((profitCount / simulations) * 100).toFixed(1),
            ruinProbability: ((ruinCount / simulations) * 100).toFixed(1),
            
            // V12 NEW: Additional statistics
            mean: mean.toFixed(2),
            stdDev: stdDev.toFixed(2),
            sharpeEstimate: (stdDev > 0 ? (mean / stdDev) : 0).toFixed(2),
            
            // V12 NEW: Confidence intervals
            ci95Lower: (mean - 1.96 * stdDev / Math.sqrt(simulations)).toFixed(2),
            ci95Upper: (mean + 1.96 * stdDev / Math.sqrt(simulations)).toFixed(2)
        };
    },
    
    // V12 NEW: Error result helper
    errorResult(message) {
        return { 
            error: message, 
            profitProbability: '0', 
            ruinProbability: '100',
            simulations: 0,
            tradeCount: 0,
            percentile5: { finalEquity: '0', totalReturn: '0', maxDrawdown: '100' },
            percentile25: { finalEquity: '0', totalReturn: '0' },
            median: { finalEquity: '0', totalReturn: '0', maxDrawdown: '100' },
            percentile75: { finalEquity: '0', totalReturn: '0' },
            percentile95: { finalEquity: '0', totalReturn: '0', maxDrawdown: '0' }
        };
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 6: GENETIC OPTIMIZER (SIMPLIFIED FOR SPEED)
// ═══════════════════════════════════════════════════════════════════════════════
const GeneticOptimizer = {
    config: { populationSize: 20, generations: 10, mutationRate: 0.2, eliteCount: 2 },
    paramBounds: {
        minScore: { min: 45, max: 70, step: 5 },  // V11-SLTP: Proper gradient where signals live
        zoneWeight: { min: 20, max: 40, step: 5 },
        smcWeight: { min: 20, max: 40, step: 5 },
        momentumWeight: { min: 20, max: 40, step: 5 },
        riskPerTrade: { min: 0.5, max: 2, step: 0.5 }
    },
    
    async run(symbol, timeframe, candles, progressCallback = null) {
        if (!candles || candles.length < 300) return { error: 'Insufficient data', bestParams: { minScore: 60, riskPerTrade: 1 }, bestFitness: 0 };
        
        let population = [];
        for (let i = 0; i < this.config.populationSize; i++) {
            population.push({ params: this.randomParams(), fitness: -Infinity });
        }
        
        let bestEver = { fitness: -Infinity, params: { minScore: 60, riskPerTrade: 1 } };
        const history = [];
        
        for (let gen = 0; gen < this.config.generations; gen++) {
            // Evaluate
            for (let i = 0; i < population.length; i++) {
                if (population[i].fitness === -Infinity) {
                    population[i].fitness = this.evaluateFitness(population[i].params, candles, symbol, timeframe);
                }
            }
            
            population.sort((a, b) => b.fitness - a.fitness);
            if (population[0].fitness > bestEver.fitness) bestEver = { ...population[0] };
            
            history.push({ generation: gen + 1, bestFitness: population[0].fitness.toFixed(2), avgFitness: (population.reduce((s, p) => s + p.fitness, 0) / population.length).toFixed(2), bestParams: { ...population[0].params } });
            
            if (progressCallback) progressCallback({ generation: gen + 1, total: this.config.generations, best: population[0].fitness.toFixed(2), params: population[0].params });
            
            // Next generation
            const nextGen = population.slice(0, this.config.eliteCount).map(p => ({ ...p, fitness: -Infinity }));
            while (nextGen.length < this.config.populationSize) {
                const parent = population[Math.floor(Math.random() * 5)]; // Top 5
                const child = { params: { ...parent.params }, fitness: -Infinity };
                if (Math.random() < this.config.mutationRate) this.mutate(child);
                nextGen.push(child);
            }
            population = nextGen;
        }
        
        return { bestParams: bestEver.params, bestFitness: bestEver.fitness, history, generations: this.config.generations };
    },
    
    randomParams() {
        const params = {};
        for (const [key, bounds] of Object.entries(this.paramBounds)) {
            const steps = Math.floor((bounds.max - bounds.min) / bounds.step);
            params[key] = bounds.min + Math.floor(Math.random() * (steps + 1)) * bounds.step;
        }
        return params;
    },
    
    evaluateFitness(params, candles, symbol, timeframe) {
        // candles should already be validated by caller
        if (!candles || candles.length < 200) return -100;
        
        const trades = [];
        // Start at 100 so we have enough lookback, step by 5 for reasonable speed
        for (let i = 100; i < candles.length - 20; i += 5) {
            const slice = candles.slice(i - 100, i);
            if (!slice || slice.length < 100) continue;
            
            try {
                const signal = quickSignalCheck(slice, symbol, timeframe);
                if (!signal || signal.score < params.minScore) continue;
                
                const future = candles.slice(i + 1, i + 21);
                if (!future || future.length < 5) continue;
                
                const outcome = simulateTradeOutcome(signal, future);
                if (outcome && typeof outcome.pnl === 'number') {
                    const netPnl = (outcome.pnl - 0.2) * (params.riskPerTrade || 1);
                    trades.push({ netPnl, won: outcome.won });
                }
            } catch (e) { 
                // Skip errors silently 
            }
        }
        
        // Return penalty if too few trades
        if (trades.length < 3) return -100;
        
        const stats = BacktestStatistics.calculate(trades, 10000);
        const sharpe = parseFloat(stats.sharpeRatio) || 0;
        const pf = parseFloat(stats.profitFactor) || 0;
        const dd = parseFloat(stats.maxDrawdownPct) || 100;
        
        // Fitness formula: prioritize Sharpe, then profit factor, reward trade count, penalize drawdown
        return sharpe * 10 + pf * 5 + Math.sqrt(trades.length) - dd * 0.3;
    },
    
    mutate(individual) {
        const keys = Object.keys(this.paramBounds);
        const key = keys[Math.floor(Math.random() * keys.length)];
        const bounds = this.paramBounds[key];
        const delta = (Math.random() < 0.5 ? -1 : 1) * bounds.step;
        individual.params[key] = Math.max(bounds.min, Math.min(bounds.max, individual.params[key] + delta));
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 7: AUTOPILOT SYSTEM - FIXED VERSION
// ═══════════════════════════════════════════════════════════════════════════════
const AutoPilot = {
    config: { 
        enabled: false, 
        symbols: UB_CONFIG.ALL_COINS.slice(0, 20), // Top 20 coins
        timeframes: ['60', '240'],
        lastFastRun: 0, 
        lastDeepRun: 0 
    },
    results: { fast: [], deep: [] },
    isRunning: false,
    
    start() { 
        this.config.enabled = true; 
        this.saveConfig(); 
        this.updateUI('🟢 ENABLED'); 
        toast('AutoPilot enabled', 'success');
    },
    
    stop() { 
        this.config.enabled = false; 
        this.saveConfig(); 
        this.updateUI('🔴 DISABLED'); 
        toast('AutoPilot disabled', '');
    },
    
    async runFast() {
        if (this.isRunning) { toast('Already running!', 'error'); return; }
        this.isRunning = true;
        
        console.log('🤖 AutoPilot FAST starting...');
        this.updateUI('🟡 FAST RUNNING...');
        
        const resultsDiv = document.getElementById('ubAPResults');
        if (resultsDiv) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:20px;">
                <div style="font-size:30px;animation:spin 1s linear infinite;">⚡</div>
                <div style="margin-top:10px;font-weight:700;">FAST SCAN RUNNING</div>
                <div id="apProgress" style="font-size:12px;color:var(--text3);margin-top:8px;">Initializing...</div>
                <div style="margin-top:10px;background:var(--bg4);border-radius:4px;height:6px;overflow:hidden;">
                    <div id="apProgressBar" style="width:0%;height:100%;background:var(--cyan);transition:width 0.3s;"></div>
                </div>
            </div>`;
        }
        
        const results = [];
        const coins = this.config.symbols;
        const tfs = this.config.timeframes;
        const totalScans = coins.length * tfs.length;
        let scanCount = 0;
        let errors = 0;
        let totalSkippedChop = 0;
        
        for (const symbol of coins) {
            for (const tf of tfs) {
                scanCount++;
                const pct = Math.round((scanCount / totalScans) * 100);
                
                const progEl = document.getElementById('apProgress');
                const barEl = document.getElementById('apProgressBar');
                if (progEl) progEl.textContent = `${symbol.replace('USDT','')} ${UB_CONFIG.TF_LABELS[tf] || tf} (${scanCount}/${totalScans})`;
                if (barEl) barEl.style.width = pct + '%';
                
                try {
                    const candles = await fetchKlines(symbol, tf, 500);
                    if (!candles || candles.length < 150) { errors++; continue; }
                    
                    const trades = [];
                    let skippedChop = 0;
                    
                    for (let i = 100; i < candles.length - 20; i += 5) {
                        const slice = candles.slice(Math.max(0, i - 100), i);
                        if (slice.length < 50) continue;
                        
                        // PARANOID: Skip choppy conditions
                        if (typeof isChoppy === 'function' && isChoppy(slice, 20)) {
                            skippedChop++;
                            continue;
                        }
                        
                        try {
                            const signal = quickSignalCheck(slice, symbol, tf);
                            if (!signal || signal.score < 15) continue;
                            
                            const future = candles.slice(i + 1, i + 21);
                            if (future.length < 5) continue;
                            
                            const outcome = simulateTradeOutcome(signal, future);
                            if (outcome) trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won, pnl: outcome.pnl, reason: outcome.reason });
                        } catch (e) { /* skip */ }
                    }
                    
                    totalSkippedChop += skippedChop;
                    
                    if (trades.length >= 3) {
                        const stats = BacktestStatistics.calculate(trades, 10000);
                        const streakAnalysis = typeof analyzeLosingStreaks === 'function' ? analyzeLosingStreaks(trades) : { maxStreak: 0, survives: true };
                        
                        results.push({ 
                            symbol, 
                            timeframe: tf, 
                            tfLabel: UB_CONFIG.TF_LABELS[tf] || tf,
                            trades: trades.length, 
                            winRate: stats.winRate, 
                            pnl: stats.totalPnl, 
                            sharpe: stats.sharpeRatio,
                            profitFactor: stats.profitFactor,
                            maxStreak: streakAnalysis.maxStreak,
                            survives: streakAnalysis.survives,
                            skippedChop
                        });
                    }
                } catch (e) { 
                    console.warn(`FAST error ${symbol} ${tf}:`, e); 
                    errors++; 
                }
                
                await new Promise(r => setTimeout(r, 30));
            }
        }
        
        this.results.fast = results;
        this.config.lastFastRun = Date.now();
        this.saveConfig();
        this.displayFastResults(results, errors);
        this.updateUI('🟢 ENABLED');
        this.isRunning = false;
        
        console.log('🤖 AutoPilot FAST complete:', results.length, 'results,', errors, 'errors, skipped chop:', totalSkippedChop);
        return results;
    },
    
    displayFastResults(results, errors = 0) {
        const resultsDiv = document.getElementById('ubAPResults');
        if (!resultsDiv) return;
        
        if (results.length === 0) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--amber);">
                <div style="font-size:40px;margin-bottom:10px;">⚠️</div>
                <div>No valid results found</div>
                <div style="font-size:11px;margin-top:5px;">${errors} pairs failed</div>
            </div>`;
            return;
        }
        
        results.sort((a, b) => parseFloat(b.pnl) - parseFloat(a.pnl));
        
        const avgWR = (results.reduce((s, r) => s + parseFloat(r.winRate), 0) / results.length).toFixed(1);
        const profitable = results.filter(r => parseFloat(r.pnl) > 0).length;
        const totalTrades = results.reduce((s, r) => s + r.trades, 0);
        const survivingPairs = results.filter(r => r.survives !== false).length;
        const totalSkipped = results.reduce((s, r) => s + (r.skippedChop || 0), 0);
        
        let rowsHTML = results.slice(0, 40).map(r => {
            const pnl = parseFloat(r.pnl);
            const wr = parseFloat(r.winRate);
            const pnlColor = pnl >= 0 ? 'var(--long)' : 'var(--short)';
            const wrColor = wr >= 55 ? 'var(--long)' : wr >= 45 ? 'var(--amber)' : 'var(--short)';
            const surviveIcon = r.survives !== false ? '✓' : '✗';
            const surviveColor = r.survives !== false ? 'var(--long)' : 'var(--short)';
            return `<div style="display:grid;grid-template-columns:1.2fr 0.5fr 0.4fr 0.6fr 0.7fr 0.5fr 0.3fr;padding:6px 8px;background:var(--bg4);border-radius:4px;margin-bottom:3px;font-size:10px;align-items:center;">
                <div style="font-weight:700;">${r.symbol.replace('USDT','')}</div>
                <div>${r.tfLabel}</div>
                <div>${r.trades}</div>
                <div style="color:${wrColor};font-weight:700;">${r.winRate}%</div>
                <div style="color:${pnlColor};font-weight:700;">${pnl >= 0 ? '+' : ''}${r.pnl}%</div>
                <div>${r.sharpe}</div>
                <div style="color:${surviveColor};font-weight:700;" title="Max losing streak: ${r.maxStreak || 0}">${surviveIcon}</div>
            </div>`;
        }).join('');
        
        resultsDiv.innerHTML = `<div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                <div style="font-size:14px;font-weight:700;">⚡ FAST SCAN RESULTS</div>
                <div style="background:linear-gradient(135deg,#ff6b35,#f7931a);color:#000;padding:3px 8px;border-radius:4px;font-size:9px;font-weight:700;">🛡️ PARANOID MODE</div>
            </div>
            <div style="font-size:9px;color:var(--text3);margin-bottom:10px;">Entry: Next Open +0.1% slip | TP/SL: Heuristic | Chop: Filtered (${totalSkipped} skipped)</div>
            <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:5px;margin-bottom:12px;">
                <div style="background:var(--bg3);padding:6px;border-radius:6px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">PAIRS</div>
                    <div style="font-size:14px;font-weight:700;">${results.length}</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:6px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">TRADES</div>
                    <div style="font-size:14px;font-weight:700;">${totalTrades}</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:6px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">AVG WIN%</div>
                    <div style="font-size:14px;font-weight:700;color:${parseFloat(avgWR) >= 50 ? 'var(--long)' : 'var(--short)'}">${avgWR}%</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:6px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">PROFIT</div>
                    <div style="font-size:14px;font-weight:700;color:var(--long)">${profitable}/${results.length}</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:6px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">SURVIVE</div>
                    <div style="font-size:14px;font-weight:700;color:${survivingPairs === results.length ? 'var(--long)' : 'var(--amber)'}">${survivingPairs}/${results.length}</div>
                </div>
            </div>
            <div style="display:grid;grid-template-columns:1.2fr 0.5fr 0.4fr 0.6fr 0.7fr 0.5fr 0.3fr;padding:6px 8px;background:var(--bg3);border-radius:4px;margin-bottom:4px;font-size:8px;font-weight:700;">
                <div>COIN</div><div>TF</div><div>#</div><div>WIN%</div><div>PNL</div><div>SHRP</div><div>💀</div>
            </div>
            <div style="max-height:280px;overflow-y:auto;">${rowsHTML}</div>
            ${results.length > 40 ? `<div style="text-align:center;font-size:10px;color:var(--text3);margin-top:8px;">Showing top 40 of ${results.length}</div>` : ''}
        </div>`;
    },
    
    async runDeep() {
        if (this.isRunning) { toast('Already running!', 'error'); return; }
        this.isRunning = true;
        
        console.log('🤖 AutoPilot DEEP starting...');
        this.updateUI('🟠 DEEP RUNNING...');
        
        const resultsDiv = document.getElementById('ubAPResults');
        if (resultsDiv) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:20px;">
                <div style="font-size:30px;animation:spin 1s linear infinite;">🔬</div>
                <div style="margin-top:10px;font-weight:700;">DEEP ANALYSIS RUNNING</div>
                <div id="apDeepProgress" style="font-size:12px;color:var(--text3);margin-top:8px;">Initializing...</div>
                <div style="font-size:10px;color:var(--amber);margin-top:5px;">Takes 2-5 minutes</div>
                <div style="margin-top:10px;background:var(--bg4);border-radius:4px;height:6px;overflow:hidden;">
                    <div id="apDeepBar" style="width:0%;height:100%;background:var(--purple);transition:width 0.3s;"></div>
                </div>
            </div>`;
        }
        
        const results = [];
        const coins = this.config.symbols.slice(0, 10);
        const tfs = ['15', '60', '240'];
        const totalScans = coins.length * tfs.length;
        let scanCount = 0;
        
        for (const symbol of coins) {
            for (const tf of tfs) {
                scanCount++;
                const pct = Math.round((scanCount / totalScans) * 100);
                
                const progEl = document.getElementById('apDeepProgress');
                const barEl = document.getElementById('apDeepBar');
                if (progEl) progEl.textContent = `${symbol.replace('USDT','')} ${UB_CONFIG.TF_LABELS[tf] || tf} (${scanCount}/${totalScans})`;
                if (barEl) barEl.style.width = pct + '%';
                
                try {
                    const candles = await fetchKlines(symbol, tf, 1000);
                    if (!candles || candles.length < 300) continue;
                    
                    const trades = [];
                    let skippedChop = 0;
                    
                    for (let i = 100; i < candles.length - 20; i += 3) {
                        const slice = candles.slice(Math.max(0, i - 100), i);
                        if (slice.length < 50) continue;
                        
                        // PARANOID: Skip choppy conditions
                        if (typeof isChoppy === 'function' && isChoppy(slice, 20)) {
                            skippedChop++;
                            continue;
                        }
                        
                        try {
                            const signal = quickSignalCheck(slice, symbol, tf);
                            if (!signal || signal.score < 15) continue;
                            
                            const future = candles.slice(i + 1, i + 21);
                            if (future.length < 5) continue;
                            
                            const outcome = simulateTradeOutcome(signal, future);
                            if (outcome) trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won, pnl: outcome.pnl, reason: outcome.reason });
                        } catch (e) { /* skip */ }
                    }
                    
                    if (trades.length >= 10) {
                        const stats = BacktestStatistics.calculate(trades, 10000);
                        const mc = MonteCarloSimulator.run(trades, 500);
                        const streakAnalysis = typeof analyzeLosingStreaks === 'function' ? analyzeLosingStreaks(trades) : { maxStreak: 0, survives: true };
                        
                        results.push({
                            symbol,
                            timeframe: tf,
                            tfLabel: UB_CONFIG.TF_LABELS[tf] || tf,
                            trades: trades.length,
                            winRate: stats.winRate,
                            pnl: stats.totalPnl,
                            sharpe: stats.sharpeRatio,
                            profitFactor: stats.profitFactor,
                            maxDD: stats.maxDrawdownPct,
                            profitProb: mc.profitProbability || '0',
                            maxStreak: streakAnalysis.maxStreak,
                            survives: streakAnalysis.survives,
                            skippedChop,
                            rating: parseFloat(stats.sharpeRatio) >= 1 && parseFloat(mc.profitProbability || 0) >= 70 && streakAnalysis.survives ? 'A' :
                                    parseFloat(stats.sharpeRatio) >= 0.5 && parseFloat(mc.profitProbability || 0) >= 55 ? 'B' : 'C'
                        });
                    }
                } catch (e) {
                    console.warn(`DEEP error ${symbol} ${tf}:`, e);
                }
                
                await new Promise(r => setTimeout(r, 50));
            }
        }
        
        this.results.deep = results;
        this.config.lastDeepRun = Date.now();
        this.saveConfig();
        this.displayDeepResults(results);
        this.updateUI('🟢 ENABLED');
        this.isRunning = false;
        
        console.log('🤖 AutoPilot DEEP complete:', results.length, 'results');
        return results;
    },
    
    displayDeepResults(results) {
        const resultsDiv = document.getElementById('ubAPResults');
        if (!resultsDiv) return;
        
        if (results.length === 0) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--amber);"><div style="font-size:40px;margin-bottom:10px;">⚠️</div><div>No valid results</div></div>`;
            return;
        }
        
        results.sort((a, b) => {
            if (a.rating !== b.rating) return a.rating.localeCompare(b.rating);
            return parseFloat(b.profitProb) - parseFloat(a.profitProb);
        });
        
        const aRated = results.filter(r => r.rating === 'A').length;
        const bRated = results.filter(r => r.rating === 'B').length;
        
        let rowsHTML = results.map(r => {
            const pnl = parseFloat(r.pnl);
            const wr = parseFloat(r.winRate);
            const pp = parseFloat(r.profitProb);
            const ratingColor = r.rating === 'A' ? 'var(--long)' : r.rating === 'B' ? 'var(--amber)' : 'var(--text3)';
            return `<div style="display:grid;grid-template-columns:1fr 0.5fr 0.4fr 0.6fr 0.7fr 0.6fr 0.5fr;padding:6px 8px;background:var(--bg4);border-radius:4px;margin-bottom:3px;font-size:10px;align-items:center;border-left:3px solid ${ratingColor};">
                <div style="font-weight:700;">${r.symbol.replace('USDT','')}</div>
                <div>${r.tfLabel}</div>
                <div>${r.trades}</div>
                <div style="color:${wr >= 55 ? 'var(--long)' : wr >= 45 ? 'var(--amber)' : 'var(--short)'}">${r.winRate}%</div>
                <div style="color:${pnl >= 0 ? 'var(--long)' : 'var(--short)'}">${pnl >= 0 ? '+' : ''}${r.pnl}%</div>
                <div style="color:${pp >= 70 ? 'var(--long)' : pp >= 55 ? 'var(--amber)' : 'var(--short)'}">${r.profitProb}%</div>
                <div style="font-weight:700;color:${ratingColor};">${r.rating}</div>
            </div>`;
        }).join('');
        
        resultsDiv.innerHTML = `<div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                <div style="font-size:14px;font-weight:700;">🔬 DEEP ANALYSIS RESULTS</div>
                <div style="font-size:9px;color:var(--text3);">${new Date().toLocaleTimeString()}</div>
            </div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-bottom:12px;">
                <div style="background:var(--long-dim);padding:10px;border-radius:6px;text-align:center;border:1px solid var(--long);">
                    <div style="font-size:9px;color:var(--text3);">A RATED</div>
                    <div style="font-size:20px;font-weight:700;color:var(--long);">${aRated}</div>
                </div>
                <div style="background:var(--amber-dim);padding:10px;border-radius:6px;text-align:center;border:1px solid var(--amber);">
                    <div style="font-size:9px;color:var(--text3);">B RATED</div>
                    <div style="font-size:20px;font-weight:700;color:var(--amber);">${bRated}</div>
                </div>
                <div style="background:var(--bg3);padding:10px;border-radius:6px;text-align:center;">
                    <div style="font-size:9px;color:var(--text3);">TOTAL</div>
                    <div style="font-size:20px;font-weight:700;">${results.length}</div>
                </div>
            </div>
            <div style="display:grid;grid-template-columns:1fr 0.5fr 0.4fr 0.6fr 0.7fr 0.6fr 0.5fr;padding:6px 8px;background:var(--bg3);border-radius:4px;margin-bottom:4px;font-size:9px;font-weight:700;">
                <div>COIN</div><div>TF</div><div>#</div><div>WIN%</div><div>PNL</div><div>MC%</div><div>RATE</div>
            </div>
            <div style="max-height:280px;overflow-y:auto;">${rowsHTML}</div>
            <div style="margin-top:10px;padding:8px;background:var(--bg3);border-radius:4px;font-size:10px;">
                <div style="font-weight:700;margin-bottom:4px;">📊 Rating:</div>
                <div><span style="color:var(--long);font-weight:700;">A</span> = Sharpe ≥1 & MC ≥70%</div>
                <div><span style="color:var(--amber);font-weight:700;">B</span> = Sharpe ≥0.5 & MC ≥55%</div>
            </div>
        </div>`;
    },
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ULTRA MODE - 150 COINS × 5 TIMEFRAMES = 750 SCANS
    // ═══════════════════════════════════════════════════════════════════════════
    async runUltra() {
        if (this.isRunning) { toast('Already running!', 'error'); return; }
        this.isRunning = true;
        
        const settings = UB_CONFIG.settings;
        const coins = UB_CONFIG.ALL_COINS.slice(0, settings.ultraCoins);
        const tfs = settings.ultraTFs;
        const totalScans = coins.length * tfs.length;
        
        console.log(`🚀 AutoPilot ULTRA starting - ${coins.length} coins × ${tfs.length} TFs = ${totalScans} scans...`);
        this.updateUI('🔴 ULTRA RUNNING...');
        
        const resultsDiv = document.getElementById('ubAPResults');
        if (resultsDiv) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:20px;">
                <div style="font-size:40px;animation:spin 1s linear infinite;">🚀</div>
                <div style="margin-top:10px;font-weight:700;color:#f7931a;">ULTRA SCAN RUNNING</div>
                <div style="font-size:11px;color:var(--text3);margin-top:5px;">${coins.length} coins × ${tfs.length} TFs = ${totalScans} scans</div>
                <div id="apUltraProgress" style="font-size:12px;color:var(--cyan);margin-top:10px;">Initializing...</div>
                <div style="margin-top:10px;background:var(--bg4);border-radius:4px;height:8px;overflow:hidden;">
                    <div id="apUltraBar" style="width:0%;height:100%;background:linear-gradient(90deg,var(--cyan),#f7931a,var(--short));transition:width 0.3s;"></div>
                </div>
                <div id="apUltraStats" style="margin-top:8px;font-size:10px;color:var(--text3);"></div>
                <div style="font-size:10px;color:var(--amber);margin-top:10px;">⏱️ Estimated: ${Math.ceil(totalScans * 0.12)} - ${Math.ceil(totalScans * 0.18)} minutes</div>
            </div>`;
        }
        
        const results = [];
        let scanCount = 0;
        let errors = 0;
        let totalSkippedChop = 0;
        let totalTrades = 0;
        const startTime = Date.now();
        
        for (const symbol of coins) {
            for (const tf of tfs) {
                scanCount++;
                const pct = Math.round((scanCount / totalScans) * 100);
                const elapsed = ((Date.now() - startTime) / 1000 / 60).toFixed(1);
                const eta = scanCount > 10 ? (((Date.now() - startTime) / scanCount) * (totalScans - scanCount) / 1000 / 60).toFixed(1) : '...';
                
                const progEl = document.getElementById('apUltraProgress');
                const barEl = document.getElementById('apUltraBar');
                const statsEl = document.getElementById('apUltraStats');
                if (progEl) progEl.textContent = `${symbol.replace('USDT','')} ${UB_CONFIG.TF_LABELS[tf]} (${scanCount}/${totalScans}) - ${pct}%`;
                if (barEl) barEl.style.width = pct + '%';
                if (statsEl) statsEl.textContent = `✓ ${results.length} valid | 📊 ${totalTrades} trades | ❌ ${errors} errors | ⏱️ ${elapsed}m / ETA ${eta}m`;
                
                try {
                    const candles = await fetchKlines(symbol, tf, 500);
                    if (!candles || candles.length < 150) { errors++; continue; }
                    
                    const trades = [];
                    let skippedChop = 0;
                    
                    for (let i = 100; i < candles.length - 20; i += 5) {
                        const slice = candles.slice(Math.max(0, i - 100), i);
                        if (slice.length < 50) continue;
                        
                        // Chop filter if enabled
                        if (settings.chopFilter && typeof isChoppy === 'function' && isChoppy(slice, 20)) {
                            skippedChop++;
                            continue;
                        }
                        
                        try {
                            const signal = quickSignalCheck(slice, symbol, tf);
                            if (!signal || signal.score < settings.minScore) continue;
                            
                            const future = candles.slice(i + 1, i + 21);
                            if (future.length < 5) continue;
                            
                            const outcome = simulateTradeOutcome(signal, future);
                            if (outcome) trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won });
                        } catch (e) { /* skip */ }
                    }
                    
                    totalSkippedChop += skippedChop;
                    totalTrades += trades.length;
                    
                    if (trades.length >= settings.minTrades) {
                        const stats = BacktestStatistics.calculate(trades, 10000);
                        const streakAnalysis = typeof analyzeLosingStreaks === 'function' ? analyzeLosingStreaks(trades) : { maxStreak: 0, survives: true };
                        
                        results.push({ 
                            symbol, 
                            timeframe: tf, 
                            tfLabel: UB_CONFIG.TF_LABELS[tf],
                            trades: trades.length, 
                            winRate: stats.winRate, 
                            pnl: stats.totalPnl, 
                            sharpe: stats.sharpeRatio,
                            profitFactor: stats.profitFactor,
                            maxDD: stats.maxDrawdownPct,
                            maxStreak: streakAnalysis.maxStreak,
                            survives: streakAnalysis.survives
                        });
                    }
                } catch (e) { 
                    errors++; 
                }
                
                await new Promise(r => setTimeout(r, 15)); // Fast for ULTRA
            }
        }
        
        const totalTime = ((Date.now() - startTime) / 1000 / 60).toFixed(1);
        this.results.ultra = results;
        this.saveConfig();
        this.displayUltraResults(results, errors, totalSkippedChop, totalTrades, totalTime);
        this.updateUI('🟢 ENABLED');
        this.isRunning = false;
        
        console.log(`🚀 AutoPilot ULTRA complete: ${results.length} results from ${totalScans} scans in ${totalTime} minutes`);
        return results;
    },
    
    displayUltraResults(results, errors = 0, skippedChop = 0, totalTrades = 0, totalTime = '0') {
        const resultsDiv = document.getElementById('ubAPResults');
        if (!resultsDiv) return;
        
        if (results.length === 0) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--amber);"><div style="font-size:40px;margin-bottom:10px;">⚠️</div><div>No valid results</div><div style="font-size:11px;margin-top:5px;">${errors} errors</div></div>`;
            return;
        }
        
        // Sort by Sharpe (best risk-adjusted return)
        results.sort((a, b) => parseFloat(b.sharpe) - parseFloat(a.sharpe));
        
        const avgWR = (results.reduce((s, r) => s + parseFloat(r.winRate), 0) / results.length).toFixed(1);
        const profitable = results.filter(r => parseFloat(r.pnl) > 0).length;
        const survivingPairs = results.filter(r => r.survives !== false).length;
        const aGrade = results.filter(r => parseFloat(r.sharpe) >= 1 && parseFloat(r.winRate) >= 55 && r.survives).length;
        const bGrade = results.filter(r => parseFloat(r.sharpe) >= 0.5 && parseFloat(r.sharpe) < 1 && parseFloat(r.winRate) >= 50).length;
        
        // Top 60 results
        let rowsHTML = results.slice(0, 60).map((r, idx) => {
            const pnl = parseFloat(r.pnl);
            const wr = parseFloat(r.winRate);
            const shrp = parseFloat(r.sharpe);
            const isTop = idx < 10;
            const bgColor = isTop ? 'var(--long-dim)' : 'var(--bg4)';
            return `<div style="display:grid;grid-template-columns:0.3fr 1fr 0.5fr 0.4fr 0.6fr 0.6fr 0.5fr;padding:5px 8px;background:${bgColor};border-radius:4px;margin-bottom:2px;font-size:9px;align-items:center;">
                <div style="color:${isTop ? 'var(--gold)' : 'var(--text3)'};font-weight:700;">#${idx+1}</div>
                <div style="font-weight:700;">${r.symbol.replace('USDT','')}</div>
                <div>${r.tfLabel}</div>
                <div>${r.trades}</div>
                <div style="color:${wr >= 55 ? 'var(--long)' : wr >= 45 ? 'var(--amber)' : 'var(--short)'};">${r.winRate}%</div>
                <div style="color:${pnl >= 0 ? 'var(--long)' : 'var(--short)'};">${pnl >= 0 ? '+' : ''}${r.pnl}%</div>
                <div style="color:${shrp >= 1 ? 'var(--long)' : shrp >= 0.5 ? 'var(--amber)' : 'var(--short)'};">${r.sharpe}</div>
            </div>`;
        }).join('');
        
        resultsDiv.innerHTML = `<div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                <div style="font-size:14px;font-weight:700;color:#f7931a;">🚀 ULTRA SCAN COMPLETE</div>
                <div style="background:linear-gradient(135deg,#ff6b35,#f7931a);color:#000;padding:3px 8px;border-radius:4px;font-size:9px;font-weight:700;">🛡️ PARANOID</div>
            </div>
            <div style="font-size:9px;color:var(--text3);margin-bottom:10px;">⏱️ ${totalTime} min | ${skippedChop} chop filtered | ${errors} errors</div>
            
            <div style="display:grid;grid-template-columns:repeat(6,1fr);gap:4px;margin-bottom:10px;">
                <div style="background:var(--bg3);padding:6px;border-radius:4px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">SCANNED</div>
                    <div style="font-size:12px;font-weight:700;">${results.length}</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:4px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">TRADES</div>
                    <div style="font-size:12px;font-weight:700;">${totalTrades}</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:4px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">AVG WIN</div>
                    <div style="font-size:12px;font-weight:700;color:${parseFloat(avgWR) >= 50 ? 'var(--long)' : 'var(--short)'}">${avgWR}%</div>
                </div>
                <div style="background:var(--bg3);padding:6px;border-radius:4px;text-align:center;">
                    <div style="font-size:7px;color:var(--text3);">PROFIT</div>
                    <div style="font-size:12px;font-weight:700;color:var(--long)">${profitable}</div>
                </div>
                <div style="background:var(--long-dim);padding:6px;border-radius:4px;text-align:center;border:1px solid var(--long);">
                    <div style="font-size:7px;color:var(--text3);">A GRADE</div>
                    <div style="font-size:12px;font-weight:700;color:var(--long);">${aGrade}</div>
                </div>
                <div style="background:var(--amber-dim);padding:6px;border-radius:4px;text-align:center;border:1px solid var(--amber);">
                    <div style="font-size:7px;color:var(--text3);">B GRADE</div>
                    <div style="font-size:12px;font-weight:700;color:var(--amber);">${bGrade}</div>
                </div>
            </div>
            
            <div style="display:grid;grid-template-columns:0.3fr 1fr 0.5fr 0.4fr 0.6fr 0.6fr 0.5fr;padding:5px 8px;background:var(--bg3);border-radius:4px;margin-bottom:4px;font-size:8px;font-weight:700;">
                <div>#</div><div>COIN</div><div>TF</div><div>TR</div><div>WIN%</div><div>PNL</div><div>SHRP</div>
            </div>
            <div style="max-height:350px;overflow-y:auto;">${rowsHTML}</div>
            ${results.length > 60 ? `<div style="text-align:center;font-size:9px;color:var(--text3);margin-top:6px;">Showing top 60 of ${results.length} | Sorted by Sharpe</div>` : ''}
            
            <div style="margin-top:10px;padding:8px;background:var(--bg3);border-radius:4px;font-size:9px;">
                <div style="font-weight:700;margin-bottom:4px;">📊 Grading:</div>
                <div><span style="color:var(--long);font-weight:700;">A</span> = Sharpe ≥1 & Win% ≥55% & Survives streak</div>
                <div><span style="color:var(--amber);font-weight:700;">B</span> = Sharpe ≥0.5 & Win% ≥50%</div>
            </div>
        </div>`;
    },
    
    saveConfig() { try { localStorage.setItem('autoPilotConfig', JSON.stringify(this.config)); localStorage.setItem('autoPilotResults', JSON.stringify(this.results)); } catch (e) {} },
    loadConfig() { 
        try { 
            const cfg = localStorage.getItem('autoPilotConfig'); 
            const res = localStorage.getItem('autoPilotResults'); 
            if (cfg) this.config = { ...this.config, ...JSON.parse(cfg) }; 
            if (res) this.results = { ...this.results, ...JSON.parse(res) };
            // Show most recent results
            if (this.results.ultra?.length > 0) setTimeout(() => this.displayUltraResults(this.results.ultra), 500);
            else if (this.results.fast?.length > 0) setTimeout(() => this.displayFastResults(this.results.fast), 500);
            else if (this.results.deep?.length > 0) setTimeout(() => this.displayDeepResults(this.results.deep), 500);
        } catch (e) {} 
    },
    updateUI(status) { const el = document.getElementById('autopilotStatusText'); if (el) el.textContent = status; }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 8: ULTIMATE BACKTEST UI
// ═══════════════════════════════════════════════════════════════════════════════
let lastBacktestTrades = [];

function createUltimateBacktestUI() {
    const existingPanel = document.getElementById('ultimateBacktestPanel');
    if (existingPanel) return;
    
    const panelHTML = `
    <div id="ultimateBacktestPanel" class="ultimate-bt-panel" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.95);z-index:9999;overflow-y:auto;padding:10px;">
        <div style="max-width:800px;margin:0 auto;">
            <div style="display:flex;justify-content:space-between;align-items:center;padding:15px;background:var(--bg2);border-radius:8px;margin-bottom:10px;">
                <div style="display:flex;align-items:center;gap:10px;">
                    <span style="font-size:24px;">🚀</span>
                    <div><div style="font-size:16px;font-weight:700;color:var(--gold);">BS SCANNER V11</div><div style="font-size:11px;color:var(--text3);">ULTIMATE BACKTEST ENGINE</div></div>
                </div>
                <button onclick="hideUltimateBacktest()" style="background:var(--short);color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-weight:700;">✕ CLOSE</button>
            </div>
            
            <div style="display:flex;gap:5px;margin-bottom:10px;flex-wrap:wrap;">
                <button onclick="switchUBTab('backtest')" id="ubTabBacktest" class="ub-tab" style="flex:1;padding:10px;background:var(--cyan);color:#000;border:none;border-radius:6px;font-weight:700;cursor:pointer;min-width:70px;">📊 TEST</button>
                <button onclick="switchUBTab('optimizer')" id="ubTabOptimizer" class="ub-tab" style="flex:1;padding:10px;background:var(--bg3);color:var(--text);border:1px solid var(--border);border-radius:6px;font-weight:700;cursor:pointer;min-width:70px;">🧬 OPT</button>
                <button onclick="switchUBTab('truth')" id="ubTabTruth" class="ub-tab" style="flex:1;padding:10px;background:var(--bg3);color:var(--text);border:1px solid var(--border);border-radius:6px;font-weight:700;cursor:pointer;min-width:70px;">🔍 TRUTH</button>
                <button onclick="switchUBTab('evlearn')" id="ubTabEVLearn" class="ub-tab" style="flex:1;padding:10px;background:var(--bg3);color:var(--text);border:1px solid var(--border);border-radius:6px;font-weight:700;cursor:pointer;min-width:70px;">🧠 EV</button>
                <button onclick="switchUBTab('montecarlo')" id="ubTabMC" class="ub-tab" style="flex:1;padding:10px;background:var(--bg3);color:var(--text);border:1px solid var(--border);border-radius:6px;font-weight:700;cursor:pointer;min-width:70px;">🎲 MC</button>
                <button onclick="switchUBTab('autopilot')" id="ubTabAP" class="ub-tab" style="flex:1;padding:10px;background:var(--bg3);color:var(--text);border:1px solid var(--border);border-radius:6px;font-weight:700;cursor:pointer;min-width:70px;">🤖 AUTO</button>
            </div>
            
            <div id="ubContentBacktest" class="ub-content">
                <div style="background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px;">
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">SYMBOL</label>
                            <select id="ubSymbol" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                                <option value="BTCUSDT">BTC</option><option value="ETHUSDT">ETH</option><option value="SOLUSDT">SOL</option><option value="BNBUSDT">BNB</option><option value="XRPUSDT">XRP</option><option value="ADAUSDT">ADA</option><option value="AVAXUSDT">AVAX</option><option value="DOTUSDT">DOT</option><option value="LINKUSDT">LINK</option><option value="MATICUSDT">MATIC</option>
                            </select></div>
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">TIMEFRAME</label>
                            <select id="ubTimeframe" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                                <option value="15" selected>15m ⚡</option><option value="30">30m</option><option value="60">1H</option><option value="240">4H</option><option value="D">1D</option>
                            </select></div>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px;">
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">MIN SCORE</label>
                            <select id="ubMinScore" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                                <option value="30">30+ (Wide Gate)</option><option value="40">40+ (Loose)</option><option value="50" selected>50+ (Standard)</option><option value="60">60+ (Strong)</option><option value="70">70+ (Strict)</option>
                            </select></div>
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">CAPITAL ($)</label>
                            <input type="number" id="ubCapital" value="10000" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;"></div>
                    </div>
                    <div style="display:flex;gap:10px;">
                        <button onclick="runUltimateBacktest()" id="ubRunBtn" style="flex:1;padding:12px;background:linear-gradient(135deg,var(--cyan),var(--blue));color:#fff;border:none;border-radius:6px;font-weight:700;cursor:pointer;font-size:14px;">▶ RUN BACKTEST</button>
                        <button onclick="runFullValidation()" id="ubValidateBtn" style="flex:1;padding:12px;background:linear-gradient(135deg,var(--purple),var(--amber));color:#fff;border:none;border-radius:6px;font-weight:700;cursor:pointer;font-size:14px;">🔬 FULL VALIDATION</button>
                    </div>
                </div>
                <div id="ubBacktestResults" style="background:var(--bg2);border-radius:8px;padding:15px;">
                    <div style="text-align:center;color:var(--text3);padding:40px;"><div style="font-size:40px;margin-bottom:10px;">📊</div><div>Select parameters and click RUN BACKTEST</div></div>
                </div>
            </div>
            
            <div id="ubContentOptimizer" class="ub-content" style="display:none;">
                <div style="background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="margin-bottom:10px;"><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">OPTIMIZATION MODE</label>
                        <select id="ubOptMode" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                            <option value="genetic">🧬 Genetic Algorithm (Recommended)</option><option value="grid">📊 Grid Search (Exhaustive)</option>
                        </select></div>
                    <button onclick="runOptimization()" id="ubOptBtn" style="width:100%;padding:12px;background:linear-gradient(135deg,var(--long),var(--cyan));color:#fff;border:none;border-radius:6px;font-weight:700;cursor:pointer;font-size:14px;">🧬 START OPTIMIZATION</button>
                </div>
                <div id="ubOptResults" style="background:var(--bg2);border-radius:8px;padding:15px;"><div style="text-align:center;color:var(--text3);padding:40px;"><div style="font-size:40px;margin-bottom:10px;">🧬</div><div>Genetic Algorithm will find optimal parameters</div></div></div>
            </div>
            
            <div id="ubContentTruth" class="ub-content" style="display:none;">
                <div style="background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="margin-bottom:15px;">
                        <div style="font-size:14px;font-weight:700;margin-bottom:5px;">🔍 TRUTH FINDER - Diagnostic Engine</div>
                        <div style="font-size:11px;color:var(--text3);">Find the REAL problem. No guessing. Pure data.</div>
                    </div>
                    
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px;">
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">COINS</label>
                            <select id="truthCoins" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                                <option value="10">Top 10 (Fast)</option>
                                <option value="20" selected>Top 20 (Standard)</option>
                                <option value="50">Top 50 (Full)</option>
                            </select></div>
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">TIMEFRAMES</label>
                            <select id="truthTFs" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                                <option value="15m">15m ONLY</option>
                                <option value="30m">30m ONLY</option>
                                <option value="1h">1H ONLY</option>
                                <option value="4h">4H ONLY</option>
                                <option value="1d">1D ONLY</option>
                                <option value="scalp">15m + 30m</option>
                                <option value="swing">1H + 4H</option>
                                <option value="all" selected>ALL TFs</option>
                            </select></div>
                    </div>
                    
                    <button onclick="runTruthFinder()" id="truthBtn" style="width:100%;padding:12px;background:linear-gradient(135deg,#ff6b6b,#ffd93d,#6bcb77,#4d96ff);background-size:300% 300%;animation:gradientShift 3s ease infinite;color:#000;border:none;border-radius:6px;font-weight:700;cursor:pointer;font-size:14px;">🔍 FIND THE TRUTH</button>
                    <style>@keyframes gradientShift{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}</style>
                </div>
                
                <div id="truthProgress" style="display:none;background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="text-align:center;">
                        <div style="font-size:40px;animation:spin 1s linear infinite;">🔍</div>
                        <div style="margin-top:10px;font-weight:700;" id="truthProgressText">Analyzing...</div>
                        <div style="margin-top:5px;font-size:11px;color:var(--text3);" id="truthProgressDetails">Initializing...</div>
                        <div style="margin-top:10px;background:var(--bg4);border-radius:4px;height:8px;overflow:hidden;">
                            <div id="truthProgressBar" style="width:0%;height:100%;background:linear-gradient(90deg,#ff6b6b,#ffd93d,#6bcb77,#4d96ff);transition:width 0.3s;"></div>
                        </div>
                    </div>
                </div>
                
                <div id="truthResults" style="background:var(--bg2);border-radius:8px;padding:15px;">
                    <div style="text-align:center;color:var(--text3);padding:40px;">
                        <div style="font-size:40px;margin-bottom:10px;">🔍</div>
                        <div style="font-weight:700;margin-bottom:5px;">Find the REAL Truth</div>
                        <div style="font-size:11px;">This will analyze ALL your signals and tell you:</div>
                        <div style="margin-top:15px;padding:10px;background:var(--bg4);border-radius:6px;text-align:left;font-size:10px;line-height:1.8;">
                            <div>• What minScore threshold ACTUALLY works</div>
                            <div>• Which timeframes are profitable</div>
                            <div>• Which confirmations help (or hurt)</div>
                            <div>• LONG vs SHORT performance</div>
                            <div>• Best and worst configurations</div>
                            <div>• Why optimizer shows -75</div>
                            <div>• The REAL recommended settings</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="ubContentMC" class="ub-content" style="display:none;">
                <div style="background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="margin-bottom:10px;"><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">SIMULATIONS</label>
                        <select id="ubMCSimulations" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                            <option value="500">500 (Fast)</option><option value="1000" selected>1,000 (Standard)</option><option value="5000">5,000 (Thorough)</option>
                        </select></div>
                    <button onclick="runMonteCarlo()" id="ubMCBtn" style="width:100%;padding:12px;background:linear-gradient(135deg,var(--amber),var(--short));color:#fff;border:none;border-radius:6px;font-weight:700;cursor:pointer;font-size:14px;">🎲 RUN MONTE CARLO</button>
                </div>
                <div id="ubMCResults" style="background:var(--bg2);border-radius:8px;padding:15px;"><div style="text-align:center;color:var(--text3);padding:40px;"><div style="font-size:40px;margin-bottom:10px;">🎲</div><div>Run backtest first, then Monte Carlo</div></div></div>
            </div>
            
            <div id="ubContentEVLearn" class="ub-content" style="display:none;">
                <div style="background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="margin-bottom:15px;">
                        <div style="font-size:14px;font-weight:700;margin-bottom:5px;">🧠 EV Learning Engine</div>
                        <div style="font-size:11px;color:var(--text3);">Learn score from outcomes, not guesses. This is the V12 breakthrough.</div>
                    </div>
                    
                    <div id="evLearnStatus" style="background:var(--bg4);padding:10px;border-radius:6px;margin-bottom:10px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <div>
                                <div style="font-size:12px;font-weight:700;" id="evStatusLabel">Status: NOT TRAINED</div>
                                <div style="font-size:10px;color:var(--text3);" id="evStatusDetails">Run bootstrap to train from historical data</div>
                            </div>
                            <div id="evStatusIcon" style="font-size:24px;">🔴</div>
                        </div>
                    </div>
                    
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px;">
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">COINS TO SCAN</label>
                            <select id="evLearnCoins" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                                <option value="10">Top 10</option>
                                <option value="20" selected>Top 20</option>
                                <option value="50">Top 50</option>
                            </select></div>
                        <div><label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">TIMEFRAMES</label>
                            <select id="evLearnTFs" style="width:100%;padding:8px;background:var(--bg4);border:1px solid var(--border);color:var(--text);border-radius:4px;">
                                <option value="main">1H, 4H, 1D</option>
                                <option value="all" selected>All (15m to 1D)</option>
                            </select></div>
                    </div>
                    
                    <div style="display:flex;gap:10px;margin-bottom:10px;">
                        <button onclick="runEVBootstrap()" id="evBootstrapBtn" style="flex:1;padding:12px;background:linear-gradient(135deg,var(--purple),var(--cyan));color:#fff;border:none;border-radius:6px;font-weight:700;cursor:pointer;font-size:14px;">🚀 BOOTSTRAP FROM HISTORY</button>
                    </div>
                    <div style="display:flex;gap:10px;">
                        <button onclick="showEVBins()" style="flex:1;padding:10px;background:var(--bg4);color:var(--text);border:1px solid var(--border);border-radius:6px;font-weight:700;cursor:pointer;">📊 SHOW BINS</button>
                        <button onclick="EVLearner.reset();updateEVStatus();" style="flex:1;padding:10px;background:var(--short-dim);color:var(--short);border:1px solid var(--short);border-radius:6px;font-weight:700;cursor:pointer;">🗑️ RESET</button>
                    </div>
                </div>
                
                <div id="evLearnProgress" style="display:none;background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="text-align:center;">
                        <div style="font-size:40px;animation:spin 1s linear infinite;">🧠</div>
                        <div style="margin-top:10px;font-weight:700;" id="evProgressText">Bootstrapping...</div>
                        <div style="margin-top:5px;font-size:11px;color:var(--text3);" id="evProgressDetails">Initializing...</div>
                        <div style="margin-top:10px;background:var(--bg4);border-radius:4px;height:8px;overflow:hidden;">
                            <div id="evProgressBar" style="width:0%;height:100%;background:linear-gradient(90deg,var(--purple),var(--cyan));transition:width 0.3s;"></div>
                        </div>
                    </div>
                </div>
                
                <div id="evLearnResults" style="background:var(--bg2);border-radius:8px;padding:15px;">
                    <div style="text-align:center;color:var(--text3);padding:40px;">
                        <div style="font-size:40px;margin-bottom:10px;">🧠</div>
                        <div style="font-weight:700;margin-bottom:5px;">EV Learning Engine</div>
                        <div style="font-size:11px;">This solves the -107 optimizer problem by learning score from actual outcomes instead of guessing.</div>
                        <div style="margin-top:15px;padding:10px;background:var(--bg4);border-radius:6px;text-align:left;font-size:10px;line-height:1.6;">
                            <div style="color:var(--cyan);font-weight:700;margin-bottom:5px;">How it works:</div>
                            <div>1. Collects 10,000+ signal/outcome pairs from history</div>
                            <div>2. Groups by feature combinations (bins)</div>
                            <div>3. Calculates expected R for each bin</div>
                            <div>4. Score = percentile of expected R</div>
                            <div>5. Now optimizer has true gradient!</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="ubContentAP" class="ub-content" style="display:none;">
                <div style="background:var(--bg2);border-radius:8px;padding:15px;margin-bottom:10px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
                        <div><div style="font-size:14px;font-weight:700;">🤖 AutoPilot Status</div><div id="autopilotStatusText" style="font-size:12px;color:var(--text3);">🔴 DISABLED</div></div>
                        <div style="display:flex;gap:8px;">
                            <button onclick="AutoPilot.start()" style="padding:8px 16px;background:var(--long);color:#fff;border:none;border-radius:4px;font-weight:700;cursor:pointer;">ENABLE</button>
                            <button onclick="AutoPilot.stop()" style="padding:8px 16px;background:var(--short);color:#fff;border:none;border-radius:4px;font-weight:700;cursor:pointer;">DISABLE</button>
                        </div>
                    </div>
                    
                    <!-- SCAN BUTTONS -->
                    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;margin-bottom:15px;">
                        <button onclick="AutoPilot.runFast()" style="padding:12px;background:var(--cyan-dim);border:1px solid var(--cyan);color:var(--cyan);border-radius:6px;font-weight:700;cursor:pointer;">
                            <div style="font-size:16px;">⚡</div>
                            <div style="font-size:11px;">FAST</div>
                            <div style="font-size:9px;opacity:0.7;">20 coins × 2 TF</div>
                        </button>
                        <button onclick="AutoPilot.runDeep()" style="padding:12px;background:var(--purple-dim);border:1px solid var(--purple);color:var(--purple);border-radius:6px;font-weight:700;cursor:pointer;">
                            <div style="font-size:16px;">🔬</div>
                            <div style="font-size:11px;">DEEP</div>
                            <div style="font-size:9px;opacity:0.7;">10 coins × 3 TF</div>
                        </button>
                        <button onclick="AutoPilot.runUltra()" style="padding:12px;background:linear-gradient(135deg,rgba(255,107,53,0.2),rgba(247,147,26,0.2));border:1px solid #f7931a;color:#f7931a;border-radius:6px;font-weight:700;cursor:pointer;">
                            <div style="font-size:16px;">🚀</div>
                            <div style="font-size:11px;">ULTRA</div>
                            <div style="font-size:9px;opacity:0.7;">150 coins × 5 TF</div>
                        </button>
                    </div>
                    
                    <!-- SETTINGS PANEL -->
                    <details style="background:var(--bg3);border-radius:6px;padding:10px;margin-bottom:10px;">
                        <summary style="cursor:pointer;font-weight:700;font-size:12px;color:var(--text);">⚙️ SCAN SETTINGS</summary>
                        <div style="margin-top:12px;display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                            <div>
                                <label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">ULTRA Coins</label>
                                <select id="ubSettingsUltraCoins" onchange="UB_CONFIG.settings.ultraCoins=parseInt(this.value)" style="width:100%;padding:6px;background:var(--bg4);color:var(--text);border:1px solid var(--border);border-radius:4px;">
                                    <option value="50">50 coins</option>
                                    <option value="100">100 coins</option>
                                    <option value="150" selected>150 coins</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">Min Score</label>
                                <select id="ubSettingsMinScore" onchange="UB_CONFIG.settings.minScore=parseInt(this.value)" style="width:100%;padding:6px;background:var(--bg4);color:var(--text);border:1px solid var(--border);border-radius:4px;">
                                    <option value="50">50+</option>
                                    <option value="60" selected>60+</option>
                                    <option value="70">70+</option>
                                    <option value="80">80+</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">Timeframes</label>
                                <select id="ubSettingsTFs" onchange="updateTFSettings(this.value)" style="width:100%;padding:6px;background:var(--bg4);color:var(--text);border:1px solid var(--border);border-radius:4px;">
                                    <option value="5m-4h" selected>5m → 4H (5 TFs)</option>
                                    <option value="15m-4h">15m → 4H (4 TFs)</option>
                                    <option value="1h-4h">1H → 4H (2 TFs)</option>
                                    <option value="all">All TFs (6 TFs)</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:10px;color:var(--text3);display:block;margin-bottom:4px;">Slippage %</label>
                                <select id="ubSettingsSlippage" onchange="UB_CONFIG.settings.slippagePct=parseFloat(this.value)" style="width:100%;padding:6px;background:var(--bg4);color:var(--text);border:1px solid var(--border);border-radius:4px;">
                                    <option value="0.05">0.05%</option>
                                    <option value="0.1" selected>0.1%</option>
                                    <option value="0.15">0.15%</option>
                                    <option value="0.2">0.2%</option>
                                </select>
                            </div>
                            <div style="grid-column:span 2;display:flex;gap:15px;margin-top:5px;">
                                <label style="font-size:11px;display:flex;align-items:center;gap:5px;cursor:pointer;">
                                    <input type="checkbox" id="ubSettingsChop" checked onchange="UB_CONFIG.settings.chopFilter=this.checked" style="width:16px;height:16px;">
                                    <span>Chop Filter</span>
                                </label>
                                <label style="font-size:11px;display:flex;align-items:center;gap:5px;cursor:pointer;">
                                    <input type="checkbox" id="ubSettingsParanoid" checked onchange="UB_CONFIG.settings.paranoidMode=this.checked" style="width:16px;height:16px;">
                                    <span>Paranoid Mode</span>
                                </label>
                            </div>
                        </div>
                    </details>
                    
                    <!-- SCAN INFO -->
                    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:10px;">
                        <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;">
                            <div style="color:var(--cyan);font-weight:700;">FAST</div>
                            <div style="color:var(--text3);">~2 min</div>
                        </div>
                        <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;">
                            <div style="color:var(--purple);font-weight:700;">DEEP</div>
                            <div style="color:var(--text3);">~5 min</div>
                        </div>
                        <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;">
                            <div style="color:#f7931a;font-weight:700;">ULTRA</div>
                            <div style="color:var(--text3);">~15-25 min</div>
                        </div>
                    </div>
                </div>
                <div id="ubAPResults" style="background:var(--bg2);border-radius:8px;padding:15px;"><div style="text-align:center;color:var(--text3);padding:40px;"><div style="font-size:40px;margin-bottom:10px;">🤖</div><div>Select FAST, DEEP, or ULTRA scan</div><div style="font-size:11px;margin-top:5px;color:var(--amber);">🛡️ Paranoid Mode: Real slippage + Chop filter</div></div></div>
            </div>
        </div>
    </div>`;
    
    document.body.insertAdjacentHTML('beforeend', panelHTML);
}

function updateTFSettings(value) {
    switch(value) {
        case '5m-4h': UB_CONFIG.settings.ultraTFs = ['5', '15', '30', '60', '240']; break;
        case '15m-4h': UB_CONFIG.settings.ultraTFs = ['15', '30', '60', '240']; break;
        case '1h-4h': UB_CONFIG.settings.ultraTFs = ['60', '240']; break;
        case 'all': UB_CONFIG.settings.ultraTFs = ['5', '15', '30', '60', '240', 'D']; break;
    }
}

function switchUBTab(tab) {
    const tabs = { backtest: 'Backtest', optimizer: 'Optimizer', truth: 'Truth', evlearn: 'EVLearn', montecarlo: 'MC', autopilot: 'AP' };
    for (const [t, id] of Object.entries(tabs)) {
        const tabEl = document.getElementById(`ubTab${id}`);
        const contentEl = document.getElementById(`ubContent${id}`);
        if (!tabEl || !contentEl) continue;
        if (t === tab) { 
            tabEl.style.background = 'var(--cyan)'; 
            tabEl.style.color = '#000'; 
            tabEl.style.border = 'none'; 
            contentEl.style.display = 'block'; 
            // Update EV status when switching to EV tab
            if (t === 'evlearn') updateEVStatus();
        }
        else { 
            tabEl.style.background = 'var(--bg3)'; 
            tabEl.style.color = 'var(--text)'; 
            tabEl.style.border = '1px solid var(--border)'; 
            contentEl.style.display = 'none'; 
        }
    }
}

// EV Learning UI Functions
function updateEVStatus() {
    const labelEl = document.getElementById('evStatusLabel');
    const detailsEl = document.getElementById('evStatusDetails');
    const iconEl = document.getElementById('evStatusIcon');
    
    if (!labelEl) return;
    
    if (EVLearner.isBootstrapped && EVLearner.bootstrapStats) {
        const stats = EVLearner.bootstrapStats;
        labelEl.textContent = `Status: TRAINED ✅`;
        labelEl.style.color = 'var(--long)';
        detailsEl.textContent = `${stats.totalOutcomes} outcomes | ${stats.binCount} bins | ${stats.profitableBins} profitable`;
        iconEl.textContent = '🟢';
    } else {
        labelEl.textContent = 'Status: NOT TRAINED';
        labelEl.style.color = 'var(--text3)';
        detailsEl.textContent = 'Run bootstrap to train from historical data';
        iconEl.textContent = '🔴';
    }
}

async function runEVBootstrap() {
    const btn = document.getElementById('evBootstrapBtn');
    const progressDiv = document.getElementById('evLearnProgress');
    const resultsDiv = document.getElementById('evLearnResults');
    
    const coinsCount = parseInt(document.getElementById('evLearnCoins').value);
    const tfMode = document.getElementById('evLearnTFs').value;
    
    const coins = UB_CONFIG.ALL_COINS.slice(0, coinsCount);
    const timeframes = tfMode === 'main' ? ['60', '240', 'D'] : ['15', '30', '60', '240', 'D'];
    
    btn.disabled = true;
    btn.textContent = '⏳ TRAINING...';
    progressDiv.style.display = 'block';
    
    try {
        const result = await EVLearner.bootstrap(coins, timeframes, (progress) => {
            const progText = document.getElementById('evProgressText');
            const progDetails = document.getElementById('evProgressDetails');
            const progBar = document.getElementById('evProgressBar');
            
            if (progress.phase === 'collecting') {
                progText.textContent = `Collecting: ${progress.coin} ${progress.tf}`;
                progDetails.textContent = `${progress.signals} signals | ${progress.outcomes} outcomes`;
                progBar.style.width = progress.progress + '%';
            } else if (progress.phase === 'learning') {
                progText.textContent = 'Learning EV from outcomes...';
                progDetails.textContent = `Processing ${progress.outcomes} outcomes`;
                progBar.style.width = '100%';
            }
        });
        
        // Save to localStorage
        EVLearner.save();
        
        // Show results
        progressDiv.style.display = 'none';
        
        if (result.success) {
            const stats = EVLearner.bootstrapStats;
            resultsDiv.innerHTML = `
                <div style="text-align:center;margin-bottom:15px;">
                    <div style="font-size:40px;margin-bottom:10px;">✅</div>
                    <div style="font-size:18px;font-weight:700;color:var(--long);">TRAINING COMPLETE</div>
                </div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:15px;">
                    <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;">
                        <div style="font-size:9px;color:var(--text3);">OUTCOMES</div>
                        <div style="font-size:18px;font-weight:700;color:var(--cyan);">${stats.totalOutcomes}</div>
                    </div>
                    <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;">
                        <div style="font-size:9px;color:var(--text3);">BINS</div>
                        <div style="font-size:18px;font-weight:700;color:var(--purple);">${stats.binCount}</div>
                    </div>
                    <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;">
                        <div style="font-size:9px;color:var(--text3);">PROFITABLE</div>
                        <div style="font-size:18px;font-weight:700;color:var(--long);">${stats.profitableBins}</div>
                    </div>
                </div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:15px;">
                    <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;">
                        <div style="font-size:9px;color:var(--text3);">AVG EV</div>
                        <div style="font-size:16px;font-weight:700;color:${parseFloat(stats.avgEV) >= 0 ? 'var(--long)' : 'var(--short)'}">${stats.avgEV}R</div>
                    </div>
                    <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;">
                        <div style="font-size:9px;color:var(--text3);">BEST BIN</div>
                        <div style="font-size:16px;font-weight:700;color:var(--long);">${stats.bestBinEV}R</div>
                    </div>
                    <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;">
                        <div style="font-size:9px;color:var(--text3);">WORST BIN</div>
                        <div style="font-size:16px;font-weight:700;color:var(--short);">${stats.worstBinEV}R</div>
                    </div>
                </div>
                <div style="background:var(--long-dim);border:1px solid var(--long);padding:12px;border-radius:6px;text-align:center;">
                    <div style="font-size:12px;font-weight:700;color:var(--long);">🎯 NOW OPTIMIZER WILL WORK!</div>
                    <div style="font-size:10px;color:var(--text3);margin-top:5px;">Score is now derived from actual EV. Run Optimizer to see positive fitness.</div>
                </div>
            `;
        } else {
            resultsDiv.innerHTML = `
                <div style="text-align:center;padding:40px;color:var(--short);">
                    <div style="font-size:40px;margin-bottom:10px;">❌</div>
                    <div>Bootstrap failed. Need more data.</div>
                </div>
            `;
        }
        
        updateEVStatus();
        
    } catch (error) {
        progressDiv.style.display = 'none';
        resultsDiv.innerHTML = `
            <div style="text-align:center;padding:40px;color:var(--short);">
                <div style="font-size:40px;margin-bottom:10px;">❌</div>
                <div>Error: ${error.message}</div>
            </div>
        `;
    }
    
    btn.disabled = false;
    btn.textContent = '🚀 BOOTSTRAP FROM HISTORY';
}

function showEVBins() {
    const resultsDiv = document.getElementById('evLearnResults');
    
    if (!EVLearner.isBootstrapped) {
        resultsDiv.innerHTML = `
            <div style="text-align:center;padding:40px;color:var(--amber);">
                <div style="font-size:40px;margin-bottom:10px;">⚠️</div>
                <div>Run bootstrap first!</div>
            </div>
        `;
        return;
    }
    
    const bins = EVLearner.getBinDetails();
    
    let binsHTML = `
        <div style="margin-bottom:10px;">
            <div style="font-size:14px;font-weight:700;margin-bottom:5px;">📊 Learned EV Bins (${bins.length})</div>
            <div style="font-size:10px;color:var(--text3);">Sorted by Expected R (best first)</div>
        </div>
        <div style="max-height:400px;overflow-y:auto;">
    `;
    
    for (const bin of bins.slice(0, 20)) {
        const evVal = parseFloat(bin.expectedR);
        const evColor = evVal >= 0.5 ? 'var(--long)' : evVal >= 0 ? 'var(--amber)' : 'var(--short)';
        const gradeColor = bin.grade === 'EXCELLENT' ? 'var(--long)' : bin.grade === 'GOOD' ? 'var(--cyan)' : bin.grade === 'MARGINAL' ? 'var(--amber)' : 'var(--short)';
        
        binsHTML += `
            <div style="background:var(--bg4);padding:10px;border-radius:6px;margin-bottom:8px;border-left:3px solid ${evColor};">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px;">
                    <div style="font-size:11px;font-weight:700;color:${evColor};">EV: ${bin.expectedR}R</div>
                    <div style="font-size:10px;padding:2px 6px;background:${gradeColor};color:#000;border-radius:3px;font-weight:700;">${bin.grade}</div>
                </div>
                <div style="font-size:9px;color:var(--text3);margin-bottom:5px;word-break:break-all;">${bin.binKey}</div>
                <div style="display:flex;gap:10px;font-size:10px;">
                    <span>WR: ${bin.winRate}</span>
                    <span>N: ${bin.sampleSize}</span>
                    <span>Kelly: ${bin.kelly}</span>
                </div>
            </div>
        `;
    }
    
    binsHTML += `</div>`;
    resultsDiv.innerHTML = binsHTML;
}

// ═══════════════════════════════════════════════════════════════════════════════
// TRUTH FINDER UI FUNCTION
// ═══════════════════════════════════════════════════════════════════════════════
async function runTruthFinder() {
    const btn = document.getElementById('truthBtn');
    const progressDiv = document.getElementById('truthProgress');
    const resultsDiv = document.getElementById('truthResults');
    
    const coinsCount = parseInt(document.getElementById('truthCoins').value);
    const tfMode = document.getElementById('truthTFs').value;
    
    const coins = UB_CONFIG.ALL_COINS.slice(0, coinsCount);
    
    // Timeframe selection - now with individual options
    let timeframes;
    switch(tfMode) {
        case '15m': timeframes = ['15']; break;
        case '30m': timeframes = ['30']; break;
        case '1h': timeframes = ['60']; break;
        case '4h': timeframes = ['240']; break;
        case '1d': timeframes = ['D']; break;
        case 'scalp': timeframes = ['15', '30']; break;
        case 'swing': timeframes = ['60', '240']; break;
        case 'all': 
        default: timeframes = ['15', '30', '60', '240', 'D']; break;
    }
    
    console.log('[TRUTH FINDER] Testing timeframes:', timeframes);
    
    btn.disabled = true;
    progressDiv.style.display = 'block';
    
    try {
        const result = await TruthFinder.runDiagnostic(coins, timeframes, (progress) => {
            const progText = document.getElementById('truthProgressText');
            const progDetails = document.getElementById('truthProgressDetails');
            const progBar = document.getElementById('truthProgressBar');
            
            if (progress.phase === 'collecting') {
                progText.textContent = `Scanning: ${progress.coin} ${progress.tf}`;
                progDetails.textContent = `${progress.signals} signals found`;
                progBar.style.width = progress.progress + '%';
            } else if (progress.phase === 'analyzing') {
                progText.textContent = 'Analyzing all data...';
                progDetails.textContent = 'Crunching numbers...';
                progBar.style.width = '100%';
            }
        });
        
        progressDiv.style.display = 'none';
        
        // Build results HTML
        const v = result.verdict;
        const rec = result.recommendedConfig;
        
        const statusColor = v.status === 'HEALTHY' ? 'var(--long)' : v.status === 'CRITICAL' ? 'var(--short)' : 'var(--amber)';
        const statusEmoji = v.status === 'HEALTHY' ? '✅' : v.status === 'CRITICAL' ? '🚨' : '⚠️';
        
        let html = `
            <div style="margin-bottom:15px;">
                <div style="text-align:center;margin-bottom:15px;">
                    <div style="font-size:40px;margin-bottom:5px;">${statusEmoji}</div>
                    <div style="font-size:18px;font-weight:700;color:${statusColor};">${v.status}</div>
                    <div style="font-size:11px;color:var(--text3);">${result.totalTrades} trades analyzed from ${result.totalSignals} signals</div>
                </div>
                
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:15px;">
                    <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;">
                        <div style="font-size:9px;color:var(--text3);">OVERALL WIN RATE</div>
                        <div style="font-size:18px;font-weight:700;color:${parseFloat(v.overallWinRate) >= 50 ? 'var(--long)' : 'var(--short)'}">${v.overallWinRate}%</div>
                    </div>
                    <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;">
                        <div style="font-size:9px;color:var(--text3);">BEST THRESHOLD</div>
                        <div style="font-size:18px;font-weight:700;color:var(--cyan);">${v.bestThreshold}</div>
                    </div>
                    <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;">
                        <div style="font-size:9px;color:var(--text3);">BEST EXPECTANCY</div>
                        <div style="font-size:18px;font-weight:700;color:${parseFloat(v.bestExpectancy) >= 0 ? 'var(--long)' : 'var(--short)'}">${v.bestExpectancy}</div>
                    </div>
                </div>
        `;
        
        // Recommended Config
        if (rec.status === 'FOUND') {
            html += `
                <div style="background:var(--long-dim);border:1px solid var(--long);padding:15px;border-radius:8px;margin-bottom:15px;">
                    <div style="font-size:12px;font-weight:700;color:var(--long);margin-bottom:10px;">🎯 RECOMMENDED CONFIGURATION</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;font-size:11px;">
                        <div><span style="color:var(--text3);">Min Score:</span> <strong>${rec.minScore}</strong></div>
                        <div><span style="color:var(--text3);">Direction:</span> <strong>${rec.direction}</strong></div>
                        <div><span style="color:var(--text3);">Timeframe:</span> <strong>${rec.timeframe}</strong></div>
                        <div><span style="color:var(--text3);">Sample:</span> <strong>${rec.sampleSize} trades</strong></div>
                        <div><span style="color:var(--text3);">Expected WR:</span> <strong style="color:var(--long)">${rec.expectedWinRate}%</strong></div>
                        <div><span style="color:var(--text3);">Expected RR:</span> <strong>${rec.expectedAvgRR}</strong></div>
                    </div>
                </div>
            `;
        } else {
            html += `
                <div style="background:var(--short-dim);border:1px solid var(--short);padding:15px;border-radius:8px;margin-bottom:15px;">
                    <div style="font-size:12px;font-weight:700;color:var(--short);margin-bottom:5px;">🚨 NO PROFITABLE CONFIGURATION</div>
                    <div style="font-size:10px;color:var(--text3);">${rec.suggestion}</div>
                </div>
            `;
        }
        
        // Issues
        if (v.issues.length > 0) {
            html += `<div style="background:var(--bg4);padding:12px;border-radius:6px;margin-bottom:10px;">
                <div style="font-size:11px;font-weight:700;margin-bottom:8px;color:var(--short);">❌ ISSUES FOUND</div>`;
            for (const issue of v.issues) {
                html += `<div style="font-size:10px;margin-bottom:4px;padding-left:10px;border-left:2px solid var(--short);">${issue}</div>`;
            }
            html += `</div>`;
        }
        
        // Insights
        if (v.insights.length > 0) {
            html += `<div style="background:var(--bg4);padding:12px;border-radius:6px;margin-bottom:10px;">
                <div style="font-size:11px;font-weight:700;margin-bottom:8px;color:var(--cyan);">📊 INSIGHTS</div>`;
            for (const insight of v.insights) {
                html += `<div style="font-size:10px;margin-bottom:4px;padding-left:10px;border-left:2px solid var(--cyan);">${insight}</div>`;
            }
            html += `</div>`;
        }
        
        // Best Combinations
        if (result.bestCombinations.length > 0) {
            html += `<div style="background:var(--bg4);padding:12px;border-radius:6px;margin-bottom:10px;">
                <div style="font-size:11px;font-weight:700;margin-bottom:8px;color:var(--long);">🏆 TOP 5 CONFIGURATIONS</div>
                <div style="max-height:200px;overflow-y:auto;">`;
            
            for (let i = 0; i < Math.min(5, result.bestCombinations.length); i++) {
                const c = result.bestCombinations[i];
                const expColor = c.expectancy >= 0.1 ? 'var(--long)' : c.expectancy >= 0 ? 'var(--amber)' : 'var(--short)';
                html += `
                    <div style="padding:8px;border-bottom:1px solid var(--border);font-size:10px;">
                        <div style="font-weight:700;margin-bottom:3px;">#${i + 1}: ${c.config}</div>
                        <div style="display:flex;gap:15px;color:var(--text3);">
                            <span>Trades: ${c.trades}</span>
                            <span>WR: ${c.winRate.toFixed(1)}%</span>
                            <span>Avg RR: ${c.avgRR.toFixed(2)}</span>
                            <span style="color:${expColor};font-weight:700;">Exp: ${c.expectancy.toFixed(3)}</span>
                        </div>
                    </div>
                `;
            }
            html += `</div></div>`;
        }
        
        // OUTCOME REASONS BREAKDOWN (NEW - shows WHY trades end)
        if (result.byReason && Object.keys(result.byReason).length > 0) {
            html += `<div style="background:var(--bg4);padding:12px;border-radius:6px;margin-bottom:10px;">
                <div style="font-size:11px;font-weight:700;margin-bottom:8px;color:var(--amber);">🔬 OUTCOME BREAKDOWN (Why Trades End)</div>
                <div style="display:grid;gap:6px;">`;
            
            // Sort by number of trades
            const reasonEntries = Object.entries(result.byReason).sort((a, b) => b[1].trades - a[1].trades);
            
            for (const [reason, stats] of reasonEntries) {
                const pct = ((stats.trades / result.totalTrades) * 100).toFixed(1);
                const wrColor = stats.winRate >= 50 ? 'var(--long)' : 'var(--short)';
                const reasonLabel = {
                    'TP_HIT': '✅ TP Hit',
                    'TP_HIT_BOTH': '✅ TP Hit (Both)',
                    'SL_HIT': '❌ SL Hit',
                    'SL_HIT_BOTH': '❌ SL Hit (Both)',
                    'TIMEOUT': '⏰ Timeout',
                    'GAP_THROUGH_SL': '💥 Gap Through SL'
                }[reason] || reason;
                
                html += `
                    <div style="display:grid;grid-template-columns:120px 60px 1fr;gap:10px;font-size:10px;padding:4px 0;border-bottom:1px solid var(--border);">
                        <span style="font-weight:600;">${reasonLabel}</span>
                        <span style="color:var(--text3);">${stats.trades} (${pct}%)</span>
                        <span style="color:${wrColor};">WR: ${stats.winRate.toFixed(1)}% | RR: ${stats.avgRR.toFixed(2)}</span>
                    </div>
                `;
            }
            html += `</div></div>`;
        }
        
        // Worst Combinations
        if (result.worstCombinations.length > 0) {
            html += `<div style="background:var(--bg4);padding:12px;border-radius:6px;">
                <div style="font-size:11px;font-weight:700;margin-bottom:8px;color:var(--short);">💀 WORST 5 CONFIGURATIONS (AVOID)</div>
                <div style="max-height:150px;overflow-y:auto;">`;
            
            for (let i = 0; i < Math.min(5, result.worstCombinations.length); i++) {
                const c = result.worstCombinations[i];
                html += `
                    <div style="padding:8px;border-bottom:1px solid var(--border);font-size:10px;">
                        <div style="font-weight:700;margin-bottom:3px;color:var(--short);">${c.config}</div>
                        <div style="display:flex;gap:15px;color:var(--text3);">
                            <span>Trades: ${c.trades}</span>
                            <span>WR: ${c.winRate.toFixed(1)}%</span>
                            <span style="color:var(--short);">Exp: ${c.expectancy.toFixed(3)}</span>
                        </div>
                    </div>
                `;
            }
            html += `</div></div>`;
        }
        
        html += `</div>`;
        resultsDiv.innerHTML = html;
        
    } catch (error) {
        progressDiv.style.display = 'none';
        resultsDiv.innerHTML = `
            <div style="text-align:center;padding:40px;color:var(--short);">
                <div style="font-size:40px;margin-bottom:10px;">❌</div>
                <div>Error: ${error.message}</div>
            </div>
        `;
    }
    
    btn.disabled = false;
}

function showUltimateBacktest() { createUltimateBacktestUI(); document.getElementById('ultimateBacktestPanel').style.display = 'block'; AutoPilot.loadConfig(); }
function hideUltimateBacktest() { document.getElementById('ultimateBacktestPanel').style.display = 'none'; }

async function runUltimateBacktest() {
    const btn = document.getElementById('ubRunBtn');
    const resultsDiv = document.getElementById('ubBacktestResults');
    const symbol = document.getElementById('ubSymbol').value;
    const timeframe = document.getElementById('ubTimeframe').value;
    const minScore = parseInt(document.getElementById('ubMinScore').value);
    const capital = parseFloat(document.getElementById('ubCapital').value) || 10000;
    
    btn.disabled = true; btn.textContent = '⏳ RUNNING...';
    resultsDiv.innerHTML = '<div style="text-align:center;padding:40px;"><div style="font-size:40px;animation:spin 1s linear infinite;">⏳</div><div style="margin-top:10px;">Fetching historical data...</div><div id="ubProgress" style="font-size:11px;color:var(--text3);margin-top:5px;">0%</div></div>';
    
    try {
        const candles = await fetchKlines(symbol, timeframe, 1500);
        if (!candles || !Array.isArray(candles) || candles.length < 200) {
            throw new Error('Insufficient data: ' + (candles?.length || 0) + ' candles');
        }
        
        // Validate candle data integrity
        const validCandles = candles.filter(c => 
            c && typeof c === 'object' && 
            c.open > 0 && c.high > 0 && c.low > 0 && c.close > 0 && 
            c.high >= c.low && !isNaN(c.volume)
        );
        
        if (validCandles.length < 200) {
            throw new Error('Too many invalid candles: only ' + validCandles.length + ' valid out of ' + candles.length);
        }
        
        document.getElementById('ubProgress').textContent = 'Analyzing signals...';
        const trades = [];
        const totalSteps = validCandles.length - 100;
        
        for (let i = 100; i < validCandles.length - 20; i += 2) {
            if (i % 50 === 0) { 
                const progressEl = document.getElementById('ubProgress');
                if (progressEl) progressEl.textContent = `${Math.round((i - 80) / totalSteps * 100)}%`; 
                await new Promise(r => setTimeout(r, 1)); 
            }
            
            const slice = validCandles.slice(i - 100, i);
            if (!slice || slice.length < 100) continue;
            
            try {
                const signal = quickSignalCheck(slice, symbol, timeframe);
                
                // DEBUG: Log first 10 signal attempts
                if (i < 100) {
                    console.log(`[BACKTEST DEBUG] i=${i}, signal=${signal ? 'EXISTS' : 'NULL'}, score=${signal?.score || 'N/A'}, minScore=${minScore}`);
                }
                
                if (!signal || signal.score < minScore) continue;
                
                const future = validCandles.slice(i + 1, i + 21);
                if (!future || future.length < 5) continue;
                
                const outcome = simulateTradeOutcome(signal, future);
                if (!outcome) continue;
                
                // V12: Record outcome for EV learning (continuous improvement)
                try {
                    if (typeof EVLearner !== 'undefined') {
                        EVLearner.recordOutcome(signal, outcome);
                    }
                } catch (e) { /* ignore EV errors */ }
                
                // STANDARDIZED: Match BacktestStatistics format (pnl - 0.2 fee)
                const netPnl = outcome.pnl - 0.2;
                
                trades.push({ symbol, timeframe, direction: signal.direction, grade: signal.grade, score: signal.score, entry: signal.entry, sl: signal.sl, tp: signal.tp1 || signal.tp, entryTime: validCandles[i].time || validCandles[i].timestamp, outcome: outcome.won ? 'WIN' : 'LOSS', pnl: outcome.pnl, netPnl, rr: outcome.rr, exitReason: outcome.exitReason });
            } catch (signalError) {
                // Skip bad signals silently
                continue;
            }
        }
        
        // V12: After backtest, re-learn EV if we have enough new data
        try {
            if (typeof EVLearner !== 'undefined' && EVLearner.outcomes.length >= 50) {
                EVLearner.learnEV();
                EVLearner.save();
                console.log('[EV LEARNER] Auto-updated from backtest. Total outcomes:', EVLearner.outcomes.length);
            }
        } catch (e) { console.warn('[EV LEARNER] Auto-update failed:', e.message); }
        
        lastBacktestTrades = trades;
        const stats = BacktestStatistics.calculate(trades, capital);
        displayUltimateResults(symbol, timeframe, validCandles.length, trades, stats, capital);
    } catch (error) {
        resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--short);"><div style="font-size:40px;margin-bottom:10px;">❌</div><div>Backtest failed: ${error.message}</div></div>`;
    }
    
    btn.disabled = false; btn.textContent = '▶ RUN BACKTEST';
}

function displayUltimateResults(symbol, timeframe, candleCount, trades, stats, capital) {
    const resultsDiv = document.getElementById('ubBacktestResults');
    const winRate = parseFloat(stats.winRate) || 0;
    const pnlPct = parseFloat(stats.totalPnlPct) || 0;
    const sharpe = parseFloat(stats.sharpeRatio) || 0;
    const maxDD = parseFloat(stats.maxDrawdownPct) || 0;
    const pf = parseFloat(stats.profitFactor) || 0;
    
    const wrColor = winRate >= 55 ? 'var(--long)' : winRate >= 45 ? 'var(--amber)' : 'var(--short)';
    const pnlColor = pnlPct > 0 ? 'var(--long)' : 'var(--short)';
    const sharpeColor = sharpe >= 1.5 ? 'var(--long)' : sharpe >= 0.5 ? 'var(--amber)' : 'var(--short)';
    const ddColor = maxDD <= 15 ? 'var(--long)' : maxDD <= 25 ? 'var(--amber)' : 'var(--short)';
    const pfColor = pf >= 1.5 ? 'var(--long)' : pf >= 1 ? 'var(--amber)' : 'var(--short)';
    
    const byGrade = {};
    trades.forEach(t => { const g = t.grade || 'VALID'; if (!byGrade[g]) byGrade[g] = { trades: 0, wins: 0, pnl: 0 }; byGrade[g].trades++; if (t.outcome === 'WIN') byGrade[g].wins++; byGrade[g].pnl += t.pnl || 0; });
    
    let gradeHTML = '';
    for (const [grade, data] of Object.entries(byGrade)) {
        const wr = data.trades > 0 ? ((data.wins / data.trades) * 100).toFixed(0) : 0;
        const pnl = data.pnl.toFixed(1);
        gradeHTML += `<div style="display:flex;justify-content:space-between;padding:6px 8px;background:var(--bg4);border-radius:4px;margin-bottom:4px;font-size:11px;"><span style="font-weight:700;">${grade}</span><span>${data.trades} trades</span><span style="color:${parseFloat(wr) >= 50 ? 'var(--long)' : 'var(--short)'}">${wr}% WR</span><span style="color:${parseFloat(pnl) >= 0 ? 'var(--long)' : 'var(--short)'}">${pnl}%</span></div>`;
    }
    
    resultsDiv.innerHTML = `<div style="margin-bottom:15px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;"><div style="font-size:14px;font-weight:700;">${symbol} ${CONFIG.TF_LABELS?.[timeframe] || timeframe}</div><div style="font-size:11px;color:var(--text3);">${candleCount} candles | ${trades.length} trades</div></div>
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:15px;">
            <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;"><div style="font-size:10px;color:var(--text3);margin-bottom:4px;">WIN RATE</div><div style="font-size:20px;font-weight:700;color:${wrColor}">${stats.winRate}%</div></div>
            <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;"><div style="font-size:10px;color:var(--text3);margin-bottom:4px;">TOTAL PNL</div><div style="font-size:20px;font-weight:700;color:${pnlColor}">${pnlPct >= 0 ? '+' : ''}${stats.totalPnlPct}%</div></div>
            <div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;"><div style="font-size:10px;color:var(--text3);margin-bottom:4px;">SHARPE</div><div style="font-size:20px;font-weight:700;color:${sharpeColor}">${stats.sharpeRatio}</div></div>
        </div>
        <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:15px;">
            <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;"><div style="font-size:9px;color:var(--text3);">MAX DD</div><div style="font-size:14px;font-weight:700;color:${ddColor}">${stats.maxDrawdownPct}%</div></div>
            <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;"><div style="font-size:9px;color:var(--text3);">PROFIT F.</div><div style="font-size:14px;font-weight:700;color:${pfColor}">${stats.profitFactor}</div></div>
            <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;"><div style="font-size:9px;color:var(--text3);">AVG RR</div><div style="font-size:14px;font-weight:700;">${stats.avgRR}</div></div>
            <div style="background:var(--bg4);padding:8px;border-radius:4px;text-align:center;"><div style="font-size:9px;color:var(--text3);">EXPECTANCY</div><div style="font-size:14px;font-weight:700;color:${parseFloat(stats.expectancy) >= 0 ? 'var(--long)' : 'var(--short)'}">${stats.expectancy}</div></div>
        </div>
        <div style="background:linear-gradient(135deg,var(--bg4),var(--bg3));padding:12px;border-radius:6px;text-align:center;margin-bottom:15px;border:1px solid ${pnlColor};"><div style="font-size:10px;color:var(--text3);margin-bottom:4px;">FINAL EQUITY</div><div style="font-size:24px;font-weight:700;color:${pnlColor}">$${stats.finalEquity}</div><div style="font-size:11px;color:var(--text3);">from $${capital.toLocaleString()}</div></div>
        <div style="margin-bottom:15px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">📊 BY GRADE</div>${gradeHTML}</div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;"><div style="background:var(--long-dim);padding:8px;border-radius:4px;text-align:center;border:1px solid var(--long);"><div style="font-size:9px;color:var(--text3);">MAX WIN STREAK</div><div style="font-size:16px;font-weight:700;color:var(--long);">${stats.maxConsecWins}</div></div><div style="background:var(--short-dim);padding:8px;border-radius:4px;text-align:center;border:1px solid var(--short);"><div style="font-size:9px;color:var(--text3);">MAX LOSS STREAK</div><div style="font-size:16px;font-weight:700;color:var(--short);">${stats.maxConsecLosses}</div></div></div>
    </div>`;
}

async function runFullValidation() {
    const btn = document.getElementById('ubValidateBtn');
    const resultsDiv = document.getElementById('ubBacktestResults');
    const symbol = document.getElementById('ubSymbol').value;
    const timeframe = document.getElementById('ubTimeframe').value;
    const minScore = parseInt(document.getElementById('ubMinScore').value);
    
    btn.disabled = true; btn.textContent = '⏳ VALIDATING...';
    resultsDiv.innerHTML = '<div style="text-align:center;padding:40px;"><div style="font-size:40px;animation:spin 1s linear infinite;">🔬</div><div style="margin-top:10px;">Running full validation...</div><div id="ubProgress" style="font-size:11px;color:var(--text3);margin-top:5px;">Step 1/4: Fetching data...</div></div>';
    
    try {
        const candles = await fetchKlines(symbol, timeframe, 1500);
        if (!candles || !Array.isArray(candles) || candles.length < 500) {
            throw new Error('Need at least 500 candles for full validation (got ' + (candles?.length || 0) + ')');
        }
        
        // VALIDATION: Check candle data integrity
        const validCandles = candles.filter(c => 
            c && typeof c === 'object' &&
            c.open > 0 && c.high > 0 && c.low > 0 && c.close > 0 && 
            c.high >= c.low && !isNaN(c.volume)
        );
        if (validCandles.length < 500) throw new Error('Too many invalid candles (' + (candles.length - validCandles.length) + ' bad)');
        
        const progressEl = document.getElementById('ubProgress');
        if (progressEl) progressEl.textContent = 'Step 1/4: Running backtest...';
        
        const trades = [];
        for (let i = 100; i < validCandles.length - 20; i += 3) {
            const slice = validCandles.slice(i - 100, i);
            if (!slice || slice.length < 100) continue;
            
            try {
                const signal = quickSignalCheck(slice, symbol, timeframe);
                if (!signal || signal.score < minScore) continue;
                
                const future = validCandles.slice(i + 1, i + 21);
                if (!future || future.length < 5) continue;
                
                const outcome = simulateTradeOutcome(signal, future);
                if (!outcome) continue;
                
                trades.push({ netPnl: outcome.pnl - 0.2, won: outcome.won, pnl: outcome.pnl });
            } catch (e) {
                // Skip bad signals
                continue;
            }
        }
        if (trades.length < 20) throw new Error('Insufficient trades for validation: ' + trades.length);
        
        lastBacktestTrades = trades;
        const btStats = BacktestStatistics.calculate(trades, 10000);
        
        document.getElementById('ubProgress').textContent = 'Step 2/4: K-Fold validation...';
        await new Promise(r => setTimeout(r, 100));
        const kfold = await KFoldCV.run(symbol, timeframe, validCandles, { minScore }, 5);
        
        document.getElementById('ubProgress').textContent = 'Step 3/4: Walk-Forward analysis...';
        await new Promise(r => setTimeout(r, 100));
        const wf = await WalkForwardAnalysis.run(symbol, timeframe, validCandles);
        
        document.getElementById('ubProgress').textContent = 'Step 4/4: Monte Carlo simulation...';
        await new Promise(r => setTimeout(r, 100));
        const mc = MonteCarloSimulator.run(trades, 1000);
        
        let confidence = 0;
        const checks = [];
        
        const wr = parseFloat(btStats.winRate);
        if (wr >= 55) { confidence += 15; checks.push({ name: 'Win Rate', status: '✅', value: wr + '%' }); }
        else if (wr >= 45) { confidence += 10; checks.push({ name: 'Win Rate', status: '⚠️', value: wr + '%' }); }
        else { checks.push({ name: 'Win Rate', status: '❌', value: wr + '%' }); }
        
        const pf = parseFloat(btStats.profitFactor);
        if (pf >= 1.5) { confidence += 15; checks.push({ name: 'Profit Factor', status: '✅', value: pf }); }
        else if (pf >= 1.0) { confidence += 10; checks.push({ name: 'Profit Factor', status: '⚠️', value: pf }); }
        else { checks.push({ name: 'Profit Factor', status: '❌', value: pf }); }
        
        if (kfold?.summary?.isConsistent) { confidence += 20; checks.push({ name: 'K-Fold Consistent', status: '✅', value: 'Yes' }); }
        else { checks.push({ name: 'K-Fold Consistent', status: '❌', value: 'No' }); }
        
        const wfEff = parseFloat(wf?.efficiency) || 0;
        if (wfEff >= 0.7) { confidence += 20; checks.push({ name: 'Walk-Forward', status: '✅', value: (wfEff * 100).toFixed(0) + '%' }); }
        else if (wfEff >= 0.5) { confidence += 10; checks.push({ name: 'Walk-Forward', status: '⚠️', value: (wfEff * 100).toFixed(0) + '%' }); }
        else { checks.push({ name: 'Walk-Forward', status: '❌', value: (wfEff * 100).toFixed(0) + '%' }); }
        
        const mcProfit = parseFloat(mc?.profitProbability) || 0;
        if (mcProfit >= 80) { confidence += 20; checks.push({ name: 'MC Profit Prob', status: '✅', value: mcProfit + '%' }); }
        else if (mcProfit >= 60) { confidence += 10; checks.push({ name: 'MC Profit Prob', status: '⚠️', value: mcProfit + '%' }); }
        else { checks.push({ name: 'MC Profit Prob', status: '❌', value: mcProfit + '%' }); }
        
        const dd = parseFloat(btStats.maxDrawdownPct);
        if (dd <= 15) { confidence += 10; checks.push({ name: 'Max Drawdown', status: '✅', value: dd + '%' }); }
        else if (dd <= 25) { confidence += 5; checks.push({ name: 'Max Drawdown', status: '⚠️', value: dd + '%' }); }
        else { checks.push({ name: 'Max Drawdown', status: '❌', value: dd + '%' }); }
        
        const rating = confidence >= 80 ? 'EXCELLENT' : confidence >= 60 ? 'GOOD' : confidence >= 40 ? 'MODERATE' : 'POOR';
        const ratingColor = confidence >= 80 ? 'var(--long)' : confidence >= 60 ? 'var(--cyan)' : confidence >= 40 ? 'var(--amber)' : 'var(--short)';
        
        let checksHTML = checks.map(c => `<div style="display:flex;justify-content:space-between;padding:8px;background:var(--bg4);border-radius:4px;margin-bottom:4px;"><span>${c.status} ${c.name}</span><span style="font-weight:700;">${c.value}</span></div>`).join('');
        
        resultsDiv.innerHTML = `<div style="margin-bottom:15px;">
            <div style="text-align:center;margin-bottom:20px;"><div style="font-size:14px;color:var(--text3);margin-bottom:5px;">STRATEGY CONFIDENCE</div><div style="font-size:48px;font-weight:700;color:${ratingColor}">${confidence}%</div><div style="font-size:18px;font-weight:700;color:${ratingColor};margin-top:5px;">${rating}</div></div>
            <div style="margin-bottom:15px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">🔬 VALIDATION CHECKS</div>${checksHTML}</div>
            <div style="background:linear-gradient(135deg,var(--bg4),var(--bg3));padding:12px;border-radius:6px;margin-bottom:15px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">🎲 MONTE CARLO (1000 sims)</div><div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;"><div style="text-align:center;"><div style="font-size:9px;color:var(--text3);">WORST 5%</div><div style="font-size:14px;font-weight:700;color:${parseFloat(mc.percentile5.totalReturn) >= 0 ? 'var(--long)' : 'var(--short)'}">${mc.percentile5.totalReturn}%</div></div><div style="text-align:center;"><div style="font-size:9px;color:var(--text3);">MEDIAN</div><div style="font-size:14px;font-weight:700;color:${parseFloat(mc.median.totalReturn) >= 0 ? 'var(--long)' : 'var(--short)'}">${mc.median.totalReturn}%</div></div><div style="text-align:center;"><div style="font-size:9px;color:var(--text3);">BEST 5%</div><div style="font-size:14px;font-weight:700;color:var(--long)">${mc.percentile95.totalReturn}%</div></div></div></div>
            <div style="background:var(--bg4);padding:12px;border-radius:6px;margin-bottom:15px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">📊 K-FOLD (5 folds)</div><div style="display:flex;justify-content:space-between;font-size:11px;"><span>Avg Win Rate: <b>${kfold?.summary?.avgWinRate || 0}%</b></span><span>Std Dev: <b>${kfold?.summary?.winRateStdDev || 0}%</b></span><span>Consistency: <b style="color:${kfold?.summary?.isConsistent ? 'var(--long)' : 'var(--short)'}">${kfold?.summary?.consistency || 0}%</b></span></div></div>
            <div style="background:var(--bg4);padding:12px;border-radius:6px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">📈 WALK-FORWARD (4 windows)</div><div style="display:flex;justify-content:space-between;font-size:11px;"><span>In-Sample: <b style="color:${parseFloat(wf.totalInSample) >= 0 ? 'var(--long)' : 'var(--short)'}">${wf.totalInSample}%</b></span><span>Out-Sample: <b style="color:${parseFloat(wf.totalOutOfSample) >= 0 ? 'var(--long)' : 'var(--short)'}">${wf.totalOutOfSample}%</b></span><span>Efficiency: <b style="color:${ratingColor}">${wf.rating}</b></span></div></div>
        </div>`;
    } catch (error) {
        resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--short);"><div style="font-size:40px;margin-bottom:10px;">❌</div><div>Validation failed: ${error.message}</div></div>`;
    }
    
    btn.disabled = false; btn.textContent = '🔬 FULL VALIDATION';
}

async function runMonteCarlo() {
    const btn = document.getElementById('ubMCBtn');
    const resultsDiv = document.getElementById('ubMCResults');
    const simulations = parseInt(document.getElementById('ubMCSimulations').value);
    
    if (!lastBacktestTrades || lastBacktestTrades.length < 10) {
        resultsDiv.innerHTML = '<div style="text-align:center;padding:40px;color:var(--amber);"><div style="font-size:40px;margin-bottom:10px;">⚠️</div><div>Run backtest first!</div><div style="font-size:11px;color:var(--text3);margin-top:10px;">lastBacktestTrades: ' + (lastBacktestTrades ? lastBacktestTrades.length : 'null') + '</div></div>';
        return;
    }
    
    // VALIDATION: Check trade data structure integrity
    const validTrades = lastBacktestTrades.filter(t => {
        if (!t || typeof t !== 'object') return false;
        const pnlVal = t.netPnl !== undefined ? t.netPnl : t.pnl;
        return pnlVal !== undefined && !isNaN(pnlVal) && isFinite(pnlVal);
    });
    
    console.log('[MONTE CARLO UI] lastBacktestTrades:', lastBacktestTrades.length, 'validTrades:', validTrades.length);
    console.log('[MONTE CARLO UI] Sample trade:', validTrades[0]);
    
    if (validTrades.length < 10) {
        resultsDiv.innerHTML = '<div style="text-align:center;padding:40px;color:var(--amber);"><div style="font-size:40px;margin-bottom:10px;">⚠️</div><div>Not enough valid trades (' + validTrades.length + '/10)</div><div style="font-size:11px;color:var(--text3);margin-top:10px;">Run backtest again with lower min score</div></div>';
        return;
    }
    
    btn.disabled = true; btn.textContent = '⏳ SIMULATING...';
    resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;"><div style="font-size:40px;animation:spin 1s linear infinite;">🎲</div><div style="margin-top:10px;">Running ${simulations.toLocaleString()} simulations...</div></div>`;
    
    await new Promise(r => setTimeout(r, 100));
    
    try {
        const mc = MonteCarloSimulator.run(validTrades, simulations);
        
        // V12 FIX: Check for error response
        if (mc.error) {
            resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--short);"><div style="font-size:40px;margin-bottom:10px;">❌</div><div>Monte Carlo Error:</div><div style="font-size:12px;margin-top:5px;">${mc.error}</div></div>`;
            btn.disabled = false; btn.textContent = '🎲 RUN MONTE CARLO';
            return;
        }
        
        const profitProb = parseFloat(mc.profitProbability) || 0;
        const probColor = profitProb >= 80 ? 'var(--long)' : profitProb >= 60 ? 'var(--amber)' : 'var(--short)';
        
        resultsDiv.innerHTML = `<div style="margin-bottom:15px;">
            <div style="text-align:center;margin-bottom:20px;"><div style="font-size:14px;color:var(--text3);margin-bottom:5px;">PROFIT PROBABILITY</div><div style="font-size:48px;font-weight:700;color:${probColor}">${mc.profitProbability}%</div><div style="font-size:11px;color:var(--text3);margin-top:5px;">${simulations.toLocaleString()} simulations | ${mc.tradeCount} trades</div></div>
            <div style="background:var(--bg4);border-radius:6px;overflow:hidden;margin-bottom:15px;">
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;background:var(--bg3);padding:8px;font-size:10px;font-weight:700;"><div>PERCENTILE</div><div style="text-align:center;">RETURN</div><div style="text-align:right;">EQUITY</div></div>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;padding:8px;font-size:11px;border-bottom:1px solid var(--border);"><div>5% (Worst)</div><div style="text-align:center;color:${parseFloat(mc.percentile5.totalReturn) >= 0 ? 'var(--long)' : 'var(--short)'}">${mc.percentile5.totalReturn}%</div><div style="text-align:right;">$${mc.percentile5.finalEquity}</div></div>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;padding:8px;font-size:11px;border-bottom:1px solid var(--border);background:var(--bg3);"><div style="font-weight:700;">50% (Median)</div><div style="text-align:center;font-weight:700;color:${parseFloat(mc.median.totalReturn) >= 0 ? 'var(--long)' : 'var(--short)'}">${mc.median.totalReturn}%</div><div style="text-align:right;font-weight:700;">$${mc.median.finalEquity}</div></div>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;padding:8px;font-size:11px;"><div>95% (Best)</div><div style="text-align:center;color:var(--long)">${mc.percentile95.totalReturn}%</div><div style="text-align:right;">$${mc.percentile95.finalEquity}</div></div>
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:15px;"><div style="background:var(--short-dim);padding:12px;border-radius:6px;text-align:center;border:1px solid var(--short);"><div style="font-size:10px;color:var(--text3);">RUIN PROBABILITY</div><div style="font-size:20px;font-weight:700;color:var(--short);">${mc.ruinProbability}%</div></div><div style="background:var(--bg4);padding:12px;border-radius:6px;text-align:center;"><div style="font-size:10px;color:var(--text3);">WORST DRAWDOWN</div><div style="font-size:20px;font-weight:700;color:var(--amber);">${mc.percentile5.maxDrawdown}%</div></div></div>
            <div style="background:var(--bg4);border-radius:6px;padding:10px;"><div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;font-size:10px;text-align:center;"><div><div style="color:var(--text3);">Mean Return</div><div style="font-weight:700;">${mc.mean || '0'}%</div></div><div><div style="color:var(--text3);">Std Dev</div><div style="font-weight:700;">${mc.stdDev || '0'}%</div></div><div><div style="color:var(--text3);">Sharpe Est.</div><div style="font-weight:700;">${mc.sharpeEstimate || '0'}</div></div></div></div>
        </div>`;
        
    } catch (error) {
        console.error('[MONTE CARLO UI] Error:', error);
        resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--short);"><div style="font-size:40px;margin-bottom:10px;">❌</div><div>Error: ${error.message}</div></div>`;
    }
    
    btn.disabled = false; btn.textContent = '🎲 RUN MONTE CARLO';
}

async function runOptimization() {
    const btn = document.getElementById('ubOptBtn');
    const resultsDiv = document.getElementById('ubOptResults');
    const symbol = document.getElementById('ubSymbol').value;
    const timeframe = document.getElementById('ubTimeframe').value;
    
    btn.disabled = true; btn.textContent = '⏳ OPTIMIZING...';
    resultsDiv.innerHTML = '<div style="text-align:center;padding:40px;"><div style="font-size:40px;animation:spin 1s linear infinite;">🧬</div><div style="margin-top:10px;">Fetching data...</div><div id="optProgress" style="font-size:11px;color:var(--text3);margin-top:5px;">Generation 0/10</div></div>';
    
    try {
        const candles = await fetchKlines(symbol, timeframe, 1000);
        if (!candles || !Array.isArray(candles) || candles.length < 500) {
            throw new Error('Need at least 500 candles for optimization');
        }
        
        // VALIDATION: Check candle data integrity
        const validCandles = candles.filter(c => 
            c && typeof c === 'object' &&
            c.open > 0 && c.high > 0 && c.low > 0 && c.close > 0 && 
            c.high >= c.low && c.high >= c.open && c.high >= c.close &&
            c.low <= c.open && c.low <= c.close && !isNaN(c.volume)
        );
        if (validCandles.length < 500) throw new Error('Too many invalid candles in data (' + (candles.length - validCandles.length) + ' bad)');
        
        const result = await GeneticOptimizer.run(symbol, timeframe, validCandles, (progress) => {
            const progressEl = document.getElementById('optProgress');
            if (progressEl) progressEl.textContent = `Generation ${progress.generation}/${progress.total} | Best: ${progress.best}`;
        });
        
        // Handle error case
        if (result.error) {
            throw new Error(result.error);
        }
        
        // Ensure all params exist with defaults
        const params = {
            minScore: result.bestParams?.minScore ?? 60,
            zoneWeight: result.bestParams?.zoneWeight ?? 30,
            smcWeight: result.bestParams?.smcWeight ?? 30,
            momentumWeight: result.bestParams?.momentumWeight ?? 30,
            riskPerTrade: result.bestParams?.riskPerTrade ?? 1
        };
        
        let historyHTML = (result.history || []).slice(-5).map(h => `<div style="display:flex;justify-content:space-between;padding:6px 8px;background:var(--bg4);border-radius:4px;margin-bottom:4px;font-size:10px;"><span>Gen ${h.generation}</span><span>Best: ${h.bestFitness}</span><span>Avg: ${h.avgFitness}</span></div>`).join('');
        
        const fitnessColor = result.bestFitness > 0 ? 'var(--long)' : 'var(--short)';
        
        resultsDiv.innerHTML = `<div style="margin-bottom:15px;">
            <div style="text-align:center;margin-bottom:20px;"><div style="font-size:14px;color:var(--text3);margin-bottom:5px;">BEST FITNESS SCORE</div><div style="font-size:48px;font-weight:700;color:${fitnessColor}">${result.bestFitness.toFixed(1)}</div></div>
            <div style="background:linear-gradient(135deg,var(--bg4),var(--bg3));padding:15px;border-radius:6px;margin-bottom:15px;border:1px solid var(--long);"><div style="font-size:12px;font-weight:700;margin-bottom:10px;">🏆 OPTIMAL PARAMETERS</div><div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;"><div style="font-size:11px;">Min Score: <b style="color:var(--cyan)">${params.minScore}</b></div><div style="font-size:11px;">Zone Weight: <b style="color:var(--cyan)">${params.zoneWeight}%</b></div><div style="font-size:11px;">SMC Weight: <b style="color:var(--purple)">${params.smcWeight}%</b></div><div style="font-size:11px;">Momentum Weight: <b style="color:var(--amber)">${params.momentumWeight}%</b></div><div style="font-size:11px;">Risk/Trade: <b style="color:var(--long)">${params.riskPerTrade}%</b></div></div></div>
            <div style="background:var(--bg4);padding:12px;border-radius:6px;"><div style="font-size:12px;font-weight:700;margin-bottom:8px;">📈 EVOLUTION (Last 5 Generations)</div>${historyHTML || '<div style="text-align:center;color:var(--text3);font-size:11px;">No history available</div>'}</div>
        </div>`;
    } catch (error) {
        resultsDiv.innerHTML = `<div style="text-align:center;padding:40px;color:var(--short);"><div style="font-size:40px;margin-bottom:10px;">❌</div><div>Optimization failed: ${error.message}</div></div>`;
    }
    
    btn.disabled = false; btn.textContent = '🧬 START OPTIMIZATION';
}

function addUltimateBacktestButton() {
    const headerBtns = document.querySelector('.header-btns');
    if (headerBtns && !document.getElementById('ubOpenBtn')) {
        const btn = document.createElement('button');
        btn.id = 'ubOpenBtn'; btn.className = 'btn'; btn.innerHTML = '🚀'; btn.title = 'Ultimate Backtest';
        btn.onclick = showUltimateBacktest;
        btn.style.background = 'linear-gradient(135deg, var(--cyan), var(--purple))';
        btn.style.border = 'none'; btn.style.color = '#fff';
        headerBtns.insertBefore(btn, headerBtns.firstChild);
    }
}

if (!document.getElementById('ubStyles')) {
    const style = document.createElement('style');
    style.id = 'ubStyles';
    style.textContent = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } .ub-tab:hover { opacity: 0.8; }';
    document.head.appendChild(style);
}

setTimeout(() => { addUltimateBacktestButton(); AutoPilot.loadConfig(); }, 1000);
console.log('🚀 BS SCANNER V19 ULTRA - LIQUIDITY-FIRST HYBRID');
console.log('🔴 ULTRA RED DNA: Liquidity Pool Finder, Sweep Detection, Regime Filter');
console.log('🔵 V18 ENGINES: SMC (+20), Zone (+15), Momentum (filter only)');
console.log('⚖️ V19 SCORING: Base 50 + Capped Bonuses (max +15) - Subtractive Penalties');
console.log('🚪 MASTER GATE: No Liquidity Pool = No Signal');
console.log('📊 MODES: CONFIRMED / LIMIT / CAUTION / WATCH (from Ultra Red)');

</script>
</body>
</html>
