<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta name="theme-color" content="#0a0a0f">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="BS SCANNER">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQlMgU2Nhbm5lciBWMSIsInNob3J0X25hbWUiOiJCUyBWMSIsImRlc2NyaXB0aW9uIjoiQnliaXQgQ3J5cHRvIFNpZ25hbCBTY2FubmVyIHdpdGggTXVsdGktQUkiLCJzdGFydF91cmwiOiIuIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzBhMGEwZiIsInRoZW1lX2NvbG9yIjoiIzBhMGEwZiIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAxMDAgMTAwJz48cmVjdCB3aWR0aD0nMTAwJyBoZWlnaHQ9JzEwMCcgZmlsbD0nJTIzMGEwYTBmJy8+PHRleHQgeD0nNTAnIHk9JzYwJyBmb250LXNpemU9JzQwJyB0ZXh0LWFuY2hvcj0nbWlkZGxlJyBmaWxsPSclMjNmZmQ3MDAnPuKaoTwvdGV4dD48L3N2Zz4iLCJzaXplcyI6IjE5MngxOTIiLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCJ9XX0=">
<title>BS Scanner V1</title>
<style>
:root{
--bg1:#0a0a0f;--bg2:#12121a;--bg3:#1a1a25;--bg4:#22222f;
--border:#2a2a3a;--text:#ffffff;--text2:#ffffff;--text3:#ffffff;
--long:#00d9a0;--long-dim:rgba(0,217,160,0.15);
--short:#ff4757;--short-dim:rgba(255,71,87,0.15);
--purple:#a855f7;--purple-dim:rgba(168,85,247,0.15);
--blue:#3b82f6;--blue-dim:rgba(59,130,246,0.15);
--amber:#f59e0b;--amber-dim:rgba(245,158,11,0.15);
--cyan:#06b6d4;--cyan-dim:rgba(6,182,212,0.15);
--gold:#ffd700;--gold-dim:rgba(255,215,0,0.15)
}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,-apple-system,sans-serif;background:var(--bg1);color:var(--text);min-height:100vh;overflow-x:hidden}
.app{display:flex;flex-direction:column;min-height:100vh}

/* HEADER - 2 ROW LAYOUT */
.header{display:flex;flex-direction:column;padding:8px 10px;background:var(--bg2);border-bottom:1px solid var(--border);gap:6px}
.header-row1{display:flex;align-items:center;gap:6px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch;scrollbar-width:none;-ms-overflow-style:none;padding:6px 10px;background:var(--bg2);border-bottom:1px solid var(--border)}
.header-row1::-webkit-scrollbar{display:none}
/* Market Info Badge - Redesigned to match ENV bar */
.info-badge{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg3);border-radius:4px;font-size:11px;border:1px solid var(--border);flex-shrink:0;white-space:nowrap}
.info-badge .icon{font-size:12px}
.info-badge .label{color:var(--text3);margin-right:2px}
.info-badge .value{font-weight:700;color:var(--text)}
.info-badge.go{border-color:var(--long);background:var(--long-dim)}
.info-badge.go .value{color:var(--long)}
.info-badge.caution{border-color:var(--amber);background:var(--amber-dim)}
.info-badge.caution .value{color:var(--amber)}
.info-badge.nogo{border-color:var(--short);background:var(--short-dim)}
.info-badge.nogo .value{color:var(--short)}
/* Old m-badge kept for compatibility but hidden */
.m-badge{display:none}
.header-row2{display:flex;align-items:center;gap:8px}
.header-btns{display:flex;gap:4px;margin-left:auto;align-items:center}
.ai-dot{width:8px;height:8px;border-radius:50%;background:var(--text3);margin-right:4px}
.ai-dot.on{background:var(--long);box-shadow:0 0 8px var(--long)}
.ai-dot.error{background:var(--short);box-shadow:0 0 8px var(--short)}
.btn{padding:4px 8px;border-radius:4px;border:1px solid var(--border);background:var(--bg3);color:var(--text);font-size:10px;cursor:pointer;transition:all 0.2s}
.btn:hover{background:var(--bg4)}
.btn.active{background:var(--long-dim);border-color:var(--long);color:var(--long)}
.btn.scanning{background:linear-gradient(90deg,rgba(255,100,100,0.9),rgba(255,180,100,0.9),rgba(255,255,100,0.9),rgba(100,255,100,0.9),rgba(100,255,255,0.9),rgba(100,180,255,0.9),rgba(180,100,255,0.9),rgba(255,100,255,0.9),rgba(255,100,180,0.9),rgba(255,100,100,0.9));background-size:200% 100%;animation:rainbowFlow 2s linear infinite;border:none;color:#fff;font-weight:700;text-shadow:0 0 5px rgba(0,0,0,0.5);box-shadow:0 0 10px rgba(200,200,255,0.4),0 0 20px rgba(100,200,255,0.2)}
.btn.scan-done{background:linear-gradient(90deg,var(--long),rgba(0,255,170,0.8),var(--cyan),rgba(0,255,170,0.8),var(--long));background-size:200% 100%;animation:completePulse 3s ease-in-out infinite;border:none;color:#fff;font-weight:700;text-shadow:0 0 5px rgba(0,0,0,0.5);box-shadow:0 0 10px var(--long),0 0 20px rgba(0,255,170,0.3)}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.6}}

/* MARKET BADGES - WIDER & SCROLLABLE */
.m-badge{display:flex;align-items:center;gap:4px;padding:6px 10px;background:var(--bg3);border-radius:6px;border:1px solid var(--border);font-size:12px;min-width:85px;flex-shrink:0}
.m-badge-icon{font-size:14px}
.m-badge-value{font-weight:700;color:var(--text);font-size:12px;white-space:nowrap}
.m-badge.bull .m-badge-value{color:var(--long)}
.m-badge.bear .m-badge-value{color:var(--short)}
.m-badge.neutral .m-badge-value{color:var(--text)}
/* Season flash animations */
.m-badge.flash-bright-green{animation:flashBrightGreen 0.5s ease-in-out infinite}
.m-badge.flash-dim-green{animation:flashDimGreen 2s ease-in-out infinite}
.m-badge.flash-bright-red{animation:flashBrightRed 0.5s ease-in-out infinite}
.m-badge.flash-dim-red{animation:flashDimRed 2s ease-in-out infinite}
.m-badge.flash-bright-green .m-badge-value{color:#00ff88;text-shadow:0 0 8px #00ff88}
.m-badge.flash-dim-green .m-badge-value{color:#00d980;text-shadow:0 0 4px #00d980}
.m-badge.flash-bright-red .m-badge-value{color:#ff4757;text-shadow:0 0 8px #ff4757}
.m-badge.flash-dim-red .m-badge-value{color:#ff6b6b;text-shadow:0 0 4px #ff6b6b}
@keyframes flashBrightGreen{0%,100%{opacity:1}50%{opacity:0.3}}
@keyframes flashDimGreen{0%,100%{opacity:1}50%{opacity:0.6}}
@keyframes flashBrightRed{0%,100%{opacity:1}50%{opacity:0.3}}
@keyframes flashDimRed{0%,100%{opacity:1}50%{opacity:0.6}}

/* ENVIRONMENT BAR */
.env-bar{display:flex;align-items:center;gap:6px;padding:6px 10px;background:var(--bg2);border-bottom:1px solid var(--border);overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch;scrollbar-width:none;-ms-overflow-style:none}
.env-bar::-webkit-scrollbar{display:none}
.env-status{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg3);border-radius:4px;font-size:11px;flex-shrink:0;white-space:nowrap}
.env-status .icon{font-size:12px}
.env-status .label{color:var(--text3);margin-right:2px}
.env-status .value{font-weight:700}
.env-status.go{border:1px solid var(--long);background:var(--long-dim)}
.env-status.go .value{color:var(--long)}
.env-status.caution{border:1px solid var(--amber);background:var(--amber-dim)}
.env-status.caution .value{color:var(--amber)}
.env-status.risky{border:1px solid #ff8c00;background:rgba(255,140,0,0.15)}
.env-status.risky .value{color:#ff8c00}
.env-status.nogo{border:1px solid var(--short);background:var(--short-dim)}
.env-status.nogo .value{color:var(--short)}
.env-verdict{margin-left:auto;display:flex;align-items:center;gap:6px;padding:4px 10px;border-radius:4px;font-size:11px;font-weight:700}
.env-verdict.go{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}
.env-verdict.caution{background:var(--amber-dim);color:var(--amber);border:1px solid var(--amber)}
.env-verdict.risky{background:rgba(255,140,0,0.15);color:#ff8c00;border:1px solid #ff8c00}
.env-verdict.nogo{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.env-score{font-size:13px;font-weight:700}

/* SIGNAL CARD ENV ICONS */
.signal-env{display:flex;gap:2px;margin-top:4px;flex-wrap:wrap}
.signal-env .env-icon{font-size:10px;padding:1px 3px;border-radius:2px;background:var(--bg4)}
.signal-env .env-icon.ok{color:var(--long)}
.signal-env .env-icon.warn{color:var(--amber)}
.signal-env .env-icon.bad{color:var(--short)}

/* FILTERED SIGNALS SECTION */
.filtered-section{padding:8px 10px;background:var(--bg3);border-top:1px solid var(--border);cursor:pointer}
.filtered-section:hover{background:var(--bg4)}
.filtered-header{display:flex;align-items:center;justify-content:space-between;font-size:11px;color:var(--text3)}
.filtered-count{color:var(--short);font-weight:700}
.filtered-list{display:none;margin-top:8px;padding-top:8px;border-top:1px solid var(--border)}
.filtered-list.show{display:block}
.filtered-item{font-size:10px;padding:4px 6px;background:var(--short-dim);border-radius:4px;margin-bottom:4px;color:var(--short)}

/* ENV PANEL SECTION */
.env-panel{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px}
.env-panel-title{font-size:12px;font-weight:700;color:var(--cyan);margin-bottom:10px;padding-bottom:6px;border-bottom:1px solid var(--border)}
.env-row{display:flex;justify-content:space-between;align-items:center;padding:4px 0;font-size:11px}
.env-row .label{color:var(--text3)}

/* BACKTEST PANEL - COLLAPSIBLE */
/* COMBINED PANELS ROW - SIDE BY SIDE 50/50 */
.panels-row{display:flex;flex-direction:row;gap:4px;padding:4px;background:var(--bg2);border-bottom:1px solid var(--border);flex-wrap:nowrap}
.panels-row .panel-half{flex:1 1 50%;min-width:0;max-width:50%;background:var(--bg3);border-radius:6px;border:1px solid var(--border);overflow:hidden}
.panel-half .panel-header{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;cursor:pointer;user-select:none;background:var(--bg3)}
.panel-half .panel-header:active{background:var(--bg4)}
.panel-half .panel-title{display:flex;align-items:center;gap:4px;font-size:11px;font-weight:700}
.panel-half .panel-title.flow-color{color:var(--amber)}
.panel-half .panel-title.backtest-color{color:var(--cyan)}
.panel-half .panel-toggle{font-size:14px;color:var(--text3);transition:transform 0.3s}
.panel-half .panel-toggle.expanded{transform:rotate(180deg)}
.panel-half .panel-content{max-height:0;overflow:hidden;transition:max-height 0.3s ease-out}
.panel-half .panel-content.expanded{max-height:400px;overflow-y:auto}

/* FLOW PANEL - COMPACT */
.flow-grid-compact{display:grid;grid-template-columns:1fr 1fr;gap:3px;padding:6px}
.flow-item-compact{text-align:center;padding:5px 3px;background:var(--bg4);border-radius:4px}
.flow-item-compact .flow-label{font-size:7px;color:var(--text3);margin-bottom:1px;text-transform:uppercase;white-space:nowrap}
.flow-item-compact .flow-value{font-size:10px;font-weight:700;color:var(--text);white-space:nowrap}
.flow-item-compact .flow-change{font-size:8px;margin-top:1px;white-space:nowrap}
.flow-item-compact .flow-change.up{color:var(--long)}
.flow-item-compact .flow-change.down{color:var(--short)}
.flow-verdict-compact{display:flex;align-items:center;justify-content:center;gap:4px;padding:5px;background:var(--bg4);border-top:1px solid var(--border)}
.flow-verdict-compact .label{font-size:8px;color:var(--text3)}
.flow-verdict-compact .value{font-size:9px;font-weight:700;padding:2px 6px;border-radius:3px}
.flow-verdict-compact .value.bullish{background:var(--long-dim);color:var(--long)}
.flow-verdict-compact .value.bearish{background:var(--short-dim);color:var(--short)}
.flow-verdict-compact .value.squeeze{background:var(--amber-dim);color:var(--amber)}
.flow-verdict-compact .value.neutral{background:var(--bg3);color:var(--text2)}

/* BACKTEST PANEL - COMPACT */
.backtest-controls-compact{display:flex;flex-direction:column;gap:3px;padding:5px}
.backtest-controls-row{display:flex;gap:3px}
.backtest-select-compact{flex:1;background:var(--bg4);border:1px solid var(--border);color:var(--text);padding:4px 4px;border-radius:3px;font-size:9px;min-width:0}
.backtest-run-compact{background:var(--cyan);color:var(--bg);border:none;padding:4px 8px;border-radius:3px;font-size:9px;font-weight:700;cursor:pointer;white-space:nowrap}
.backtest-run-compact:hover{background:var(--long)}
.backtest-run-compact:disabled{background:var(--bg4);color:var(--text3);cursor:not-allowed}
.backtest-results-compact{padding:5px;font-size:9px}
.backtest-results-compact .backtest-summary{display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-bottom:5px}
.backtest-results-compact .backtest-stat{background:var(--bg4);padding:5px;border-radius:4px}
.backtest-results-compact .backtest-stat-label{font-size:7px;color:var(--text3);margin-bottom:1px}
.backtest-results-compact .backtest-stat-value{font-size:11px;font-weight:700}
.backtest-results-compact .backtest-stat-value.positive{color:var(--long)}
.backtest-results-compact .backtest-stat-value.negative{color:var(--short)}
.backtest-results-compact .backtest-grade-row{display:flex;align-items:center;justify-content:space-between;padding:3px 5px;background:var(--bg4);border-radius:3px;margin-bottom:2px;font-size:8px}
.backtest-results-compact .grade-name{font-weight:700}
.backtest-results-compact .win-rate{color:var(--long);font-weight:600}
.backtest-results-compact .pnl.positive{color:var(--long)}
.backtest-results-compact .pnl.negative{color:var(--short)}
.backtest-empty{text-align:center;padding:10px;color:var(--text3);font-size:8px}
.backtest-empty .icon{font-size:14px;margin-bottom:3px}

/* Hide old panels - kept for backwards compatibility */
.backtest-panel{display:none}
.flow-panel{display:none}

/* Legacy support classes */
.backtest-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;cursor:pointer;user-select:none}
.backtest-header:hover{background:var(--bg3)}
.backtest-title{display:flex;align-items:center;gap:8px;font-size:12px;font-weight:700;color:var(--cyan)}
.backtest-toggle{font-size:14px;color:var(--text3);transition:transform 0.3s}
.backtest-toggle.expanded{transform:rotate(180deg)}
.backtest-content{max-height:0;overflow:hidden;transition:max-height 0.3s ease-out}
.backtest-content.expanded{max-height:600px;overflow-y:auto}
.backtest-controls{display:flex;flex-wrap:wrap;gap:8px;padding:10px 12px;background:var(--bg3);border-top:1px solid var(--border)}
.backtest-select{background:var(--bg4);border:1px solid var(--border);color:var(--text);padding:6px 10px;border-radius:4px;font-size:11px}
.backtest-run{background:var(--cyan);color:var(--bg);border:none;padding:6px 16px;border-radius:4px;font-size:11px;font-weight:700;cursor:pointer}
.backtest-run:hover{background:var(--long)}
.backtest-run:disabled{background:var(--bg4);color:var(--text3);cursor:not-allowed}
.backtest-results{padding:10px 12px}
.backtest-summary{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px}
.backtest-stat{background:var(--bg3);padding:10px;border-radius:6px;border:1px solid var(--border)}
.backtest-stat-label{font-size:10px;color:var(--text3);margin-bottom:4px}
.backtest-stat-value{font-size:16px;font-weight:700}
.backtest-stat-value.positive{color:var(--long)}
.backtest-stat-value.negative{color:var(--short)}
.backtest-stat-value.neutral{color:var(--text)}
.backtest-grades{margin-bottom:12px}
.backtest-grade-row{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:var(--bg3);border-radius:4px;margin-bottom:6px;font-size:11px}
.backtest-grade-row .grade-name{font-weight:700}
.backtest-grade-row .grade-stats{display:flex;gap:12px;color:var(--text2)}
.backtest-grade-row .win-rate{color:var(--long);font-weight:700}
.backtest-grade-row .pnl.positive{color:var(--long)}
.backtest-grade-row .pnl.negative{color:var(--short)}
.backtest-insights{background:var(--bg3);padding:10px;border-radius:6px;border:1px solid var(--border)}
.backtest-insight{display:flex;align-items:center;gap:8px;font-size:11px;padding:4px 0;color:var(--text2)}
.backtest-insight .icon{font-size:14px}
.backtest-insight .highlight{color:var(--long);font-weight:700}
.backtest-insight .lowlight{color:var(--short);font-weight:700}
.backtest-loading{text-align:center;padding:30px;color:var(--text3)}
.backtest-loading .spinner{font-size:24px;animation:spin 1s linear infinite}
@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}

/* Legacy flow panel CSS - hidden but kept for compatibility */
.flow-panel{display:none;background:var(--bg2);border-bottom:1px solid var(--border)}
.flow-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;cursor:pointer;user-select:none}
.flow-header:hover{background:var(--bg3)}
.flow-title{display:flex;align-items:center;gap:8px;font-size:12px;font-weight:700;color:var(--amber)}
.flow-status{font-size:10px;font-weight:400;padding:2px 6px;border-radius:3px;margin-left:8px}
.flow-status.bullish{background:var(--long-dim);color:var(--long)}
.flow-status.bearish{background:var(--short-dim);color:var(--short)}
.flow-status.neutral{background:var(--amber-dim);color:var(--amber)}
.flow-toggle{font-size:14px;color:var(--text3);transition:transform 0.3s}
.flow-toggle.expanded{transform:rotate(180deg)}
.flow-content{max-height:0;overflow:hidden;transition:max-height 0.3s ease-out}
.flow-content.expanded{max-height:200px}
.flow-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;padding:10px 12px;background:var(--bg3)}
.flow-item{text-align:center;padding:8px 4px;background:var(--bg4);border-radius:6px;border:1px solid var(--border)}
.flow-label{font-size:9px;color:var(--text3);margin-bottom:4px;text-transform:uppercase}
.flow-value{font-size:13px;font-weight:700;color:var(--text)}
.flow-change{font-size:10px;margin-top:2px}
.flow-change.up{color:var(--long)}
.flow-change.down{color:var(--short)}
.flow-change.neutral{color:var(--text3)}
.flow-verdict{display:flex;align-items:center;justify-content:center;gap:8px;padding:8px 12px;background:var(--bg4);border-top:1px solid var(--border)}
.flow-verdict-label{font-size:10px;color:var(--text3);text-transform:uppercase}
.flow-verdict-value{font-size:12px;font-weight:700;padding:4px 12px;border-radius:4px}
.flow-verdict-value.bullish{background:var(--long-dim);color:var(--long);border:1px solid var(--long)}
.flow-verdict-value.bearish{background:var(--short-dim);color:var(--short);border:1px solid var(--short)}
.flow-verdict-value.squeeze{background:var(--amber-dim);color:var(--amber);border:1px solid var(--amber)}
.flow-verdict-value.neutral{background:var(--bg3);color:var(--text2);border:1px solid var(--border)}

.env-row .value{font-weight:600}
.env-row .value.ok{color:var(--long)}
.env-row .value.warn{color:var(--amber)}
.env-row .value.bad{color:var(--short)}
.env-row .points{font-size:10px;color:var(--text3);margin-left:6px}
.env-divider{height:1px;background:var(--border);margin:8px 0}
.env-total{display:flex;justify-content:space-between;align-items:center;padding:8px 0;font-size:13px;font-weight:700}
.env-total .score{font-size:16px}
.env-total .score.go{color:var(--long)}
.env-total .score.caution{color:var(--amber)}
.env-total .score.risky{color:#ff8c00}
.env-total .score.nogo{color:var(--short)}

/* AI ENV VERDICT */
.ai-env-verdict{padding:8px;background:var(--bg4);border-radius:6px;margin-top:8px;font-size:11px}
.ai-env-verdict.agree{border-left:3px solid var(--long)}
.ai-env-verdict.warn{border-left:3px solid var(--amber)}
.ai-env-verdict.disagree{border-left:3px solid var(--short)}

/* SCAN PROGRESS BAR - LONGER & GLOWING */
.scan-progress-bar{display:none;flex:1;align-items:center;gap:6px}
.scan-progress-bar.active{display:flex}
.scan-progress-track{flex:1;height:6px;background:var(--bg4);border-radius:3px;overflow:hidden;box-shadow:inset 0 0 3px rgba(0,0,0,0.3)}
.scan-progress-fill{height:100%;border-radius:3px;transition:width 0.3s;background:var(--amber)}
.scan-progress-fill.scanning{background:linear-gradient(90deg,rgba(255,100,100,0.9),rgba(255,180,100,0.9),rgba(255,255,100,0.9),rgba(100,255,100,0.9),rgba(100,255,255,0.9),rgba(100,180,255,0.9),rgba(180,100,255,0.9),rgba(255,100,255,0.9),rgba(255,100,180,0.9),rgba(255,100,100,0.9));background-size:200% 100%;animation:rainbowFlow 2s linear infinite;box-shadow:0 0 8px rgba(200,200,255,0.3),0 0 15px rgba(100,200,255,0.2)}
.scan-progress-fill.done{background:linear-gradient(90deg,var(--long),rgba(0,255,170,0.8),var(--cyan),rgba(0,255,170,0.8),var(--long));background-size:200% 100%;animation:completePulse 3s ease-in-out infinite;box-shadow:0 0 10px var(--long),0 0 20px rgba(0,255,170,0.3)}
.scan-progress-fill.error{background:linear-gradient(90deg,var(--short),rgba(255,107,107,0.8),rgba(255,71,87,0.8),rgba(255,107,107,0.8),var(--short));background-size:200% 100%;animation:errorPulse 1.5s ease-in-out infinite;box-shadow:0 0 10px var(--short),0 0 20px rgba(255,71,87,0.3)}
@keyframes errorPulse{0%,100%{background-position:0% 50%;box-shadow:0 0 8px var(--short)}50%{background-position:100% 50%;box-shadow:0 0 15px var(--short)}}
.scan-progress-text.error{color:var(--short)}
.scan-progress-pct.error{color:var(--short)}
@keyframes rainbowFlow{0%{background-position:0% 50%}100%{background-position:200% 50%}}
@keyframes completePulse{0%,100%{background-position:0% 50%;box-shadow:0 0 10px var(--long)}50%{background-position:100% 50%;box-shadow:0 0 20px var(--long),0 0 30px var(--cyan)}}
.scan-progress-text{font-size:10px;color:var(--amber);white-space:nowrap}
.scan-progress-text.done{color:var(--long)}
@keyframes scanGlow{0%,100%{box-shadow:0 0 5px var(--amber),0 0 10px rgba(247,166,0,0.4)}50%{box-shadow:0 0 8px var(--amber),0 0 15px rgba(247,166,0,0.5)}}

/* GLOW RADAR ICON */
.glow-radar{color:var(--gold);text-shadow:0 0 10px var(--gold),0 0 20px var(--gold),0 0 30px rgba(255,215,0,0.5);animation:radarPulse 2s ease-in-out infinite}
@keyframes radarPulse{0%,100%{transform:scale(1);opacity:1}50%{transform:scale(1.1);opacity:0.8}}

/* RAINBOW CIRCLE SPINNER WITH TEXT INSIDE */
.rainbow-circle-container{
    width:120px;
    height:120px;
    position:relative;
    margin:0 auto 10px;
}
.rainbow-circle-ring{
    position:absolute;
    top:0;left:0;right:0;bottom:0;
    border-radius:50%;
    border:4px solid transparent;
    background:linear-gradient(var(--bg2),var(--bg2)) padding-box,
               conic-gradient(from 0deg,
                   rgba(255,100,100,0.8),
                   rgba(255,180,100,0.8),
                   rgba(255,255,100,0.8),
                   rgba(100,255,100,0.8),
                   rgba(100,255,255,0.8),
                   rgba(100,180,255,0.8),
                   rgba(180,100,255,0.8),
                   rgba(255,100,255,0.8),
                   rgba(255,100,180,0.8),
                   rgba(255,100,100,0.8)
               ) border-box;
    animation:rainbowSpin 2s linear infinite, gentleFlash 1s ease-in-out infinite;
    box-shadow:0 0 15px rgba(100,200,255,0.3),0 0 30px rgba(255,100,200,0.2);
}
.rainbow-circle-inner{
    position:absolute;
    top:8px;left:8px;right:8px;bottom:8px;
    border-radius:50%;
    background:var(--bg2);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    padding:8px;
}
.rainbow-circle-coin{
    font-size:14px;
    font-weight:700;
    color:var(--cyan);
    text-shadow:0 0 5px rgba(0,200,255,0.5);
}
.rainbow-circle-tf{
    font-size:11px;
    font-weight:600;
    color:var(--amber);
}
.rainbow-circle-count{
    font-size:10px;
    color:var(--text2);
    margin-top:2px;
}
.rainbow-circle-pct{
    font-size:16px;
    font-weight:700;
    color:var(--gold);
    text-shadow:0 0 5px rgba(255,200,0,0.4);
}
@keyframes rainbowSpin{
    0%{transform:rotate(0deg)}
    100%{transform:rotate(360deg)}
}
@keyframes gentleFlash{
    0%,100%{opacity:1}
    50%{opacity:0.7}
}

/* SIMPLE SCANNING TEXT */
.scan-text-glow{
    color:var(--cyan);
    text-shadow:0 0 5px rgba(0,200,255,0.5);
    font-weight:600;
}
.scan-text-amber{
    color:var(--amber);
    text-shadow:0 0 5px rgba(255,180,0,0.4);
    font-weight:600;
}

/* CONTENT LAYOUT */
.content{display:flex;flex-direction:column;flex:1}
@media(min-width:900px){.content{flex-direction:row}.sidebar{width:380px;border-right:1px solid var(--border)}.main{flex:1}}
.sidebar{background:var(--bg2);display:flex;flex-direction:column;max-height:55vh}
@media(min-width:900px){.sidebar{max-height:none;height:calc(100vh - 52px)}}

/* SIDEBAR TOP */
.sidebar-top{padding:10px;border-bottom:1px solid var(--border)}
.mode-row{display:flex;gap:4px;margin-bottom:8px}
.mode-btn{flex:1;padding:8px 4px;border:1px solid var(--border);border-radius:5px;background:transparent;color:var(--text2);font-size:11px;font-weight:600;cursor:pointer;transition:all 0.2s}
.mode-btn.active{background:var(--purple);border-color:var(--purple);color:white}
.mode-btn:hover:not(.active){background:var(--bg4)}
.filter-row{display:flex;gap:4px}
.filter-btn{flex:1;padding:6px 4px;border:1px solid var(--border);border-radius:4px;background:transparent;color:var(--text3);font-size:12px;cursor:pointer;transition:all 0.2s}
.filter-btn.active{background:var(--bg4);color:var(--text);border-color:var(--text3)}
.filter-btn .count{margin-left:3px;color:var(--cyan)}

/* SIGNAL LIST */
.signal-list{flex:1;overflow-y:auto;padding:8px}
.signal-card{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:8px;cursor:pointer;transition:all 0.3s}
.signal-card:hover{transform:translateX(2px)}
.signal-card.active{border-color:var(--gold);background:var(--gold-dim)}

/* GLOWING EFFECTS - LONG/SHORT */
.signal-card.long{border-left:3px solid var(--long);box-shadow:0 0 12px rgba(0,217,160,0.2),inset 0 0 20px rgba(0,217,160,0.05)}
.signal-card.long:hover{box-shadow:0 0 20px rgba(0,217,160,0.4),inset 0 0 30px rgba(0,217,160,0.1)}
.signal-card.short{border-left:3px solid var(--short);box-shadow:0 0 12px rgba(255,71,87,0.2),inset 0 0 20px rgba(255,71,87,0.05)}
.signal-card.short:hover{box-shadow:0 0 20px rgba(255,71,87,0.4),inset 0 0 30px rgba(255,71,87,0.1)}

/* GLOWING GRADE BADGES */
.signal-card.long.grade-perfect{box-shadow:0 0 15px rgba(0,217,160,0.3),0 0 25px rgba(255,215,0,0.3)}
.signal-card.short.grade-perfect{box-shadow:0 0 15px rgba(255,71,87,0.3),0 0 25px rgba(255,215,0,0.3)}
.signal-card.long.grade-strong{box-shadow:0 0 15px rgba(0,217,160,0.35)}
.signal-card.short.grade-strong{box-shadow:0 0 15px rgba(255,71,87,0.35)}
.signal-card.long.grade-valid{box-shadow:0 0 12px rgba(0,217,160,0.25),0 0 20px rgba(59,130,246,0.2)}
.signal-card.short.grade-valid{box-shadow:0 0 12px rgba(255,71,87,0.25),0 0 20px rgba(59,130,246,0.2)}
.signal-card.long.grade-heating{box-shadow:0 0 10px rgba(0,217,160,0.2),0 0 15px rgba(245,158,11,0.2)}
.signal-card.short.grade-heating{box-shadow:0 0 10px rgba(255,71,87,0.2),0 0 15px rgba(245,158,11,0.2)}
.signal-card.grade-brewing{box-shadow:0 0 8px rgba(168,85,247,0.15)}

/* 3/3 AGREEMENT EXTRA GLOW */
.signal-card.full-agree{animation:pulseGlow 2s ease-in-out infinite}
@keyframes pulseGlow{0%,100%{filter:brightness(1)}50%{filter:brightness(1.1)}}

.signal-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.signal-pair{font-weight:700;font-size:14px;display:flex;align-items:center;gap:5px}
.dir-tag{font-size:12px;font-weight:700;padding:2px 6px;border-radius:3px}
.dir-tag.long{background:var(--long-dim);color:var(--long);box-shadow:0 0 8px rgba(0,217,160,0.3)}
.dir-tag.short{background:var(--short-dim);color:var(--short);box-shadow:0 0 8px rgba(255,71,87,0.3)}
.tf-tag{font-size:12px;padding:2px 6px;border-radius:3px;background:var(--bg4);border:1px solid var(--cyan);color:var(--cyan)}

/* GLOWING GRADE BADGES */
.grade{font-size:12px;font-weight:700;padding:4px 8px;border-radius:4px}
.grade.perfect{background:linear-gradient(135deg,var(--gold),#ffaa00);color:#000;box-shadow:0 0 15px rgba(255,215,0,0.5);animation:goldPulse 1.5s ease-in-out infinite}
@keyframes goldPulse{0%,100%{box-shadow:0 0 15px rgba(255,215,0,0.5)}50%{box-shadow:0 0 25px rgba(255,215,0,0.8)}}
.grade.strong{background:var(--long);color:#000;box-shadow:0 0 12px rgba(0,217,160,0.4)}
.grade.valid{background:var(--blue);color:white;box-shadow:0 0 10px rgba(59,130,246,0.4)}
.grade.heating{background:var(--amber);color:#000;box-shadow:0 0 10px rgba(245,158,11,0.4)}
.grade.brewing{background:var(--purple-dim);color:var(--purple);border:1px solid var(--purple);box-shadow:0 0 8px rgba(168,85,247,0.3)}
.signal-meta{display:flex;gap:6px;font-size:12px;color:var(--text2);margin-bottom:5px}
.signal-scores{display:flex;gap:3px;flex-wrap:wrap}
.score-tag{font-size:12px;padding:2px 5px;border-radius:3px;background:var(--bg4);color:var(--text2);font-family:monospace}
.score-tag.good{color:var(--long);text-shadow:0 0 5px rgba(0,217,160,0.5)}
.score-tag.mid{color:var(--amber);text-shadow:0 0 5px rgba(245,158,11,0.5)}
.score-tag.low{color:var(--short);text-shadow:0 0 5px rgba(255,71,87,0.5)}

/* STATUS BADGES */
.status-badge{font-size:11px;font-weight:700;padding:2px 5px;border-radius:3px;margin-left:4px}
.status-badge.new{background:var(--cyan-dim);color:var(--cyan);box-shadow:0 0 8px rgba(6,182,212,0.4)}
.status-badge.up{background:var(--long-dim);color:var(--long)}
.status-badge.down{background:var(--short-dim);color:var(--short)}
.status-badge.gone{background:var(--bg4);color:var(--text3);text-decoration:line-through}

/* MAIN PANEL */
.main{padding:12px;overflow-y:auto;background:var(--bg1)}
@media(min-width:900px){.main{height:calc(100vh - 52px)}}
.detail-box{background:var(--bg2);border:1px solid var(--border);border-radius:10px;padding:14px}
.detail-header{display:flex;justify-content:space-between;align-items:center;padding-bottom:12px;border-bottom:1px solid var(--border);margin-bottom:12px;flex-wrap:wrap;gap:8px}
.detail-title{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.detail-pair{font-size:22px;font-weight:700}
.detail-price{text-align:right}
.detail-price-label{font-size:12px;color:var(--text2)}
.detail-price-value{font-size:18px;font-weight:700;font-family:monospace}

/* HTF BOX */
.htf-box{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:12px}
.htf-title{font-size:11px;color:var(--text2);margin-bottom:8px;display:flex;align-items:center;gap:6px}
.htf-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:6px}
.htf-item{text-align:center;padding:6px 4px;background:var(--bg4);border-radius:5px}
.htf-label{font-size:12px;color:var(--text3)}
.htf-value{font-size:11px;font-weight:700}
.htf-value.bull{color:var(--long)}
.htf-value.bear{color:var(--short)}
.htf-value.neutral{color:var(--text3)}

/* AI SECTION */
.ai-section{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:14px;margin-bottom:12px}
.ai-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
.ai-title{font-size:13px;font-weight:700;display:flex;align-items:center;gap:6px}
.ai-verdict{font-size:11px;font-weight:700;padding:4px 12px;border-radius:4px}
.ai-verdict.take{background:var(--long-dim);color:var(--long)}
.ai-verdict.skip{background:var(--short-dim);color:var(--short)}
.ai-verdict.wait{background:var(--amber-dim);color:var(--amber)}
.ai-bar{height:8px;background:var(--bg2);border-radius:4px;overflow:hidden;margin-bottom:8px}
.ai-fill{height:100%;border-radius:4px;transition:width 0.3s}
.ai-text{font-size:11px;color:var(--text2);line-height:1.5;margin-bottom:8px}
.ai-risks{font-size:12px;color:var(--amber);margin-bottom:8px}
.ai-btn{width:100%;padding:10px;background:linear-gradient(135deg,#f55036,#ff6b4a);border:none;color:white;border-radius:6px;font-size:12px;font-weight:700;cursor:pointer}
.ai-btn:hover{opacity:0.9}

/* ANALYSIS GRID */
.analysis-grid{display:grid;grid-template-columns:1fr;gap:10px;margin-bottom:12px}
@media(min-width:600px){.analysis-grid{grid-template-columns:repeat(3,1fr)}}
.analysis-card{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px}
.analysis-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.analysis-title{font-size:11px;color:var(--text2)}
.analysis-score{font-family:monospace;font-weight:700;padding:3px 8px;border-radius:4px;font-size:12px}
.analysis-row{display:flex;justify-content:space-between;font-size:12px;padding:3px 0;border-bottom:1px solid var(--border)}
.analysis-row:last-child{border-bottom:none}
.analysis-label{color:var(--text2)}
.analysis-value{font-family:monospace;font-weight:600}
.factor-list{display:flex;flex-wrap:wrap;gap:3px;margin-top:8px}
.factor{font-size:12px;padding:2px 5px;border-radius:3px;background:var(--bg4);color:var(--text2)}
.factor.bull{background:var(--long-dim);color:var(--long)}
.factor.bear{background:var(--short-dim);color:var(--short)}
.factor.warn{background:var(--amber-dim);color:var(--amber)}

/* TRADE SECTION */
.trade-section{margin-bottom:12px}
.trade-title{font-size:12px;font-weight:600;margin-bottom:10px;color:var(--text2)}
.trade-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:6px}
@media(max-width:600px){.trade-grid{grid-template-columns:repeat(3,1fr)}}
@media(max-width:400px){.trade-grid{grid-template-columns:repeat(2,1fr)}}
.trade-box{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:8px 4px;text-align:center}
.trade-box-label{font-size:12px;color:var(--text3);margin-bottom:2px}
.trade-box-value{font-family:monospace;font-size:12px;font-weight:600;word-break:break-all}
.trade-box.entry{border-color:var(--cyan)}.trade-box.entry .trade-box-value{color:var(--cyan)}
.trade-box.limit{border-color:var(--purple);background:var(--purple-dim)}.trade-box.limit .trade-box-value{color:var(--purple)}
.trade-box.limit .limit-type{font-size:9px;color:var(--purple);font-weight:700;margin-top:2px}
.trade-box.sl{border-color:var(--short)}.trade-box.sl .trade-box-value{color:var(--short)}
.trade-box.tp{border-color:var(--long)}.trade-box.tp .trade-box-value{color:var(--long)}
.trade-meta{display:flex;justify-content:space-between;align-items:center;margin-top:10px}
.rr-tag{background:var(--purple-dim);color:var(--purple);padding:5px 12px;border-radius:5px;font-size:11px;font-weight:600}
.track-btn{padding:10px 20px;background:var(--amber-dim);border:1px solid var(--amber);color:var(--amber);border-radius:6px;font-size:12px;font-weight:600;cursor:pointer}
.track-btn:hover{background:var(--amber);color:#000}

/* ACTIVE TRADES */
.active-section{border-top:1px solid var(--border);padding:10px;background:var(--bg1)}
.active-title{font-size:11px;font-weight:700;margin-bottom:8px;display:flex;align-items:center;gap:6px}
.active-count{background:var(--purple);color:white;font-size:12px;padding:2px 6px;border-radius:8px}
.active-list{max-height:150px;overflow-y:auto}
.active-card{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:6px}
.active-card.long{border-left:3px solid var(--long)}
.active-card.short{border-left:3px solid var(--short)}
.active-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
.active-pair{font-weight:700;font-size:12px;display:flex;align-items:center;gap:5px}
.active-pnl{font-family:monospace;font-size:11px;font-weight:700;padding:2px 6px;border-radius:4px}
.active-pnl.profit{background:var(--long-dim);color:var(--long)}
.active-pnl.loss{background:var(--short-dim);color:var(--short)}
.active-levels{display:grid;grid-template-columns:repeat(5,1fr);gap:3px;margin-bottom:4px}
.active-level{text-align:center;padding:3px;background:var(--bg4);border-radius:3px}
.active-level-label{font-size:11px;color:var(--text3)}
.active-level-value{font-family:monospace;font-size:12px}
.active-level.hit{background:var(--long-dim);border:1px solid var(--long)}
.active-level.stopped{background:var(--short-dim);border:1px solid var(--short)}
.active-meta{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--text3)}
.close-btn{padding:3px 8px;background:var(--bg4);border:1px solid var(--border);color:var(--text2);border-radius:3px;font-size:12px;cursor:pointer}
.close-btn:hover{background:var(--short-dim);border-color:var(--short);color:var(--short)}
.btn-history{padding:2px 6px;background:var(--purple-dim);border:1px solid var(--purple);color:var(--purple);border-radius:3px;font-size:10px;cursor:pointer;margin-left:auto}
.btn-history:hover{background:var(--purple);color:#fff}

/* SAVED TRADES */
.saved-section{border-top:1px solid var(--border);padding:10px;background:linear-gradient(135deg, var(--bg1) 0%, rgba(0,200,255,0.05) 100%)}
.saved-title{font-size:11px;font-weight:700;display:flex;justify-content:space-between;align-items:center;cursor:pointer;padding:4px 0;color:var(--cyan)}
.saved-title:hover{color:var(--gold)}
.saved-count{background:var(--cyan);color:var(--bg1);font-size:10px;padding:2px 6px;border-radius:8px;font-weight:700}
.saved-toggle{font-size:10px;transition:transform 0.2s}
.saved-toggle.open{transform:rotate(180deg)}
.saved-list{max-height:200px;overflow-y:auto;margin-top:8px}
.saved-card{background:var(--bg3);border:1px solid var(--cyan);border-radius:6px;padding:10px;margin-bottom:8px;position:relative}
.saved-card.long{border-left:3px solid var(--long)}
.saved-card.short{border-left:3px solid var(--short)}
.saved-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.saved-pair{font-weight:700;font-size:13px;color:var(--text)}
.saved-dir{font-size:10px;padding:2px 6px;border-radius:3px;font-weight:700}
.saved-dir.long{background:var(--long);color:#000}
.saved-dir.short{background:var(--short);color:#fff}
.saved-grade{font-size:10px;padding:2px 6px;border-radius:3px;font-weight:700;background:var(--gold);color:#000}
.saved-info{display:grid;grid-template-columns:repeat(4,1fr);gap:4px;margin-bottom:8px}
.saved-info-item{text-align:center;background:var(--bg4);border-radius:4px;padding:4px}
.saved-info-label{font-size:9px;color:var(--text3)}
.saved-info-value{font-size:11px;font-weight:600;font-family:monospace}
.saved-meta{display:flex;justify-content:space-between;align-items:center;font-size:10px;color:var(--text3)}
.saved-time{font-style:italic}
.saved-actions{display:flex;gap:6px}
.saved-btn{padding:4px 10px;border-radius:4px;font-size:10px;font-weight:600;cursor:pointer;border:1px solid}
.saved-btn.view{background:var(--cyan-dim);border-color:var(--cyan);color:var(--cyan)}
.saved-btn.view:hover{background:var(--cyan);color:#000}
.saved-btn.delete{background:var(--short-dim);border-color:var(--short);color:var(--short)}
.saved-btn.delete:hover{background:var(--short);color:#fff}
.save-btn{padding:10px 20px;background:var(--cyan-dim);border:1px solid var(--cyan);color:var(--cyan);border-radius:6px;font-size:12px;font-weight:600;cursor:pointer;margin-left:8px}
.save-btn:hover{background:var(--cyan);color:#000}


/* ═══════════════════════════════════════════════════════════════════════════════
   ENHANCED SAVED TRADES STYLES v2.0
   ═══════════════════════════════════════════════════════════════════════════════ */

/* Saved Trade Card - Enhanced */
.saved-card-enhanced {
    background: var(--bg3);
    border: 1px solid var(--border);
    border-radius: 8px;
    margin-bottom: 10px;
    overflow: hidden;
    transition: all 0.3s ease;
}
.saved-card-enhanced.long { border-left: 4px solid var(--long); }
.saved-card-enhanced.short { border-left: 4px solid var(--short); }
.saved-card-enhanced:hover { border-color: var(--cyan); }

/* Card Header */
.saved-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 12px;
    background: var(--bg4);
    border-bottom: 1px solid var(--border);
}
.saved-card-pair {
    font-weight: 700;
    font-size: 14px;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 8px;
}
.saved-card-dir {
    font-size: 10px;
    padding: 3px 8px;
    border-radius: 4px;
    font-weight: 700;
}
.saved-card-dir.long { background: var(--long); color: #000; }
.saved-card-dir.short { background: var(--short); color: #fff; }

/* Status Badge */
.saved-status-badge {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: 700;
}
.saved-status-badge.strong-profit { background: var(--long-dim); color: var(--long); }
.saved-status-badge.in-profit { background: var(--long-dim); color: var(--long); }
.saved-status-badge.tp-hit { background: var(--gold-dim); color: var(--gold); animation: pulse 1s infinite; }
.saved-status-badge.near-entry { background: var(--amber-dim); color: var(--amber); }
.saved-status-badge.small-loss { background: var(--amber-dim); color: var(--amber); }
.saved-status-badge.at-risk { background: var(--short-dim); color: var(--short); animation: pulse 0.5s infinite; }
.saved-status-badge.stopped-out { background: var(--short); color: #fff; }
.saved-status-badge.loading { background: var(--bg4); color: var(--text3); }

/* Row Container */
.saved-row {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
}
.saved-row:last-child { border-bottom: none; }

/* Row Label */
.saved-row-label {
    font-size: 10px;
    font-weight: 700;
    color: var(--text3);
    margin-bottom: 6px;
    display: flex;
    align-items: center;
    gap: 6px;
}
.saved-row-label .emoji { font-size: 12px; }

/* ROW 1: Original Data */
.saved-row.original {
    background: linear-gradient(90deg, rgba(59,130,246,0.05) 0%, transparent 100%);
}
.saved-original-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
}
.saved-original-item {
    background: var(--bg4);
    border-radius: 4px;
    padding: 6px;
    text-align: center;
}
.saved-original-item .label {
    font-size: 9px;
    color: var(--text3);
    margin-bottom: 2px;
}
.saved-original-item .value {
    font-size: 11px;
    font-weight: 600;
    font-family: 'Courier New', monospace;
}
.saved-original-item .value.entry { color: var(--cyan); }
.saved-original-item .value.sl { color: var(--short); }
.saved-original-item .value.tp { color: var(--long); }
.saved-original-item .value.rr { color: var(--purple); }

/* ROW 2: Live Progress */
.saved-row.live {
    background: linear-gradient(90deg, rgba(0,217,160,0.05) 0%, transparent 100%);
}
.saved-live-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}
.saved-live-price {
    font-size: 16px;
    font-weight: 700;
    font-family: 'Courier New', monospace;
}
.saved-live-pnl {
    font-size: 14px;
    font-weight: 700;
    padding: 4px 10px;
    border-radius: 4px;
}
.saved-live-pnl.profit { background: var(--long-dim); color: var(--long); }
.saved-live-pnl.loss { background: var(--short-dim); color: var(--short); }

/* Progress Bar */
.saved-progress-container {
    margin-top: 8px;
}
.saved-progress-bar {
    position: relative;
    height: 24px;
    background: var(--bg4);
    border-radius: 12px;
    overflow: visible;
    margin-bottom: 4px;
}
.saved-progress-fill {
    height: 100%;
    border-radius: 12px;
    transition: width 0.5s ease;
}
.saved-progress-fill.profit {
    background: linear-gradient(90deg, var(--long-dim), var(--long));
}
.saved-progress-fill.loss {
    background: linear-gradient(90deg, var(--short), var(--short-dim));
}
.saved-progress-fill.neutral {
    background: linear-gradient(90deg, var(--amber-dim), var(--amber));
}

/* Progress Markers */
.saved-progress-marker {
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 10px;
    font-weight: 700;
    padding: 2px 4px;
    border-radius: 3px;
    white-space: nowrap;
    z-index: 2;
}
.saved-progress-marker.current {
    background: var(--gold);
    color: #000;
    font-size: 12px;
    padding: 3px 6px;
    box-shadow: 0 0 10px var(--gold);
    z-index: 3;
}

/* Progress Labels */
.saved-progress-labels {
    display: flex;
    justify-content: space-between;
    font-size: 9px;
    color: var(--text3);
    padding: 0 4px;
}

/* ROW 3: AI Interpretation */
.saved-row.ai {
    background: linear-gradient(90deg, rgba(168,85,247,0.05) 0%, transparent 100%);
}
.saved-ai-commentary {
    font-size: 12px;
    color: var(--text);
    line-height: 1.5;
    padding: 8px 10px;
    background: var(--bg4);
    border-radius: 6px;
    border-left: 3px solid var(--purple);
}
.saved-ai-suggestion {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-top: 8px;
    padding: 6px 10px;
    background: var(--long-dim);
    border: 1px solid var(--long);
    border-radius: 4px;
    font-size: 11px;
    color: var(--long);
}
.saved-ai-warning {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-top: 8px;
    padding: 6px 10px;
    background: var(--amber-dim);
    border: 1px solid var(--amber);
    border-radius: 4px;
    font-size: 11px;
    color: var(--amber);
}
.saved-ai-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px;
    color: var(--text3);
    font-size: 11px;
}
.saved-ai-btn {
    padding: 6px 12px;
    background: var(--purple-dim);
    border: 1px solid var(--purple);
    color: var(--purple);
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}
.saved-ai-btn:hover {
    background: var(--purple);
    color: #fff;
}

/* Card Actions */
.saved-card-actions {
    display: flex;
    gap: 6px;
    padding: 10px 12px;
    background: var(--bg4);
    border-top: 1px solid var(--border);
}
.saved-action-btn {
    flex: 1;
    padding: 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    border: 1px solid;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
}
.saved-action-btn.refresh {
    background: var(--cyan-dim);
    border-color: var(--cyan);
    color: var(--cyan);
}
.saved-action-btn.refresh:hover {
    background: var(--cyan);
    color: #000;
}
.saved-action-btn.details {
    background: var(--purple-dim);
    border-color: var(--purple);
    color: var(--purple);
}
.saved-action-btn.details:hover {
    background: var(--purple);
    color: #fff;
}
.saved-action-btn.delete {
    background: var(--short-dim);
    border-color: var(--short);
    color: var(--short);
    flex: 0.5;
}
.saved-action-btn.delete:hover {
    background: var(--short);
    color: #fff;
}

/* Last Updated */
.saved-last-updated {
    font-size: 9px;
    color: var(--text3);
    text-align: right;
    padding: 4px 12px;
    background: var(--bg4);
}

/* Enhanced saved list */
.saved-list-enhanced {
    max-height: 400px;
    overflow-y: auto;
    padding: 8px;
}

/* Empty state */
.saved-empty {
    text-align: center;
    padding: 20px;
    color: var(--text3);
}
.saved-empty-icon {
    font-size: 32px;
    margin-bottom: 8px;
}
.saved-empty-text {
    font-size: 12px;
}

/* Refresh All Button */
.saved-refresh-all {
    width: 100%;
    padding: 8px;
    background: var(--bg4);
    border: 1px dashed var(--border);
    border-radius: 6px;
    color: var(--text3);
    font-size: 11px;
    cursor: pointer;
    margin-bottom: 10px;
    transition: all 0.2s;
}
.saved-refresh-all:hover {
    background: var(--cyan-dim);
    border-color: var(--cyan);
    color: var(--cyan);
}
/* EMPTY & LOADING */
.empty{text-align:center;padding:40px 20px;color:var(--text2)}
.empty-icon{font-size:36px;margin-bottom:10px}
.spinner{width:24px;height:24px;border:3px solid var(--bg4);border-top-color:var(--gold);border-radius:50%;animation:spin 0.8s linear infinite;margin:0 auto 10px}
@keyframes spin{to{transform:rotate(360deg)}}
.scan-status{font-size:12px;color:var(--text3);margin-top:6px}

/* MODAL */
.modal-bg{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;z-index:1000;padding:10px}
.modal-bg.show{display:flex}
.modal{background:var(--bg2);border:1px solid var(--border);border-radius:12px;width:100%;max-width:500px;max-height:90vh;overflow:hidden}
.modal-head{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border-bottom:1px solid var(--border)}
.modal-title{font-size:14px;font-weight:700}
.modal-close{background:none;border:none;color:var(--text2);font-size:22px;cursor:pointer}
.modal-body{padding:14px;overflow-y:auto;max-height:60vh}
.form-group{margin-bottom:12px}
.form-label{font-size:12px;color:var(--text2);margin-bottom:4px;display:block}
.form-input,.form-select{width:100%;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px}
.form-row{display:flex;gap:8px;margin-top:6px}
.form-row .btn{flex:1}
.key-status{font-size:12px;padding:6px 10px;border-radius:5px;margin-bottom:12px}
.key-status.valid{background:var(--long-dim);color:var(--long)}
.key-status.invalid{background:var(--short-dim);color:var(--short)}

/* Key Status Grid */
.key-grid{display:grid;grid-template-columns:repeat(11,1fr);gap:4px;margin:10px 0;padding:8px;background:var(--bg4);border-radius:6px}
.key-slot{display:flex;flex-direction:column;align-items:center;padding:4px 2px;border-radius:4px;font-size:9px;background:var(--bg3)}
.key-slot.active{background:var(--long-dim);border:1px solid var(--long)}
.key-slot.error{background:var(--short-dim);border:1px solid var(--short)}
.key-slot.off{background:var(--bg4);opacity:0.4}
.key-slot.empty{background:var(--bg3);border:1px dashed var(--border)}
.key-slot-icon{font-size:12px}
.key-slot-label{color:var(--text3);font-size:8px}

/* Key Row with Toggle */
.key-row{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.key-row .form-input{flex:1}

/* Toggle Switch */
.toggle-switch{position:relative;width:32px;height:18px;flex-shrink:0}
.toggle-switch input{opacity:0;width:0;height:0}
.toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:var(--bg4);border-radius:18px;transition:0.3s}
.toggle-slider:before{position:absolute;content:"";height:12px;width:12px;left:3px;bottom:3px;background:var(--text3);border-radius:50%;transition:0.3s}
.toggle-switch input:checked+.toggle-slider{background:var(--long)}
.toggle-switch input:checked+.toggle-slider:before{transform:translateX(14px)}

/* Key Status Indicator */
.key-indicator{font-size:14px;width:20px;text-align:center;flex-shrink:0}

.modal-foot{padding:12px 14px;border-top:1px solid var(--border);display:flex;justify-content:flex-end;gap:8px}
.groq-info{background:var(--cyan-dim);border:1px solid var(--cyan);border-radius:6px;padding:10px;font-size:11px;color:var(--cyan);margin-bottom:12px}
.groq-info a{color:var(--cyan)}

/* TIMEFRAME & ALERT TOGGLES */
.tf-toggle{display:flex;align-items:center;justify-content:center;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;cursor:pointer;transition:all 0.2s}
.tf-toggle:has(input:checked){background:var(--long-dim);border-color:var(--long)}
.tf-toggle input{display:none}
.tf-toggle-label{font-size:13px;font-weight:700;color:var(--text)}
.tf-toggle:has(input:checked) .tf-toggle-label{color:var(--long)}
.alert-toggle{display:flex;align-items:center;gap:10px;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;cursor:pointer;margin-bottom:8px}
.alert-toggle:has(input:checked){background:var(--amber-dim);border-color:var(--amber)}
.alert-toggle input{width:18px;height:18px;accent-color:var(--amber)}
.alert-toggle-label{font-size:12px;color:var(--text)}

/* TOAST */
.toast-box{position:fixed;bottom:12px;right:12px;z-index:1100}
.toast{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:10px 14px;margin-top:6px;font-size:12px;animation:slideIn 0.3s}
.toast.success{border-color:var(--long);background:var(--long-dim)}
.toast.error{border-color:var(--short);background:var(--short-dim)}
.toast.warning{border-color:var(--amber);background:var(--amber-dim)}
@keyframes slideIn{from{opacity:0;transform:translateX(30px)}to{opacity:1;transform:translateX(0)}}

/* DASHBOARD STATS BAR */
.stats-bar{display:grid;grid-template-columns:repeat(6,1fr);gap:4px;padding:8px 6px;background:var(--bg2);border-bottom:1px solid var(--border)}
.stat-box{text-align:center;padding:6px 3px;background:var(--bg3);border-radius:6px;border:1px solid var(--border);transition:all 0.2s}
.stat-box:hover{background:var(--bg4);transform:scale(1.02)}
.stat-box:active{transform:scale(0.98)}
.stat-value{font-size:15px;font-weight:700;font-family:monospace}
.stat-value.long{color:var(--long);text-shadow:0 0 8px rgba(0,217,160,0.4)}
.stat-value.short{color:var(--short);text-shadow:0 0 8px rgba(255,71,87,0.4)}
.stat-value.gold{color:var(--gold);text-shadow:0 0 8px rgba(255,215,0,0.4)}
.stat-label{font-size:9px;color:var(--text3);margin-top:2px;font-weight:600;letter-spacing:0.5px}
/* Individual stat box styles */
.stat-box:nth-child(1){border-color:var(--cyan);border-width:1px 1px 2px 1px}
.stat-box:nth-child(1) .stat-value{color:var(--cyan)}
.stat-box:nth-child(2){border-color:#00ffcc;border-width:1px 1px 2px 1px;background:linear-gradient(180deg,var(--bg3) 0%,rgba(0,255,204,0.1) 100%)}
.stat-box:nth-child(2) .stat-label{color:#00ffcc}
.stat-box:nth-child(3){border-color:var(--gold);border-width:1px 1px 2px 1px;background:linear-gradient(180deg,var(--bg3) 0%,rgba(255,215,0,0.1) 100%)}
.stat-box:nth-child(3) .stat-label{color:var(--gold)}
.stat-box:nth-child(4){border-color:var(--long);border-width:1px 1px 2px 1px}
.stat-box:nth-child(4) .stat-label{color:var(--long)}
.stat-box:nth-child(5){border-color:var(--short);border-width:1px 1px 2px 1px}
.stat-box:nth-child(5) .stat-label{color:var(--short)}
.stat-box:nth-child(6){border-color:var(--amber);border-width:1px 1px 2px 1px}
.stat-box:nth-child(6) .stat-value{color:var(--amber)}
.stat-box:nth-child(6) .stat-label{color:var(--amber)}

/* COIN MANAGER */
.coin-manager{max-height:200px;overflow-y:auto;border:1px solid var(--border);border-radius:6px;padding:8px;background:var(--bg4)}
.coin-grid{display:flex;flex-wrap:wrap;gap:4px}
.coin-chip{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg3);border:1px solid var(--border);border-radius:4px;font-size:11px;font-weight:600}
.coin-chip .remove-coin{cursor:pointer;color:var(--short);font-weight:700}
.coin-chip .remove-coin:hover{color:#ff0000}
.add-coin-row{display:flex;gap:6px;margin-bottom:8px}
.add-coin-row input{flex:1;padding:8px;background:var(--bg4);border:1px solid var(--border);border-radius:4px;color:var(--text);font-size:12px;text-transform:uppercase}

/* HEAT MAP */
.heat-map-container{padding:8px;overflow-x:auto}
.heat-map-table{width:100%;border-collapse:collapse;font-size:11px}
.heat-map-table th{padding:6px 4px;background:var(--bg3);color:var(--text2);font-weight:600;border:1px solid var(--border);position:sticky;top:0}
.heat-map-table td{padding:4px;text-align:center;border:1px solid var(--border);cursor:pointer;transition:all 0.2s}
.heat-map-table td:hover{transform:scale(1.1);z-index:10}
.heat-map-table .coin-name{text-align:left;font-weight:600;background:var(--bg3);position:sticky;left:0}
.heat-cell{border-radius:4px;padding:4px 2px;font-weight:700;font-size:10px}
.heat-cell.long{background:var(--long-dim);color:var(--long);box-shadow:inset 0 0 10px rgba(0,217,160,0.3)}
.heat-cell.short{background:var(--short-dim);color:var(--short);box-shadow:inset 0 0 10px rgba(255,71,87,0.3)}
.heat-cell.none{background:var(--bg4);color:var(--text3)}
.heat-cell.perfect{box-shadow:0 0 8px rgba(255,215,0,0.5)}

/* RISK CALCULATOR */
.risk-calc{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px}
.risk-row{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
.risk-input{padding:8px;background:var(--bg4);border:1px solid var(--border);border-radius:4px;color:var(--text);font-size:12px;width:100%}
.risk-result{background:var(--long-dim);border:1px solid var(--long);border-radius:6px;padding:10px;text-align:center}
.risk-result-value{font-size:18px;font-weight:700;color:var(--long)}
.risk-result-label{font-size:11px;color:var(--text2)}

/* SIGNAL HISTORY */
.history-list{max-height:200px;overflow-y:auto}
.history-item{display:flex;justify-content:space-between;align-items:center;padding:8px;background:var(--bg3);border-radius:6px;margin-bottom:6px;border-left:3px solid var(--border)}
.history-item.win{border-left-color:var(--long);background:var(--long-dim)}
.history-item.loss{border-left-color:var(--short);background:var(--short-dim)}
.history-item.pending{border-left-color:var(--amber)}
.history-pnl{font-weight:700;font-family:monospace}
.history-pnl.profit{color:var(--long)}
.history-pnl.loss{color:var(--short)}

/* WEIGHT SLIDERS */
.weight-slider{margin-bottom:12px}
.weight-slider-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
.weight-slider-label{font-size:12px;color:var(--text2);flex:1}
.weight-slider-value{font-size:12px;font-weight:700;color:var(--cyan)}
.weight-slider input[type="range"]{width:100%;height:6px;background:var(--bg4);border-radius:3px;outline:none;-webkit-appearance:none}
.weight-slider input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;background:var(--cyan);border-radius:50%;cursor:pointer;box-shadow:0 0 8px rgba(6,182,212,0.5)}
.weight-slider input[type="range"]:disabled{opacity:0.5;cursor:not-allowed}
.weight-slider.locked{opacity:0.7;background:var(--bg4);border-radius:6px;padding:4px}

/* LOCK BUTTONS */
.lock-btn{background:transparent;border:1px solid var(--border);border-radius:4px;padding:2px 6px;font-size:12px;cursor:pointer;margin:0 8px;transition:all 0.2s}
.lock-btn:hover{background:var(--bg4)}
.lock-btn.locked{background:var(--amber-dim);border-color:var(--amber);color:var(--amber)}

/* VIEW TOGGLE */
.view-toggle{display:flex;gap:4px;margin-bottom:8px}
.view-btn{flex:1;padding:8px;border:1px solid var(--border);border-radius:4px;background:var(--bg4);color:var(--text3);font-size:12px;cursor:pointer;transition:all 0.2s}
.view-btn.active{background:var(--cyan-dim);border-color:var(--cyan);color:var(--cyan)}

/* OLED THEME */
body.oled{--bg1:#000000;--bg2:#050505;--bg3:#0a0a0a;--bg4:#111111;--border:#1a1a1a}
</style>
</head>
<body>
<div class="app">
<header class="header">
<!-- ROW 1: Market Info (Scrollable, matching ENV bar style) -->
<div class="header-row1">
<div class="info-badge" id="badgeBTC" title="BTC Price"><span class="icon">₿</span><span class="label">BTC:</span><span class="value" id="badgeBTCVal">---</span></div>
<div class="info-badge" id="badgeFG" title="Fear & Greed"><span class="icon">😱</span><span class="label">F&G:</span><span class="value" id="badgeFGVal">--</span></div>
<div class="info-badge" id="badgeDom" title="BTC Dominance"><span class="icon">📊</span><span class="label">DOM:</span><span class="value" id="badgeDomVal">--</span></div>
<div class="info-badge" id="badgeSeason" title="Alt/BTC Season"><span class="icon">🌙</span><span class="label">SZN:</span><span class="value" id="badgeSeasonVal">--</span></div>
<div class="info-badge" id="badgeSession" title="Trading Session"><span class="icon">🌍</span><span class="label">SESSION:</span><span class="value" id="badgeSessionVal">---</span></div>
<div class="info-badge" id="badgeAlts" title="Alts Condition"><span class="icon">🪙</span><span class="label">ALTS:</span><span class="value" id="badgeAltsVal">--</span></div>
</div>
<!-- ROW 2: Scan Progress Bar + Buttons -->
<div class="header-row2">
<div class="scan-progress-bar active" id="scanProgressBar">
    <span class="scan-progress-text" id="scanProgressText">Ready</span>
    <div class="scan-progress-track"><div class="scan-progress-fill" id="scanProgressFill" style="width:0%"></div></div>
    <span class="scan-progress-text" id="scanProgressPct">0%</span>
</div>
<div class="header-btns">
<button class="btn active" id="scanBtn" onclick="toggleScan()"><span id="scanIcon">●</span> Scan</button>
<button class="btn" onclick="showSettings()">⚙</button>
</div>
</div>
</header>

<!-- ENVIRONMENT BAR -->
<div class="env-bar" id="envBar">
<div class="env-status" id="envBTC" title="BTC Trend"><span class="icon">₿</span><span class="label">BTC:</span><span class="value" id="envBTCVal">--</span></div>
<div class="env-status" id="envBTCD" title="BTC Dominance Trend"><span class="icon">📊</span><span class="label">BTC.D:</span><span class="value" id="envBTCDVal">--</span></div>
<div class="env-status" id="envDXY" title="DXY Trend"><span class="icon">💵</span><span class="label">DXY:</span><span class="value" id="envDXYVal">--</span></div>
<div class="env-status" id="envStruct" title="BTC Structure"><span class="icon">🏗️</span><span class="label">STRUCT:</span><span class="value" id="envStructVal">--</span></div>
<div class="env-status" id="envRSI" title="BTC RSI"><span class="icon">📈</span><span class="label">RSI:</span><span class="value" id="envRSIVal">--</span></div>
<div class="env-status" id="envFund" title="Funding Rate"><span class="icon">💰</span><span class="label">FUND:</span><span class="value" id="envFundVal">--</span></div>
<div class="env-status" id="envOI" title="BTC Open Interest"><span class="icon">📊</span><span class="label">OI:</span><span class="value" id="envOIVal">--</span></div>
<div class="env-verdict" id="envVerdict"><span class="env-score" id="envScore">--</span><span id="envVerdictText">LOADING</span></div>
</div>

<!-- MARKET FLOW PANEL (Collapsible) -->
<!-- COMBINED PANELS ROW - FLOW & BACKTEST SIDE BY SIDE -->
<div class="panels-row">
    <!-- FLOW PANEL (LEFT HALF) -->
    <div class="panel-half" id="flowPanelNew">
        <div class="panel-header" onclick="toggleFlowNew()">
            <div class="panel-title flow-color">
                <span>💹</span>
                <span>FLOW</span>
            </div>
            <span class="panel-toggle" id="flowToggleNew">▼</span>
        </div>
        <div class="panel-content" id="flowContentNew">
            <div class="flow-grid-compact">
                <div class="flow-item-compact">
                    <div class="flow-label">BTC OI</div>
                    <div class="flow-value" id="flowBtcOINew">--</div>
                    <div class="flow-change" id="flowBtcOIChangeNew">--</div>
                </div>
                <div class="flow-item-compact">
                    <div class="flow-label">OI vs Price</div>
                    <div class="flow-value" id="flowOIPriceNew">--</div>
                    <div class="flow-change" id="flowOIPriceStatusNew">--</div>
                </div>
                <div class="flow-item-compact">
                    <div class="flow-label">Longs Liq</div>
                    <div class="flow-value" id="flowLongsLiqNew">--</div>
                    <div class="flow-change" id="flowLongsLiqPctNew">--</div>
                </div>
                <div class="flow-item-compact">
                    <div class="flow-label">Shorts Liq</div>
                    <div class="flow-value" id="flowShortsLiqNew">--</div>
                    <div class="flow-change" id="flowShortsLiqPctNew">--</div>
                </div>
            </div>
            <div class="flow-verdict-compact">
                <span class="label">BIAS:</span>
                <span class="value neutral" id="flowBiasNew">LOADING...</span>
            </div>
        </div>
    </div>
    
    <!-- BACKTEST PANEL (RIGHT HALF) -->
    <div class="panel-half" id="backtestPanelNew">
        <div class="panel-header" onclick="toggleBacktestNew()">
            <div class="panel-title backtest-color">
                <span>📊</span>
                <span>BACKTEST</span>
            </div>
            <span class="panel-toggle" id="backtestToggleNew">▼</span>
        </div>
        <div class="panel-content" id="backtestContentNew">
            <div class="backtest-controls-compact">
                <div class="backtest-controls-row">
                    <select class="backtest-select-compact" id="btRangeNew">
                        <option value="7">7D</option>
                        <option value="14">14D</option>
                        <option value="30" selected>30D</option>
                        <option value="90">90D</option>
                    </select>
                    <select class="backtest-select-compact" id="btGradeNew">
                        <option value="all" selected>All</option>
                        <option value="cream">💎</option>
                        <option value="perfect">🥇</option>
                        <option value="strong">Strong+</option>
                    </select>
                    <button class="backtest-run-compact" id="btRunBtnNew" onclick="runBacktestNew()">▶ RUN</button>
                </div>
            </div>
            <div class="backtest-results-compact" id="backtestResultsNew">
                <div class="backtest-empty">
                    <div class="icon">📊</div>
                    <div>Tap RUN to backtest</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- OLD FLOW PANEL (HIDDEN - kept for backward compatibility) -->
<div class="flow-panel" id="flowPanel">
    <div class="flow-header" onclick="toggleFlow()">
        <div class="flow-title">
            <span>💹</span>
            <span>MARKET FLOW</span>
            <span class="flow-status" id="flowStatus"></span>
        </div>
        <span class="flow-toggle" id="flowToggle">▼</span>
    </div>
    <div class="flow-content" id="flowContent">
        <div class="flow-grid">
            <div class="flow-item">
                <div class="flow-label">BTC OI</div>
                <div class="flow-value" id="flowBtcOI">--</div>
                <div class="flow-change" id="flowBtcOIChange">--</div>
            </div>
            <div class="flow-item">
                <div class="flow-label">OI vs Price</div>
                <div class="flow-value" id="flowOIPrice">--</div>
                <div class="flow-change" id="flowOIPriceStatus">--</div>
            </div>
            <div class="flow-item">
                <div class="flow-label">Longs Liq (1H)</div>
                <div class="flow-value" id="flowLongsLiq">--</div>
                <div class="flow-change" id="flowLongsLiqPct">--</div>
            </div>
            <div class="flow-item">
                <div class="flow-label">Shorts Liq (1H)</div>
                <div class="flow-value" id="flowShortsLiq">--</div>
                <div class="flow-change" id="flowShortsLiqPct">--</div>
            </div>
        </div>
        <div class="flow-verdict" id="flowVerdict">
            <span class="flow-verdict-label">MARKET BIAS:</span>
            <span class="flow-verdict-value" id="flowBias">LOADING...</span>
        </div>
    </div>
</div>

<!-- DASHBOARD STATS BAR -->
<div class="stats-bar">
    <div class="stat-box" onclick="filterByStats('all')" style="cursor:pointer"><div class="stat-value" id="statTotal">0</div><div class="stat-label">ALL</div></div>
    <div class="stat-box" onclick="filterByStats('cream')" style="cursor:pointer"><div class="stat-value" id="statCream" style="color:#00ffcc;text-shadow:0 0 8px #00ffcc">0</div><div class="stat-label">💎</div></div>
    <div class="stat-box" onclick="filterByStats('perfect')" style="cursor:pointer"><div class="stat-value gold" id="statPerfect">0</div><div class="stat-label">🥇</div></div>
    <div class="stat-box" onclick="filterByStats('long')" style="cursor:pointer"><div class="stat-value long" id="statLong">0</div><div class="stat-label">LONG</div></div>
    <div class="stat-box" onclick="filterByStats('short')" style="cursor:pointer"><div class="stat-value short" id="statShort">0</div><div class="stat-label">SHORT</div></div>
    <div class="stat-box" onclick="filterByStats('agree3')" style="cursor:pointer"><div class="stat-value" id="statFullAgree">0</div><div class="stat-label">3/3</div></div>
</div>

<!-- BACKTEST PANEL (Collapsible) -->
<div class="backtest-panel" id="backtestPanel">
    <div class="backtest-header" onclick="toggleBacktest()">
        <div class="backtest-title">
            <span>📊</span>
            <span>BACKTEST ENGINE</span>
            <span id="backtestStatus" style="font-size:10px;color:var(--text3);font-weight:400"></span>
        </div>
        <span class="backtest-toggle" id="backtestToggle">▼</span>
    </div>
    <div class="backtest-content" id="backtestContent">
        <div class="backtest-controls">
            <select class="backtest-select" id="btRange">
                <option value="7">Last 7 Days</option>
                <option value="14">Last 14 Days</option>
                <option value="30" selected>Last 30 Days</option>
                <option value="90">Last 90 Days</option>
            </select>
            <select class="backtest-select" id="btGrade">
                <option value="all" selected>All Grades</option>
                <option value="cream">💎 Cream Only</option>
                <option value="perfect">Perfect Only</option>
                <option value="strong">Strong+</option>
            </select>
            <select class="backtest-select" id="btTF">
                <option value="all" selected>All TFs</option>
                <option value="scalp">Scalp (5m-1H)</option>
                <option value="swing">Swing (4H-1D)</option>
            </select>
            <button class="backtest-run" id="btRunBtn" onclick="runBacktest()">▶ RUN</button>
        </div>
        <div class="backtest-results" id="backtestResults">
            <div style="text-align:center;padding:20px;color:var(--text3)">
                <div style="font-size:24px;margin-bottom:8px">📊</div>
                <div>Select options and click RUN to backtest</div>
            </div>
        </div>
    </div>
</div>

<div class="content">
<aside class="sidebar">
<div class="sidebar-top">
<!-- VIEW TOGGLE -->
<div class="view-toggle">
    <button class="view-btn active" id="viewList" onclick="setView('list')">📋 List</button>
    <button class="view-btn" id="viewHeatmap" onclick="setView('heatmap')">🌡️ Heat Map</button>
</div>
<div class="mode-row">
<button class="mode-btn active" id="modeAll" onclick="setMode('ALL')">ALL</button>
<button class="mode-btn" id="modeScalp" onclick="setMode('SCALP')">SCALP</button>
<button class="mode-btn" id="modeSwing" onclick="setMode('SWING')">SWING</button>
</div>
<div class="filter-row">
<button class="filter-btn active" id="filterAll" onclick="setFilter('all')">All<span class="count" id="cAll">0</span></button>
<button class="filter-btn" id="filterPerfect" onclick="setFilter('perfect')">🔥<span class="count" id="cPerfect">0</span></button>
<button class="filter-btn" id="filterReady" onclick="setFilter('ready')">Ready<span class="count" id="cReady">0</span></button>
<button class="filter-btn" id="filterEarly" onclick="setFilter('early')">Early<span class="count" id="cEarly">0</span></button>
</div>
</div>
<div class="signal-list" id="signalList"><div class="empty"><div class="rainbow-circle-container"><div class="rainbow-circle-ring"></div><div class="rainbow-circle-inner"><div class="rainbow-circle-coin">Ready</div><div class="rainbow-circle-tf">to scan</div><div class="rainbow-circle-pct">0%</div><div class="rainbow-circle-count">0/0</div></div></div></div></div>

<!-- SAVED TRADES SECTION -->
<div class="saved-section" id="savedSection">
<div class="saved-title" onclick="toggleSavedTrades()">
    <span>💾 Saved Trades <span class="saved-count" id="savedCount">0</span></span>
    <span class="saved-toggle" id="savedToggle">▼</span>
</div>
<div class="saved-list" id="savedList" style="display:none">
    <div style="text-align:center;color:var(--text3);font-size:12px;padding:8px">No saved trades</div>
</div>
</div>

</aside>
<main class="main" id="mainPanel"><div class="empty"><div class="empty-icon" style="font-size:48px;color:var(--cyan);text-shadow:0 0 15px rgba(0,200,255,0.5)">📊</div>Select a signal to view details</div></main>
</div>
</div>

<!-- SETTINGS MODAL -->
<div class="modal-bg" id="settingsModal">
<div class="modal" style="max-height:90vh;overflow-y:auto">
<div class="modal-head"><span class="modal-title">⚙️ Settings</span><button class="modal-close" onclick="hideSettings()">×</button></div>
<div class="modal-body">

<!-- AI SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin-bottom:10px;border-bottom:1px solid var(--border);padding-bottom:6px">🤖 AI Configuration (v13 Multi-AI - 11 Keys)</div>
<div id="keyStatus" class="key-status valid">✅ Multi-AI System Ready</div>
<div class="groq-info">🧠 v13 uses 3 AI providers with auto-failover & key rotation: Groq → DeepSeek → Gemini</div>

<!-- Key Status Grid -->
<div class="key-grid" id="keyStatusGrid">
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G1</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G2</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G3</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G4</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">G5</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">DS</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm1</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm2</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm3</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm4</span></div>
    <div class="key-slot empty"><span class="key-slot-icon">⚪</span><span class="key-slot-label">Gm5</span></div>
</div>

<!-- Groq Keys (5 slots) -->
<div style="font-size:12px;font-weight:600;color:var(--long);margin:12px 0 8px 0">🟢 Groq API Keys (5 slots - FREE)</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey1On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey1" placeholder="Groq Key 1: gsk_...">
    <span class="key-indicator" id="groqKey1Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey2On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey2" placeholder="Groq Key 2: gsk_...">
    <span class="key-indicator" id="groqKey2Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey3On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey3" placeholder="Groq Key 3: gsk_...">
    <span class="key-indicator" id="groqKey3Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey4On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey4" placeholder="Groq Key 4: gsk_...">
    <span class="key-indicator" id="groqKey4Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="groqKey5On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="groqKey5" placeholder="Groq Key 5: gsk_...">
    <span class="key-indicator" id="groqKey5Status">⚪</span>
</div>
<div style="font-size:10px;color:var(--text3);margin-bottom:12px">Get free keys: <a href="https://console.groq.com/keys" target="_blank" style="color:var(--cyan)">console.groq.com/keys</a></div>

<!-- DeepSeek Key (1 slot) -->
<div style="font-size:12px;font-weight:600;color:var(--blue);margin:12px 0 8px 0">🔵 DeepSeek API Key (1 slot - Paid)</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="deepseekKey1On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="deepseekKey1" placeholder="DeepSeek Key: sk-...">
    <span class="key-indicator" id="deepseekKey1Status">⚪</span>
</div>
<div style="font-size:10px;color:var(--text3);margin-bottom:12px">Best value: <a href="https://platform.deepseek.com" target="_blank" style="color:var(--cyan)">platform.deepseek.com</a> (~$0.14/1M tokens)</div>

<!-- Gemini Keys (5 slots) -->
<div style="font-size:12px;font-weight:600;color:var(--purple);margin:12px 0 8px 0">🟣 Gemini API Keys (5 slots - FREE)</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey1On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey1" placeholder="Gemini Key 1: AIza...">
    <span class="key-indicator" id="geminiKey1Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey2On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey2" placeholder="Gemini Key 2: AIza...">
    <span class="key-indicator" id="geminiKey2Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey3On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey3" placeholder="Gemini Key 3: AIza...">
    <span class="key-indicator" id="geminiKey3Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey4On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey4" placeholder="Gemini Key 4: AIza...">
    <span class="key-indicator" id="geminiKey4Status">⚪</span>
</div>
<div class="key-row">
    <label class="toggle-switch"><input type="checkbox" id="geminiKey5On" checked><span class="toggle-slider"></span></label>
    <input type="password" class="form-input" id="geminiKey5" placeholder="Gemini Key 5: AIza...">
    <span class="key-indicator" id="geminiKey5Status">⚪</span>
</div>
<div style="font-size:10px;color:var(--text3);margin-bottom:12px">Free backup: <a href="https://aistudio.google.com/apikey" target="_blank" style="color:var(--cyan)">aistudio.google.com/apikey</a></div>

<div class="form-row">
<button class="btn" onclick="toggleKeyVis()">👁️ Show</button>
<button class="btn" onclick="clearKey()">🗑️ Clear All</button>
<button class="btn primary" onclick="testAllKeys()">🔌 Test All Keys</button>
</div>

<div class="form-group">
<label class="form-label">AI Model (Groq)</label>
<select class="form-select" id="aiModelSelect">
<option value="llama-3.3-70b-versatile">Llama 3.3 70B (Best)</option>
<option value="llama-3.1-8b-instant">Llama 3.1 8B (Fast)</option>
<option value="mixtral-8x7b-32768">Mixtral 8x7B</option>
<option value="gemma2-9b-it">Gemma 2 9B</option>
</select>
</div>

<!-- AI DISPLAY MODE SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--purple);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🤖 AI Display Mode</div>
<div style="display:flex;gap:8px;margin-bottom:10px">
<button class="btn" id="aiModeDetailed" onclick="setAIDisplayMode('detailed')" style="flex:1">📊 Detailed (13)</button>
<button class="btn" id="aiModeCompact" onclick="setAIDisplayMode('compact')" style="flex:1">📱 Compact (6)</button>
</div>
<div style="font-size:11px;color:var(--text3);margin-bottom:10px">
<b>Detailed:</b> All 13 sections expanded separately<br>
<b>Compact:</b> 6 grouped sections for mobile/quick view
</div>

<!-- COIN SELECTION SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🪙 Coin Selection</div>
<div style="display:flex;gap:6px;margin-bottom:10px">
<button class="btn" onclick="setCoinCount(50)">Top 50</button>
<button class="btn" onclick="setCoinCount(100)">Top 100</button>
<button class="btn" onclick="setCoinCount(150)">Top 150</button>
<button class="btn" onclick="setCoinCount(200)">Top 200</button>
</div>
<div class="add-coin-row">
<input type="text" id="addCoinInput" placeholder="Add coin (e.g. TRUMP)" maxlength="15">
<button class="btn" onclick="addCoin()">➕ Add</button>
</div>
<div style="font-size:11px;color:var(--text3);margin-bottom:6px">Selected: <span id="coinCountDisplay">50</span> coins (Click × to remove)</div>
<div class="coin-manager" id="coinManager"></div>

<!-- WEIGHT SLIDERS SECTION WITH LOCK -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">⚖️ Engine Weights <button class="btn" onclick="lockAllEngines()" style="font-size:10px;padding:2px 6px;margin-left:10px">🔒 Lock All</button> <button class="btn" onclick="unlockAllEngines()" style="font-size:10px;padding:2px 6px">🔓 Unlock All</button></div>
<div class="weight-slider" id="sliderZone">
<div class="weight-slider-header"><span class="weight-slider-label">🎯 Zone Analysis</span><button class="lock-btn" id="lockZone" onclick="toggleEngineLock('zone')">🔓</button><span class="weight-slider-value" id="weightZoneVal">35%</span></div>
<input type="range" min="10" max="60" value="35" id="weightZone" oninput="updateWeightDisplay()">
</div>
<div class="weight-slider" id="sliderSMC">
<div class="weight-slider-header"><span class="weight-slider-label">📐 SMC Analysis</span><button class="lock-btn" id="lockSMC" onclick="toggleEngineLock('smc')">🔓</button><span class="weight-slider-value" id="weightSMCVal">35%</span></div>
<input type="range" min="10" max="60" value="35" id="weightSMC" oninput="updateWeightDisplay()">
</div>
<div class="weight-slider" id="sliderMomentum">
<div class="weight-slider-header"><span class="weight-slider-label">📊 Momentum Analysis</span><button class="lock-btn" id="lockMomentum" onclick="toggleEngineLock('momentum')">🔓</button><span class="weight-slider-value" id="weightMomentumVal">30%</span></div>
<input type="range" min="10" max="60" value="30" id="weightMomentum" oninput="updateWeightDisplay()">
</div>
<div style="font-size:10px;color:var(--amber);text-align:center;margin-top:4px">🔒 = Locked (won't change when scrolling)</div>
<div style="font-size:11px;color:var(--text3);text-align:center;margin-top:4px">Total: <span id="weightTotal">100%</span></div>

<!-- RISK CALCULATOR SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">💰 Risk Management</div>
<div class="risk-row">
<div class="form-group" style="margin:0">
<label class="form-label">Account Size ($)</label>
<input type="number" class="risk-input" id="riskAccount" value="1000" placeholder="1000">
</div>
<div class="form-group" style="margin:0">
<label class="form-label">Risk Per Trade (%)</label>
<input type="number" class="risk-input" id="riskPercent" value="2" min="0.5" max="10" step="0.5" placeholder="2">
</div>
</div>
<div class="risk-row">
<div class="form-group" style="margin:0">
<label class="form-label">Default Leverage</label>
<select class="form-select" id="riskLeverage">
<option value="3">3x</option>
<option value="5">5x</option>
<option value="10" selected>10x</option>
<option value="20">20x</option>
</select>
</div>
<div class="form-group" style="margin:0">
<label class="form-label">Max Position ($)</label>
<input type="number" class="risk-input" id="riskMaxPosition" value="500" placeholder="500">
</div>
</div>

<!-- TIMEFRAME SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">⏱️ Timeframes to Scan</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<label class="tf-toggle"><input type="checkbox" id="tf5m" checked><span class="tf-toggle-label">5m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf15m" checked><span class="tf-toggle-label">15m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf30m" checked><span class="tf-toggle-label">30m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf1h" checked><span class="tf-toggle-label">1H</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf4h" checked><span class="tf-toggle-label">4H</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf1d" checked><span class="tf-toggle-label">1D</span></label>
</div>

<!-- AUTO-SCAN INTERVAL -->
<div class="form-group">
<label class="form-label">🔄 Auto-Scan Interval</label>
<select class="form-select" id="scanInterval">
<option value="60000">1 Minute</option>
<option value="180000">3 Minutes</option>
<option value="300000" selected>5 Minutes</option>
<option value="600000">10 Minutes</option>
</select>
</div>

<!-- ALERTS SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🔔 Alert Settings</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="alertSound" checked><span class="alert-toggle-label">🔊 Sound Alert on New Signal</span></label>
</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="alertVibrate"><span class="alert-toggle-label">📳 Vibrate on New Signal</span></label>
</div>
<div class="form-group">
<label class="form-label">Alert for Grade</label>
<select class="form-select" id="alertGrade">
<option value="PERFECT">PERFECT only</option>
<option value="STRONG">STRONG and above</option>
<option value="VALID">VALID and above</option>
<option value="HEATING">HEATING and above</option>
<option value="BREWING" selected>All signals (BREWING+)</option>
</select>
</div>
<button class="btn" onclick="testAlert()" style="width:100%;margin-top:8px">🔔 Test Alert</button>

<!-- TELEGRAM SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">📱 Telegram Alerts</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="telegramEnabled"><span class="alert-toggle-label">Enable Telegram Alerts</span></label>
</div>
<div class="form-group">
<label class="form-label">Bot Token</label>
<input type="text" class="form-input" id="telegramToken" placeholder="123456789:ABCdefGHI...">
</div>
<div class="form-group">
<label class="form-label">Chat ID</label>
<input type="text" class="form-input" id="telegramChatId" placeholder="Your chat ID">
</div>
<button class="btn" onclick="testTelegram()" style="width:100%;margin-top:8px">📱 Test Telegram</button>

<!-- THEME SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🎨 Theme</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="oledTheme"><span class="alert-toggle-label">🌙 OLED Black Theme (Battery Saver)</span></label>
</div>

<!-- TIMEZONE SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">🕐 Timezone & Session</div>
<div class="form-group">
<label class="form-label">Your City</label>
<select class="form-select" id="userTimezone">
<option value="auto">🌐 Auto-Detect</option>
<option value="Australia/Melbourne">🇦🇺 Melbourne (UTC+11)</option>
<option value="Australia/Sydney">🇦🇺 Sydney (UTC+11)</option>
<option value="Australia/Perth">🇦🇺 Perth (UTC+8)</option>
<option value="Asia/Singapore">🇸🇬 Singapore (UTC+8)</option>
<option value="Asia/Hong_Kong">🇭🇰 Hong Kong (UTC+8)</option>
<option value="Asia/Tokyo">🇯🇵 Tokyo (UTC+9)</option>
<option value="Asia/Dubai">🇦🇪 Dubai (UTC+4)</option>
<option value="Europe/London">🇬🇧 London (UTC+0)</option>
<option value="Europe/Paris">🇫🇷 Paris (UTC+1)</option>
<option value="America/New_York">🇺🇸 New York (UTC-5)</option>
<option value="America/Chicago">🇺🇸 Chicago (UTC-6)</option>
<option value="America/Los_Angeles">🇺🇸 Los Angeles (UTC-8)</option>
</select>
</div>
<div id="timezonePreview" style="font-size:11px;color:var(--text3);padding:8px;background:var(--bg4);border-radius:4px;margin-top:8px">
🕐 Current: -- | Session: --
</div>

</div>
<div class="modal-foot">
<button class="btn" onclick="hideSettings()">Cancel</button>
<button class="btn active" onclick="saveSettings()">Save</button>
</div>
</div>
</div>
<div class="toast-box" id="toastBox"></div>

<script>
// ═══════════════════════════════════════════════════════════════════════════════
// GLOBAL ERROR HANDLERS - CRASH PREVENTION
// ═══════════════════════════════════════════════════════════════════════════════

// Catch all uncaught errors
window.onerror = function(msg, url, line, col, error) {
    console.error('🛑 Global Error:', msg, 'at line', line);
    // Show user-friendly toast if available
    if (typeof toast === 'function') {
        toast('An error occurred - check console', 'error');
    }
    return true;  // Prevents default error handling (crash)
};

// Catch unhandled promise rejections
window.onunhandledrejection = function(event) {
    console.error('🛑 Unhandled Promise Rejection:', event.reason);
    if (typeof toast === 'function') {
        toast('Network/API error - retrying...', 'warning');
    }
    event.preventDefault();  // Prevents crash
};

// Console log limiter
let consoleLogCount = 0;
const originalConsoleLog = console.log;
console.log = function(...args) {
    consoleLogCount++;
    if (consoleLogCount > 1000) {
        if (consoleLogCount === 1001) {
            originalConsoleLog('⚠️ Console log limit reached - throttling');
        }
        if (consoleLogCount % 100 === 0) {
            originalConsoleLog(...args);  // Log every 100th
        }
        return;
    }
    originalConsoleLog(...args);
};

// ═══════════════════════════════════════════════════════════════════════════════
// Bybit Scanner - CONFIGURATION
// ═══════════════════════════════════════════════════════════════════════════════

const CONFIG = {
    // FULL 200 COINS LIST - Bybit perpetuals
    ALL_COINS: [
        // Top 50 (Default)
        'BTCUSDT','ETHUSDT','SOLUSDT','XRPUSDT','DOGEUSDT','ADAUSDT','AVAXUSDT','LINKUSDT',
        'DOTUSDT','MATICUSDT','UNIUSDT','LTCUSDT','ATOMUSDT','ETCUSDT','XLMUSDT','APTUSDT',
        'NEARUSDT','OPUSDT','ARBUSDT','INJUSDT','FILUSDT','LDOUSDT','SUIUSDT','SEIUSDT',
        'TIAUSDT','JUPUSDT','STXUSDT','IMXUSDT','RUNEUSDT','FETUSDT','AGIXUSDT','RNDRUSDT',
        'WLDUSDT','PENDLEUSDT','ENAUSDT','WUSDT','TAOUSDT','KASUSDT','PEPEUSDT','BONKUSDT',
        'FLOKIUSDT','SHIBUSDT','ORDIUSDT','1000SATSUSDT','WIFUSDT','BOMEUSDT','MEWUSDT',
        'POPCATUSDT','NOTUSDT','TONUSDT',
        // 51-100
        'AAVEUSDT','MKRUSDT','SNXUSDT','COMPUSDT','CRVUSDT','YFIUSDT','SUSHIUSDT','1INCHUSDT',
        'DYDXUSDT','GMXUSDT','PERPUSDT','UMAUSDT','ZRXUSDT','LRCUSDT','KNCUSDT','BALUSDT',
        'OCEANUSDT','GRTUSDT','ILVUSDT','AXSUSDT','SANDUSDT','MANAUSDT','GALAUSDT','ENJUSDT',
        'CHZUSDT','FLOWUSDT','ROSAUSDT','MINAUSDT','KAVAUSDT','ALGOUSDT','QNTUSDT','VETUSDT',
        'HBARUSDT','EGLDUSDT','FTMUSDT','ONEUSDT','ZILUSDT','ICPUSDT','THETAUSDT','NEOUSDT',
        'IOTAUSDT','XTZUSDT','EOSUSDT','XECUSDT','BCHUSDT','BSVUSDT','DASHUSDT','ZECUSDT',
        'XMRUSDT','DCRUSDT',
        // 101-150
        'KSMUSDT','ARUSDT','STORJUSDT','ANKRUSDT','SKLUSDT','CELOUSDT','CTSIUSDT','BANDUSDT',
        'RLCUSDT','NMRUSDT','OXTUSDT','STMXUSDT','DENTUSDT','HOTUSDT','SCUSDT','CKBUSDT',
        'RVNUSDT','DGBUSDT','BTGUSDT','ONTUSDT','IOSTUSDT','ZENUSDT','WAVESUSDT','RENUSDT',
        'LPTUSDT','API3USDT','MASKUSDT','HIGHUSDT','BICOUSDT','BLURUSDT','ARPAUSDT',
        'MAGICUSDT','GMTUSDT','APEUSDT','LOOKSUSDT','AUDIOUSDT','RDNTUSDT','CFXUSDT',
        'LEVERUSDT','MDTUSDT','AMBUSDT','PHBUSDT','TUSDT','POLYXUSDT','VIBUSDT','PROSUSDT',
        'SYNUSDT','HOOKUSDT','IDUSDT','EDUUSDT','MAVUSDT','CYBERUSDT',
        // 151-200
        'ARKMUSDT','FRONTUSDT','GLMRUSDT','AGLDUSDT','YGGUSDT','TRUUSDT','LQTYUSDT','TUSDT',
        'XVSUSDT','ALPACAUSDT','TLMUSDT','DARUSDT','MOVRUSDT','RADUSDT','MBOXUSDT','RAREUSDT',
        'SUPERUSDT','PORTALUSDT','PIXELUSDT','STRKUSDT','ACEUSDT','XAIUSDT','ALTUSDT','JTOUSDT',
        'MANTAUSDT','RONINUSDT','DYMUSDT','OMUSDT','PYTHUSDT','ZETAUSDT','LSKUSDT','SAGAUSDT',
        'TNSRUSDT','AEVOUSDT','REZUSDT','BBUSDT','IOUSDT','ZKUSDT','LISTAUSDT','WUSDT',
        'RENDERUSDT','ATHUSDT','EIGENUSDT','SCRUSDT','MORPHOUSDT','DRIFTUSDT','SAFEUSDT',
        'GRASSUSDT','MOVEUSDT','MEUSDT','VANAUSDT','TRUMPUSDT'
    ],
    
    // Active coins list (can be modified by user)
    COINS: [],
    
    // Timeframes for scanning
    TF_SCALP: ['5','15','30','60'],      // 5m, 15m, 30m, 1H
    TF_SWING: ['60','240','D'],           // 1H, 4H, 1D
    TF_ALL: ['5','15','30','60','240','D'],
    TF_LABELS: {'5':'5m','15':'15m','30':'30m','60':'1H','240':'4H','D':'1D','W':'1W'},
    
    // HTF mapping for each entry TF
    HTF_MAP: {
        '5': ['15','60','240'],    // 5m entry → check 15m, 1H, 4H
        '15': ['60','240','D'],    // 15m entry → check 1H, 4H, 1D
        '30': ['60','240','D'],    // 30m entry → check 1H, 4H, 1D
        '60': ['240','D','W'],     // 1H entry → check 4H, 1D, 1W
        '240': ['D','W'],          // 4H entry → check 1D, 1W
        'D': ['W']                 // 1D entry → check 1W
    },
    
    // Zone Analysis TFs for multi-TF confluence
    ZONE_TFS: ['15','30','60','240','D','W'],
    
    // Scoring weights (can be modified by user)
    WEIGHTS: { zone: 0.35, smc: 0.35, momentum: 0.30 },
    
    // Grade thresholds (V1 ULTIMATE - Updated)
    GRADES: {
        PERFECT: 90,
        STRONG: 75,
        VALID: 60,
        HEATING: 45
    },
    
    // Conflict penalties
    PENALTIES: {
        ZONE_SMC_CONFLICT: -20,
        HTF_CONFLICT: -10,
        EXHAUSTION: -10,
        DIVERGENCE_AGAINST: -15
    },
    
    // API
    BYBIT_BASE: 'https://api.bybit.com',
    GROQ_URL: 'https://api.groq.com/openai/v1/chat/completions',
    DEEPSEEK_URL: 'https://api.deepseek.com/v1/chat/completions',
    GEMINI_URL: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent',
    
    // Scan intervals
    SCAN_DELAY: 150,        // ms between API calls (SAFETY: prevent rate limit)
    AUTO_SCAN_INTERVAL: 60000,  // 1 minute
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // SAFETY LIMITS - CRASH PREVENTION
    // ═══════════════════════════════════════════════════════════════════════════════
    SAFETY: {
        // Array limits
        MAX_SIGNALS: 500,
        MAX_SAVED_TRADES: 50,
        MAX_HISTORY: 100,
        MAX_CONSOLE_LOGS: 1000,
        
        // API limits
        API_TIMEOUT_MS: 10000,      // 10 second timeout
        MAX_RETRIES: 3,             // Max retry attempts
        SCAN_DELAY_MS: 150,         // Delay between API calls
        AI_DELAY_MS: 500,           // Delay between AI calls
        
        // Interval limits
        MIN_SCAN_INTERVAL_MS: 30000, // Min 30 seconds
        PRICE_REFRESH_MS: 5000,      // 5 second price refresh
        
        // Storage limits
        MAX_STORAGE_MB: 2,           // Max localStorage usage
        MAX_STORAGE_ITEMS: 50,       // Max items per storage key
        
        // Loop limits
        MAX_ITERATIONS: 10000,       // Max loop iterations
        MAX_RECURSION: 100,          // Max recursion depth
        MAX_COINS_PER_SCAN: 300,     // Max coins per scan (increased from 100)
        
        // Concurrent limits
        MAX_CONCURRENT_SCANS: 1,     // Only 1 scan at a time
        MAX_CONCURRENT_AI: 1         // Only 1 AI call at a time
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// STATE MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════════
// MULTI-AI PROVIDER SYSTEM (v13 UPGRADE)
// ═══════════════════════════════════════════════════════════════════════════════

// Groq API Keys (5 keys for rotation) - Add your keys in Settings
const GROQ_KEYS = [
    '', // Add your Groq key in Settings
    '',
    '',
    '',
    ''
];

// DeepSeek API Keys (paid - best value)
const DEEPSEEK_KEYS = [
    '', // Add your DeepSeek key in Settings
];

// Gemini API Keys (free backup)
const GEMINI_KEYS = [
    '', // Add your Gemini key in Settings
    '',
    '',
    '',
    ''
];

// KEY ENABLED STATE (ON/OFF toggles)
const KEY_ENABLED = {
    groq: [true, true, true, true, true],
    deepseek: [true],
    gemini: [true, true, true, true, true]
};

// KEY STATUS (null=untested, true=working, false=failed)
const KEY_STATUS = {
    groq: [null, null, null, null, null],
    deepseek: [null],
    gemini: [null, null, null, null, null]
};

let currentGroqKeyIndex = 0;
let currentDeepSeekKeyIndex = 0;
let currentGeminiKeyIndex = 0;

// Get next API key with rotation (respects ON/OFF toggles)
function getNextGroqKey() {
    const validKeys = GROQ_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.groq[item.index]);
    if (validKeys.length === 0) return null;
    const item = validKeys[currentGroqKeyIndex % validKeys.length];
    console.log(`🔑 Using Groq Key #${item.index + 1} (${currentGroqKeyIndex % validKeys.length + 1}/${validKeys.length})`);
    currentGroqKeyIndex++;
    return item.key;
}

function getNextDeepSeekKey() {
    const validKeys = DEEPSEEK_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.deepseek[item.index]);
    if (validKeys.length === 0) return null;
    const item = validKeys[currentDeepSeekKeyIndex % validKeys.length];
    console.log(`🔑 Using DeepSeek Key #${item.index + 1}`);
    currentDeepSeekKeyIndex++;
    return item.key;
}

function getNextGeminiKey() {
    const validKeys = GEMINI_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.gemini[item.index]);
    if (validKeys.length === 0) return null;
    const item = validKeys[currentGeminiKeyIndex % validKeys.length];
    console.log(`🔑 Using Gemini Key #${item.index + 1} (${currentGeminiKeyIndex % validKeys.length + 1}/${validKeys.length})`);
    currentGeminiKeyIndex++;
    return item.key;
}

// Legacy support
const API_KEYS = GROQ_KEYS;
let currentKeyIndex = 0;

// Get next API key (round-robin rotation) - Legacy support
function getNextAPIKey() {
    return getNextGroqKey() || API_KEYS[0];
}

const DEFAULT_KEY = '';

const STATE = {
    mode: 'ALL',
    filter: 'all',
    statsFilter: 'all',  // Stats bar filter: 'all', 'perfect', 'long', 'short', 'agree3'
    view: 'list',  // 'list' or 'heatmap'
    scanning: false,
    scanInProgress: false,  // SAFETY: Lock to prevent concurrent scans
    aiCallInProgress: false,  // SAFETY: Lock to prevent concurrent AI calls
    signals: [],
    previousSignals: [],  // For tracking changes (⬆️⬇️🆕💀)
    selected: null,
    current: null,
    aiResult: null,
    trades: [],
    savedTrades: [],  // 💾 Saved trades for later reference
    signalHistory: [],  // Track TP/SL hits
    btc: { price: 0, change: 0 },
    // Market data for badges
    fearGreed: null,
    dxy: null,
    funding: null,
    btcDominance: null,
    btcDomTrend: 'flat',
    altSeasonScore: 50,
    aiKey: DEFAULT_KEY,
    aiModel: 'llama-3.3-70b-versatile',
    // v13 Multi-AI Keys
    deepseekKey: '',
    geminiKey: '',
    scanProgress: { current: 0, total: 0, coin: '', tf: '' },
    // Timeframe toggles
    tfEnabled: {
        '5': true,
        '15': true,
        '30': true,
        '60': true,
        '240': true,
        'D': true
    },
    // Alert settings
    alertSound: true,
    alertVibrate: false,
    alertGrade: 'BREWING',
    // Telegram settings
    telegramEnabled: false,
    telegramToken: '',
    telegramChatId: '',
    // Scan interval (ms)
    scanInterval: 300000,  // 5 minutes default
    // AI expanded state
    aiExpanded: false,
    // AI Display Mode: 'detailed' (13 sections) or 'compact' (6 sections)
    aiDisplayMode: 'detailed',
    // Risk management
    riskAccount: 1000,
    riskPercent: 2,
    riskLeverage: 10,
    riskMaxPosition: 500,
    // Theme
    oledTheme: false,
    // Custom coins (if modified)
    customCoins: null,
    coinCount: 50,
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // ENVIRONMENT SYSTEM STATE
    // ═══════════════════════════════════════════════════════════════════════════════
    environment: {
        // Layer 1: Macro
        dxy: { value: 0, trend: 'FLAT', favorable: null },       // null = unknown
        btcTrend: { direction: 'FLAT', strength: 0 },
        btcDominance: { value: 0, trend: 'FLAT' },
        
        // Layer 2: BTC Health
        btcStructure: { status: 'UNKNOWN', score: 0 },          // INTACT, BROKEN, UNKNOWN
        btcRSI: { value: 50, status: 'HEALTHY' },               // HEALTHY, OVERBOUGHT, OVERSOLD
        
        // Layer 3: Leverage
        funding: { rate: 0, status: 'NORMAL' },                 // NORMAL, ELEVATED, EXTREME
        
        // Layer 4: Verdict
        score: 50,
        verdict: 'UNKNOWN',                                      // GO, CAUTION, RISKY, NO-GO
        favoredDirection: null,                                  // LONG, SHORT, or null
        
        // Timestamps
        lastUpdate: null,
        isStale: false
    },
    
    // Filtered signals count
    filteredSignals: [],
    filteredCount: 0,
    showFiltered: false
};

// ═══════════════════════════════════════════════════════════════════════════════
// UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

// BUG FIX #1: Safe DOM element text setter - prevents crash if element doesn't exist
function safeSetText(id, text) {
    const el = document.getElementById(id);
    if (el) el.textContent = text;
}

// BUG FIX #1: Safe DOM element HTML setter
function safeSetHTML(id, html) {
    const el = document.getElementById(id);
    if (el) el.innerHTML = html;
}

// BUG FIX #1: Safe DOM class operations
function safeAddClass(id, className) {
    const el = document.getElementById(id);
    if (el) el.classList.add(className);
}

function safeRemoveClass(id, className) {
    const el = document.getElementById(id);
    if (el) el.classList.remove(className);
}

function safeSetStyle(id, prop, value) {
    const el = document.getElementById(id);
    if (el) el.style[prop] = value;
}

// BUG FIX #2: Safe localStorage operations - prevents crash in private mode or when full
function safeStorageSet(key, value) {
    try {
        localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));
        return true;
    } catch (e) {
        console.warn('⚠️ localStorage.setItem failed:', key, e.message);
        return false;
    }
}

function safeStorageGet(key, defaultValue = null) {
    try {
        const item = localStorage.getItem(key);
        if (item === null) return defaultValue;
        try {
            return JSON.parse(item);
        } catch {
            return item; // Return as string if not JSON
        }
    } catch (e) {
        console.warn('⚠️ localStorage.getItem failed:', key, e.message);
        return defaultValue;
    }
}

function safeStorageRemove(key) {
    try {
        localStorage.removeItem(key);
        return true;
    } catch (e) {
        console.warn('⚠️ localStorage.removeItem failed:', key, e.message);
        return false;
    }
}

function toast(msg, type = '') {
    const box = document.getElementById('toastBox');
    if (!box) return; // BUG FIX #1: Null check
    const t = document.createElement('div');
    t.className = 'toast ' + type;
    t.textContent = msg;
    box.appendChild(t);
    setTimeout(() => t.remove(), 3500);
}

function fmtPrice(p) {
    if (!p || isNaN(p)) return '0';
    if (p >= 1000) return p.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    if (p >= 1) return p.toFixed(4);
    if (p >= 0.001) return p.toFixed(6);
    return p.toFixed(8);
}

function fmtPct(p) {
    // FIX: Add null/undefined check
    if (p === null || p === undefined || isNaN(p)) return '+0.00%';
    return (p >= 0 ? '+' : '') + p.toFixed(2) + '%';
}

function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

function scoreColor(s) {
    if (s >= 70) return 'var(--long)';
    if (s >= 50) return 'var(--amber)';
    return 'var(--short)';
}

function scoreClass(s) {
    if (s >= 70) return 'good';
    if (s >= 50) return 'mid';
    return 'low';
}

// ═══════════════════════════════════════════════════════════════════════════════
// API FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

async function fetchJSON(url, retries = 0) {
    const timeout = CONFIG.SAFETY?.API_TIMEOUT_MS || 10000;
    const maxRetries = CONFIG.SAFETY?.MAX_RETRIES || 3;
    
    try {
        // Create abort controller for timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const r = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        
        // BUG FIX #7: Handle Bybit rate limiting (429)
        if (r.status === 429) {
            console.warn('⚠️ Rate limited (429), backing off...', url.substring(0, 50));
            if (retries < maxRetries) {
                // Longer backoff for rate limits
                await sleep(2000 * (retries + 1));
                return fetchJSON(url, retries + 1);
            }
            return null;
        }
        
        // BUG FIX #7: Handle other API errors
        if (r.status === 403 || r.status === 401) {
            console.warn('⚠️ API auth error:', r.status, url.substring(0, 50));
            return null;
        }
        
        if (r.ok) return await r.json();
    } catch (e) {
        if (e.name === 'AbortError') {
            console.warn('⏱️ Request timed out:', url.substring(0, 50));
        }
    }
    
    // Retry logic
    if (retries < maxRetries) {
        await sleep(500 * (retries + 1));  // Exponential backoff
        return fetchJSON(url, retries + 1);
    }
    
    // Fallback to proxy (last resort)
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const r2 = await fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(url), { signal: controller.signal });
        clearTimeout(timeoutId);
        
        if (r2.ok) return await r2.json();
    } catch (e2) {}
    
    return null;
}

async function fetchKlines(symbol, tf, limit = 200) {
    // SAFETY: Limit max klines
    limit = Math.min(limit, 500);
    
    const url = `${CONFIG.BYBIT_BASE}/v5/market/kline?category=linear&symbol=${symbol}&interval=${tf}&limit=${limit}`;
    const d = await fetchJSON(url);
    if (d && d.result && d.result.list) {
        return d.result.list.reverse().map(k => ({
            time: parseInt(k[0]),
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
        }));
    }
    return null;
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🏦 INSTITUTIONAL DATA FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

// Fetch Funding Rate for a symbol
async function fetchFundingRate(symbol) {
    try {
        const url = `${CONFIG.BYBIT_BASE}/v5/market/funding/history?category=linear&symbol=${symbol}&limit=1`;
        const d = await fetchJSON(url);
        if (d && d.result && d.result.list && d.result.list[0]) {
            const rate = parseFloat(d.result.list[0].fundingRate) || 0;
            const time = parseInt(d.result.list[0].fundingRateTimestamp) || 0;
            return {
                rate: rate,
                ratePercent: (rate * 100).toFixed(4),
                timestamp: time,
                // Interpretation
                sentiment: rate > 0.0003 ? 'OVERLEVERAGED_LONG' : 
                          rate < -0.0003 ? 'OVERLEVERAGED_SHORT' : 
                          rate > 0 ? 'SLIGHTLY_LONG' : 
                          rate < 0 ? 'SLIGHTLY_SHORT' : 'NEUTRAL',
                // Trading signal
                signal: rate > 0.001 ? 'SHORT_SQUEEZE_RISK' :
                       rate < -0.001 ? 'LONG_SQUEEZE_RISK' :
                       rate > 0.0005 ? 'LONGS_PAYING' :
                       rate < -0.0005 ? 'SHORTS_PAYING' : 'BALANCED'
            };
        }
    } catch(e) { 
        console.log('Funding rate fetch error:', e); 
    }
    return null;
}

// Fetch Open Interest
async function fetchOpenInterest(symbol) {
    try {
        const url = `${CONFIG.BYBIT_BASE}/v5/market/open-interest?category=linear&symbol=${symbol}&intervalTime=5min&limit=48`;
        const d = await fetchJSON(url);
        if (d && d.result && d.result.list && d.result.list.length > 0) {
            const latest = d.result.list[0];
            const oldest = d.result.list[d.result.list.length - 1];
            
            const currentOI = parseFloat(latest.openInterest) || 0;
            const oldOI = parseFloat(oldest.openInterest) || 1; // Prevent div by zero
            const change = oldOI > 0 ? ((currentOI - oldOI) / oldOI) * 100 : 0;
            
            // Calculate OI trend over last 48 intervals (4 hours on 5min)
            let rising = 0, falling = 0;
            for (let i = 1; i < d.result.list.length; i++) {
                const curr = parseFloat(d.result.list[i-1].openInterest);
                const prev = parseFloat(d.result.list[i].openInterest);
                if (curr > prev) rising++;
                else if (curr < prev) falling++;
            }
            
            return {
                current: currentOI,
                change4h: change.toFixed(2),
                trend: rising > falling * 1.5 ? 'RISING' : 
                      falling > rising * 1.5 ? 'FALLING' : 'STABLE',
                risingCount: rising,
                fallingCount: falling,
                // Trading interpretation
                signal: change > 5 ? 'NEW_POSITIONS_OPENING' :
                       change < -5 ? 'POSITIONS_CLOSING' :
                       change > 2 ? 'SLIGHT_BUILDUP' :
                       change < -2 ? 'SLIGHT_UNWIND' : 'STABLE'
            };
        }
    } catch(e) { 
        console.log('Open Interest fetch error:', e); 
    }
    return null;
}

// Fetch Long/Short Ratio
async function fetchLongShortRatio(symbol) {
    try {
        const url = `${CONFIG.BYBIT_BASE}/v5/market/account-ratio?category=linear&symbol=${symbol}&period=1h&limit=24`;
        const d = await fetchJSON(url);
        if (d && d.result && d.result.list && d.result.list.length > 0) {
            const latest = d.result.list[0];
            const buyRatio = parseFloat(latest.buyRatio) || 0.5;
            const sellRatio = parseFloat(latest.sellRatio) || 0.5;
            
            // Calculate trend
            let buyTrend = 0;
            for (let i = 1; i < Math.min(6, d.result.list.length); i++) {
                const curr = parseFloat(d.result.list[i-1].buyRatio) || 0;
                const prev = parseFloat(d.result.list[i].buyRatio) || 0;
                if (curr > prev) buyTrend++;
                else if (curr < prev) buyTrend--;
            }
            
            return {
                buyRatio: (buyRatio * 100).toFixed(1),
                sellRatio: (sellRatio * 100).toFixed(1),
                ratio: sellRatio > 0 ? (buyRatio / sellRatio).toFixed(2) : '1.00',
                dominance: buyRatio > 0.55 ? 'LONG_DOMINANT' :
                          sellRatio > 0.55 ? 'SHORT_DOMINANT' : 'BALANCED',
                trend: buyTrend > 2 ? 'LONGS_INCREASING' :
                      buyTrend < -2 ? 'SHORTS_INCREASING' : 'STABLE',
                // Contrarian signal
                contrarianSignal: buyRatio > 0.65 ? 'BEARISH' :
                                 sellRatio > 0.65 ? 'BULLISH' :
                                 buyRatio > 0.55 ? 'SLIGHTLY_BEARISH' :
                                 sellRatio > 0.55 ? 'SLIGHTLY_BULLISH' : 'NEUTRAL'
            };
        }
    } catch(e) { 
        console.log('Long/Short ratio fetch error:', e); 
    }
    return null;
}

// Calculate Liquidation Levels based on current price
function calculateLiquidationLevels(currentPrice, direction) {
    // SAFETY: Validate currentPrice
    if (!currentPrice || currentPrice <= 0 || isNaN(currentPrice)) {
        return { levels: [], longCluster: [], shortCluster: [], analysis: 'No price data' };
    }
    
    // Common leverage levels used by traders
    const leverages = [3, 5, 10, 20, 25, 50, 75, 100];
    const levels = [];
    
    leverages.forEach(lev => {
        // Approximate liquidation prices (simplified, doesn't account for fees/maintenance margin)
        // Long liquidation: entry * (1 - 1/leverage)
        // Short liquidation: entry * (1 + 1/leverage)
        
        const longLiqPrice = currentPrice * (1 - (0.9 / lev)); // 90% of margin used
        const shortLiqPrice = currentPrice * (1 + (0.9 / lev));
        
        // SAFETY: Safe division
        const longDist = currentPrice > 0 ? ((currentPrice - longLiqPrice) / currentPrice * 100).toFixed(2) : '0.00';
        const shortDist = currentPrice > 0 ? ((shortLiqPrice - currentPrice) / currentPrice * 100).toFixed(2) : '0.00';
        
        levels.push({
            leverage: lev,
            longLiqPrice: longLiqPrice,
            shortLiqPrice: shortLiqPrice,
            longDistPct: longDist,
            shortDistPct: shortDist
        });
    });
    
    // Find key liquidation clusters (where most retail traders would be liquidated)
    const retailLeverages = [10, 20, 25]; // Most common retail leverage
    const longCluster = levels.filter(l => retailLeverages.includes(l.leverage))
                              .map(l => l.longLiqPrice);
    const shortCluster = levels.filter(l => retailLeverages.includes(l.leverage))
                               .map(l => l.shortLiqPrice);
    
    return {
        levels: levels,
        longCluster: {
            low: longCluster.length > 0 ? Math.min(...longCluster) : 0,
            high: longCluster.length > 0 ? Math.max(...longCluster) : 0,
            mid: longCluster.length > 0 ? longCluster.reduce((a, b) => a + b, 0) / longCluster.length : 0
        },
        shortCluster: {
            low: shortCluster.length > 0 ? Math.min(...shortCluster) : 0,
            high: shortCluster.length > 0 ? Math.max(...shortCluster) : 0,
            mid: shortCluster.length > 0 ? shortCluster.reduce((a, b) => a + b, 0) / shortCluster.length : 0
        },
        // Key magnet levels (where price is attracted to grab liquidity)
        magnetLong: levels.find(l => l.leverage === 20)?.longLiqPrice || 0,
        magnetShort: levels.find(l => l.leverage === 20)?.shortLiqPrice || 0
    };
}

// Master function: Fetch all institutional data for a symbol
async function fetchInstitutionalData(symbol, currentPrice) {
    const [funding, oi, lsRatio] = await Promise.all([
        fetchFundingRate(symbol),
        fetchOpenInterest(symbol),
        fetchLongShortRatio(symbol)
    ]);
    
    const liqLevels = calculateLiquidationLevels(currentPrice, null);
    
    // Calculate institutional bias
    let bullScore = 0, bearScore = 0;
    
    // Funding Rate Analysis
    if (funding) {
        if (funding.rate > 0.0005) bearScore += 20; // Longs overleveraged
        else if (funding.rate < -0.0005) bullScore += 20; // Shorts overleveraged
        else if (funding.rate > 0.0001) bearScore += 10;
        else if (funding.rate < -0.0001) bullScore += 10;
    }
    
    // OI Analysis
    if (oi) {
        // Rising OI with price direction = trend continuation
        // Rising OI against price = reversal brewing
        if (parseFloat(oi.change4h) > 5) {
            // New positions opening - need to combine with price action
            bullScore += 5;
            bearScore += 5;
        } else if (parseFloat(oi.change4h) < -5) {
            // Positions closing - trend exhaustion
            bullScore += 0;
            bearScore += 0;
        }
    }
    
    // Long/Short Ratio (Contrarian)
    if (lsRatio) {
        if (parseFloat(lsRatio.buyRatio) > 60) bearScore += 25; // Too many longs
        else if (parseFloat(lsRatio.sellRatio) > 60) bullScore += 25; // Too many shorts
        else if (parseFloat(lsRatio.buyRatio) > 55) bearScore += 15;
        else if (parseFloat(lsRatio.sellRatio) > 55) bullScore += 15;
    }
    
    // Determine overall institutional bias
    let institutionalBias = 'NEUTRAL';
    let biasStrength = 0;
    
    if (bullScore > bearScore + 20) {
        institutionalBias = 'BULLISH';
        biasStrength = bullScore - bearScore;
    } else if (bearScore > bullScore + 20) {
        institutionalBias = 'BEARISH';
        biasStrength = bearScore - bullScore;
    } else if (bullScore > bearScore + 10) {
        institutionalBias = 'SLIGHTLY_BULLISH';
        biasStrength = bullScore - bearScore;
    } else if (bearScore > bullScore + 10) {
        institutionalBias = 'SLIGHTLY_BEARISH';
        biasStrength = bearScore - bullScore;
    }
    
    // Squeeze detection
    let squeezeRisk = null;
    if (funding && lsRatio) {
        if (funding.rate > 0.0008 && parseFloat(lsRatio.buyRatio) > 60) {
            squeezeRisk = {
                type: 'LONG_SQUEEZE',
                probability: 'HIGH',
                trigger: liqLevels.magnetLong,
                reason: 'High funding + crowded longs'
            };
        } else if (funding.rate < -0.0008 && parseFloat(lsRatio.sellRatio) > 60) {
            squeezeRisk = {
                type: 'SHORT_SQUEEZE',
                probability: 'HIGH',
                trigger: liqLevels.magnetShort,
                reason: 'Negative funding + crowded shorts'
            };
        } else if (funding.rate > 0.0005 && parseFloat(lsRatio.buyRatio) > 55) {
            squeezeRisk = {
                type: 'LONG_SQUEEZE',
                probability: 'MEDIUM',
                trigger: liqLevels.magnetLong,
                reason: 'Elevated funding + long bias'
            };
        } else if (funding.rate < -0.0005 && parseFloat(lsRatio.sellRatio) > 55) {
            squeezeRisk = {
                type: 'SHORT_SQUEEZE',
                probability: 'MEDIUM',
                trigger: liqLevels.magnetShort,
                reason: 'Negative funding + short bias'
            };
        }
    }
    
    return {
        funding: funding,
        openInterest: oi,
        longShortRatio: lsRatio,
        liquidationLevels: liqLevels,
        institutionalBias: institutionalBias,
        biasStrength: biasStrength,
        bullScore: bullScore,
        bearScore: bearScore,
        squeezeRisk: squeezeRisk,
        timestamp: Date.now()
    };
}

// Analyze institutional data for trade decision
function analyzeInstitutionalData(instData, direction) {
    if (!instData) return { score: 0, factors: [], warnings: [] };
    
    const result = {
        score: 0,
        factors: [],
        warnings: [],
        recommendation: 'NEUTRAL'
    };
    
    // Check if institutional bias aligns with trade direction
    if (direction === 'LONG') {
        if (instData.institutionalBias === 'BULLISH') {
            result.score += 25;
            result.factors.push('Institutional bias: BULLISH');
        } else if (instData.institutionalBias === 'SLIGHTLY_BULLISH') {
            result.score += 15;
            result.factors.push('Institutional bias: Slightly bullish');
        } else if (instData.institutionalBias === 'BEARISH') {
            result.score -= 20;
            result.warnings.push('⚠️ Institutional bias AGAINST long');
        } else if (instData.institutionalBias === 'SLIGHTLY_BEARISH') {
            result.score -= 10;
            result.warnings.push('Institutional bias slightly against');
        }
        
        // Squeeze risk check
        if (instData.squeezeRisk) {
            if (instData.squeezeRisk.type === 'LONG_SQUEEZE') {
                result.score -= 30;
                result.warnings.push(`🚨 ${instData.squeezeRisk.probability} LONG SQUEEZE risk`);
            } else if (instData.squeezeRisk.type === 'SHORT_SQUEEZE') {
                result.score += 20;
                result.factors.push('🚀 Short squeeze potential');
            }
        }
        
    } else { // SHORT
        if (instData.institutionalBias === 'BEARISH') {
            result.score += 25;
            result.factors.push('Institutional bias: BEARISH');
        } else if (instData.institutionalBias === 'SLIGHTLY_BEARISH') {
            result.score += 15;
            result.factors.push('Institutional bias: Slightly bearish');
        } else if (instData.institutionalBias === 'BULLISH') {
            result.score -= 20;
            result.warnings.push('⚠️ Institutional bias AGAINST short');
        } else if (instData.institutionalBias === 'SLIGHTLY_BULLISH') {
            result.score -= 10;
            result.warnings.push('Institutional bias slightly against');
        }
        
        // Squeeze risk check
        if (instData.squeezeRisk) {
            if (instData.squeezeRisk.type === 'SHORT_SQUEEZE') {
                result.score -= 30;
                result.warnings.push(`🚨 ${instData.squeezeRisk.probability} SHORT SQUEEZE risk`);
            } else if (instData.squeezeRisk.type === 'LONG_SQUEEZE') {
                result.score += 20;
                result.factors.push('🚀 Long squeeze potential');
            }
        }
    }
    
    // Funding rate bonus/penalty
    if (instData.funding) {
        if (direction === 'LONG' && instData.funding.rate < -0.0003) {
            result.score += 10;
            result.factors.push(`Negative funding (${instData.funding.ratePercent}%) - shorts paying`);
        } else if (direction === 'SHORT' && instData.funding.rate > 0.0003) {
            result.score += 10;
            result.factors.push(`Positive funding (${instData.funding.ratePercent}%) - longs paying`);
        } else if (direction === 'LONG' && instData.funding.rate > 0.0005) {
            result.score -= 10;
            result.warnings.push(`High funding (${instData.funding.ratePercent}%) - expensive longs`);
        } else if (direction === 'SHORT' && instData.funding.rate < -0.0005) {
            result.score -= 10;
            result.warnings.push(`Negative funding (${instData.funding.ratePercent}%) - expensive shorts`);
        }
    }
    
    // OI trend
    if (instData.openInterest) {
        if (instData.openInterest.trend === 'RISING') {
            result.factors.push(`OI rising +${instData.openInterest.change4h}% (new positions)`);
        } else if (instData.openInterest.trend === 'FALLING') {
            result.warnings.push(`OI falling ${instData.openInterest.change4h}% (positions closing)`);
        }
    }
    
    // Overall recommendation
    if (result.score >= 30) {
        result.recommendation = 'STRONG_CONFIRM';
    } else if (result.score >= 15) {
        result.recommendation = 'CONFIRM';
    } else if (result.score <= -20) {
        result.recommendation = 'AVOID';
    } else if (result.score <= -10) {
        result.recommendation = 'CAUTION';
    } else {
        result.recommendation = 'NEUTRAL';
    }
    
    return result;
}


async function fetchBTC() {
    const d = await fetchJSON(`${CONFIG.BYBIT_BASE}/v5/market/tickers?category=linear&symbol=BTCUSDT`);
    if (d && d.result && d.result.list && d.result.list[0]) {
        STATE.btc.price = parseFloat(d.result.list[0].lastPrice);
        STATE.btc.change = parseFloat(d.result.list[0].price24hPcnt) * 100;
        // Update BTC badge
        const btcBadge = document.getElementById('badgeBTC');
        const btcVal = document.getElementById('badgeBTCVal');
        if (btcVal) {
            const priceK = '$' + (STATE.btc.price / 1000).toFixed(1) + 'K';
            const arrow = STATE.btc.change >= 0 ? '▲' : '▼';
            btcVal.textContent = priceK + arrow;
            btcBadge.className = 'info-badge ' + (STATE.btc.change >= 0 ? 'go' : 'nogo');
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENVIRONMENT ANALYSIS SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Fetch BTC klines for structure and RSI analysis
async function fetchBTCAnalysis() {
    try {
        // Fetch BTC 1H and 4H klines
        const btc1H = await fetchKlines('BTCUSDT', '60', 100);
        const btc4H = await fetchKlines('BTCUSDT', '240', 100);
        
        if (!btc1H || !btc4H || btc1H.length < 50 || btc4H.length < 50) {
            return null;
        }
        
        // Calculate BTC RSI (14 period on 4H)
        const rsi = calcRSI(btc4H);
        STATE.environment.btcRSI = {
            value: Math.round(rsi.value),
            status: rsi.value > 70 ? 'OVERBOUGHT' : rsi.value < 30 ? 'OVERSOLD' : 'HEALTHY'
        };
        
        // Determine BTC Trend from 4H
        const ema20 = calcEMA(btc4H.map(k => k.close), 20);
        const ema50 = calcEMA(btc4H.map(k => k.close), 50);
        const currentPrice = btc4H[btc4H.length - 1].close;
        const ema20Val = ema20[ema20.length - 1];
        const ema50Val = ema50[ema50.length - 1];
        
        let btcTrend = 'FLAT';
        let strength = 50;
        
        if (currentPrice > ema20Val && ema20Val > ema50Val) {
            btcTrend = 'BULLISH';
            strength = 70 + Math.min(30, ((currentPrice - ema50Val) / ema50Val) * 100);
        } else if (currentPrice < ema20Val && ema20Val < ema50Val) {
            btcTrend = 'BEARISH';
            strength = 70 + Math.min(30, ((ema50Val - currentPrice) / ema50Val) * 100);
        } else if (currentPrice > ema20Val) {
            btcTrend = 'BULLISH';
            strength = 55;
        } else if (currentPrice < ema20Val) {
            btcTrend = 'BEARISH';
            strength = 55;
        }
        
        STATE.environment.btcTrend = { direction: btcTrend, strength: Math.min(100, strength) };
        
        // Check BTC Structure (look for recent BOS)
        const swings = findSwingPoints(btc4H, 5, 5);
        let structureStatus = 'INTACT';
        
        // Check if recent swing low was broken (bearish structure break)
        if (swings.lows.length >= 2) {
            const recentLow = swings.lows[swings.lows.length - 1];
            const prevLow = swings.lows[swings.lows.length - 2];
            if (currentPrice < prevLow.price && recentLow.price < prevLow.price) {
                structureStatus = 'BROKEN_DOWN';
            }
        }
        
        // Check if recent swing high was broken (bullish structure break)
        if (swings.highs.length >= 2) {
            const recentHigh = swings.highs[swings.highs.length - 1];
            const prevHigh = swings.highs[swings.highs.length - 2];
            if (currentPrice > prevHigh.price && recentHigh.price > prevHigh.price) {
                structureStatus = 'BROKEN_UP';
            }
        }
        
        STATE.environment.btcStructure = {
            status: structureStatus,
            score: structureStatus === 'INTACT' ? 100 : 
                   structureStatus === 'BROKEN_UP' ? 80 : 
                   structureStatus === 'BROKEN_DOWN' ? 20 : 50
        };
        
        return true;
    } catch (e) {
        console.error('BTC Analysis error:', e);
        return null;
    }
}

// Calculate Environment Score (FULL 100 points with null safety)
function calculateEnvironmentScore(signalDirection, signal = null) {
    let score = 0;
    let details = [];
    const dir = signalDirection || 'LONG';
    const env = STATE.environment || {};
    
    // SAFETY: Default values if environment not loaded
    const dxy = env.dxy || { trend: 'FLAT', value: 0 };
    const btcTrend = env.btcTrend || { direction: 'FLAT', strength: 50 };
    const btcD = env.btcDominance || { trend: 'FLAT', value: 0 };
    const struct = env.btcStructure || { status: 'UNKNOWN', score: 50 };
    const rsi = env.btcRSI || { value: 50, status: 'HEALTHY' };
    const funding = env.funding || { rate: 0, status: 'NORMAL' };
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 1: MACRO (40 points)
    // ═══════════════════════════════════════════════════════════════════
    
    // DXY (10 points)
    if (dxy.trend === 'FALLING') {
        score += 10;
        details.push({ label: 'DXY', value: '▼ DOWN', status: 'ok', points: '+10' });
    } else if (dxy.trend === 'RISING') {
        score += 2;
        details.push({ label: 'DXY', value: '▲ UP', status: 'bad', points: '+2' });
    } else {
        score += 5;
        details.push({ label: 'DXY', value: '─ FLAT', status: 'warn', points: '+5' });
    }
    
    // BTC Trend (15 points)
    if ((dir === 'LONG' && btcTrend.direction === 'BULLISH') ||
        (dir === 'SHORT' && btcTrend.direction === 'BEARISH')) {
        score += 15;
        details.push({ label: 'BTC Trend', value: btcTrend.direction, status: 'ok', points: '+15' });
    } else if (btcTrend.direction === 'FLAT') {
        score += 7;
        details.push({ label: 'BTC Trend', value: 'FLAT', status: 'warn', points: '+7' });
    } else {
        score += 0;
        details.push({ label: 'BTC Trend', value: (btcTrend.direction || 'N/A') + ' ❌', status: 'bad', points: '+0' });
    }
    
    // BTC.D (15 points)
    if ((dir === 'LONG' && btcD.trend === 'FALLING') ||
        (dir === 'SHORT' && btcD.trend === 'RISING')) {
        score += 15;
        details.push({ label: 'BTC.D', value: btcD.trend === 'FALLING' ? '▼ ALTS' : '▲ BTC', status: 'ok', points: '+15' });
    } else if (btcD.trend === 'FLAT') {
        score += 7;
        details.push({ label: 'BTC.D', value: '─ FLAT', status: 'warn', points: '+7' });
    } else {
        score += 0;
        details.push({ label: 'BTC.D', value: btcD.trend === 'RISING' ? '▲ BTC SZN' : '▼ ALT SZN', status: 'bad', points: '+0' });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 2: BTC HEALTH (25 points)
    // ═══════════════════════════════════════════════════════════════════
    
    // BTC Structure (15 points)
    if (struct.status === 'INTACT') {
        score += 15;
        details.push({ label: 'Structure', value: 'INTACT', status: 'ok', points: '+15' });
    } else if ((dir === 'LONG' && struct.status === 'BROKEN_UP') ||
               (dir === 'SHORT' && struct.status === 'BROKEN_DOWN')) {
        score += 12;
        details.push({ label: 'Structure', value: struct.status, status: 'ok', points: '+12' });
    } else if (struct.status === 'UNKNOWN') {
        score += 7;
        details.push({ label: 'Structure', value: 'UNKNOWN', status: 'warn', points: '+7' });
    } else {
        score += 0;
        details.push({ label: 'Structure', value: (struct.status || 'N/A') + ' ❌', status: 'bad', points: '+0' });
    }
    
    // BTC RSI (10 points)
    if (rsi.status === 'HEALTHY') {
        score += 10;
        details.push({ label: 'BTC RSI', value: rsi.value + ' OK', status: 'ok', points: '+10' });
    } else if ((dir === 'LONG' && rsi.status === 'OVERSOLD') ||
               (dir === 'SHORT' && rsi.status === 'OVERBOUGHT')) {
        score += 10;
        details.push({ label: 'BTC RSI', value: rsi.value + ' ' + rsi.status, status: 'ok', points: '+10' });
    } else {
        score += 3;
        details.push({ label: 'BTC RSI', value: rsi.value + ' ⚠️', status: 'warn', points: '+3' });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 3: LEVERAGE (10 points)
    // ═══════════════════════════════════════════════════════════════════
    
    // Funding Rate (10 points)
    const fundingPct = ((funding.rate || 0) * 100).toFixed(3);
    if (funding.status === 'NORMAL') {
        score += 10;
        details.push({ label: 'Funding', value: fundingPct + '%', status: 'ok', points: '+10' });
    } else if (funding.status === 'ELEVATED') {
        if ((dir === 'LONG' && funding.rate < 0) || (dir === 'SHORT' && funding.rate > 0)) {
            score += 10;
            details.push({ label: 'Funding', value: fundingPct + '%', status: 'ok', points: '+10' });
        } else {
            score += 5;
            details.push({ label: 'Funding', value: fundingPct + '% ⚠️', status: 'warn', points: '+5' });
        }
    } else { // EXTREME
        if ((dir === 'LONG' && funding.rate > 0) || (dir === 'SHORT' && funding.rate < 0)) {
            score += 0;
            details.push({ label: 'Funding', value: fundingPct + '% ❌', status: 'bad', points: '+0' });
        } else {
            score += 10;
            details.push({ label: 'Funding', value: fundingPct + '%', status: 'ok', points: '+10' });
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 4: MARKET FLOW (10 points) - OI Analysis
    // ═══════════════════════════════════════════════════════════════════
    
    // Open Interest Analysis (10 points)
    const oiAnalysis = analyzeOIForSignal(dir, signal?.coinOI);
    score += oiAnalysis.score;
    
    if (oiAnalysis.status === 'CONFIRMED') {
        details.push({ label: 'OI Flow', value: '✅ CONFIRMED', status: 'ok', points: `+${oiAnalysis.score}` });
    } else if (oiAnalysis.status === 'SQUEEZE') {
        details.push({ label: 'OI Flow', value: '⚠️ SQUEEZE', status: 'warn', points: `+${oiAnalysis.score}` });
    } else if (oiAnalysis.status === 'DANGER') {
        details.push({ label: 'OI Flow', value: '❌ LIQUIDATIONS', status: 'bad', points: `+${oiAnalysis.score}` });
    } else {
        details.push({ label: 'OI Flow', value: '─ NEUTRAL', status: 'warn', points: `+${oiAnalysis.score}` });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // Layer 5: COIN SPECIFIC (15 points) - RS + HTF (reduced from 25)
    // ═══════════════════════════════════════════════════════════════════
    
    // Coin Relative Strength (8 points - reduced from 15)
    if (signal && signal.coinRS !== undefined) {
        const rs = signal.coinRS;
        if (rs >= 1.2) {
            score += 8;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x STRONG', status: 'ok', points: '+8' });
        } else if (rs >= 1.0) {
            score += 6;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x OK', status: 'ok', points: '+6' });
        } else if (rs >= 0.8) {
            score += 3;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x ⚠️', status: 'warn', points: '+3' });
        } else {
            score += 0;
            details.push({ label: 'Coin RS', value: rs.toFixed(2) + 'x WEAK ❌', status: 'bad', points: '+0' });
        }
    } else {
        score += 4;
        details.push({ label: 'Coin RS', value: 'N/A', status: 'warn', points: '+4' });
    }
    
    // HTF Alignment (7 points - reduced from 10)
    if (signal && signal.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 0;
        if (htfPct >= 75) {
            score += 7;
            details.push({ label: 'HTF Align', value: Math.round(htfPct) + '% ✓', status: 'ok', points: '+7' });
        } else if (htfPct >= 50) {
            score += 4;
            details.push({ label: 'HTF Align', value: Math.round(htfPct) + '%', status: 'warn', points: '+4' });
        } else {
            score += 0;
            details.push({ label: 'HTF Align', value: Math.round(htfPct) + '% ❌', status: 'bad', points: '+0' });
        }
    } else {
        score += 3;
        details.push({ label: 'HTF Align', value: 'N/A', status: 'warn', points: '+3' });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // FINAL SCORE (100 points max)
    // DXY: 10 + BTC Trend: 15 + BTC.D: 15 + Structure: 15 + RSI: 10 + 
    // Funding: 10 + OI: 10 + RS: 8 + HTF: 7 = 100
    // ═══════════════════════════════════════════════════════════════════
    
    // Determine verdict based on 100-point scale
    let verdict = 'NO-GO';
    if (score >= 80) verdict = 'GO';
    else if (score >= 60) verdict = 'CAUTION';
    else if (score >= 40) verdict = 'RISKY';
    
    // Add OI warning if squeeze detected
    const oiWarning = oiAnalysis.warning;
    
    return { score, verdict, details, oiWarning };
}

// Update Environment Display
function updateEnvironmentDisplay() {
    const env = STATE.environment || {};
    
    // SAFETY: Default values
    const btcTrend = env.btcTrend || { direction: 'FLAT' };
    const btcDom = env.btcDominance || { trend: 'FLAT' };
    const dxy = env.dxy || { value: 0, trend: 'FLAT' };
    const struct = env.btcStructure || { status: 'UNKNOWN' };
    const rsi = env.btcRSI || { value: 50, status: 'HEALTHY' };
    const funding = env.funding || { rate: 0, status: 'NORMAL' };
    
    // BTC Trend
    const btcEl = document.getElementById('envBTC');
    const btcVal = document.getElementById('envBTCVal');
    if (btcVal && btcEl) {
        const trend = btcTrend.direction || 'FLAT';
        btcVal.textContent = trend === 'BULLISH' ? '🟢 BULL' : trend === 'BEARISH' ? '🔴 BEAR' : '🟡 FLAT';
        btcEl.className = 'env-status ' + (trend === 'BULLISH' ? 'go' : trend === 'BEARISH' ? 'nogo' : 'caution');
    }
    
    // BTC.D Trend
    const btcdEl = document.getElementById('envBTCD');
    const btcdVal = document.getElementById('envBTCDVal');
    if (btcdVal && btcdEl) {
        const trend = btcDom.trend || 'FLAT';
        btcdVal.textContent = trend === 'FALLING' ? '▼ ALTS' : trend === 'RISING' ? '▲ BTC' : '─ FLAT';
        btcdEl.className = 'env-status ' + (trend === 'FALLING' ? 'go' : trend === 'RISING' ? 'nogo' : 'caution');
    }
    
    // DXY Trend
    const dxyEl = document.getElementById('envDXY');
    const dxyVal = document.getElementById('envDXYVal');
    if (dxyVal && dxyEl) {
        const trend = dxy.trend || 'FLAT';
        const value = dxy.value || 0;
        dxyVal.textContent = value ? value.toFixed(1) + (trend === 'FALLING' ? '▼' : trend === 'RISING' ? '▲' : '') : '--';
        dxyEl.className = 'env-status ' + (trend === 'FALLING' ? 'go' : trend === 'RISING' ? 'nogo' : 'caution');
    }
    
    // Structure
    const structEl = document.getElementById('envStruct');
    const structVal = document.getElementById('envStructVal');
    if (structVal && structEl) {
        const status = struct.status || 'UNKNOWN';
        structVal.textContent = status === 'INTACT' ? '✅ OK' : status === 'BROKEN_UP' ? '⬆️ BRK' : status === 'BROKEN_DOWN' ? '⬇️ BRK' : '❓';
        structEl.className = 'env-status ' + (status === 'INTACT' ? 'go' : status === 'UNKNOWN' ? 'caution' : status === 'BROKEN_UP' ? 'caution' : 'nogo');
    }
    
    // RSI
    const rsiEl = document.getElementById('envRSI');
    const rsiVal = document.getElementById('envRSIVal');
    if (rsiVal && rsiEl) {
        const rsiStatus = rsi.status || 'HEALTHY';
        const rsiValue = rsi.value || 50;
        rsiVal.textContent = rsiValue + (rsiStatus === 'HEALTHY' ? '' : rsiStatus === 'OVERBOUGHT' ? '🔥' : '❄️');
        rsiEl.className = 'env-status ' + (rsiStatus === 'HEALTHY' ? 'go' : 'caution');
    }
    
    // Funding
    const fundEl = document.getElementById('envFund');
    const fundVal = document.getElementById('envFundVal');
    if (fundVal && fundEl) {
        const rate = funding.rate || 0;
        const status = funding.status || 'NORMAL';
        fundVal.textContent = (rate * 100).toFixed(2) + '%';
        fundEl.className = 'env-status ' + (status === 'NORMAL' ? 'go' : status === 'ELEVATED' ? 'caution' : 'nogo');
    }
    
    // Calculate overall score for favored direction
    const longEnv = calculateEnvironmentScore('LONG');
    const shortEnv = calculateEnvironmentScore('SHORT');
    
    let favoredDir = null;
    let bestScore = 0;
    let bestVerdict = 'NO-GO';
    
    if (longEnv.score > shortEnv.score) {
        favoredDir = 'LONG';
        bestScore = longEnv.score;
        bestVerdict = longEnv.verdict;
    } else if (shortEnv.score > longEnv.score) {
        favoredDir = 'SHORT';
        bestScore = shortEnv.score;
        bestVerdict = shortEnv.verdict;
    } else {
        bestScore = longEnv.score;
        bestVerdict = longEnv.verdict;
    }
    
    STATE.environment.score = bestScore;
    STATE.environment.verdict = bestVerdict;
    STATE.environment.favoredDirection = favoredDir;
    STATE.environment.lastUpdate = Date.now();
    
    // Update verdict display
    const verdictEl = document.getElementById('envVerdict');
    const scoreEl = document.getElementById('envScore');
    const verdictText = document.getElementById('envVerdictText');
    
    if (verdictEl && scoreEl && verdictText) {
        scoreEl.textContent = bestScore + '/100';
        const dirText = favoredDir ? (favoredDir === 'LONG' ? '📈' : '📉') : '';
        verdictText.textContent = dirText + ' ' + bestVerdict;
        
        const verdictClass = bestVerdict === 'GO' ? 'go' : 
                            bestVerdict === 'CAUTION' ? 'caution' : 
                            bestVerdict === 'RISKY' ? 'risky' : 'nogo';
        verdictEl.className = 'env-verdict ' + verdictClass;
    }
}

// Full Environment Update
async function updateEnvironment() {
    try {
        // Fetch BTC analysis
        await fetchBTCAnalysis();
        
        // Update DXY trend from existing state
        if (STATE.dxy && STATE.dxy.price) {
            STATE.environment.dxy = {
                value: STATE.dxy.price,
                trend: STATE.dxy.price > STATE.dxy.prevPrice ? 'RISING' : 
                       STATE.dxy.price < STATE.dxy.prevPrice ? 'FALLING' : 'FLAT',
                favorable: STATE.dxy.price < STATE.dxy.prevPrice
            };
        }
        
        // Update BTC.D trend from existing state
        STATE.environment.btcDominance = {
            value: STATE.btcDominance || 0,
            trend: STATE.btcDomTrend === 'rising' ? 'RISING' : 
                   STATE.btcDomTrend === 'falling' ? 'FALLING' : 'FLAT'
        };
        
        // Update Funding from existing state
        if (STATE.funding !== null) {
            const rate = STATE.funding;
            STATE.environment.funding = {
                rate: rate,
                status: Math.abs(rate) > 0.001 ? 'EXTREME' : 
                        Math.abs(rate) > 0.0005 ? 'ELEVATED' : 'NORMAL'
            };
        }
        
        // Update display
        updateEnvironmentDisplay();
        
        // Update ALTS badge based on new environment
        updateAltsBadge();
        
    } catch (e) {
        console.error('Environment update error:', e);
    }
}

// Check if signal should be filtered based on environment
function shouldFilterSignal(signal) {
    const env = STATE.environment || {};
    const dir = signal?.direction || 'LONG';
    
    // SAFETY: Default values
    const structStatus = env.btcStructure?.status || 'UNKNOWN';
    const fundStatus = env.funding?.status || 'NORMAL';
    const fundRate = env.funding?.rate || 0;
    
    // HARD BLOCK 1: BTC Structure broken against signal
    if (dir === 'LONG' && structStatus === 'BROKEN_DOWN') {
        return { filter: true, reason: 'BTC Structure broken down - no longs' };
    }
    if (dir === 'SHORT' && structStatus === 'BROKEN_UP') {
        return { filter: true, reason: 'BTC Structure broken up - no shorts' };
    }
    
    // HARD BLOCK 2: Extreme funding against signal
    if (fundStatus === 'EXTREME') {
        if (dir === 'LONG' && fundRate > 0.001) {
            return { filter: true, reason: 'Extreme positive funding (longs crowded)' };
        }
        if (dir === 'SHORT' && fundRate < -0.001) {
            return { filter: true, reason: 'Extreme negative funding (shorts crowded)' };
        }
    }
    
    // HARD BLOCK 3: HTF severely misaligned (<25%)
    if (signal?.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 50;
        if (htfPct < 25) {
            return { filter: true, reason: 'HTF severely misaligned (' + Math.round(htfPct) + '%)' };
        }
    }
    
    // HARD BLOCK 4: Environment score too low (using signal for RS/HTF)
    const envScore = calculateEnvironmentScore(dir, signal);
    if (envScore.score < 30) {
        return { filter: true, reason: 'Environment score too low (' + envScore.score + '/100)' };
    }
    
    return { filter: false, reason: null };
}

// Get environment icons for signal card
function getEnvIcons(signal) {
    const env = STATE.environment || {};
    const dir = signal?.direction || 'LONG';
    const icons = [];
    
    // SAFETY: Default values
    const btcTrend = env.btcTrend?.direction || 'FLAT';
    const btcDomTrend = env.btcDominance?.trend || 'FLAT';
    const dxyTrend = env.dxy?.trend || 'FLAT';
    const structStatus = env.btcStructure?.status || 'UNKNOWN';
    const rsiStatus = env.btcRSI?.status || 'HEALTHY';
    const fundStatus = env.funding?.status || 'NORMAL';
    const fundRate = env.funding?.rate || 0;
    
    // BTC Trend
    const btcOk = (dir === 'LONG' && btcTrend === 'BULLISH') ||
                  (dir === 'SHORT' && btcTrend === 'BEARISH') ||
                  btcTrend === 'FLAT';
    icons.push({ label: 'BTC', ok: btcOk, warn: btcTrend === 'FLAT' });
    
    // BTC.D
    const btcdOk = (dir === 'LONG' && btcDomTrend === 'FALLING') ||
                   (dir === 'SHORT' && btcDomTrend === 'RISING') ||
                   btcDomTrend === 'FLAT';
    icons.push({ label: 'D', ok: btcdOk, warn: btcDomTrend === 'FLAT' });
    
    // DXY
    const dxyOk = dxyTrend === 'FALLING' || dxyTrend === 'FLAT';
    icons.push({ label: 'DXY', ok: dxyOk, warn: dxyTrend === 'FLAT' });
    
    // Structure
    const structOk = structStatus === 'INTACT' ||
                     (dir === 'LONG' && structStatus === 'BROKEN_UP') ||
                     (dir === 'SHORT' && structStatus === 'BROKEN_DOWN');
    icons.push({ label: 'STR', ok: structOk, warn: structStatus === 'UNKNOWN' });
    
    // RSI
    const rsiOk = rsiStatus === 'HEALTHY' ||
                  (dir === 'LONG' && rsiStatus === 'OVERSOLD') ||
                  (dir === 'SHORT' && rsiStatus === 'OVERBOUGHT');
    icons.push({ label: 'RSI', ok: rsiOk, warn: !rsiOk });
    
    // Funding
    const fundOk = fundStatus === 'NORMAL' ||
                   (dir === 'LONG' && fundRate < 0) ||
                   (dir === 'SHORT' && fundRate > 0);
    icons.push({ label: 'FND', ok: fundOk, warn: fundStatus === 'ELEVATED' });
    
    // HTF (from signal)
    if (signal?.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 0;
        const htfOk = htfPct >= 50;
        icons.push({ label: 'HTF', ok: htfOk, warn: htfPct >= 33 && htfPct < 50 });
    }
    
    return icons;
}

// Generate Environment HTML for signal card
function generateEnvIconsHtml(signal) {
    const icons = getEnvIcons(signal);
    const envScore = calculateEnvironmentScore(signal?.direction, signal);
    
    let html = '<div class="signal-env">';
    icons.forEach(icon => {
        const statusClass = icon.ok ? 'ok' : icon.warn ? 'warn' : 'bad';
        const symbol = icon.ok ? '✓' : icon.warn ? '!' : '✗';
        html += `<span class="env-icon ${statusClass}" title="${icon.label}">${icon.label}${symbol}</span>`;
    });
    html += `<span class="env-icon ${envScore.verdict === 'GO' ? 'ok' : envScore.verdict === 'CAUTION' ? 'warn' : 'bad'}">${envScore.score}</span>`;
    html += '</div>';
    
    return html;
}

// Generate Environment Panel HTML for main panel
function generateEnvPanelHtml(signal) {
    const envScore = calculateEnvironmentScore(signal?.direction, signal);
    const verdictClass = envScore.verdict === 'GO' ? 'go' : 
                        envScore.verdict === 'CAUTION' ? 'caution' : 
                        envScore.verdict === 'RISKY' ? 'risky' : 'nogo';
    
    let html = `
    <div class="env-panel">
        <div class="env-panel-title">📊 ENVIRONMENT ANALYSIS</div>`;
    
    envScore.details.forEach(d => {
        html += `
        <div class="env-row">
            <span class="label">${d.label}</span>
            <span class="value ${d.status}">${d.value}<span class="points">${d.points}</span></span>
        </div>`;
    });
    
    html += `
        <div class="env-divider"></div>
        <div class="env-total">
            <span>ENVIRONMENT SCORE:</span>
            <span class="score ${verdictClass}">${envScore.score}/100 ${envScore.verdict}</span>
        </div>
    </div>`;
    
    return html;
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARKET BADGES DATA FETCHING
// ═══════════════════════════════════════════════════════════════════════════════

// Fetch Fear & Greed Index
async function fetchFearGreed() {
    try {
        const d = await fetchJSON('https://api.alternative.me/fng/?limit=1');
        if (d && d.data && d.data[0]) {
            const value = parseInt(d.data[0].value);
            STATE.fearGreed = value;
            const badge = document.getElementById('badgeFG');
            const val = document.getElementById('badgeFGVal');
            if (val) {
                val.textContent = value;
                // Green for fear (<=40 = buying opportunity), Red for greed (>=60 = caution)
                if (value <= 40) {
                    badge.className = 'info-badge go';
                } else if (value >= 60) {
                    badge.className = 'info-badge nogo';
                } else {
                    badge.className = 'info-badge caution';
                }
            }
        }
    } catch(e) { console.log('Fear & Greed fetch error:', e); }
}

// Fetch DXY Index
async function fetchDXY() {
    try {
        // BUG FIX #6: Multiple proxy fallbacks
        const url = 'https://query1.finance.yahoo.com/v8/finance/chart/DX-Y.NYB?interval=1d&range=1d';
        const proxies = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
            `https://corsproxy.io/?${encodeURIComponent(url)}`,
            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
        ];
        
        let d = null;
        for (const proxyUrl of proxies) {
            try {
                d = await fetchJSON(proxyUrl);
                if (d && d.chart && d.chart.result) break;
            } catch (proxyError) {
                console.log('Proxy failed, trying next...', proxyError.message);
            }
        }
        
        if (d && d.chart && d.chart.result && d.chart.result[0]) {
            const meta = d.chart.result[0].meta;
            const price = meta.regularMarketPrice || meta.previousClose;
            const prevPrice = meta.chartPreviousClose || meta.previousClose;
            STATE.dxy = { price, prevPrice };
            // DXY display now handled by Environment Bar
        }
    } catch(e) { 
        console.log('DXY fetch error:', e);
    }
}

// Fetch Funding Rate
async function fetchFunding() {
    try {
        const d = await fetchJSON(`${CONFIG.BYBIT_BASE}/v5/market/tickers?category=linear&symbol=BTCUSDT`);
        if (d && d.result && d.result.list && d.result.list[0]) {
            const rate = parseFloat(d.result.list[0].fundingRate);
            STATE.funding = rate; // Store as decimal (e.g., 0.0001 = 0.01%)
            // Funding display now handled by Environment Bar
        }
    } catch(e) { console.log('Funding fetch error:', e); }
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🕐 SESSION & TIMEZONE AWARENESS SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

// Initialize awareness state
if (!STATE.awareness) {
    STATE.awareness = {
        timezone: 'auto',
        currentSession: null,
        nextSession: null,
        news: [],
        lastNewsUpdate: 0
    };
}

// Trading sessions in UTC
const TRADING_SESSIONS = {
    ASIA: { start: 0, end: 8, name: 'ASIA', emoji: '🌏', volatility: 'LOW', color: 'var(--cyan)' },
    LONDON: { start: 8, end: 16, name: 'LONDON', emoji: '🇬🇧', volatility: 'HIGH', color: 'var(--amber)' },
    NEW_YORK: { start: 13, end: 21, name: 'NEW YORK', emoji: '🇺🇸', volatility: 'HIGH', color: 'var(--amber)' },
    OVERLAP: { start: 13, end: 16, name: 'LONDON/NY OVERLAP', emoji: '🔥', volatility: 'EXTREME', color: 'var(--short)' },
    OFF_HOURS: { start: 21, end: 24, name: 'OFF HOURS', emoji: '😴', volatility: 'LOW', color: 'var(--text3)' }
};

// Get user's local time based on selected timezone
function getUserTime() {
    const tz = STATE.awareness.timezone || 'auto';
    const options = { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: true,
        timeZone: tz === 'auto' ? undefined : tz
    };
    return new Date().toLocaleTimeString('en-US', options);
}

// Get user's timezone name
function getUserTimezoneName() {
    const tz = STATE.awareness.timezone || 'auto';
    if (tz === 'auto') {
        return Intl.DateTimeFormat().resolvedOptions().timeZone.split('/').pop().replace('_', ' ');
    }
    return tz.split('/').pop().replace('_', ' ');
}

// Get current UTC hour
function getUTCHour() {
    return new Date().getUTCHours();
}

// Determine current trading session
function getCurrentSession() {
    const utcHour = getUTCHour();
    
    // Check for overlap first (highest priority)
    if (utcHour >= 13 && utcHour < 16) {
        return TRADING_SESSIONS.OVERLAP;
    }
    // London session
    if (utcHour >= 8 && utcHour < 16) {
        return TRADING_SESSIONS.LONDON;
    }
    // New York session
    if (utcHour >= 13 && utcHour < 21) {
        return TRADING_SESSIONS.NEW_YORK;
    }
    // Asia session
    if (utcHour >= 0 && utcHour < 8) {
        return TRADING_SESSIONS.ASIA;
    }
    // Off hours
    return TRADING_SESSIONS.OFF_HOURS;
}

// Get next session and time until it starts
function getNextSession() {
    const utcHour = getUTCHour();
    const utcMinute = new Date().getUTCMinutes();
    
    let nextSession, hoursUntil;
    
    if (utcHour < 8) {
        nextSession = TRADING_SESSIONS.LONDON;
        hoursUntil = 8 - utcHour;
    } else if (utcHour < 13) {
        nextSession = TRADING_SESSIONS.OVERLAP;
        hoursUntil = 13 - utcHour;
    } else if (utcHour < 16) {
        nextSession = TRADING_SESSIONS.NEW_YORK;
        hoursUntil = 16 - utcHour;
    } else if (utcHour < 21) {
        nextSession = TRADING_SESSIONS.OFF_HOURS;
        hoursUntil = 21 - utcHour;
    } else {
        nextSession = TRADING_SESSIONS.ASIA;
        hoursUntil = (24 - utcHour) + 0;
    }
    
    const minutesUntil = 60 - utcMinute;
    const totalMinutes = (hoursUntil - 1) * 60 + minutesUntil;
    
    return {
        session: nextSession,
        hours: Math.floor(totalMinutes / 60),
        minutes: totalMinutes % 60
    };
}

// Fetch crypto news/events
async function fetchCryptoNews() {
    try {
        // Using CoinGecko's free events API
        const events = [];
        
        // Check for known major events (hardcoded for reliability)
        const now = new Date();
        const today = now.toISOString().split('T')[0];
        
        // Major recurring events to watch
        const majorEvents = [
            { day: 'Wednesday', time: '18:00', name: 'FOMC Minutes', impact: 'HIGH' },
            { day: 'Friday', time: '12:30', name: 'US Jobs Report', impact: 'HIGH' },
            { day: 'Thursday', time: '12:30', name: 'US CPI Data', impact: 'HIGH' },
        ];
        
        const dayOfWeek = now.toLocaleDateString('en-US', { weekday: 'long' });
        
        majorEvents.forEach(event => {
            if (event.day === dayOfWeek) {
                events.push({
                    name: event.name,
                    time: event.time + ' UTC',
                    impact: event.impact,
                    emoji: event.impact === 'HIGH' ? '⚠️' : '📰'
                });
            }
        });
        
        // Try to fetch live news from alternative API
        try {
            const newsUrl = 'https://api.coingecko.com/api/v3/events';
            const d = await fetchJSON(newsUrl);
            if (d && d.data && Array.isArray(d.data)) {
                const todayEvents = d.data.filter(e => e.start_date && e.start_date.startsWith(today)).slice(0, 3);
                todayEvents.forEach(e => {
                    events.push({
                        name: e.title || 'Crypto Event',
                        time: e.start_date,
                        impact: 'MEDIUM',
                        emoji: '📅'
                    });
                });
            }
        } catch (e) {
            // Ignore if news fetch fails - use static events only
        }
        
        STATE.awareness.news = events;
        STATE.awareness.lastNewsUpdate = Date.now();
        
    } catch(e) { 
        console.log('News fetch error:', e);
        STATE.awareness.news = [];
    }
}

// Generate awareness check HTML for main panel
function generateAwarenessHtml() {
    const session = getCurrentSession();
    const nextSess = getNextSession();
    const userTime = getUserTime();
    const cityName = getUserTimezoneName();
    const news = STATE.awareness.news || [];
    
    const volColor = session.volatility === 'EXTREME' ? 'var(--short)' : 
                     session.volatility === 'HIGH' ? 'var(--amber)' : 'var(--long)';
    const volBg = session.volatility === 'EXTREME' ? 'var(--short-dim)' : 
                  session.volatility === 'HIGH' ? 'var(--amber-dim)' : 'var(--long-dim)';
    
    let newsHtml = '';
    if (news.length > 0) {
        newsHtml = news.map(n => `
            <div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0">
                <span style="font-size:11px">${n.emoji} ${n.name}</span>
                <span style="font-size:10px;color:${n.impact === 'HIGH' ? 'var(--short)' : 'var(--amber)'}">${n.time}</span>
            </div>
        `).join('');
    } else {
        newsHtml = '<div style="font-size:11px;color:var(--text3)">✅ No major news today</div>';
    }
    
    // Generate tips based on session
    let tips = [];
    if (session.volatility === 'EXTREME') {
        tips = ['⚠️ Widen SL by 20% during overlap', '⚠️ Reduce position size', '⚠️ Expect fast moves'];
    } else if (session.volatility === 'HIGH') {
        tips = ['📈 Good for breakout trades', '💡 Watch for fake-outs at open', '⏰ First 30min = volatile'];
    } else if (session.name === 'ASIA') {
        tips = ['📊 Range-bound trading likely', '💡 Good for scalping S/R', '😴 Lower volume expected'];
    } else {
        tips = ['😴 Low liquidity period', '⚠️ Spreads may widen', '💤 Consider waiting'];
    }
    
    return `
        <div style="background:var(--bg4);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px">
            <div style="font-size:12px;font-weight:700;color:var(--purple);margin-bottom:10px;display:flex;justify-content:space-between;align-items:center">
                <span>⚠️ AWARENESS CHECK</span>
                <span style="font-size:10px;color:var(--text3)">${userTime}</span>
            </div>
            
            <!-- Session Info -->
            <div style="background:${volBg};border:1px solid ${volColor};border-radius:6px;padding:10px;margin-bottom:10px">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                    <span style="font-size:13px;font-weight:700;color:${volColor}">${session.emoji} ${session.name}</span>
                    <span style="font-size:10px;padding:2px 8px;border-radius:3px;background:${volColor};color:var(--bg1);font-weight:600">${session.volatility} VOL</span>
                </div>
                <div style="font-size:10px;color:var(--text2)">
                    🕐 Your time: ${userTime} (${cityName})
                </div>
                <div style="font-size:10px;color:var(--text3);margin-top:4px">
                    ⏭️ Next: ${nextSess.session.emoji} ${nextSess.session.name} in ${nextSess.hours}h ${nextSess.minutes}m
                </div>
            </div>
            
            <!-- News -->
            <div style="background:var(--bg3);border-radius:6px;padding:8px;margin-bottom:10px">
                <div style="font-size:11px;font-weight:600;color:var(--amber);margin-bottom:6px">📰 TODAY'S NEWS</div>
                ${newsHtml}
            </div>
            
            <!-- Tips -->
            <div style="background:var(--bg3);border-radius:6px;padding:8px">
                <div style="font-size:11px;font-weight:600;color:var(--cyan);margin-bottom:6px">💡 SESSION TIPS</div>
                ${tips.map(t => `<div style="font-size:10px;color:var(--text2);padding:2px 0">${t}</div>`).join('')}
            </div>
        </div>
    `;
}

// Update timezone preview in settings
function updateTimezonePreview() {
    const preview = document.getElementById('timezonePreview');
    if (preview) {
        const session = getCurrentSession();
        const userTime = getUserTime();
        const cityName = getUserTimezoneName();
        preview.innerHTML = `🕐 ${userTime} (${cityName}) | ${session.emoji} ${session.name} | ${session.volatility} Vol`;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// OPEN INTEREST & LIQUIDATION TRACKING
// ═══════════════════════════════════════════════════════════════════════════════

// Initialize OI state
if (!STATE.openInterest) {
    STATE.openInterest = {
        btc: { current: 0, previous: 0, change1h: 0, change24h: 0 },
        history: [],
        lastUpdate: 0
    };
}

if (!STATE.liquidations) {
    STATE.liquidations = {
        longs1h: 0,
        shorts1h: 0,
        totalLongs24h: 0,
        totalShorts24h: 0,
        lastUpdate: 0
    };
}

// Fetch BTC Open Interest from Bybit
async function fetchBTCOpenInterest() {
    try {
        const d = await fetchJSON(`${CONFIG.BYBIT_BASE}/v5/market/open-interest?category=linear&symbol=BTCUSDT&intervalTime=1h&limit=25`);
        
        if (d && d.result && d.result.list && d.result.list.length > 0) {
            const oiList = d.result.list;
            const currentOI = parseFloat(oiList[0].openInterest);
            const previousOI = STATE.openInterest.btc.current || currentOI;
            
            // Store OI history for trend analysis
            STATE.openInterest.history = oiList.map(item => ({
                oi: parseFloat(item.openInterest),
                time: parseInt(item.timestamp)
            }));
            
            // Calculate changes
            const oi1hAgo = oiList.length > 1 ? parseFloat(oiList[1].openInterest) : currentOI;
            const oi24hAgo = oiList.length > 23 ? parseFloat(oiList[23].openInterest) : currentOI;
            
            const change1h = oi1hAgo > 0 ? ((currentOI - oi1hAgo) / oi1hAgo) * 100 : 0;
            const change24h = oi24hAgo > 0 ? ((currentOI - oi24hAgo) / oi24hAgo) * 100 : 0;
            
            STATE.openInterest.btc = {
                current: currentOI,
                previous: previousOI,
                change1h: change1h,
                change24h: change24h,
                trend: change1h > 0.5 ? 'RISING' : change1h < -0.5 ? 'FALLING' : 'FLAT'
            };
            
            STATE.openInterest.lastUpdate = Date.now();
            
            // Update ENV bar OI display
            updateOIDisplay();
            
            // Update Market Flow panel
            updateMarketFlowPanel();
            
            console.log(`📊 BTC OI: ${(currentOI / 1e9).toFixed(2)}B (${change1h >= 0 ? '+' : ''}${change1h.toFixed(2)}% 1H)`);
        }
    } catch (e) {
        console.log('OI fetch error:', e);
    }
}

// Fetch coin-specific OI
async function fetchCoinOI(symbol) {
    try {
        const d = await fetchJSON(`${CONFIG.BYBIT_BASE}/v5/market/open-interest?category=linear&symbol=${symbol}&intervalTime=1h&limit=2`);
        
        if (d && d.result && d.result.list && d.result.list.length > 1) {
            const currentOI = parseFloat(d.result.list[0].openInterest);
            const prevOI = parseFloat(d.result.list[1].openInterest);
            const change = prevOI > 0 ? ((currentOI - prevOI) / prevOI) * 100 : 0;
            
            return {
                current: currentOI,
                change1h: change,
                trend: change > 0.5 ? 'RISING' : change < -0.5 ? 'FALLING' : 'FLAT'
            };
        }
    } catch (e) {
        console.log(`OI fetch error for ${symbol}:`, e);
    }
    return null;
}

// Fetch recent liquidations (estimated from funding + OI changes)
async function fetchLiquidations() {
    try {
        // Bybit doesn't have direct liquidation API for free
        // We estimate based on OI drops during price moves
        
        const btcOI = STATE.openInterest.btc;
        const btcChange = STATE.btc.change || 0;
        
        // Estimate liquidations based on OI change vs price change
        let longsLiq = 0;
        let shortsLiq = 0;
        
        if (btcOI.change1h < -1 && btcChange < -1) {
            // OI down + Price down = Long liquidations
            longsLiq = Math.abs(btcOI.change1h) * 5; // Rough estimate in $M
        } else if (btcOI.change1h < -1 && btcChange > 1) {
            // OI down + Price up = Short liquidations
            shortsLiq = Math.abs(btcOI.change1h) * 5;
        }
        
        STATE.liquidations = {
            longs1h: longsLiq,
            shorts1h: shortsLiq,
            bias: longsLiq > shortsLiq ? 'LONGS_LIQUIDATED' : 
                  shortsLiq > longsLiq ? 'SHORTS_LIQUIDATED' : 'BALANCED',
            lastUpdate: Date.now()
        };
        
        updateMarketFlowPanel();
        
    } catch (e) {
        console.log('Liquidation estimation error:', e);
    }
}

// Update OI display in ENV bar
function updateOIDisplay() {
    const oiEl = document.getElementById('envOI');
    const oiVal = document.getElementById('envOIVal');
    
    if (oiVal && oiEl) {
        const btcOI = STATE.openInterest.btc;
        const change = btcOI.change1h || 0;
        const arrow = change > 0.5 ? '▲' : change < -0.5 ? '▼' : '';
        const sign = change >= 0 ? '+' : '';
        
        oiVal.textContent = `${sign}${change.toFixed(1)}%${arrow}`;
        
        // Color based on OI trend
        if (change > 1) {
            oiEl.className = 'env-status go';
        } else if (change < -1) {
            oiEl.className = 'env-status nogo';
        } else {
            oiEl.className = 'env-status caution';
        }
    }
}

// Toggle Market Flow panel
function toggleFlow() {
    const content = document.getElementById('flowContent');
    const toggle = document.getElementById('flowToggle');
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    safeStorageSet('flowExpanded', !isExpanded);
}

// Restore Flow panel state
function restoreFlowState() {
    const expandedVal = safeStorageGet('flowExpanded', false);
    const expanded = expandedVal === true || expandedVal === 'true';
    if (expanded) {
        document.getElementById('flowContent')?.classList.add('expanded');
        document.getElementById('flowToggle')?.classList.add('expanded');
        // Also expand new panel
        document.getElementById('flowContentNew')?.classList.add('expanded');
        document.getElementById('flowToggleNew')?.classList.add('expanded');
    }
}

// Toggle NEW compact Flow panel
function toggleFlowNew() {
    const content = document.getElementById('flowContentNew');
    const toggle = document.getElementById('flowToggleNew');
    if (!content || !toggle) return;
    
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    safeStorageSet('flowExpanded', !isExpanded);
}

// Toggle NEW compact Backtest panel
function toggleBacktestNew() {
    const content = document.getElementById('backtestContentNew');
    const toggle = document.getElementById('backtestToggleNew');
    if (!content || !toggle) return;
    
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    safeStorageSet('backtestExpanded', !isExpanded);
}

// Restore NEW panels state
function restoreNewPanelsState() {
    // Flow panel
    const flowExpanded = safeStorageGet('flowExpanded', false);
    if (flowExpanded === true || flowExpanded === 'true') {
        document.getElementById('flowContentNew')?.classList.add('expanded');
        document.getElementById('flowToggleNew')?.classList.add('expanded');
    }
    // Backtest panel
    const btExpanded = safeStorageGet('backtestExpanded', false);
    if (btExpanded === true || btExpanded === 'true') {
        document.getElementById('backtestContentNew')?.classList.add('expanded');
        document.getElementById('backtestToggleNew')?.classList.add('expanded');
    }
}

// Update Market Flow panel (both old and new compact)
function updateMarketFlowPanel() {
    const btcOI = STATE.openInterest.btc;
    const btcPrice = STATE.btc || {};
    const liq = STATE.liquidations || {};
    
    // Calculate values once
    const oiInB = (btcOI.current / 1e9).toFixed(2);
    const change = btcOI.change1h || 0;
    const changeText = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
    const changeClass = `flow-change ${change > 0 ? 'up' : change < 0 ? 'down' : 'neutral'}`;
    
    // BTC OI Value - OLD panel
    const flowBtcOI = document.getElementById('flowBtcOI');
    const flowBtcOIChange = document.getElementById('flowBtcOIChange');
    if (flowBtcOI) {
        flowBtcOI.textContent = `$${oiInB}B`;
        flowBtcOIChange.textContent = `${changeText} 1H`;
        flowBtcOIChange.className = changeClass;
    }
    
    // BTC OI Value - NEW compact panel
    const flowBtcOINew = document.getElementById('flowBtcOINew');
    const flowBtcOIChangeNew = document.getElementById('flowBtcOIChangeNew');
    if (flowBtcOINew) {
        flowBtcOINew.textContent = `$${oiInB}B`;
        flowBtcOIChangeNew.textContent = changeText;
        flowBtcOIChangeNew.className = changeClass;
    }
    
    // OI vs Price interpretation
    const oiChange = btcOI.change1h || 0;
    const priceChange = btcPrice.change || 0;
    
    let interpretation = 'NEUTRAL';
    let status = 'neutral';
    
    if (priceChange > 0.5 && oiChange > 0.5) {
        interpretation = '✅ REAL BUY';
        status = 'up';
    } else if (priceChange > 0.5 && oiChange < -0.5) {
        interpretation = '⚠️ SQUEEZE';
        status = 'down';
    } else if (priceChange < -0.5 && oiChange > 0.5) {
        interpretation = '✅ REAL SELL';
        status = 'up';
    } else if (priceChange < -0.5 && oiChange < -0.5) {
        interpretation = '⚠️ LONG LIQ';
        status = 'down';
    }
    
    const priceStatusText = `P:${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(1)}%`;
    
    // OLD panel
    const flowOIPrice = document.getElementById('flowOIPrice');
    const flowOIPriceStatus = document.getElementById('flowOIPriceStatus');
    if (flowOIPrice) {
        flowOIPrice.textContent = interpretation;
        flowOIPriceStatus.textContent = priceStatusText;
        flowOIPriceStatus.className = `flow-change ${status}`;
    }
    
    // NEW compact panel
    const flowOIPriceNew = document.getElementById('flowOIPriceNew');
    const flowOIPriceStatusNew = document.getElementById('flowOIPriceStatusNew');
    if (flowOIPriceNew) {
        flowOIPriceNew.textContent = interpretation.replace('✅ ', '').replace('⚠️ ', '');
        flowOIPriceStatusNew.textContent = priceStatusText;
        flowOIPriceStatusNew.className = `flow-change ${status}`;
    }
    
    // Store interpretation for signal filtering
    STATE.openInterest.interpretation = interpretation.includes('REAL') ? 'REAL' : 
                                        interpretation.includes('SQUEEZE') ? 'SQUEEZE' : 
                                        interpretation.includes('LIQ') ? 'LIQUIDATION' : 'NEUTRAL';
    
    // Liquidations - OLD panel
    const flowLongsLiq = document.getElementById('flowLongsLiq');
    const flowShortsLiq = document.getElementById('flowShortsLiq');
    if (flowLongsLiq && flowShortsLiq) {
        flowLongsLiq.textContent = `$${(liq.longs1h || 0).toFixed(1)}M`;
        flowShortsLiq.textContent = `$${(liq.shorts1h || 0).toFixed(1)}M`;
        
        document.getElementById('flowLongsLiqPct').textContent = liq.longs1h > 5 ? '🔥 HIGH' : 'Normal';
        document.getElementById('flowLongsLiqPct').className = `flow-change ${liq.longs1h > 5 ? 'down' : 'neutral'}`;
        
        document.getElementById('flowShortsLiqPct').textContent = liq.shorts1h > 5 ? '🔥 HIGH' : 'Normal';
        document.getElementById('flowShortsLiqPct').className = `flow-change ${liq.shorts1h > 5 ? 'down' : 'neutral'}`;
    }
    
    // Liquidations - NEW compact panel
    const flowLongsLiqNew = document.getElementById('flowLongsLiqNew');
    const flowShortsLiqNew = document.getElementById('flowShortsLiqNew');
    if (flowLongsLiqNew && flowShortsLiqNew) {
        flowLongsLiqNew.textContent = `$${(liq.longs1h || 0).toFixed(1)}M`;
        flowShortsLiqNew.textContent = `$${(liq.shorts1h || 0).toFixed(1)}M`;
        
        const flowLongsLiqPctNew = document.getElementById('flowLongsLiqPctNew');
        const flowShortsLiqPctNew = document.getElementById('flowShortsLiqPctNew');
        if (flowLongsLiqPctNew) {
            flowLongsLiqPctNew.textContent = liq.longs1h > 5 ? '🔥' : 'OK';
            flowLongsLiqPctNew.className = `flow-change ${liq.longs1h > 5 ? 'down' : 'neutral'}`;
        }
        if (flowShortsLiqPctNew) {
            flowShortsLiqPctNew.textContent = liq.shorts1h > 5 ? '🔥' : 'OK';
            flowShortsLiqPctNew.className = `flow-change ${liq.shorts1h > 5 ? 'down' : 'neutral'}`;
        }
    }
    
    // Market Bias calculation
    const interp = STATE.openInterest.interpretation || 'NEUTRAL';
    let bias = 'NEUTRAL';
    let biasClass = 'neutral';
    
    if (interp === 'REAL' && priceChange > 0) {
        bias = '🟢 BULLISH';
        biasClass = 'bullish';
    } else if (interp === 'REAL' && priceChange < 0) {
        bias = '🔴 BEARISH';
        biasClass = 'bearish';
    } else if (interp === 'SQUEEZE') {
        bias = '⚠️ SQUEEZE';
        biasClass = 'squeeze';
    } else if (interp === 'LIQUIDATION') {
        bias = '💀 LIQUIDATIONS';
        biasClass = 'squeeze';
    }
    
    // OLD panel bias
    const flowBias = document.getElementById('flowBias');
    const flowStatus = document.getElementById('flowStatus');
    if (flowBias) {
        flowBias.textContent = bias;
        flowBias.className = `flow-verdict-value ${biasClass}`;
        
        if (flowStatus) {
            flowStatus.textContent = bias.replace(/[🟢🔴⚠️💀]/g, '').trim();
            flowStatus.className = `flow-status ${biasClass}`;
        }
    }
    
    // NEW compact panel bias
    const flowBiasNew = document.getElementById('flowBiasNew');
    if (flowBiasNew) {
        flowBiasNew.textContent = bias;
        flowBiasNew.className = `value ${biasClass}`;
    }
}

// Analyze OI for signal validation
function analyzeOIForSignal(direction, coinOI = null) {
    const btcOI = STATE.openInterest.btc;
    const btcPrice = STATE.btc || {};
    const interp = STATE.openInterest.interpretation || 'NEUTRAL';
    
    let score = 5; // Base score
    let status = 'NEUTRAL';
    let warning = null;
    
    // Check if OI confirms direction
    if (direction === 'LONG') {
        if (interp === 'REAL' && btcPrice.change > 0) {
            // Real buying - great for longs
            score = 10;
            status = 'CONFIRMED';
        } else if (interp === 'SQUEEZE') {
            // Short squeeze - risky for new longs
            score = 3;
            status = 'SQUEEZE';
            warning = 'Short squeeze detected - risky entry';
        } else if (interp === 'LIQUIDATION') {
            // Long liquidations - terrible for longs
            score = 0;
            status = 'DANGER';
            warning = 'Long liquidations in progress';
        }
    } else { // SHORT
        if (interp === 'REAL' && btcPrice.change < 0) {
            // Real selling - great for shorts
            score = 10;
            status = 'CONFIRMED';
        } else if (interp === 'SQUEEZE' || interp === 'LIQUIDATION') {
            // Squeeze happening - risky for shorts
            score = 3;
            status = 'SQUEEZE';
            warning = 'Potential squeeze - risky entry';
        }
    }
    
    // Coin-specific OI boost
    if (coinOI && coinOI.trend === 'RISING') {
        score += 2;
    }
    
    return { score: Math.min(10, score), status, warning };
}

// Fetch BTC Dominance
async function fetchBTCDominance() {
    try {
        const d = await fetchJSON('https://api.coingecko.com/api/v3/global');
        if (d && d.data && d.data.market_cap_percentage) {
            const dom = d.data.market_cap_percentage.btc;
            const prevDom = STATE.btcDominance || dom;
            STATE.btcDominance = dom;
            STATE.btcDomTrend = dom > prevDom ? 'rising' : dom < prevDom ? 'falling' : 'flat';
            
            const badge = document.getElementById('badgeDom');
            const val = document.getElementById('badgeDomVal');
            if (val) {
                const arrow = STATE.btcDomTrend === 'rising' ? '▲' : STATE.btcDomTrend === 'falling' ? '▼' : '';
                val.textContent = dom.toFixed(1) + '%' + arrow;
                
                // Green if falling (good for alts), Red if rising
                badge.className = 'info-badge ' + (STATE.btcDomTrend === 'falling' ? 'go' : STATE.btcDomTrend === 'rising' ? 'nogo' : 'caution');
            }
            
            // Update Season badge based on dominance
            updateSeasonBadge(dom, STATE.btcDomTrend);
            
            // Update ALTS condition badge
            updateAltsBadge();
        }
    } catch(e) { console.log('BTC Dominance fetch error:', e); }
}

// Update ALTS GOOD/BAD badge
function updateAltsBadge() {
    const badge = document.getElementById('badgeAlts');
    const val = document.getElementById('badgeAltsVal');
    if (!badge || !val) return;
    
    const env = STATE.environment || {};
    const btcDomTrend = STATE.btcDomTrend || 'flat';
    const btcStructure = env.btcStructure?.status || 'UNKNOWN';
    
    // ALTS GOOD: BTC.D falling + BTC structure intact
    // ALTS BAD: BTC.D rising OR BTC structure broken down
    // ALTS FLAT: BTC.D flat
    
    if (btcDomTrend === 'falling' && btcStructure === 'INTACT') {
        val.textContent = '🟢 GOOD';
        badge.className = 'info-badge go';
    } else if (btcDomTrend === 'rising' || btcStructure === 'BROKEN_DOWN') {
        val.textContent = '🔴 BAD';
        badge.className = 'info-badge nogo';
    } else {
        val.textContent = '🟡 FLAT';
        badge.className = 'info-badge caution';
    }
}

// Update Alt/BTC Season badge
function updateSeasonBadge(dom, trend) {
    const badge = document.getElementById('badgeSeason');
    const val = document.getElementById('badgeSeasonVal');
    if (!badge || !val) return;
    
    // Calculate alt season score (0-100, higher = more alt season)
    let altScore = 100 - dom; // Base: inverse of dominance
    if (trend === 'falling') altScore += 10;
    if (trend === 'rising') altScore -= 10;
    altScore = Math.max(0, Math.min(100, altScore));
    
    STATE.altSeasonScore = altScore;
    
    if (altScore >= 60) {
        // Alt Season
        val.textContent = '🌙 ALT';
        badge.className = 'info-badge go';
    } else if (altScore <= 40) {
        // BTC Season
        val.textContent = '₿ BTC';
        badge.className = 'info-badge nogo';
    } else {
        // Neutral
        val.textContent = '⚖️ MIX';
        badge.className = 'info-badge caution';
    }
}

// Update Trading Session Badge
function updateSessionBadge() {
    const badge = document.getElementById('badgeSession');
    const val = document.getElementById('badgeSessionVal');
    if (!badge || !val) return;
    
    const now = new Date();
    const utcHour = now.getUTCHours();
    
    let session = '---';
    let isActive = false;
    
    // Session times (UTC)
    if (utcHour >= 0 && utcHour < 8) {
        session = '🌏 ASIA';
        isActive = true;
    } else if (utcHour >= 8 && utcHour < 12) {
        session = '🌍 LDN';
        isActive = true;
    } else if (utcHour >= 12 && utcHour < 21) {
        session = '🌎 NY';
        isActive = true;
    } else {
        session = '🌑 OFF';
        isActive = false;
    }
    
    val.textContent = session;
    badge.className = isActive ? 'info-badge go' : 'info-badge caution';
}

// Fetch all market data
async function fetchAllMarketData() {
    await Promise.all([
        fetchFearGreed(),
        fetchDXY(),
        fetchFunding(),
        fetchBTCDominance()
    ]);
    updateSessionBadge();
}

// Update scan progress bar when complete
function setScanComplete() {
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    const btn = document.getElementById('scanBtn');
    
    if (fill) {
        fill.style.width = '100%';
        fill.classList.remove('scanning');
        fill.classList.add('done');
    }
    if (text) {
        text.textContent = '✅ Complete';
        text.classList.add('done');
    }
    if (pct) {
        pct.textContent = '100%';
        pct.classList.add('done');
    }
    if (btn) {
        btn.classList.remove('scanning');
        btn.classList.add('scan-done');
    }
}

// Reset scan progress bar
function resetScanProgress() {
    const bar = document.getElementById('scanProgressBar');
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    const btn = document.getElementById('scanBtn');
    
    if (bar) {
        bar.classList.add('active');
    }
    if (fill) {
        fill.style.width = '5%'; // Start with visible bar
        fill.classList.remove('done', 'error');
        fill.classList.add('scanning');
    }
    if (text) {
        text.textContent = '🔄 Starting...';
        text.classList.remove('done', 'error');
    }
    if (pct) {
        pct.textContent = '0%';
        pct.classList.remove('done', 'error');
    }
    if (btn) {
        btn.classList.remove('scan-done');
        btn.classList.add('scanning');
    }
}

// Set scan error state (red)
function setScanError(message) {
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    
    if (fill) {
        fill.classList.remove('scanning', 'done');
        fill.classList.add('error');
    }
    if (text) {
        text.textContent = '❌ ' + (message || 'Error');
        text.classList.add('error');
    }
    if (pct) {
        pct.classList.add('error');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// STATS BAR FILTER FUNCTION
// ═══════════════════════════════════════════════════════════════════════════════

function filterByStats(type) {
    STATE.statsFilter = type;
    updateSignalList();
    
    // Highlight active stat box
    document.querySelectorAll('.stat-box').forEach(box => {
        box.style.borderColor = 'var(--border)';
    });
    
    const activeBox = event.currentTarget;
    if (type !== 'all') {
        activeBox.style.borderColor = 'var(--gold)';
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// BACKTEST ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

// Toggle backtest panel expand/collapse
function toggleBacktest() {
    const content = document.getElementById('backtestContent');
    const toggle = document.getElementById('backtestToggle');
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
    } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
    }
    
    // Save state
    safeStorageSet('backtestExpanded', !isExpanded);
}

// Restore backtest panel state on load
function restoreBacktestState() {
    const expandedVal = safeStorageGet('backtestExpanded', false);
    const expanded = expandedVal === true || expandedVal === 'true';
    if (expanded) {
        document.getElementById('backtestContent')?.classList.add('expanded');
        document.getElementById('backtestToggle')?.classList.add('expanded');
        // Also expand new panel
        document.getElementById('backtestContentNew')?.classList.add('expanded');
        document.getElementById('backtestToggleNew')?.classList.add('expanded');
    }
}

// Run backtest from NEW compact panel
async function runBacktestNew() {
    const btn = document.getElementById('btRunBtnNew');
    const results = document.getElementById('backtestResultsNew');
    
    const range = parseInt(document.getElementById('btRangeNew').value);
    const gradeFilter = document.getElementById('btGradeNew').value;
    
    // Disable button and show loading
    if (btn) {
        btn.disabled = true;
        btn.textContent = '⏳...';
    }
    
    if (results) {
        results.innerHTML = `
            <div class="backtest-empty">
                <div class="icon">⏳</div>
                <div>Running backtest...</div>
            </div>
        `;
    }
    
    try {
        // Get coins to backtest
        const coins = STATE.coins?.length > 0 ? STATE.coins.slice(0, 15) : [
            'BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'BNBUSDT', 'XRPUSDT',
            'DOGEUSDT', 'ADAUSDT', 'AVAXUSDT', 'DOTUSDT', 'MATICUSDT'
        ];
        
        // Use mixed timeframes for compact test
        const timeframes = ['60', '240'];  // 1H, 4H
        const candlesNeeded = range * 24;
        
        // Run backtest simulation
        const backtestResults = await simulateBacktest(coins, timeframes, candlesNeeded, gradeFilter);
        
        // Display results in compact format
        displayBacktestResultsCompact(backtestResults, range);
        
    } catch (error) {
        console.error('Backtest error:', error);
        if (results) {
            results.innerHTML = `
                <div class="backtest-empty">
                    <div class="icon">❌</div>
                    <div>Failed: ${error.message}</div>
                </div>
            `;
        }
    }
    
    if (btn) {
        btn.disabled = false;
        btn.textContent = '▶ RUN';
    }
}

// Display backtest results in compact format for new panel
function displayBacktestResultsCompact(results, days) {
    const container = document.getElementById('backtestResultsNew');
    if (!container) return;
    
    const winRate = results.totalTrades > 0 ? ((results.wins / results.totalTrades) * 100).toFixed(0) : 0;
    const pnlClass = results.totalPnL >= 0 ? 'positive' : 'negative';
    
    container.innerHTML = `
        <div class="backtest-summary">
            <div class="backtest-stat">
                <div class="backtest-stat-label">Win Rate</div>
                <div class="backtest-stat-value ${results.wins > results.losses ? 'positive' : 'negative'}">${winRate}%</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">PnL (${days}D)</div>
                <div class="backtest-stat-value ${pnlClass}">${results.totalPnL >= 0 ? '+' : ''}${results.totalPnL.toFixed(0)}%</div>
            </div>
        </div>
        <div class="backtest-grade-row">
            <span class="grade-name">💎 Cream</span>
            <span class="win-rate">${results.byGrade.cream.trades > 0 ? ((results.byGrade.cream.wins / results.byGrade.cream.trades) * 100).toFixed(0) : 0}%</span>
            <span class="pnl ${results.byGrade.cream.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.cream.pnl >= 0 ? '+' : ''}${results.byGrade.cream.pnl.toFixed(0)}%</span>
        </div>
        <div class="backtest-grade-row">
            <span class="grade-name">🥇 Perfect</span>
            <span class="win-rate">${results.byGrade.perfect.trades > 0 ? ((results.byGrade.perfect.wins / results.byGrade.perfect.trades) * 100).toFixed(0) : 0}%</span>
            <span class="pnl ${results.byGrade.perfect.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.perfect.pnl >= 0 ? '+' : ''}${results.byGrade.perfect.pnl.toFixed(0)}%</span>
        </div>
        <div style="text-align:center;font-size:8px;color:var(--text3);margin-top:4px">${results.totalTrades} trades analyzed</div>
    `;
}

// Run backtest
async function runBacktest() {
    const btn = document.getElementById('btRunBtn');
    const results = document.getElementById('backtestResults');
    const status = document.getElementById('backtestStatus');
    
    const range = parseInt(document.getElementById('btRange').value);
    const gradeFilter = document.getElementById('btGrade').value;
    const tfFilter = document.getElementById('btTF').value;
    
    // Disable button and show loading
    btn.disabled = true;
    btn.textContent = '⏳ Running...';
    status.textContent = '(Running...)';
    
    results.innerHTML = `
        <div class="backtest-loading">
            <div class="spinner">⏳</div>
            <div style="margin-top:10px">Fetching historical data...</div>
            <div style="font-size:10px;color:var(--text3);margin-top:4px">This may take 30-60 seconds</div>
        </div>
    `;
    
    try {
        // Get coins to backtest (use current selection or top coins)
        const coins = STATE.coins?.length > 0 ? STATE.coins.slice(0, 20) : [
            'BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'BNBUSDT', 'XRPUSDT',
            'DOGEUSDT', 'ADAUSDT', 'AVAXUSDT', 'DOTUSDT', 'MATICUSDT'
        ];
        
        // Get timeframes based on filter
        let timeframes = ['60', '240', 'D'];  // 1H, 4H, 1D
        if (tfFilter === 'scalp') {
            timeframes = ['5', '15', '60'];  // 5m, 15m, 1H
        } else if (tfFilter === 'swing') {
            timeframes = ['240', 'D'];  // 4H, 1D
        }
        
        // Calculate how many candles we need
        const candlesNeeded = range * 24;  // Approximate candles per day for 1H
        
        // Run backtest simulation
        const backtestResults = await simulateBacktest(coins, timeframes, candlesNeeded, gradeFilter);
        
        // Display results
        displayBacktestResults(backtestResults, range);
        
        status.textContent = `(${backtestResults.totalTrades} trades analyzed)`;
        
    } catch (error) {
        console.error('Backtest error:', error);
        results.innerHTML = `
            <div style="text-align:center;padding:20px;color:var(--short)">
                <div style="font-size:24px;margin-bottom:8px">❌</div>
                <div>Backtest failed: ${error.message}</div>
            </div>
        `;
        status.textContent = '(Error)';
    }
    
    btn.disabled = false;
    btn.textContent = '▶ RUN';
}

// Simulate backtest using historical data
async function simulateBacktest(coins, timeframes, candlesNeeded, gradeFilter) {
    const results = {
        totalTrades: 0,
        wins: 0,
        losses: 0,
        totalPnL: 0,
        byGrade: {
            cream: { trades: 0, wins: 0, pnl: 0, avgRR: 0 },
            perfect: { trades: 0, wins: 0, pnl: 0, avgRR: 0 },
            strong: { trades: 0, wins: 0, pnl: 0, avgRR: 0 },
            valid: { trades: 0, wins: 0, pnl: 0, avgRR: 0 }
        },
        byTF: {},
        byCoin: {},
        trades: []
    };
    
    // Process each coin/TF combination
    for (const coin of coins) {
        for (const tf of timeframes) {
            try {
                // Fetch historical klines
                const klines = await fetchKlines(coin, tf, Math.min(candlesNeeded + 200, 1000));
                if (!klines || klines.length < 200) continue;
                
                // Slide through history and simulate signals
                for (let i = 200; i < klines.length - 20; i += 5) {
                    // Create subset of candles up to this point
                    const historicalKlines = klines.slice(0, i + 1);
                    
                    // Quick signal check (simplified for performance)
                    const signalResult = quickSignalCheck(historicalKlines, coin, tf);
                    
                    if (!signalResult) continue;
                    
                    // Apply grade filter
                    if (gradeFilter === 'cream' && !signalResult.isCream) continue;
                    if (gradeFilter === 'perfect' && signalResult.grade !== 'PERFECT') continue;
                    if (gradeFilter === 'strong' && !['PERFECT', 'STRONG'].includes(signalResult.grade)) continue;
                    
                    // Simulate trade outcome
                    const futureKlines = klines.slice(i + 1, i + 21);
                    const outcome = simulateTradeOutcome(signalResult, futureKlines);
                    
                    // Record results
                    results.totalTrades++;
                    if (outcome.won) results.wins++;
                    else results.losses++;
                    results.totalPnL += outcome.pnl;
                    
                    // By grade
                    const gradeKey = signalResult.isCream ? 'cream' : signalResult.grade.toLowerCase();
                    if (results.byGrade[gradeKey]) {
                        results.byGrade[gradeKey].trades++;
                        if (outcome.won) results.byGrade[gradeKey].wins++;
                        results.byGrade[gradeKey].pnl += outcome.pnl;
                        results.byGrade[gradeKey].avgRR += outcome.rr;
                    }
                    
                    // By TF
                    const tfLabel = CONFIG.TF_LABELS[tf] || tf;
                    if (!results.byTF[tfLabel]) results.byTF[tfLabel] = { trades: 0, wins: 0 };
                    results.byTF[tfLabel].trades++;
                    if (outcome.won) results.byTF[tfLabel].wins++;
                    
                    // By Coin
                    if (!results.byCoin[coin]) results.byCoin[coin] = { trades: 0, wins: 0 };
                    results.byCoin[coin].trades++;
                    if (outcome.won) results.byCoin[coin].wins++;
                    
                    // Store trade
                    results.trades.push({
                        coin,
                        tf: tfLabel,
                        grade: signalResult.grade,
                        direction: signalResult.direction,
                        entry: signalResult.entry,
                        outcome: outcome.won ? 'WIN' : 'LOSS',
                        pnl: outcome.pnl,
                        rr: outcome.rr,
                        time: new Date(historicalKlines[historicalKlines.length - 1].time).toLocaleDateString()
                    });
                }
                
                // Small delay to prevent rate limiting
                await sleep(50);
                
            } catch (e) {
                console.warn(`Backtest error for ${coin} ${tf}:`, e);
            }
        }
    }
    
    // Calculate averages
    Object.keys(results.byGrade).forEach(grade => {
        const g = results.byGrade[grade];
        if (g.trades > 0) {
            g.avgRR = (g.avgRR / g.trades).toFixed(1);
        }
    });
    
    return results;
}

// Quick signal check (simplified version for backtest performance)
function quickSignalCheck(klines, symbol, tf) {
    if (klines.length < 100) return null;
    
    const currentPrice = klines[klines.length - 1].close;
    const atr = calcATR(klines);
    
    // Quick Zone Analysis
    const zones = detectZones(klines);
    const nearestSupport = zones.filter(z => z.type === 'support' && z.high < currentPrice)
                                .sort((a, b) => b.high - a.high)[0];
    const nearestResistance = zones.filter(z => z.type === 'resistance' && z.low > currentPrice)
                                   .sort((a, b) => a.low - b.low)[0];
    
    let zoneDir = 'NEUTRAL';
    let zoneScore = 50;
    
    if (nearestSupport) {
        const distPct = ((currentPrice - nearestSupport.high) / currentPrice) * 100;
        if (distPct < 2) {
            zoneDir = 'LONG';
            zoneScore = 70 + (nearestSupport.touches * 5);
        }
    }
    if (nearestResistance) {
        const distPct = ((nearestResistance.low - currentPrice) / currentPrice) * 100;
        if (distPct < 2) {
            zoneDir = 'SHORT';
            zoneScore = 70 + (nearestResistance.touches * 5);
        }
    }
    
    // Quick Momentum Analysis
    const rsi = calcRSI(klines);
    const ema20 = calcEMA(klines.map(k => k.close), 20);
    const ema50 = calcEMA(klines.map(k => k.close), 50);
    
    let momDir = 'NEUTRAL';
    let momScore = 50;
    
    if (ema20[ema20.length - 1] > ema50[ema50.length - 1] && rsi.value < 70) {
        momDir = 'LONG';
        momScore = 65;
    } else if (ema20[ema20.length - 1] < ema50[ema50.length - 1] && rsi.value > 30) {
        momDir = 'SHORT';
        momScore = 65;
    }
    
    // Need zone and momentum to agree
    if (zoneDir === 'NEUTRAL' || zoneDir !== momDir) return null;
    
    const direction = zoneDir;
    const totalScore = Math.round((zoneScore + momScore) / 2);
    
    // Determine grade
    let grade = 'VALID';
    if (totalScore >= 90) grade = 'PERFECT';
    else if (totalScore >= 75) grade = 'STRONG';
    
    // Quick cream check
    const isCream = grade === 'PERFECT' && totalScore >= 85;
    
    return {
        direction,
        grade,
        score: totalScore,
        entry: currentPrice,
        atr,
        isCream,
        levels: {
            sl: direction === 'LONG' ? currentPrice - atr * 1.5 : currentPrice + atr * 1.5,
            tp: direction === 'LONG' ? currentPrice + atr * 2.5 : currentPrice - atr * 2.5
        }
    };
}

// Simulate trade outcome based on future candles
function simulateTradeOutcome(signal, futureKlines) {
    if (!futureKlines || futureKlines.length === 0) {
        return { won: false, pnl: 0, rr: 0 };
    }
    
    const entry = signal.entry;
    const sl = signal.levels.sl;
    const tp = signal.levels.tp;
    const direction = signal.direction;
    
    const risk = Math.abs(entry - sl);
    const reward = Math.abs(tp - entry);
    const targetRR = risk > 0 ? reward / risk : 0;
    
    // Check each future candle
    for (const candle of futureKlines) {
        if (direction === 'LONG') {
            // Check SL hit first (worst case)
            if (candle.low <= sl) {
                return { won: false, pnl: -100, rr: -1 };  // 1% loss assumed
            }
            // Check TP hit
            if (candle.high >= tp) {
                return { won: true, pnl: 100 * targetRR, rr: targetRR };
            }
        } else {  // SHORT
            // Check SL hit first
            if (candle.high >= sl) {
                return { won: false, pnl: -100, rr: -1 };
            }
            // Check TP hit
            if (candle.low <= tp) {
                return { won: true, pnl: 100 * targetRR, rr: targetRR };
            }
        }
    }
    
    // Neither hit - calculate current position
    const lastPrice = futureKlines[futureKlines.length - 1].close;
    const unrealizedPnL = entry > 0 ? (direction === 'LONG' 
        ? ((lastPrice - entry) / entry) * 10000  // basis points
        : ((entry - lastPrice) / entry) * 10000) : 0;
    
    const rrDivisor = risk > 0 && entry > 0 ? (risk / entry * 10000) : 1;
    return { 
        won: unrealizedPnL > 0, 
        pnl: unrealizedPnL / 100,  // Convert to percentage
        rr: unrealizedPnL / rrDivisor 
    };
}

// Display backtest results
function displayBacktestResults(results, days) {
    const container = document.getElementById('backtestResults');
    
    const winRate = results.totalTrades > 0 ? ((results.wins / results.totalTrades) * 100).toFixed(1) : 0;
    const pnlClass = results.totalPnL >= 0 ? 'positive' : 'negative';
    
    // Find best/worst
    let bestCoin = '-', bestCoinWin = 0;
    let worstCoin = '-', worstCoinWin = 100;
    Object.entries(results.byCoin).forEach(([coin, data]) => {
        if (data.trades >= 3) {
            const wr = (data.wins / data.trades) * 100;
            if (wr > bestCoinWin) { bestCoin = coin.replace('USDT', ''); bestCoinWin = wr; }
            if (wr < worstCoinWin) { worstCoin = coin.replace('USDT', ''); worstCoinWin = wr; }
        }
    });
    
    let bestTF = '-', bestTFWin = 0;
    Object.entries(results.byTF).forEach(([tf, data]) => {
        if (data.trades >= 3) {
            const wr = (data.wins / data.trades) * 100;
            if (wr > bestTFWin) { bestTF = tf; bestTFWin = wr; }
        }
    });
    
    container.innerHTML = `
        <div class="backtest-summary">
            <div class="backtest-stat">
                <div class="backtest-stat-label">Total Trades</div>
                <div class="backtest-stat-value neutral">${results.totalTrades}</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Win Rate</div>
                <div class="backtest-stat-value ${parseFloat(winRate) >= 50 ? 'positive' : 'negative'}">${winRate}%</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Total P&L</div>
                <div class="backtest-stat-value ${pnlClass}">${results.totalPnL >= 0 ? '+' : ''}${results.totalPnL.toFixed(0)}%</div>
            </div>
            <div class="backtest-stat">
                <div class="backtest-stat-label">Wins / Losses</div>
                <div class="backtest-stat-value neutral">${results.wins} / ${results.losses}</div>
            </div>
        </div>
        
        <div class="backtest-grades">
            <div class="backtest-grade-row" style="border-left:3px solid #00ffcc">
                <span class="grade-name">💎 CREAM</span>
                <span class="grade-stats">
                    <span>${results.byGrade.cream.trades} trades</span>
                    <span class="win-rate">${results.byGrade.cream.trades > 0 ? ((results.byGrade.cream.wins / results.byGrade.cream.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.cream.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.cream.pnl >= 0 ? '+' : ''}${results.byGrade.cream.pnl.toFixed(0)}%</span>
                </span>
            </div>
            <div class="backtest-grade-row" style="border-left:3px solid var(--gold)">
                <span class="grade-name">🥇 PERFECT</span>
                <span class="grade-stats">
                    <span>${results.byGrade.perfect.trades} trades</span>
                    <span class="win-rate">${results.byGrade.perfect.trades > 0 ? ((results.byGrade.perfect.wins / results.byGrade.perfect.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.perfect.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.perfect.pnl >= 0 ? '+' : ''}${results.byGrade.perfect.pnl.toFixed(0)}%</span>
                </span>
            </div>
            <div class="backtest-grade-row" style="border-left:3px solid var(--cyan)">
                <span class="grade-name">🥈 STRONG</span>
                <span class="grade-stats">
                    <span>${results.byGrade.strong.trades} trades</span>
                    <span class="win-rate">${results.byGrade.strong.trades > 0 ? ((results.byGrade.strong.wins / results.byGrade.strong.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.strong.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.strong.pnl >= 0 ? '+' : ''}${results.byGrade.strong.pnl.toFixed(0)}%</span>
                </span>
            </div>
            <div class="backtest-grade-row" style="border-left:3px solid var(--amber)">
                <span class="grade-name">🥉 VALID</span>
                <span class="grade-stats">
                    <span>${results.byGrade.valid.trades} trades</span>
                    <span class="win-rate">${results.byGrade.valid.trades > 0 ? ((results.byGrade.valid.wins / results.byGrade.valid.trades) * 100).toFixed(0) : 0}% win</span>
                    <span class="pnl ${results.byGrade.valid.pnl >= 0 ? 'positive' : 'negative'}">${results.byGrade.valid.pnl >= 0 ? '+' : ''}${results.byGrade.valid.pnl.toFixed(0)}%</span>
                </span>
            </div>
        </div>
        
        <div class="backtest-insights">
            <div class="backtest-insight">
                <span class="icon">📈</span>
                <span>Best Coin: <span class="highlight">${bestCoin}</span> (${bestCoinWin.toFixed(0)}% win)</span>
            </div>
            <div class="backtest-insight">
                <span class="icon">📉</span>
                <span>Worst Coin: <span class="lowlight">${worstCoin}</span> (${worstCoinWin.toFixed(0)}% win)</span>
            </div>
            <div class="backtest-insight">
                <span class="icon">⏰</span>
                <span>Best TF: <span class="highlight">${bestTF}</span> (${bestTFWin.toFixed(0)}% win)</span>
            </div>
            <div class="backtest-insight">
                <span class="icon">📊</span>
                <span>Period: Last <span class="highlight">${days}</span> days</span>
            </div>
        </div>
    `;
}

function calculateSmartLimitEntry(currentPrice, direction, atr, zoneDetails, smcDetails, adx) {
    const result = {
        limitEntry: null,
        entryType: null,  // 'ZONE' or 'ATR'
        zoneScore: 0,
        atrScore: 0,
        confidence: 0
    };
    
    // Get relevant zone
    const zone = direction === 'LONG' ? zoneDetails.nearestSupport : zoneDetails.nearestResistance;
    
    // Calculate Zone Score (if zone exists)
    if (zone) {
        let zScore = 0;
        
        // Touch count (max 25)
        if (zone.touches >= 4) zScore += 25;
        else if (zone.touches >= 3) zScore += 20;
        else if (zone.touches >= 2) zScore += 15;
        else zScore += 5;
        
        // Distance to zone (max 25)
        const zonePrice = direction === 'LONG' ? zone.high : zone.low;
        const distancePct = currentPrice > 0 ? Math.abs(currentPrice - zonePrice) / currentPrice * 100 : 0;
        if (distancePct <= 0.5) zScore += 25;
        else if (distancePct <= 1.0) zScore += 22;
        else if (distancePct <= 1.5) zScore += 18;
        else if (distancePct <= 2.0) zScore += 12;
        else if (distancePct <= 3.0) zScore += 5;
        
        // Order Block confluence (max 20)
        if (smcDetails && smcDetails.orderBlocks) {
            const obs = direction === 'LONG' ? smcDetails.orderBlocks.bullish : smcDetails.orderBlocks.bearish;
            const obAtZone = obs && obs.some(ob => Math.abs(ob.price - zonePrice) / zonePrice < 0.01);
            if (obAtZone) zScore += 20;
        }
        
        // Zone strength (max 15)
        if (zone.strength >= 70) zScore += 15;
        else if (zone.strength >= 50) zScore += 10;
        else zScore += 5;
        
        result.zoneScore = Math.min(100, zScore);
        result.zoneEntry = direction === 'LONG' ? zone.high * 1.002 : zone.low * 0.998;
    }
    
    // Calculate ATR Entry
    let pullbackMult = 0.4;
    const adxVal = adx || 25;
    
    // Adjust by trend strength
    if (adxVal > 40) pullbackMult = 0.25;
    else if (adxVal > 30) pullbackMult = 0.35;
    else if (adxVal > 20) pullbackMult = 0.45;
    else pullbackMult = 0.55;
    
    result.atrEntry = direction === 'LONG' 
        ? currentPrice - (atr * pullbackMult)
        : currentPrice + (atr * pullbackMult);
    
    // ATR Score
    result.atrScore = 50;
    if (adxVal > 30) result.atrScore += 20;
    else if (adxVal > 25) result.atrScore += 10;
    if (!zone || result.zoneScore < 40) result.atrScore += 15;
    result.atrScore = Math.min(100, result.atrScore);
    
    // Decision: Zone vs ATR
    if (result.zoneScore >= 70 && zone) {
        const distPct = Math.abs(currentPrice - result.zoneEntry) / currentPrice * 100;
        if (distPct <= 2.0) {
            result.entryType = 'ZONE';
            result.limitEntry = result.zoneEntry;
            result.confidence = Math.round(result.zoneScore * 0.9);
        }
    }
    
    if (!result.entryType) {
        if (result.zoneScore > result.atrScore && result.zoneScore >= 50) {
            result.entryType = 'ZONE';
            result.limitEntry = result.zoneEntry;
            result.confidence = Math.round(result.zoneScore * 0.85);
        } else {
            result.entryType = 'ATR';
            result.limitEntry = result.atrEntry;
            result.confidence = Math.round(result.atrScore * 0.85);
        }
    }
    
    // Safety: max 3% from current price
    const maxDist = 0.03;
    const entryDist = Math.abs(currentPrice - result.limitEntry) / currentPrice;
    if (entryDist > maxDist) {
        result.limitEntry = direction === 'LONG'
            ? currentPrice * (1 - maxDist)
            : currentPrice * (1 + maxDist);
        result.confidence = Math.round(result.confidence * 0.8);
    }
    
    return result;
}


// ═══════════════════════════════════════════════════════════════════════════════
// ZONE ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════════

// Find swing highs and lows with configurable left/right bars
function findSwingPoints(klines, leftBars = 5, rightBars = 5) {
    const swingHighs = [];
    const swingLows = [];
    
    if (!klines || klines.length < leftBars + rightBars + 1) return { highs: [], lows: [] };
    
    for (let i = leftBars; i < klines.length - rightBars; i++) {
        let isHigh = true;
        let isLow = true;
        
        const currentHigh = klines[i].high;
        const currentLow = klines[i].low;
        
        // Check left bars
        for (let j = i - leftBars; j < i; j++) {
            if (klines[j].high >= currentHigh) isHigh = false;
            if (klines[j].low <= currentLow) isLow = false;
        }
        
        // Check right bars
        for (let j = i + 1; j <= i + rightBars; j++) {
            if (klines[j].high >= currentHigh) isHigh = false;
            if (klines[j].low <= currentLow) isLow = false;
        }
        
        if (isHigh) {
            swingHighs.push({
                index: i,
                price: currentHigh,
                time: klines[i].time,
                volume: klines[i].volume
            });
        }
        
        if (isLow) {
            swingLows.push({
                index: i,
                price: currentLow,
                time: klines[i].time,
                volume: klines[i].volume
            });
        }
    }
    
    return { highs: swingHighs, lows: swingLows };
}

// Cluster nearby price levels into zones
function clusterZones(points, threshold = 0.005) {
    if (!points || points.length === 0) return [];
    
    const sorted = [...points].sort((a, b) => a.price - b.price);
    const clusters = [];
    let currentCluster = [sorted[0]];
    
    for (let i = 1; i < sorted.length; i++) {
        const clusterAvg = currentCluster.reduce((sum, p) => sum + p.price, 0) / currentCluster.length;
        const pctDiff = Math.abs(sorted[i].price - clusterAvg) / clusterAvg;
        
        if (pctDiff <= threshold) {
            currentCluster.push(sorted[i]);
        } else {
            clusters.push(currentCluster);
            currentCluster = [sorted[i]];
        }
    }
    clusters.push(currentCluster);
    
    // Convert clusters to zones
    return clusters.map(cluster => {
        const prices = cluster.map(p => p.price);
        const high = Math.max(...prices);
        const low = Math.min(...prices);
        const totalVolume = cluster.reduce((sum, p) => sum + (p.volume || 0), 0);
        const times = cluster.map(p => p.time);
        
        return {
            high: high,
            low: low,
            price: (high + low) / 2,
            touches: cluster.length,
            volume: totalVolume,
            firstTouch: Math.min(...times),
            lastTouch: Math.max(...times),
            indices: cluster.map(p => p.index)
        };
    });
}

// Calculate zone strength with decay over time
function calcZoneStrength(zone, currentIndex, totalBars, avgVolume) {
    // SAFETY: Validate inputs
    if (!zone) return 0;
    
    let strength = 0;
    const touches = zone.touches || 0;
    const volume = zone.volume || 0;
    const indices = zone.indices || [];
    
    // Touch count bonus (max 30 points)
    if (touches >= 5) strength += 30;
    else if (touches >= 4) strength += 25;
    else if (touches >= 3) strength += 20;
    else if (touches >= 2) strength += 12;
    else strength += 5;
    
    // Volume bonus (max 20 points) - FIXED: Safe division
    if (avgVolume > 0 && touches > 0) {
        const volRatio = volume / (avgVolume * touches);
        if (!isNaN(volRatio) && isFinite(volRatio)) {
            if (volRatio >= 2.0) strength += 20;
            else if (volRatio >= 1.5) strength += 15;
            else if (volRatio >= 1.2) strength += 10;
            else if (volRatio >= 1.0) strength += 5;
        }
    }
    
    // Freshness bonus (max 20 points) - newer zones are stronger
    // SAFETY: Check indices array is not empty
    if (indices.length > 0) {
        const lastTouchIndex = Math.max(...indices);
        const barsSinceTouch = currentIndex - lastTouchIndex;
        if (barsSinceTouch <= 10) strength += 20;
        else if (barsSinceTouch <= 25) strength += 15;
        else if (barsSinceTouch <= 50) strength += 10;
        else if (barsSinceTouch <= 100) strength += 5;
        
        // Age decay - reduce strength for very old zones
        const firstTouchIndex = Math.min(...indices);
        const zoneAge = currentIndex - firstTouchIndex;
        if (zoneAge > 150) strength -= 10;
        else if (zoneAge > 100) strength -= 5;
    }
    
    return Math.max(0, Math.min(100, strength));
}

// Check if price is at a round number
function checkRoundNumber(price) {
    let bonus = 0;
    const priceStr = price.toString();
    
    // Check for major round numbers
    if (price >= 1000) {
        if (price % 10000 === 0) bonus = 8;      // 10000, 20000, etc.
        else if (price % 5000 === 0) bonus = 6;  // 5000, 15000, etc.
        else if (price % 1000 === 0) bonus = 4;  // 1000, 2000, etc.
        else if (price % 500 === 0) bonus = 3;
        else if (price % 100 === 0) bonus = 2;
    } else if (price >= 1) {
        if (price % 100 === 0) bonus = 5;
        else if (price % 50 === 0) bonus = 4;
        else if (price % 10 === 0) bonus = 3;
        else if (price % 5 === 0) bonus = 2;
        else if (price % 1 === 0) bonus = 1;
    } else {
        // For small prices like 0.00001234
        const decimals = priceStr.split('.')[1] || '';
        const zeros = (decimals.match(/0+$/) || [''])[0].length;
        if (zeros >= 4) bonus = 4;
        else if (zeros >= 3) bonus = 3;
        else if (zeros >= 2) bonus = 2;
    }
    
    return bonus;
}

// Calculate Fibonacci levels from swing high to swing low
function calcFibLevels(swingHigh, swingLow) {
    const range = swingHigh - swingLow;
    return {
        level_0: swingLow,
        level_236: swingLow + range * 0.236,
        level_382: swingLow + range * 0.382,
        level_5: swingLow + range * 0.5,
        level_618: swingLow + range * 0.618,
        level_786: swingLow + range * 0.786,
        level_1: swingHigh
    };
}

// Check if zone aligns with Fibonacci level
function checkFibAlignment(zonePrice, fibLevels, tolerance = 0.005) {
    const fibs = [0.236, 0.382, 0.5, 0.618, 0.786];
    const fibPrices = [fibLevels.level_236, fibLevels.level_382, fibLevels.level_5, fibLevels.level_618, fibLevels.level_786];
    
    for (let i = 0; i < fibPrices.length; i++) {
        const pctDiff = Math.abs(zonePrice - fibPrices[i]) / fibPrices[i];
        if (pctDiff <= tolerance) {
            return { aligned: true, level: fibs[i], bonus: fibs[i] === 0.618 ? 8 : fibs[i] === 0.5 ? 6 : 4 };
        }
    }
    return { aligned: false, level: null, bonus: 0 };
}

// Detect fakeout (wick through zone but close back inside)
function detectFakeout(klines, zone, lookback = 5) {
    if (!klines || klines.length < lookback) return { detected: false };
    
    const recent = klines.slice(-lookback);
    
    for (const candle of recent) {
        // Bullish fakeout: wick below support but close above
        if (candle.low < zone.low && candle.close > zone.low && candle.close > candle.open) {
            return { detected: true, type: 'bullish', strength: 'strong' };
        }
        // Bearish fakeout: wick above resistance but close below
        if (candle.high > zone.high && candle.close < zone.high && candle.close < candle.open) {
            return { detected: true, type: 'bearish', strength: 'strong' };
        }
    }
    
    return { detected: false };
}

// Get distance status from current price to zone
function getZoneDistance(currentPrice, zone) {
    const zoneMid = zone.price;
    const pctDistance = Math.abs(currentPrice - zoneMid) / currentPrice * 100;
    
    let status, score;
    if (pctDistance <= 0.3) {
        status = 'AT';
        score = 40;
    } else if (pctDistance <= 0.8) {
        status = 'CLOSE';
        score = 30;
    } else if (pctDistance <= 1.5) {
        status = 'NEAR';
        score = 20;
    } else if (pctDistance <= 3.0) {
        status = 'APPROACHING';
        score = 10;
    } else {
        status = 'FAR';
        score = 0;
    }
    
    return { status, score, pctDistance };
}

// Multi-timeframe zone confluence analysis
async function analyzeZoneConfluence(symbol, currentPrice, entryTF) {
    const confluenceTFs = CONFIG.ZONE_TFS;
    const allZones = { support: [], resistance: [] };
    
    for (const tf of confluenceTFs) {
        try {
            const klines = await fetchKlines(symbol, tf, 200);
            if (!klines || klines.length < 50) continue;
            
            const swings = findSwingPoints(klines, 5, 5);
            const supportZones = clusterZones(swings.lows, 0.005);
            const resistanceZones = clusterZones(swings.highs, 0.005);
            
            // Tag zones with their timeframe
            supportZones.forEach(z => {
                z.tf = tf;
                z.type = 'support';
                if (z.price < currentPrice) allZones.support.push(z);
            });
            
            resistanceZones.forEach(z => {
                z.tf = tf;
                z.type = 'resistance';
                if (z.price > currentPrice) allZones.resistance.push(z);
            });
            
            await sleep(50);
        } catch (e) {
            console.error(`Zone confluence error for ${tf}:`, e);
        }
    }
    
    // Find confluent zones (zones that appear in multiple TFs)
    const findConfluent = (zones) => {
        const confluent = [];
        const used = new Set();
        
        for (let i = 0; i < zones.length; i++) {
            if (used.has(i)) continue;
            
            const zone = zones[i];
            const matching = [zone];
            
            for (let j = i + 1; j < zones.length; j++) {
                if (used.has(j)) continue;
                
                const other = zones[j];
                const pctDiff = Math.abs(zone.price - other.price) / zone.price;
                
                if (pctDiff <= 0.015) { // 1.5% tolerance for confluence
                    matching.push(other);
                    used.add(j);
                }
            }
            
            if (matching.length >= 1) {
                const tfs = [...new Set(matching.map(m => m.tf))];
                const avgPrice = matching.reduce((sum, m) => sum + m.price, 0) / matching.length;
                const totalTouches = matching.reduce((sum, m) => sum + m.touches, 0);
                
                confluent.push({
                    price: avgPrice,
                    high: Math.max(...matching.map(m => m.high)),
                    low: Math.min(...matching.map(m => m.low)),
                    tfs: tfs,
                    tfCount: tfs.length,
                    totalTouches: totalTouches,
                    type: zone.type
                });
            }
            used.add(i);
        }
        
        return confluent.sort((a, b) => b.tfCount - a.tfCount);
    };
    
    return {
        support: findConfluent(allZones.support),
        resistance: findConfluent(allZones.resistance)
    };
}

// MAIN ZONE ANALYSIS FUNCTION
async function performZoneAnalysis(klines, symbol, tf, currentPrice) {
    const result = {
        score: 0,
        direction: null,
        status: 'FAR',
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const len = klines.length;
    // FIXED: Safe volume calculation
    const volSlice = klines.slice(-50).filter(k => k?.volume > 0);
    const avgVolume = volSlice.length > 0 ? volSlice.reduce((sum, k) => sum + k.volume, 0) / volSlice.length : 1;
    
    // Find swing points
    const swings = findSwingPoints(klines, 5, 5);
    
    // Cluster into zones
    const supportZones = clusterZones(swings.lows, 0.005).filter(z => z.price < currentPrice);
    const resistanceZones = clusterZones(swings.highs, 0.005).filter(z => z.price > currentPrice);
    
    // Calculate strength for each zone
    supportZones.forEach(z => {
        z.strength = calcZoneStrength(z, len - 1, len, avgVolume);
    });
    resistanceZones.forEach(z => {
        z.strength = calcZoneStrength(z, len - 1, len, avgVolume);
    });
    
    // Sort by strength
    supportZones.sort((a, b) => b.strength - a.strength);
    resistanceZones.sort((a, b) => b.strength - a.strength);
    
    // Get nearest zones
    const nearestSupport = supportZones.length > 0 ? supportZones[0] : null;
    const nearestResistance = resistanceZones.length > 0 ? resistanceZones[0] : null;
    
    result.details.nearestSupport = nearestSupport;
    result.details.nearestResistance = nearestResistance;
    result.details.supportCount = supportZones.length;
    result.details.resistanceCount = resistanceZones.length;
    
    // Calculate Fib levels
    const recentHigh = Math.max(...klines.slice(-100).map(k => k.high));
    const recentLow = Math.min(...klines.slice(-100).map(k => k.low));
    const fibLevels = calcFibLevels(recentHigh, recentLow);
    result.details.fibLevels = fibLevels;
    
    let score = 0;
    
    // Check support zone
    if (nearestSupport) {
        const dist = getZoneDistance(currentPrice, nearestSupport);
        
        if (dist.status !== 'FAR') {
            result.direction = 'LONG';
            result.status = dist.status;
            score += dist.score;
            result.factors.push(`${dist.status} Support`);
            
            // Touch count bonus
            if (nearestSupport.touches >= 4) {
                score += 15;
                result.factors.push(`${nearestSupport.touches} touches`);
            } else if (nearestSupport.touches >= 3) {
                score += 10;
                result.factors.push(`${nearestSupport.touches} touches`);
            } else if (nearestSupport.touches >= 2) {
                score += 5;
            }
            
            // Strength bonus
            if (nearestSupport.strength >= 60) {
                score += 10;
                result.factors.push('Strong zone');
            } else if (nearestSupport.strength >= 40) {
                score += 5;
            }
            
            // Round number bonus
            const roundBonus = checkRoundNumber(nearestSupport.price);
            if (roundBonus >= 4) {
                score += roundBonus;
                result.factors.push('Round number');
            }
            
            // Fib alignment bonus
            const fibCheck = checkFibAlignment(nearestSupport.price, fibLevels);
            if (fibCheck.aligned) {
                score += fibCheck.bonus;
                result.factors.push(`Fib ${fibCheck.level}`);
            }
            
            // Fakeout bonus
            const fakeout = detectFakeout(klines, nearestSupport);
            if (fakeout.detected && fakeout.type === 'bullish') {
                score += 12;
                result.factors.push('Fakeout sweep ✓');
            }
        }
    }
    
    // Check resistance zone
    if (nearestResistance) {
        const dist = getZoneDistance(currentPrice, nearestResistance);
        
        if (dist.status !== 'FAR' && !result.direction) {
            result.direction = 'SHORT';
            result.status = dist.status;
            score += dist.score;
            result.factors.push(`${dist.status} Resistance`);
            
            // Touch count bonus
            if (nearestResistance.touches >= 4) {
                score += 15;
                result.factors.push(`${nearestResistance.touches} touches`);
            } else if (nearestResistance.touches >= 3) {
                score += 10;
                result.factors.push(`${nearestResistance.touches} touches`);
            } else if (nearestResistance.touches >= 2) {
                score += 5;
            }
            
            // Strength bonus
            if (nearestResistance.strength >= 60) {
                score += 10;
                result.factors.push('Strong zone');
            } else if (nearestResistance.strength >= 40) {
                score += 5;
            }
            
            // Round number bonus
            const roundBonus = checkRoundNumber(nearestResistance.price);
            if (roundBonus >= 4) {
                score += roundBonus;
                result.factors.push('Round number');
            }
            
            // Fib alignment bonus
            const fibCheck = checkFibAlignment(nearestResistance.price, fibLevels);
            if (fibCheck.aligned) {
                score += fibCheck.bonus;
                result.factors.push(`Fib ${fibCheck.level}`);
            }
            
            // Fakeout bonus
            const fakeout = detectFakeout(klines, nearestResistance);
            if (fakeout.detected && fakeout.type === 'bearish') {
                score += 12;
                result.factors.push('Fakeout sweep ✓');
            }
        }
    }
    
    // If price is between zones (no clear direction)
    if (!result.direction && nearestSupport && nearestResistance) {
        const supDist = (currentPrice - nearestSupport.price) / currentPrice;
        const resDist = (nearestResistance.price - currentPrice) / currentPrice;
        
        if (supDist < resDist) {
            result.direction = 'LONG';
            result.factors.push('Closer to support');
            score += 5;
        } else {
            result.direction = 'SHORT';
            result.factors.push('Closer to resistance');
            score += 5;
        }
        result.status = 'BETWEEN';
        result.warnings.push('Mid-range - wait for zone');
    }
    
    result.score = Math.min(100, Math.max(0, score));
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF PART 1 - Zone Analysis Complete
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// SMC ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════════

// Detect market structure (HH, HL, LH, LL)
function detectStructure(klines, lookback = 50) {
    if (!klines || klines.length < lookback) return { trend: 'NEUTRAL', swings: [], counts: {} };
    
    const swings = findSwingPoints(klines, 3, 3);
    const allSwings = [];
    
    // Combine and sort swings by index
    swings.highs.forEach(h => allSwings.push({ ...h, type: 'high' }));
    swings.lows.forEach(l => allSwings.push({ ...l, type: 'low' }));
    allSwings.sort((a, b) => a.index - b.index);
    
    // Label structure points
    let lastHigh = null;
    let lastLow = null;
    const structure = [];
    const counts = { HH: 0, HL: 0, LH: 0, LL: 0 };
    
    for (const swing of allSwings) {
        if (swing.type === 'high') {
            if (lastHigh !== null) {
                if (swing.price > lastHigh.price) {
                    structure.push({ ...swing, label: 'HH' });
                    counts.HH++;
                } else {
                    structure.push({ ...swing, label: 'LH' });
                    counts.LH++;
                }
            } else {
                structure.push({ ...swing, label: 'H' });
            }
            lastHigh = swing;
        } else {
            if (lastLow !== null) {
                if (swing.price > lastLow.price) {
                    structure.push({ ...swing, label: 'HL' });
                    counts.HL++;
                } else {
                    structure.push({ ...swing, label: 'LL' });
                    counts.LL++;
                }
            } else {
                structure.push({ ...swing, label: 'L' });
            }
            lastLow = swing;
        }
    }
    
    // Determine trend from recent structure
    const recentStructure = structure.slice(-6);
    let bullishPoints = 0;
    let bearishPoints = 0;
    
    recentStructure.forEach(s => {
        if (s.label === 'HH' || s.label === 'HL') bullishPoints++;
        if (s.label === 'LH' || s.label === 'LL') bearishPoints++;
    });
    
    let trend = 'NEUTRAL';
    if (bullishPoints >= 3 && bullishPoints > bearishPoints) trend = 'BULLISH';
    else if (bearishPoints >= 3 && bearishPoints > bullishPoints) trend = 'BEARISH';
    
    return { trend, swings: structure, counts, lastHigh, lastLow };
}

// Detect Break of Structure (BOS) - BODY CLOSE confirmation
function detectBOS(klines, structure) {
    if (!klines || klines.length < 10 || !structure.swings || structure.swings.length < 2) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const prevCandle = klines[len - 2];
    
    // Get recent swing highs and lows
    const recentHighs = structure.swings.filter(s => s.type === 'high').slice(-3);
    const recentLows = structure.swings.filter(s => s.type === 'low').slice(-3);
    
    // Bullish BOS: Current candle BODY CLOSES above recent swing high
    for (const high of recentHighs) {
        if (prevCandle.close <= high.price && currentCandle.close > high.price) {
            // Confirm it's a body close, not just wick
            if (currentCandle.close > currentCandle.open) { // Green candle
                const bodyTop = currentCandle.close;
                if (bodyTop > high.price) {
                    return {
                        detected: true,
                        direction: 'BULLISH',
                        type: 'BOS',
                        level: high.price,
                        strength: currentCandle.close - high.price > (currentCandle.high - currentCandle.low) * 0.3 ? 'STRONG' : 'NORMAL'
                    };
                }
            }
        }
    }
    
    // Bearish BOS: Current candle BODY CLOSES below recent swing low
    for (const low of recentLows) {
        if (prevCandle.close >= low.price && currentCandle.close < low.price) {
            // Confirm it's a body close, not just wick
            if (currentCandle.close < currentCandle.open) { // Red candle
                const bodyBottom = currentCandle.close;
                if (bodyBottom < low.price) {
                    return {
                        detected: true,
                        direction: 'BEARISH',
                        type: 'BOS',
                        level: low.price,
                        strength: low.price - currentCandle.close > (currentCandle.high - currentCandle.low) * 0.3 ? 'STRONG' : 'NORMAL'
                    };
                }
            }
        }
    }
    
    return { detected: false };
}

// Detect Change of Character (CHoCH)
function detectCHoCH(klines, structure) {
    if (!klines || klines.length < 10 || !structure.swings || structure.swings.length < 4) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const trend = structure.trend;
    
    const recentHighs = structure.swings.filter(s => s.type === 'high').slice(-3);
    const recentLows = structure.swings.filter(s => s.type === 'low').slice(-3);
    
    // Bullish CHoCH: In a downtrend, price breaks above a lower high
    if (trend === 'BEARISH' && recentHighs.length >= 2) {
        const lastLH = recentHighs.find(h => h.label === 'LH');
        if (lastLH && currentCandle.close > lastLH.price) {
            return {
                detected: true,
                direction: 'BULLISH',
                type: 'CHoCH',
                level: lastLH.price,
                previousTrend: 'BEARISH'
            };
        }
    }
    
    // Bearish CHoCH: In an uptrend, price breaks below a higher low
    if (trend === 'BULLISH' && recentLows.length >= 2) {
        const lastHL = recentLows.find(l => l.label === 'HL');
        if (lastHL && currentCandle.close < lastHL.price) {
            return {
                detected: true,
                direction: 'BEARISH',
                type: 'CHoCH',
                level: lastHL.price,
                previousTrend: 'BULLISH'
            };
        }
    }
    
    return { detected: false };
}

// Detect Order Blocks with Mitigation Tracking
function detectOrderBlocks(klines, lookback = 50) {
    if (!klines || klines.length < lookback) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const bullishOBs = [];
    const bearishOBs = [];
    const currentPrice = klines[len - 1].close;
    
    // Calculate average volume for filtering - FIXED: Safe calculation
    const volSlice = klines.slice(-50).filter(k => k?.volume > 0);
    const avgVolume = volSlice.length > 0 ? volSlice.reduce((sum, k) => sum + k.volume, 0) / volSlice.length : 1;
    
    for (let i = len - lookback; i < len - 3; i++) {
        if (i < 1) continue;
        
        const candle = klines[i];
        const nextCandle = klines[i + 1];
        const followCandle = klines[i + 2];
        
        // Bullish Order Block: Down candle followed by strong up move
        if (candle.close < candle.open) { // Red candle
            const moveUp = followCandle.close - candle.low;
            const candleRange = candle.high - candle.low;
            
            // Strong impulse move away
            if (moveUp > candleRange * 2 && candle.volume > avgVolume * 0.8) {
                // Check if OB has been mitigated
                let mitigated = false;
                let mitigationPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].low <= candle.high) {
                        mitigated = true;
                        mitigationPct = Math.min(100, ((candle.high - klines[j].low) / candleRange) * 100);
                        break;
                    }
                }
                
                // Only add if not fully mitigated and price is above
                if (mitigationPct < 100 && currentPrice > candle.low) {
                    bullishOBs.push({
                        high: candle.high,
                        low: candle.low,
                        price: (candle.high + candle.low) / 2,
                        index: i,
                        time: candle.time,
                        volume: candle.volume,
                        mitigated: mitigated,
                        mitigationPct: mitigationPct,
                        fresh: !mitigated
                    });
                }
            }
        }
        
        // Bearish Order Block: Up candle followed by strong down move
        if (candle.close > candle.open) { // Green candle
            const moveDown = candle.high - followCandle.close;
            const candleRange = candle.high - candle.low;
            
            // Strong impulse move away
            if (moveDown > candleRange * 2 && candle.volume > avgVolume * 0.8) {
                // Check if OB has been mitigated
                let mitigated = false;
                let mitigationPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].high >= candle.low) {
                        mitigated = true;
                        mitigationPct = Math.min(100, ((klines[j].high - candle.low) / candleRange) * 100);
                        break;
                    }
                }
                
                // Only add if not fully mitigated and price is below
                if (mitigationPct < 100 && currentPrice < candle.high) {
                    bearishOBs.push({
                        high: candle.high,
                        low: candle.low,
                        price: (candle.high + candle.low) / 2,
                        index: i,
                        time: candle.time,
                        volume: candle.volume,
                        mitigated: mitigated,
                        mitigationPct: mitigationPct,
                        fresh: !mitigated
                    });
                }
            }
        }
    }
    
    // Sort by freshness and proximity to current price
    bullishOBs.sort((a, b) => {
        if (a.fresh !== b.fresh) return a.fresh ? -1 : 1;
        return Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price);
    });
    
    bearishOBs.sort((a, b) => {
        if (a.fresh !== b.fresh) return a.fresh ? -1 : 1;
        return Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price);
    });
    
    return { bullish: bullishOBs.slice(0, 5), bearish: bearishOBs.slice(0, 5) };
}

// Detect Breaker Blocks (Mitigated OB that becomes S/R)
function detectBreakerBlocks(klines, orderBlocks) {
    if (!klines || !orderBlocks) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    const bullishBreakers = [];
    const bearishBreakers = [];
    
    // Bullish Breaker: Former bearish OB that got broken and now acts as support
    for (const ob of orderBlocks.bearish) {
        if (ob.mitigated && ob.mitigationPct >= 80) {
            // Check if price broke through and is now above
            if (currentPrice > ob.high) {
                // This bearish OB is now a bullish breaker (support)
                bullishBreakers.push({
                    high: ob.high,
                    low: ob.low,
                    price: ob.price,
                    type: 'BREAKER',
                    originalType: 'BEARISH_OB',
                    index: ob.index
                });
            }
        }
    }
    
    // Bearish Breaker: Former bullish OB that got broken and now acts as resistance
    for (const ob of orderBlocks.bullish) {
        if (ob.mitigated && ob.mitigationPct >= 80) {
            // Check if price broke through and is now below
            if (currentPrice < ob.low) {
                // This bullish OB is now a bearish breaker (resistance)
                bearishBreakers.push({
                    high: ob.high,
                    low: ob.low,
                    price: ob.price,
                    type: 'BREAKER',
                    originalType: 'BULLISH_OB',
                    index: ob.index
                });
            }
        }
    }
    
    return { bullish: bullishBreakers, bearish: bearishBreakers };
}

// Detect Fair Value Gaps (FVG) with Fill Tracking
function detectFVG(klines, lookback = 30) {
    if (!klines || klines.length < lookback) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const bullishFVGs = [];
    const bearishFVGs = [];
    const currentPrice = klines[len - 1].close;
    
    for (let i = len - lookback; i < len - 2; i++) {
        if (i < 1) continue;
        
        const candle1 = klines[i];
        const candle2 = klines[i + 1];
        const candle3 = klines[i + 2];
        
        // Bullish FVG: Gap between candle1 high and candle3 low
        if (candle3.low > candle1.high) {
            const gapHigh = candle3.low;
            const gapLow = candle1.high;
            const gapSize = gapHigh - gapLow;
            const gapPct = (gapSize / candle2.close) * 100;
            
            if (gapPct >= 0.1) { // Minimum gap size
                // Check if FVG has been filled
                let filled = false;
                let fillPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].low <= gapHigh) {
                        const fillAmount = gapHigh - Math.max(klines[j].low, gapLow);
                        fillPct = Math.min(100, (fillAmount / gapSize) * 100);
                        if (fillPct >= 100) {
                            filled = true;
                            break;
                        }
                    }
                }
                
                // Check if price is in the FVG zone
                const inZone = currentPrice >= gapLow && currentPrice <= gapHigh;
                
                if (!filled) {
                    bullishFVGs.push({
                        high: gapHigh,
                        low: gapLow,
                        price: (gapHigh + gapLow) / 2,
                        size: gapSize,
                        sizePct: gapPct,
                        index: i + 1,
                        time: candle2.time,
                        filled: filled,
                        fillPct: fillPct,
                        inZone: inZone
                    });
                }
            }
        }
        
        // Bearish FVG: Gap between candle1 low and candle3 high
        if (candle3.high < candle1.low) {
            const gapHigh = candle1.low;
            const gapLow = candle3.high;
            const gapSize = gapHigh - gapLow;
            const gapPct = (gapSize / candle2.close) * 100;
            
            if (gapPct >= 0.1) { // Minimum gap size
                // Check if FVG has been filled
                let filled = false;
                let fillPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].high >= gapLow) {
                        const fillAmount = Math.min(klines[j].high, gapHigh) - gapLow;
                        fillPct = Math.min(100, (fillAmount / gapSize) * 100);
                        if (fillPct >= 100) {
                            filled = true;
                            break;
                        }
                    }
                }
                
                // Check if price is in the FVG zone
                const inZone = currentPrice >= gapLow && currentPrice <= gapHigh;
                
                if (!filled) {
                    bearishFVGs.push({
                        high: gapHigh,
                        low: gapLow,
                        price: (gapHigh + gapLow) / 2,
                        size: gapSize,
                        sizePct: gapPct,
                        index: i + 1,
                        time: candle2.time,
                        filled: filled,
                        fillPct: fillPct,
                        inZone: inZone
                    });
                }
            }
        }
    }
    
    // Sort by proximity to current price
    bullishFVGs.sort((a, b) => Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price));
    bearishFVGs.sort((a, b) => Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price));
    
    return { bullish: bullishFVGs.slice(0, 5), bearish: bearishFVGs.slice(0, 5) };
}


// Detect Equal Highs and Equal Lows (Liquidity Pools)
function detectEqualLevels(klines, tolerance = 0.002) {
    if (!klines || klines.length < 50) return { equalHighs: [], equalLows: [] };
    
    const swings = findSwingPoints(klines, 4, 4);
    const equalHighs = [];
    const equalLows = [];
    
    // Find equal highs
    for (let i = 0; i < swings.highs.length; i++) {
        const matches = [swings.highs[i]];
        
        for (let j = i + 1; j < swings.highs.length; j++) {
            const pctDiff = Math.abs(swings.highs[i].price - swings.highs[j].price) / swings.highs[i].price;
            if (pctDiff <= tolerance) {
                matches.push(swings.highs[j]);
            }
        }
        
        if (matches.length >= 2) {
            const avgPrice = matches.reduce((sum, m) => sum + m.price, 0) / matches.length;
            // Check if not already added
            const exists = equalHighs.some(eh => Math.abs(eh.price - avgPrice) / avgPrice < tolerance);
            if (!exists) {
                equalHighs.push({
                    price: avgPrice,
                    count: matches.length,
                    indices: matches.map(m => m.index),
                    type: 'EQH'
                });
            }
        }
    }
    
    // Find equal lows
    for (let i = 0; i < swings.lows.length; i++) {
        const matches = [swings.lows[i]];
        
        for (let j = i + 1; j < swings.lows.length; j++) {
            const pctDiff = Math.abs(swings.lows[i].price - swings.lows[j].price) / swings.lows[i].price;
            if (pctDiff <= tolerance) {
                matches.push(swings.lows[j]);
            }
        }
        
        if (matches.length >= 2) {
            const avgPrice = matches.reduce((sum, m) => sum + m.price, 0) / matches.length;
            // Check if not already added
            const exists = equalLows.some(el => Math.abs(el.price - avgPrice) / avgPrice < tolerance);
            if (!exists) {
                equalLows.push({
                    price: avgPrice,
                    count: matches.length,
                    indices: matches.map(m => m.index),
                    type: 'EQL'
                });
            }
        }
    }
    
    return { equalHighs, equalLows };
}

// Detect Liquidity Sweep
function detectLiquiditySweep(klines, equalLevels) {
    if (!klines || klines.length < 5 || !equalLevels) return { detected: false };
    
    const len = klines.length;
    const lastCandle = klines[len - 1];
    const prevCandle = klines[len - 2];
    
    // Check sweep of equal highs (bullish reversal setup after sweep)
    for (const eqh of equalLevels.equalHighs) {
        // Wick above EQH but close below (sweep and reject)
        if (lastCandle.high > eqh.price && lastCandle.close < eqh.price && lastCandle.close < lastCandle.open) {
            const wickAbove = lastCandle.high - Math.max(lastCandle.open, lastCandle.close);
            const body = Math.abs(lastCandle.close - lastCandle.open);
            
            if (wickAbove > body * 0.5) {
                return {
                    detected: true,
                    direction: 'BEARISH', // Swept highs = bearish
                    type: 'SWEEP',
                    level: eqh.price,
                    sweepType: 'EQH',
                    significance: eqh.count >= 3 ? 'HIGH' : 'MEDIUM'
                };
            }
        }
    }
    
    // Check sweep of equal lows (bearish reversal setup after sweep)
    for (const eql of equalLevels.equalLows) {
        // Wick below EQL but close above (sweep and reject)
        if (lastCandle.low < eql.price && lastCandle.close > eql.price && lastCandle.close > lastCandle.open) {
            const wickBelow = Math.min(lastCandle.open, lastCandle.close) - lastCandle.low;
            const body = Math.abs(lastCandle.close - lastCandle.open);
            
            if (wickBelow > body * 0.5) {
                return {
                    detected: true,
                    direction: 'BULLISH', // Swept lows = bullish
                    type: 'SWEEP',
                    level: eql.price,
                    sweepType: 'EQL',
                    significance: eql.count >= 3 ? 'HIGH' : 'MEDIUM'
                };
            }
        }
    }
    
    return { detected: false };
}

// Get Premium/Discount Zones
function getPremiumDiscount(klines, lookback = 100) {
    if (!klines || klines.length < lookback) return null;
    
    const recent = klines.slice(-lookback);
    const high = Math.max(...recent.map(k => k.high));
    const low = Math.min(...recent.map(k => k.low));
    const range = high - low;
    const currentPrice = klines[klines.length - 1].close;
    
    const equilibrium = (high + low) / 2;
    const premium = high - range * 0.3;      // Top 30%
    const discount = low + range * 0.3;      // Bottom 30%
    
    let zone;
    if (currentPrice >= premium) zone = 'PREMIUM';
    else if (currentPrice <= discount) zone = 'DISCOUNT';
    else zone = 'EQUILIBRIUM';
    
    const percentFromEQ = ((currentPrice - equilibrium) / equilibrium) * 100;
    const positionPct = ((currentPrice - low) / range) * 100;
    
    return {
        high,
        low,
        equilibrium,
        premium,
        discount,
        currentPrice,
        zone,
        percentFromEQ,
        positionPct,
        favorsBuy: zone === 'DISCOUNT',
        favorsSell: zone === 'PREMIUM'
    };
}

// Detect Kill Zone (Trading Sessions)
function getKillZone() {
    const now = new Date();
    const utcHour = now.getUTCHours();
    
    const sessions = [
        { name: 'ASIA', start: 0, end: 3, color: '#06b6d4', active: false },
        { name: 'LONDON', start: 7, end: 10, color: '#a855f7', active: false },
        { name: 'NY_AM', start: 12, end: 15, color: '#f59e0b', active: false },
        { name: 'NY_PM', start: 15, end: 17, color: '#ef4444', active: false }
    ];
    
    for (const session of sessions) {
        if (utcHour >= session.start && utcHour < session.end) {
            return { ...session, active: true, bonus: session.name === 'LONDON' || session.name === 'NY_AM' ? 10 : 5 };
        }
    }
    
    return { name: 'OFF_SESSION', active: false, bonus: 0, color: '#64748b' };
}

// Signal State Machine
function getSignalState(bos, choch, ob, fvg, currentPrice) {
    // LOCKED: Clear trigger present (BOS or CHoCH)
    if (bos.detected || choch.detected) {
        // Check if we're in pullback to OB or FVG
        const direction = bos.detected ? bos.direction : choch.direction;
        
        if (direction === 'BULLISH') {
            // Check if price pulled back to bullish OB or FVG
            const nearOB = ob.bullish.length > 0 && 
                Math.abs(currentPrice - ob.bullish[0].price) / currentPrice < 0.01;
            const nearFVG = fvg.bullish.length > 0 && 
                (currentPrice >= fvg.bullish[0].low && currentPrice <= fvg.bullish[0].high);
            
            if (nearOB || nearFVG) {
                return { state: 'ENTRY', reason: nearOB ? 'At Bullish OB' : 'In Bullish FVG' };
            }
            return { state: 'PULLBACK', reason: 'Waiting for pullback to OB/FVG' };
        } else {
            // Check if price pulled back to bearish OB or FVG
            const nearOB = ob.bearish.length > 0 && 
                Math.abs(currentPrice - ob.bearish[0].price) / currentPrice < 0.01;
            const nearFVG = fvg.bearish.length > 0 && 
                (currentPrice >= fvg.bearish[0].low && currentPrice <= fvg.bearish[0].high);
            
            if (nearOB || nearFVG) {
                return { state: 'ENTRY', reason: nearOB ? 'At Bearish OB' : 'In Bearish FVG' };
            }
            return { state: 'PULLBACK', reason: 'Waiting for pullback to OB/FVG' };
        }
    }
    
    // FORMING: OB or FVG present but no trigger yet
    if (ob.bullish.length > 0 || ob.bearish.length > 0 || fvg.bullish.length > 0 || fvg.bearish.length > 0) {
        return { state: 'FORMING', reason: 'Waiting for BOS/CHoCH trigger' };
    }
    
    return { state: 'WAITING', reason: 'No setup detected' };
}

// MAIN SMC ANALYSIS FUNCTION
function performSMCAnalysis(klines, tf) {
    const result = {
        score: 0,
        direction: null,
        trigger: null,
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    
    // Get market structure
    const structure = detectStructure(klines);
    result.details.structure = structure;
    result.details.trend = structure.trend;
    
    // Detect BOS
    const bos = detectBOS(klines, structure);
    result.details.bos = bos;
    
    // Detect CHoCH
    const choch = detectCHoCH(klines, structure);
    result.details.choch = choch;
    
    // Detect Order Blocks
    const orderBlocks = detectOrderBlocks(klines);
    result.details.orderBlocks = orderBlocks;
    
    // Detect Breaker Blocks
    const breakerBlocks = detectBreakerBlocks(klines, orderBlocks);
    result.details.breakerBlocks = breakerBlocks;
    
    // Detect FVG
    const fvg = detectFVG(klines);
    result.details.fvg = fvg;
    
    // Detect Equal Levels
    const equalLevels = detectEqualLevels(klines);
    result.details.equalLevels = equalLevels;
    
    // Detect Liquidity Sweep
    const sweep = detectLiquiditySweep(klines, equalLevels);
    result.details.sweep = sweep;
    
    // Get Premium/Discount
    const pdZone = getPremiumDiscount(klines);
    result.details.pdZone = pdZone;
    
    // Get Kill Zone
    const killZone = getKillZone();
    result.details.killZone = killZone;
    
    // Get Signal State
    const signalState = getSignalState(bos, choch, orderBlocks, fvg, currentPrice);
    result.details.signalState = signalState;
    
    // SCORING
    let score = 0;
    let bullScore = 0;
    let bearScore = 0;
    
    // Structure trend (10 points)
    if (structure.trend === 'BULLISH') {
        bullScore += 10;
        result.factors.push('Bullish Structure');
    } else if (structure.trend === 'BEARISH') {
        bearScore += 10;
        result.factors.push('Bearish Structure');
    }
    
    // BOS (25 points)
    if (bos.detected) {
        if (bos.direction === 'BULLISH') {
            bullScore += 25;
            result.factors.push('BOS↑');
            if (bos.strength === 'STRONG') {
                bullScore += 5;
                result.factors.push('Strong BOS');
            }
        } else {
            bearScore += 25;
            result.factors.push('BOS↓');
            if (bos.strength === 'STRONG') {
                bearScore += 5;
                result.factors.push('Strong BOS');
            }
        }
        result.trigger = 'BOS';
    }
    
    // CHoCH (30 points - stronger signal)
    if (choch.detected) {
        if (choch.direction === 'BULLISH') {
            bullScore += 30;
            result.factors.push('CHoCH↑');
        } else {
            bearScore += 30;
            result.factors.push('CHoCH↓');
        }
        result.trigger = result.trigger ? result.trigger + '+CHoCH' : 'CHoCH';
    }
    
    // Order Blocks (15 points)
    if (orderBlocks.bullish.length > 0) {
        const nearestOB = orderBlocks.bullish[0];
        const distance = Math.abs(currentPrice - nearestOB.price) / currentPrice;
        if (distance < 0.01) {
            bullScore += 15;
            result.factors.push(nearestOB.fresh ? 'Fresh Bull OB' : 'Bull OB');
        } else if (distance < 0.02) {
            bullScore += 8;
        }
    }
    if (orderBlocks.bearish.length > 0) {
        const nearestOB = orderBlocks.bearish[0];
        const distance = Math.abs(currentPrice - nearestOB.price) / currentPrice;
        if (distance < 0.01) {
            bearScore += 15;
            result.factors.push(nearestOB.fresh ? 'Fresh Bear OB' : 'Bear OB');
        } else if (distance < 0.02) {
            bearScore += 8;
        }
    }
    
    // Breaker Blocks (12 points)
    if (breakerBlocks.bullish.length > 0) {
        const distance = Math.abs(currentPrice - breakerBlocks.bullish[0].price) / currentPrice;
        if (distance < 0.015) {
            bullScore += 12;
            result.factors.push('Bull Breaker');
        }
    }
    if (breakerBlocks.bearish.length > 0) {
        const distance = Math.abs(currentPrice - breakerBlocks.bearish[0].price) / currentPrice;
        if (distance < 0.015) {
            bearScore += 12;
            result.factors.push('Bear Breaker');
        }
    }
    
    // FVG (10 points)
    if (fvg.bullish.length > 0 && fvg.bullish[0].inZone) {
        bullScore += 10;
        result.factors.push('In Bull FVG');
    }
    if (fvg.bearish.length > 0 && fvg.bearish[0].inZone) {
        bearScore += 10;
        result.factors.push('In Bear FVG');
    }
    
    // Liquidity Sweep (15 points)
    if (sweep.detected) {
        if (sweep.direction === 'BULLISH') {
            bullScore += sweep.significance === 'HIGH' ? 18 : 12;
            result.factors.push('Liq Sweep↑');
        } else {
            bearScore += sweep.significance === 'HIGH' ? 18 : 12;
            result.factors.push('Liq Sweep↓');
        }
        result.trigger = result.trigger ? result.trigger + '+Sweep' : 'Sweep';
    }
    
    // Premium/Discount (10 points)
    if (pdZone) {
        if (pdZone.zone === 'DISCOUNT') {
            bullScore += 10;
            result.factors.push('Discount Zone');
        } else if (pdZone.zone === 'PREMIUM') {
            bearScore += 10;
            result.factors.push('Premium Zone');
        }
    }
    
    // Kill Zone bonus
    if (killZone.active) {
        score += killZone.bonus;
        result.factors.push(killZone.name + ' Session');
    }
    
    // Determine direction and final score
    if (bullScore > bearScore + 10) {
        result.direction = 'LONG';
        score += bullScore;
    } else if (bearScore > bullScore + 10) {
        result.direction = 'SHORT';
        score += bearScore;
    } else {
        // Mixed signals
        score += Math.max(bullScore, bearScore) * 0.5;
        result.warnings.push('Mixed SMC signals');
    }
    
    // Signal state bonus/penalty
    if (signalState.state === 'ENTRY') {
        score += 10;
        result.factors.push(signalState.reason);
    } else if (signalState.state === 'FORMING') {
        result.warnings.push(signalState.reason);
    }
    
    result.score = Math.min(100, Math.max(0, Math.round(score)));
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF PART 2 - SMC Analysis Complete
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// CANDLE PATTERN DETECTION ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

function analyzeCandlePatterns(klines) {
    if (!klines || klines.length < 10) {
        return { patterns: [], currentCandle: null, behavior: null, strength: 0 };
    }
    
    const result = {
        patterns: [],
        currentCandle: null,
        behavior: null,
        strength: 0,
        control: 'NEUTRAL',
        factors: []
    };
    
    // Get recent candles
    const candles = klines.slice(-10);
    const current = candles[candles.length - 1];
    const prev = candles[candles.length - 2];
    const prev2 = candles[candles.length - 3];
    
    // Calculate candle metrics
    const calcCandleMetrics = (c) => {
        const range = c.high - c.low;
        const body = Math.abs(c.close - c.open);
        const upperWick = c.high - Math.max(c.close, c.open);
        const lowerWick = Math.min(c.close, c.open) - c.low;
        const isBullish = c.close > c.open;
        
        return {
            range,
            body,
            bodyPercent: range > 0 ? (body / range) * 100 : 0,
            upperWick,
            lowerWick,
            upperWickPercent: range > 0 ? (upperWick / range) * 100 : 0,
            lowerWickPercent: range > 0 ? (lowerWick / range) * 100 : 0,
            isBullish,
            isBearish: !isBullish && c.close !== c.open
        };
    };
    
    const cm = calcCandleMetrics(current);
    const pm = calcCandleMetrics(prev);
    
    // Current candle analysis
    result.currentCandle = {
        type: 'Unknown',
        bodyPercent: Math.round(cm.bodyPercent || 0),
        upperWickPercent: Math.round(cm.upperWickPercent || 0),
        lowerWickPercent: Math.round(cm.lowerWickPercent || 0),
        isBullish: cm.isBullish,
        behavior: ''
    };
    
    // Calculate average volume - FIXED: Safe calculation
    const volumes = candles.map(c => c?.volume || 0).filter(v => v > 0);
    const avgVolume = volumes.length > 0 ? volumes.reduce((a, b) => a + b, 0) / volumes.length : 1;
    const volumeRatio = avgVolume > 0 ? (current?.volume || 0) / avgVolume : 1;
    result.currentCandle.volumeRatio = isNaN(volumeRatio) ? 1 : Math.round(volumeRatio * 10) / 10;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // PATTERN DETECTION
    // ═══════════════════════════════════════════════════════════════════════════
    
    // 1. DOJI - Small body, indecision
    const isDoji = cm.bodyPercent < 10;
    if (isDoji) {
        result.patterns.push({ 
            name: 'Doji', 
            signal: 'NEUTRAL', 
            strength: 'Medium',
            meaning: 'Indecision - trend may pause or reverse'
        });
        result.currentCandle.type = 'Doji';
    }
    
    // 2. HAMMER / HANGING MAN - Long lower wick at bottom
    const isHammer = cm.lowerWickPercent > 60 && cm.upperWickPercent < 15 && cm.bodyPercent < 35;
    if (isHammer) {
        // Hammer at support = bullish, at resistance = bearish (hanging man)
        result.patterns.push({ 
            name: cm.isBullish ? 'Hammer' : 'Hanging Man', 
            signal: 'BULLISH', 
            strength: 'High',
            meaning: 'Buyers rejected lower prices - potential reversal up'
        });
        result.currentCandle.type = cm.isBullish ? 'Hammer' : 'Hanging Man';
    }
    
    // 3. SHOOTING STAR / INVERTED HAMMER - Long upper wick at top
    const isShootingStar = cm.upperWickPercent > 60 && cm.lowerWickPercent < 15 && cm.bodyPercent < 35;
    if (isShootingStar) {
        result.patterns.push({ 
            name: cm.isBullish ? 'Inverted Hammer' : 'Shooting Star', 
            signal: 'BEARISH', 
            strength: 'High',
            meaning: 'Sellers rejected higher prices - potential reversal down'
        });
        result.currentCandle.type = cm.isBullish ? 'Inverted Hammer' : 'Shooting Star';
    }
    
    // 4. BULLISH ENGULFING
    const isBullishEngulfing = cm.isBullish && pm.isBearish && 
        current.close > prev.open && current.open < prev.close &&
        cm.body > pm.body;
    if (isBullishEngulfing) {
        result.patterns.push({ 
            name: 'Bullish Engulfing', 
            signal: 'BULLISH', 
            strength: 'Very High',
            meaning: 'Strong buying pressure - buyers overwhelmed sellers'
        });
        result.currentCandle.type = 'Bullish Engulfing';
        result.strength += 25;
    }
    
    // 5. BEARISH ENGULFING
    const isBearishEngulfing = cm.isBearish && pm.isBullish && 
        current.close < prev.open && current.open > prev.close &&
        cm.body > pm.body;
    if (isBearishEngulfing) {
        result.patterns.push({ 
            name: 'Bearish Engulfing', 
            signal: 'BEARISH', 
            strength: 'Very High',
            meaning: 'Strong selling pressure - sellers overwhelmed buyers'
        });
        result.currentCandle.type = 'Bearish Engulfing';
        result.strength += 25;
    }
    
    // 6. MORNING STAR (3 candle bullish reversal)
    if (candles.length >= 3) {
        const pm2 = calcCandleMetrics(prev2);
        const isMorningStar = pm2.isBearish && pm2.bodyPercent > 50 && // Strong red
            pm.bodyPercent < 30 && // Small body (star)
            cm.isBullish && cm.bodyPercent > 50 && // Strong green
            current.close > (prev2.open + prev2.close) / 2;
        if (isMorningStar) {
            result.patterns.push({ 
                name: 'Morning Star', 
                signal: 'BULLISH', 
                strength: 'Very High',
                meaning: 'Major bullish reversal - high probability long'
            });
            result.strength += 30;
        }
    }
    
    // 7. EVENING STAR (3 candle bearish reversal)
    if (candles.length >= 3) {
        const pm2 = calcCandleMetrics(prev2);
        const isEveningStar = pm2.isBullish && pm2.bodyPercent > 50 && // Strong green
            pm.bodyPercent < 30 && // Small body (star)
            cm.isBearish && cm.bodyPercent > 50 && // Strong red
            current.close < (prev2.open + prev2.close) / 2;
        if (isEveningStar) {
            result.patterns.push({ 
                name: 'Evening Star', 
                signal: 'BEARISH', 
                strength: 'Very High',
                meaning: 'Major bearish reversal - high probability short'
            });
            result.strength += 30;
        }
    }
    
    // 8. INSIDE BAR - Consolidation, breakout coming
    const isInsideBar = current.high < prev.high && current.low > prev.low;
    if (isInsideBar) {
        result.patterns.push({ 
            name: 'Inside Bar', 
            signal: 'NEUTRAL', 
            strength: 'Medium',
            meaning: 'Consolidation - breakout expected soon'
        });
        result.currentCandle.type = 'Inside Bar';
    }
    
    // 9. PIN BAR - Rejection candle
    const isPinBar = (cm.upperWickPercent > 65 || cm.lowerWickPercent > 65) && cm.bodyPercent < 25;
    if (isPinBar && !isHammer && !isShootingStar) {
        const pinSignal = cm.lowerWickPercent > cm.upperWickPercent ? 'BULLISH' : 'BEARISH';
        result.patterns.push({ 
            name: 'Pin Bar', 
            signal: pinSignal, 
            strength: 'High',
            meaning: pinSignal === 'BULLISH' ? 'Strong rejection of lows' : 'Strong rejection of highs'
        });
        result.currentCandle.type = 'Pin Bar';
        result.strength += 20;
    }
    
    // 10. MARUBOZU - Full body, strong momentum
    const isMarubozu = cm.bodyPercent > 85 && cm.upperWickPercent < 8 && cm.lowerWickPercent < 8;
    if (isMarubozu) {
        result.patterns.push({ 
            name: cm.isBullish ? 'Bullish Marubozu' : 'Bearish Marubozu', 
            signal: cm.isBullish ? 'BULLISH' : 'BEARISH', 
            strength: 'Very High',
            meaning: cm.isBullish ? 'Extreme buying pressure - no resistance' : 'Extreme selling pressure - no support'
        });
        result.currentCandle.type = cm.isBullish ? 'Bullish Marubozu' : 'Bearish Marubozu';
        result.strength += 25;
    }
    
    // 11. TWEEZER TOP/BOTTOM
    const isTweezerBottom = Math.abs(current.low - prev.low) / current.low < 0.001 && cm.isBullish && pm.isBearish;
    const isTweezerTop = Math.abs(current.high - prev.high) / current.high < 0.001 && cm.isBearish && pm.isBullish;
    if (isTweezerBottom) {
        result.patterns.push({ 
            name: 'Tweezer Bottom', 
            signal: 'BULLISH', 
            strength: 'High',
            meaning: 'Double rejection at support - reversal likely'
        });
        result.strength += 20;
    }
    if (isTweezerTop) {
        result.patterns.push({ 
            name: 'Tweezer Top', 
            signal: 'BEARISH', 
            strength: 'High',
            meaning: 'Double rejection at resistance - reversal likely'
        });
        result.strength += 20;
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // BEHAVIOR ANALYSIS
    // ═══════════════════════════════════════════════════════════════════════════
    
    // Determine who's in control (last 3 candles)
    let bullishCandles = 0;
    let bearishCandles = 0;
    let totalBullishBody = 0;
    let totalBearishBody = 0;
    
    for (let i = candles.length - 3; i < candles.length; i++) {
        if (i >= 0) {
            const c = candles[i];
            if (c.close > c.open) {
                bullishCandles++;
                totalBullishBody += c.close - c.open;
            } else {
                bearishCandles++;
                totalBearishBody += c.open - c.close;
            }
        }
    }
    
    if (bullishCandles > bearishCandles && totalBullishBody > totalBearishBody) {
        result.control = 'BUYERS';
        result.controlBuyers = true;
        result.controlSellers = false;
    } else if (bearishCandles > bullishCandles && totalBearishBody > totalBullishBody) {
        result.control = 'SELLERS';
        result.controlBuyers = false;
        result.controlSellers = true;
    } else {
        result.control = 'CONTESTED';
        result.controlBuyers = false;
        result.controlSellers = false;
    }
    
    // Momentum direction
    let momentum = 'NEUTRAL';
    const bodyTrend = [];
    for (let i = candles.length - 5; i < candles.length; i++) {
        if (i >= 0) {
            const c = candles[i];
            bodyTrend.push(Math.abs(c.close - c.open));
        }
    }
    if (bodyTrend.length >= 3) {
        const recentAvg = bodyTrend.slice(-2).reduce((a, b) => a + b, 0) / 2;
        const olderAvg = bodyTrend.slice(0, 2).reduce((a, b) => a + b, 0) / 2;
        if (recentAvg > olderAvg * 1.2) momentum = 'INCREASING';
        else if (recentAvg < olderAvg * 0.8) momentum = 'DECREASING';
    }
    
    // Check for exhaustion
    let exhaustionSigns = [];
    if (isDoji && volumeRatio > 1.5) exhaustionSigns.push('Doji on high volume');
    if (cm.upperWickPercent > 50 && cm.isBullish) exhaustionSigns.push('Long upper wick on green');
    if (cm.lowerWickPercent > 50 && cm.isBearish) exhaustionSigns.push('Long lower wick on red');
    
    // Check for trap potential
    let trapPotential = 'LOW';
    if (isShootingStar && volumeRatio < 0.7) trapPotential = 'HIGH - Low volume rejection';
    if (isBullishEngulfing && volumeRatio < 0.8) trapPotential = 'MEDIUM - Engulfing on weak volume';
    
    // Build behavior object
    result.behavior = {
        control: result.control,
        momentum: momentum,
        exhaustionSigns: exhaustionSigns.length > 0 ? exhaustionSigns : ['None detected'],
        trapPotential: trapPotential,
        volumeConfirmation: volumeRatio > 1.2 ? 'STRONG' : volumeRatio > 0.8 ? 'NORMAL' : 'WEAK'
    };
    
    // Current candle behavior text
    if (cm.isBullish && cm.bodyPercent > 60) {
        result.currentCandle.behavior = 'Aggressive buying, strong conviction';
    } else if (cm.isBearish && cm.bodyPercent > 60) {
        result.currentCandle.behavior = 'Aggressive selling, strong conviction';
    } else if (cm.lowerWickPercent > 40) {
        result.currentCandle.behavior = 'Buyers absorbed selling pressure';
    } else if (cm.upperWickPercent > 40) {
        result.currentCandle.behavior = 'Sellers absorbed buying pressure';
    } else if (isDoji) {
        result.currentCandle.behavior = 'Indecision, equilibrium between buyers and sellers';
    } else {
        result.currentCandle.behavior = cm.isBullish ? 'Mild buying pressure' : 'Mild selling pressure';
    }
    
    // Set default type if none detected
    if (result.currentCandle.type === 'Unknown') {
        if (cm.isBullish && cm.bodyPercent > 60) result.currentCandle.type = 'Strong Bullish';
        else if (cm.isBearish && cm.bodyPercent > 60) result.currentCandle.type = 'Strong Bearish';
        else if (cm.isBullish) result.currentCandle.type = 'Bullish';
        else if (cm.isBearish) result.currentCandle.type = 'Bearish';
        else result.currentCandle.type = 'Neutral';
    }
    
    // Calculate overall pattern strength
    const patternCount = result.patterns.length;
    const bullishPatterns = result.patterns.filter(p => p.signal === 'BULLISH').length;
    const bearishPatterns = result.patterns.filter(p => p.signal === 'BEARISH').length;
    
    result.patternSignal = bullishPatterns > bearishPatterns ? 'BULLISH' : 
                           bearishPatterns > bullishPatterns ? 'BEARISH' : 'NEUTRAL';
    
    // Strength score (0-100)
    result.strength = Math.min(100, result.strength + (patternCount * 10) + (volumeRatio > 1.2 ? 15 : 0));
    
    // Add factors for display
    if (result.patterns.length > 0) {
        result.factors = result.patterns.map(p => p.name + ' (' + p.signal + ')');
    }
    
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// V1 ULTIMATE - NEW ENGINES (Sequence, Pattern-at-Level, Rejection Score)
// ═══════════════════════════════════════════════════════════════════════════════

// SEQUENCE VALIDATOR - Checks if signal follows proper SMC sequence
// FIX #1: Added direction parameter to filter zones/OBs/FVGs by signal direction
function validateSequence(smcData, zoneData, candlePatterns, klines, direction) {
    const result = {
        steps: {
            sweep: false,
            bos: false,
            fvg: false,
            ob: false,
            pullback: false,
            pattern: false
        },
        completed: 0,
        total: 6,
        score: 0,
        state: 'NEUTRAL',
        quality: 'WEAK',
        details: []
    };
    
    const smcD = smcData.details || {};
    const currentPrice = klines[klines.length - 1].close;
    
    // Step 1: Check for Liquidity Sweep
    if (smcD.liquidityData && (smcD.liquidityData.recentSweep || smcD.liquidityData.sweepCount > 0)) {
        result.steps.sweep = true;
        result.details.push('✅ Sweep: Liquidity taken');
    }
    
    // Step 2: Check for BOS/CHoCH
    if (smcD.structure && (smcD.structure.bos || smcD.structure.choch)) {
        result.steps.bos = true;
        result.details.push('✅ BOS/CHoCH: Structure confirmed');
    }
    
    // Step 3: Check for FVG (direction-appropriate ONLY)
    const fvgData = smcD.fvg || {};
    let hasFVG = false;
    if (direction === 'LONG' && fvgData.bullish && fvgData.bullish.length > 0) {
        hasFVG = true;
        result.details.push('✅ FVG: Bullish imbalance detected');
    } else if (direction === 'SHORT' && fvgData.bearish && fvgData.bearish.length > 0) {
        hasFVG = true;
        result.details.push('✅ FVG: Bearish imbalance detected');
    } else if ((fvgData.bullish && fvgData.bullish.length > 0) || (fvgData.bearish && fvgData.bearish.length > 0)) {
        // FIX: Wrong direction FVG = NO step credit (hasFVG stays false)
        result.details.push('❌ FVG: Found but OPPOSITE direction (no credit)');
    }
    if (hasFVG) {
        result.steps.fvg = true;
    }
    
    // Step 4: Check for Order Block (direction-appropriate ONLY)
    const obData = smcD.orderBlocks || {};
    let hasOB = false;
    if (direction === 'LONG' && obData.bullish && obData.bullish.length > 0) {
        hasOB = true;
        result.details.push('✅ OB: Bullish Order Block identified');
    } else if (direction === 'SHORT' && obData.bearish && obData.bearish.length > 0) {
        hasOB = true;
        result.details.push('✅ OB: Bearish Order Block identified');
    } else if ((obData.bullish && obData.bullish.length > 0) || (obData.bearish && obData.bearish.length > 0)) {
        // FIX: Wrong direction OB = NO step credit (hasOB stays false)
        result.details.push('❌ OB: Found but OPPOSITE direction (no credit)');
    }
    if (hasOB) {
        result.steps.ob = true;
    }
    
    // Step 5: Check if price pulled back to DIRECTION-APPROPRIATE POI
    const zoneD = zoneData.details || {};
    let atCorrectZone = false;
    let atOB = false;
    let atFVG = false;
    let poiType = '';
    
    // For LONG: Check support zones, bullish OBs, bullish FVGs
    // For SHORT: Check resistance zones, bearish OBs, bearish FVGs
    if (direction === 'LONG') {
        // Check support zone
        if (zoneD.nearestSupport) {
            const distPct = Math.abs(currentPrice - zoneD.nearestSupport.price) / currentPrice;
            if (distPct < 0.015) {
                atCorrectZone = true;
                poiType = 'Support';
            }
        }
        // Check bullish OB
        if (obData.bullish && obData.bullish.length > 0) {
            atOB = obData.bullish.some(ob => currentPrice >= ob.low && currentPrice <= ob.high * 1.005);
            if (atOB) poiType = 'Bullish OB';
        }
        // Check bullish FVG
        if (fvgData.bullish && fvgData.bullish.length > 0) {
            atFVG = fvgData.bullish.some(fvg => currentPrice >= fvg.low && currentPrice <= fvg.high * 1.005);
            if (atFVG) poiType = 'Bullish FVG';
        }
    } else if (direction === 'SHORT') {
        // Check resistance zone
        if (zoneD.nearestResistance) {
            const distPct = Math.abs(currentPrice - zoneD.nearestResistance.price) / currentPrice;
            if (distPct < 0.015) {
                atCorrectZone = true;
                poiType = 'Resistance';
            }
        }
        // Check bearish OB
        if (obData.bearish && obData.bearish.length > 0) {
            atOB = obData.bearish.some(ob => currentPrice >= ob.low * 0.995 && currentPrice <= ob.high);
            if (atOB) poiType = 'Bearish OB';
        }
        // Check bearish FVG
        if (fvgData.bearish && fvgData.bearish.length > 0) {
            atFVG = fvgData.bearish.some(fvg => currentPrice >= fvg.low * 0.995 && currentPrice <= fvg.high);
            if (atFVG) poiType = 'Bearish FVG';
        }
    }
    
    if (atCorrectZone || atOB || atFVG) {
        result.steps.pullback = true;
        result.details.push(`✅ Pullback: Price at ${poiType}`);
    } else {
        result.details.push(`❌ Pullback: Price not at ${direction === 'LONG' ? 'support/bullish' : 'resistance/bearish'} POI`);
    }
    
    // Step 6: Check for Pattern at Level
    if (candlePatterns && candlePatterns.patterns && candlePatterns.patterns.length > 0) {
        if (result.steps.pullback) {
            result.steps.pattern = true;
            result.details.push('✅ Pattern: Confirmation at POI');
        } else {
            result.details.push('⚠️ Pattern: Found but NOT at POI');
        }
    }
    
    // Calculate completion
    result.completed = Object.values(result.steps).filter(Boolean).length;
    
    // Calculate score (0-100)
    result.score = Math.round((result.completed / result.total) * 100);
    
    // Determine state
    if (result.completed >= 5) {
        result.state = 'ENTRY_READY';
        result.quality = 'PERFECT';
    } else if (result.completed >= 4) {
        result.state = 'PATTERN_CONFIRMED';
        result.quality = 'STRONG';
    } else if (result.completed >= 3) {
        result.state = 'PULLBACK_TO_POI';
        result.quality = 'VALID';
    } else if (result.completed >= 2) {
        result.state = 'POI_IDENTIFIED';
        result.quality = 'DEVELOPING';
    } else {
        result.state = 'FORMING';
        result.quality = 'WEAK';
    }
    
    return result;
}

// PATTERN-AT-LEVEL - Checks if pattern is at a significant level
// FIX #2: Added direction parameter to only check direction-appropriate levels
function checkPatternAtLevel(candlePatterns, zoneData, smcData, currentPrice, direction) {
    const result = {
        atLevel: false,
        levelType: 'NONE',
        levelPrice: null,
        distance: 999,
        distancePercent: 999,
        bonus: 0,
        details: ''
    };
    
    if (!candlePatterns || !candlePatterns.patterns || candlePatterns.patterns.length === 0) {
        result.details = 'No pattern detected';
        return result;
    }
    
    const zoneD = zoneData.details || {};
    const smcD = smcData.details || {};
    const levels = [];
    const obData = smcD.orderBlocks || {};
    const fvgData = smcD.fvg || {};
    
    // Collect DIRECTION-APPROPRIATE levels only
    if (direction === 'LONG') {
        // For LONG: Support zones, Bullish OBs, Bullish FVGs
        if (zoneD.nearestSupport) {
            levels.push({ type: 'SUPPORT', price: zoneD.nearestSupport.price, strength: zoneD.nearestSupport.strength || 50 });
        }
        if (obData.bullish) {
            obData.bullish.forEach(ob => {
                levels.push({ type: 'BULLISH_OB', price: (ob.high + ob.low) / 2, high: ob.high, low: ob.low, strength: 70 });
            });
        }
        if (fvgData.bullish) {
            fvgData.bullish.forEach(fvg => {
                levels.push({ type: 'BULLISH_FVG', price: (fvg.high + fvg.low) / 2, high: fvg.high, low: fvg.low, strength: 60 });
            });
        }
    } else if (direction === 'SHORT') {
        // For SHORT: Resistance zones, Bearish OBs, Bearish FVGs
        if (zoneD.nearestResistance) {
            levels.push({ type: 'RESISTANCE', price: zoneD.nearestResistance.price, strength: zoneD.nearestResistance.strength || 50 });
        }
        if (obData.bearish) {
            obData.bearish.forEach(ob => {
                levels.push({ type: 'BEARISH_OB', price: (ob.high + ob.low) / 2, high: ob.high, low: ob.low, strength: 70 });
            });
        }
        if (fvgData.bearish) {
            fvgData.bearish.forEach(fvg => {
                levels.push({ type: 'BEARISH_FVG', price: (fvg.high + fvg.low) / 2, high: fvg.high, low: fvg.low, strength: 60 });
            });
        }
    }
    
    // If no direction-appropriate levels found, return early
    if (levels.length === 0) {
        result.details = `No ${direction === 'LONG' ? 'support/bullish' : 'resistance/bearish'} levels found`;
        return result;
    }
    
    // Find closest level
    let closestLevel = null;
    let closestDist = Infinity;
    
    for (const level of levels) {
        let dist;
        if (level.high && level.low) {
            // For ranges (OB, FVG), check if price is within range
            if (currentPrice >= level.low && currentPrice <= level.high) {
                dist = 0;
            } else {
                dist = Math.min(
                    Math.abs(currentPrice - level.high),
                    Math.abs(currentPrice - level.low)
                );
            }
        } else {
            dist = Math.abs(currentPrice - level.price);
        }
        
        if (dist < closestDist) {
            closestDist = dist;
            closestLevel = level;
        }
    }
    
    if (closestLevel) {
        result.levelType = closestLevel.type;
        result.levelPrice = closestLevel.price;
        result.distance = closestDist;
        result.distancePercent = (closestDist / currentPrice) * 100;
        
        // Determine if "at level" (within 0.5%)
        if (result.distancePercent <= 0.5) {
            result.atLevel = true;
            result.bonus = 25;
            result.details = `Pattern AT ${closestLevel.type} (${result.distancePercent.toFixed(2)}%)`;
        } else if (result.distancePercent <= 1.0) {
            result.atLevel = true;
            result.bonus = 15;
            result.details = `Pattern CLOSE to ${closestLevel.type} (${result.distancePercent.toFixed(2)}%)`;
        } else if (result.distancePercent <= 1.5) {
            result.bonus = 5;
            result.details = `Pattern NEAR ${closestLevel.type} (${result.distancePercent.toFixed(2)}%)`;
        } else {
            result.details = `Pattern FAR from levels (${result.distancePercent.toFixed(2)}%)`;
        }
    }
    
    return result;
}

// REJECTION SCORE - Rates quality of price rejection at level
function calculateRejectionScore(klines, zoneData, smcData, direction) {
    const result = {
        score: 0,
        breakdown: {
            wickTouch: 0,
            bodyClosed: 0,
            wickRatio: 0,
            volumeConfirm: 0,
            followThrough: 0
        },
        quality: 'NONE',
        details: []
    };
    
    if (!klines || klines.length < 3) return result;
    
    const current = klines[klines.length - 1];
    const prev = klines[klines.length - 2];
    const zoneD = zoneData.details || {};
    const smcD = smcData.details || {};
    
    // Get target level based on direction
    let targetLevel = null;
    if (direction === 'LONG') {
        if (zoneD.nearestSupport) targetLevel = zoneD.nearestSupport.price;
        const obData = smcD.orderBlocks || {};
        if (obData.bullish && obData.bullish.length > 0) {
            const obLevel = obData.bullish[0].low;
            if (!targetLevel || Math.abs(current.close - obLevel) < Math.abs(current.close - targetLevel)) {
                targetLevel = obLevel;
            }
        }
    } else if (direction === 'SHORT') {
        if (zoneD.nearestResistance) targetLevel = zoneD.nearestResistance.price;
        const obData = smcD.orderBlocks || {};
        if (obData.bearish && obData.bearish.length > 0) {
            const obLevel = obData.bearish[0].high;
            if (!targetLevel || Math.abs(current.close - obLevel) < Math.abs(current.close - targetLevel)) {
                targetLevel = obLevel;
            }
        }
    }
    
    if (!targetLevel) {
        result.details.push('No target level found');
        return result;
    }
    
    const distanceToLevel = Math.abs(current.close - targetLevel) / targetLevel * 100;
    
    // 1. WICK TOUCH (max 30 points) - Proximity based
    const wickTouchLevel = direction === 'LONG' ? current.low : current.high;
    const wickDistance = Math.abs(wickTouchLevel - targetLevel) / targetLevel * 100;
    
    if (wickDistance <= 0.1) {
        result.breakdown.wickTouch = 30;
        result.details.push('Wick touched level exactly (+30)');
    } else if (wickDistance <= 0.3) {
        result.breakdown.wickTouch = 25;
        result.details.push('Wick very close to level (+25)');
    } else if (wickDistance <= 0.5) {
        result.breakdown.wickTouch = 20;
        result.details.push('Wick near level (+20)');
    } else if (wickDistance <= 1.0) {
        result.breakdown.wickTouch = 10;
        result.details.push('Wick approaching level (+10)');
    }
    
    // 2. BODY CLOSED (max 25 points)
    if (direction === 'LONG' && current.close > current.open && current.close > targetLevel) {
        result.breakdown.bodyClosed = 25;
        result.details.push('Body closed bullish above level (+25)');
    } else if (direction === 'SHORT' && current.close < current.open && current.close < targetLevel) {
        result.breakdown.bodyClosed = 25;
        result.details.push('Body closed bearish below level (+25)');
    } else if (direction === 'LONG' && current.close > current.open) {
        result.breakdown.bodyClosed = 15;
        result.details.push('Body closed bullish (+15)');
    } else if (direction === 'SHORT' && current.close < current.open) {
        result.breakdown.bodyClosed = 15;
        result.details.push('Body closed bearish (+15)');
    }
    
    // 3. WICK RATIO (max 20 points)
    const bodySize = Math.abs(current.close - current.open);
    const upperWick = current.high - Math.max(current.open, current.close);
    const lowerWick = Math.min(current.open, current.close) - current.low;
    const relevantWick = direction === 'LONG' ? lowerWick : upperWick;
    const wickRatio = bodySize > 0 ? relevantWick / bodySize : 0;
    
    if (wickRatio > 2) {
        result.breakdown.wickRatio = 20;
        result.details.push('Strong wick ratio >2x (+20)');
    } else if (wickRatio > 1.5) {
        result.breakdown.wickRatio = 15;
        result.details.push('Good wick ratio >1.5x (+15)');
    } else if (wickRatio > 1) {
        result.breakdown.wickRatio = 10;
        result.details.push('Moderate wick ratio >1x (+10)');
    }
    
    // 4. VOLUME CONFIRMATION (max 15 points) - FIXED: Safe calculation
    const volSlice = klines.slice(-20).filter(k => k?.volume > 0);
    const avgVolume = volSlice.length > 0 ? volSlice.reduce((sum, k) => sum + k.volume, 0) / volSlice.length : 1;
    const volumeRatio = avgVolume > 0 ? ((current?.volume || 0) / avgVolume) : 1;
    
    if (!isNaN(volumeRatio) && volumeRatio > 1.5) {
        result.breakdown.volumeConfirm = 15;
        result.details.push('High volume confirmation (+15)');
    } else if (volumeRatio > 1.2) {
        result.breakdown.volumeConfirm = 10;
        result.details.push('Good volume (+10)');
    } else if (volumeRatio > 1.0) {
        result.breakdown.volumeConfirm = 5;
        result.details.push('Normal volume (+5)');
    }
    
    // 5. FOLLOW THROUGH (max 10 points) - Check previous candle direction
    const prevDirection = prev.close > prev.open ? 'BULLISH' : 'BEARISH';
    const currDirection = current.close > current.open ? 'BULLISH' : 'BEARISH';
    
    if (direction === 'LONG' && currDirection === 'BULLISH' && prevDirection === 'BEARISH') {
        result.breakdown.followThrough = 10;
        result.details.push('Reversal follow-through (+10)');
    } else if (direction === 'SHORT' && currDirection === 'BEARISH' && prevDirection === 'BULLISH') {
        result.breakdown.followThrough = 10;
        result.details.push('Reversal follow-through (+10)');
    } else if ((direction === 'LONG' && currDirection === 'BULLISH') || 
               (direction === 'SHORT' && currDirection === 'BEARISH')) {
        result.breakdown.followThrough = 5;
        result.details.push('Directional alignment (+5)');
    }
    
    // Calculate total
    result.score = Object.values(result.breakdown).reduce((sum, v) => sum + v, 0);
    
    // Determine quality
    if (result.score >= 80) result.quality = 'PERFECT';
    else if (result.score >= 60) result.quality = 'STRONG';
    else if (result.score >= 40) result.quality = 'MODERATE';
    else if (result.score >= 20) result.quality = 'WEAK';
    else result.quality = 'NONE';
    
    return result;
}

// ZONE OVERRIDE CHECK - Can bypass weak SMC if zone is strong
function checkZoneOverride(zoneData, smcData, momentumData, direction, currentPrice) {
    const result = {
        eligible: false,
        conditions: {
            zoneScore: false,
            priceAtZone: false,
            touchCount: false,
            directionMatch: false,
            momentumNotOpposing: false,
            zoneFresh: false
        },
        passed: 0,
        required: 5,
        reason: ''
    };
    
    const zoneD = zoneData.details || {};
    const zoneScore = zoneData.score || 0;
    
    // Condition 1: Zone Score >= 75
    if (zoneScore >= 75) {
        result.conditions.zoneScore = true;
        result.passed++;
    }
    
    // Condition 2: Price within 1% of zone
    let targetZone = null;
    let distancePercent = 999;
    
    if (direction === 'LONG' && zoneD.nearestSupport) {
        targetZone = zoneD.nearestSupport;
        distancePercent = Math.abs(currentPrice - targetZone.price) / currentPrice * 100;
    } else if (direction === 'SHORT' && zoneD.nearestResistance) {
        targetZone = zoneD.nearestResistance;
        distancePercent = Math.abs(currentPrice - targetZone.price) / currentPrice * 100;
    }
    
    if (distancePercent <= 1.0) {
        result.conditions.priceAtZone = true;
        result.passed++;
    }
    
    // Condition 3: Zone has 3+ touches
    if (targetZone && targetZone.touches >= 3) {
        result.conditions.touchCount = true;
        result.passed++;
    }
    
    // Condition 4: Direction matches (LONG at support, SHORT at resistance)
    if ((direction === 'LONG' && zoneD.nearestSupport) || 
        (direction === 'SHORT' && zoneD.nearestResistance)) {
        result.conditions.directionMatch = true;
        result.passed++;
    }
    
    // Condition 5: Momentum NOT strongly opposing
    const momDir = momentumData.direction || 'NEUTRAL';
    const momScore = momentumData.score || 0;
    const momOpposing = (direction === 'LONG' && momDir === 'SHORT') || 
                        (direction === 'SHORT' && momDir === 'LONG');
    
    if (!momOpposing || momScore < 60) {
        result.conditions.momentumNotOpposing = true;
        result.passed++;
    }
    
    // Condition 6: Zone freshness (at least 1 touch in last 50 candles) - bonus
    if (targetZone && targetZone.lastTouch && targetZone.lastTouch < 50) {
        result.conditions.zoneFresh = true;
    }
    
    // Check eligibility (need 5 of 5 main conditions)
    result.eligible = result.passed >= 5;
    
    if (result.eligible) {
        result.reason = `Zone Override ACTIVE: ${result.passed}/5 conditions met`;
    } else {
        const missing = [];
        if (!result.conditions.zoneScore) missing.push('Zone<75');
        if (!result.conditions.priceAtZone) missing.push('Price>1%');
        if (!result.conditions.touchCount) missing.push('Touches<3');
        if (!result.conditions.directionMatch) missing.push('Direction');
        if (!result.conditions.momentumNotOpposing) missing.push('Momentum opposing');
        result.reason = `Zone Override DENIED: Missing ${missing.join(', ')}`;
    }
    
    return result;
}

// CONFLICT DETECTOR - Identifies and handles engine conflicts
function detectEngineConflicts(zoneData, smcData, momentumData, candlePatterns) {
    const result = {
        hasConflict: false,
        conflictCount: 0,
        neutralCount: 0,
        conflicts: [],
        directions: {
            zone: 'NEUTRAL',
            smc: 'NEUTRAL',
            momentum: 'NEUTRAL',
            candle: 'NEUTRAL'
        },
        votes: { LONG: 0, SHORT: 0, NEUTRAL: 0 },
        shouldSkip: false,
        reason: ''
    };
    
    // Get directions (treat score < 30 as NEUTRAL)
    result.directions.zone = (zoneData.score >= 30) ? (zoneData.direction || 'NEUTRAL') : 'NEUTRAL';
    result.directions.smc = (smcData.score >= 30) ? (smcData.direction || 'NEUTRAL') : 'NEUTRAL';
    result.directions.momentum = (momentumData.score >= 30) ? (momentumData.direction || 'NEUTRAL') : 'NEUTRAL';
    result.directions.candle = candlePatterns.patternSignal || 'NEUTRAL';
    
    // Normalize candle direction
    if (result.directions.candle === 'BULLISH') result.directions.candle = 'LONG';
    if (result.directions.candle === 'BEARISH') result.directions.candle = 'SHORT';
    
    // Count votes
    for (const [engine, dir] of Object.entries(result.directions)) {
        if (dir === 'LONG') result.votes.LONG++;
        else if (dir === 'SHORT') result.votes.SHORT++;
        else result.votes.NEUTRAL++;
    }
    
    result.neutralCount = result.votes.NEUTRAL;
    
    // Check for LONG vs SHORT conflicts
    const activeEngines = Object.entries(result.directions).filter(([k, v]) => v !== 'NEUTRAL');
    const longEngines = activeEngines.filter(([k, v]) => v === 'LONG').map(([k]) => k);
    const shortEngines = activeEngines.filter(([k, v]) => v === 'SHORT').map(([k]) => k);
    
    if (longEngines.length > 0 && shortEngines.length > 0) {
        result.hasConflict = true;
        result.conflictCount = Math.min(longEngines.length, shortEngines.length);
        result.conflicts.push(`${longEngines.join('+')} say LONG vs ${shortEngines.join('+')} say SHORT`);
    }
    
    // RULE 3: 2+ engines conflict → SKIP
    if (result.conflictCount >= 2) {
        result.shouldSkip = true;
        result.reason = 'RULE 3: 2+ engines conflict';
    }
    
    // RULE 4: 2+ engines NEUTRAL → WAIT (not skip, but warning)
    if (result.neutralCount >= 2 && !result.shouldSkip) {
        result.reason = 'RULE 4: 2+ engines neutral - low conviction';
    }
    
    return result;
}

// 7 MANDATORY RULES CHECKER
function checkMandatoryRules(zoneData, smcData, momentumData, htfBias, conflictResult, zoneOverride, trapDetection) {
    const result = {
        allPassed: true,
        rules: {
            rule1: { passed: true, description: 'SMC >= 20', reason: '' },
            rule2: { passed: true, description: 'SMC >= 30 or Zone Override', reason: '' },
            rule3: { passed: true, description: 'No 2+ engine conflict', reason: '' },
            rule4: { passed: true, description: 'No 2+ engines neutral', reason: '' },
            rule5: { passed: true, description: 'Momentum not opposing with strength', reason: '' },
            rule6: { passed: true, description: 'HTF >= 50% aligned', reason: '' },
            rule7: { passed: true, description: 'No high confidence trap', reason: '' }
        },
        verdict: 'TAKE',
        violations: []
    };
    
    const smcScore = smcData.score || 0;
    const momScore = momentumData.score || 0;
    const momDir = momentumData.direction || 'NEUTRAL';
    
    // RULE 1: SMC < 20 → NO_TRADE (absolute)
    if (smcScore < 20) {
        result.rules.rule1.passed = false;
        result.rules.rule1.reason = `SMC score ${smcScore} < 20`;
        result.violations.push('RULE 1: SMC critically low');
        result.verdict = 'NO_TRADE';
        result.allPassed = false;
    }
    
    // RULE 2: SMC < 30 → SKIP (unless Zone Override)
    if (smcScore >= 20 && smcScore < 30 && !zoneOverride.eligible) {
        result.rules.rule2.passed = false;
        result.rules.rule2.reason = `SMC score ${smcScore} < 30, no Zone Override`;
        result.violations.push('RULE 2: SMC weak, no override');
        if (result.verdict !== 'NO_TRADE') result.verdict = 'SKIP';
        result.allPassed = false;
    } else if (smcScore < 30 && zoneOverride.eligible) {
        result.rules.rule2.reason = 'Zone Override applied';
    }
    
    // RULE 3: 2+ engines conflict → SKIP
    if (conflictResult.conflictCount >= 2) {
        result.rules.rule3.passed = false;
        result.rules.rule3.reason = conflictResult.conflicts.join('; ');
        result.violations.push('RULE 3: Multiple engine conflict');
        if (result.verdict !== 'NO_TRADE') result.verdict = 'SKIP';
        result.allPassed = false;
    }
    
    // RULE 4: 2+ engines NEUTRAL → WAIT
    if (conflictResult.neutralCount >= 2) {
        result.rules.rule4.passed = false;
        result.rules.rule4.reason = `${conflictResult.neutralCount} engines neutral`;
        result.violations.push('RULE 4: Low conviction');
        if (result.verdict !== 'NO_TRADE' && result.verdict !== 'SKIP') result.verdict = 'WAIT';
        result.allPassed = false;
    }
    
    // RULE 5: Momentum opposes + score >= 50 → SKIP
    // (We need direction from main signal, passed via conflictResult comparison)
    // This will be checked in main function where we know the final direction
    
    // RULE 6: HTF < 50% aligned → SKIP
    const htfPct = htfBias.total > 0 ? (htfBias.aligned / htfBias.total) * 100 : 0;
    if (htfPct < 50) {
        result.rules.rule6.passed = false;
        result.rules.rule6.reason = `HTF ${htfPct.toFixed(0)}% < 50%`;
        result.violations.push('RULE 6: HTF misaligned');
        if (result.verdict !== 'NO_TRADE') result.verdict = 'SKIP';
        result.allPassed = false;
    }
    
    // RULE 7: Trap HIGH confidence → NO_TRADE
    if (trapDetection && trapDetection.confidence === 'HIGH') {
        result.rules.rule7.passed = false;
        result.rules.rule7.reason = `${trapDetection.type} detected`;
        result.violations.push('RULE 7: High confidence trap');
        result.verdict = 'NO_TRADE';
        result.allPassed = false;
    }
    
    return result;
}

// ULTIMATE SCORE CALCULATOR - New formula
function calculateUltimateScore(sequenceResult, rejectionResult, htfBias, momentumData, volumeConfirmed) {
    // NEW FORMULA: Sequence 40% + Rejection 25% + HTF 15% + Momentum 10% + Volume 10%
    const sequenceScore = sequenceResult.score || 0;
    const rejectionScore = rejectionResult.score || 0;
    const htfScore = htfBias.total > 0 ? (htfBias.aligned / htfBias.total) * 100 : 50;
    // FIX: Use typeof check so score of 0 is valid (not replaced with 50)
    const momentumScore = typeof momentumData.score === 'number' ? momentumData.score : 50;
    const volumeScore = volumeConfirmed ? 100 : 50;
    
    const finalScore = 
        (sequenceScore * 0.40) +
        (rejectionScore * 0.25) +
        (htfScore * 0.15) +
        (momentumScore * 0.10) +
        (volumeScore * 0.10);
    
    return {
        final: Math.round(finalScore),
        breakdown: {
            sequence: { raw: sequenceScore, weighted: Math.round(sequenceScore * 0.40), weight: '40%' },
            rejection: { raw: rejectionScore, weighted: Math.round(rejectionScore * 0.25), weight: '25%' },
            htf: { raw: Math.round(htfScore), weighted: Math.round(htfScore * 0.15), weight: '15%' },
            momentum: { raw: momentumScore, weighted: Math.round(momentumScore * 0.10), weight: '10%' },
            volume: { raw: volumeScore, weighted: Math.round(volumeScore * 0.10), weight: '10%' }
        }
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// MOMENTUM ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════════

// Calculate RSI with Wilder Smoothing (correct implementation)
function calcRSI(closes, period = 14) {
    if (!closes || closes.length < period + 1) return { value: 50, trend: 'NEUTRAL' };
    
    const gains = [];
    const losses = [];
    
    for (let i = 1; i < closes.length; i++) {
        const change = closes[i] - closes[i - 1];
        gains.push(change > 0 ? change : 0);
        losses.push(change < 0 ? -change : 0);
    }
    
    // Initial average (SMA)
    let avgGain = 0;
    let avgLoss = 0;
    for (let i = 0; i < period; i++) {
        avgGain += gains[i];
        avgLoss += losses[i];
    }
    avgGain /= period;
    avgLoss /= period;
    
    // Wilder smoothing for remaining values
    for (let i = period; i < gains.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
    }
    
    if (avgLoss === 0) return { value: 100, trend: 'OVERBOUGHT' };
    
    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));
    
    let trend = 'NEUTRAL';
    if (rsi >= 70) trend = 'OVERBOUGHT';
    else if (rsi >= 60) trend = 'BULLISH';
    else if (rsi <= 30) trend = 'OVERSOLD';
    else if (rsi <= 40) trend = 'BEARISH';
    
    return { value: rsi, trend, avgGain, avgLoss };
}

// Calculate MACD with Signal Line and Histogram
function calcMACD(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
    if (!closes || closes.length < slowPeriod + signalPeriod) {
        return { macd: 0, signal: 0, histogram: 0, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate EMAs
    const calcEMA = (data, period) => {
        const k = 2 / (period + 1);
        let ema = data[0];
        const emaValues = [ema];
        
        for (let i = 1; i < data.length; i++) {
            ema = data[i] * k + ema * (1 - k);
            emaValues.push(ema);
        }
        return emaValues;
    };
    
    const ema12 = calcEMA(closes, fastPeriod);
    const ema26 = calcEMA(closes, slowPeriod);
    
    // MACD Line
    const macdLine = [];
    for (let i = 0; i < closes.length; i++) {
        macdLine.push(ema12[i] - ema26[i]);
    }
    
    // Signal Line (EMA of MACD)
    const signalLine = calcEMA(macdLine.slice(slowPeriod - 1), signalPeriod);
    
    const currentMACD = macdLine[macdLine.length - 1];
    const currentSignal = signalLine[signalLine.length - 1];
    const prevMACD = macdLine[macdLine.length - 2];
    const prevSignal = signalLine[signalLine.length - 2];
    const histogram = currentMACD - currentSignal;
    const prevHistogram = prevMACD - prevSignal;
    
    // Detect crossover
    let crossover = null;
    if (prevMACD <= prevSignal && currentMACD > currentSignal) {
        crossover = 'BULLISH';
    } else if (prevMACD >= prevSignal && currentMACD < currentSignal) {
        crossover = 'BEARISH';
    }
    
    // Histogram momentum
    let histogramTrend = 'NEUTRAL';
    if (histogram > 0 && histogram > prevHistogram) histogramTrend = 'BULLISH_EXPANDING';
    else if (histogram > 0 && histogram < prevHistogram) histogramTrend = 'BULLISH_CONTRACTING';
    else if (histogram < 0 && histogram < prevHistogram) histogramTrend = 'BEARISH_EXPANDING';
    else if (histogram < 0 && histogram > prevHistogram) histogramTrend = 'BEARISH_CONTRACTING';
    
    let trend = 'NEUTRAL';
    if (currentMACD > 0 && currentMACD > currentSignal) trend = 'BULLISH';
    else if (currentMACD < 0 && currentMACD < currentSignal) trend = 'BEARISH';
    
    return {
        macd: currentMACD,
        signal: currentSignal,
        histogram,
        histogramTrend,
        trend,
        crossover,
        ema12: ema12[ema12.length - 1],
        ema26: ema26[ema26.length - 1]
    };
}

// Calculate ADX with DI+ and DI-
function calcADX(klines, period = 14) {
    // SAFETY: Comprehensive null/edge case checks
    if (!klines || !Array.isArray(klines) || klines.length < period * 2) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK', crossover: null, trending: false };
    }
    
    const plusDM = [];
    const minusDM = [];
    const tr = [];
    
    for (let i = 1; i < klines.length; i++) {
        const candle = klines[i];
        const prevCandle = klines[i - 1];
        
        // SAFETY: Validate candle data exists
        if (!candle || !prevCandle) continue;
        
        const high = candle.high || 0;
        const low = candle.low || 0;
        const prevHigh = prevCandle.high || 0;
        const prevLow = prevCandle.low || 0;
        const prevClose = prevCandle.close || 0;
        
        // Directional Movement
        const upMove = high - prevHigh;
        const downMove = prevLow - low;
        
        plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
        minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);
        
        // True Range
        tr.push(Math.max(
            high - low,
            Math.abs(high - prevClose),
            Math.abs(low - prevClose)
        ));
    }
    
    // SAFETY: Check we have enough data after filtering
    if (plusDM.length < period || minusDM.length < period || tr.length < period) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK', crossover: null, trending: false };
    }
    
    // Smoothed values
    let smoothPlusDM = 0;
    let smoothMinusDM = 0;
    let smoothTR = 0;
    
    for (let i = 0; i < period; i++) {
        smoothPlusDM += plusDM[i] || 0;
        smoothMinusDM += minusDM[i] || 0;
        smoothTR += tr[i] || 0;
    }
    
    const dxValues = [];
    
    for (let i = period; i < plusDM.length; i++) {
        smoothPlusDM = smoothPlusDM - smoothPlusDM / period + (plusDM[i] || 0);
        smoothMinusDM = smoothMinusDM - smoothMinusDM / period + (minusDM[i] || 0);
        smoothTR = smoothTR - smoothTR / period + (tr[i] || 0);
        
        // SAFETY: Prevent division by zero
        const diPlus = smoothTR > 0 ? (smoothPlusDM / smoothTR) * 100 : 0;
        const diMinus = smoothTR > 0 ? (smoothMinusDM / smoothTR) * 100 : 0;
        const diSum = diPlus + diMinus;
        const dx = diSum > 0 ? Math.abs(diPlus - diMinus) / diSum * 100 : 0;
        
        dxValues.push({ dx, diPlus, diMinus });
    }
    
    if (dxValues.length < period) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK', crossover: null, trending: false };
    }
    
    // ADX (smoothed DX)
    let adx = 0;
    for (let i = 0; i < period; i++) {
        adx += dxValues[i]?.dx || 0;
    }
    adx /= period;
    
    for (let i = period; i < dxValues.length; i++) {
        adx = (adx * (period - 1) + (dxValues[i]?.dx || 0)) / period;
    }
    
    // SAFETY: Ensure we have DI values
    const lastDI = dxValues[dxValues.length - 1] || { diPlus: 0, diMinus: 0 };
    const prevDI = dxValues[dxValues.length - 2] || { diPlus: 0, diMinus: 0 };
    
    // Trend direction and strength
    let trend = 'NEUTRAL';
    if (lastDI.diPlus > lastDI.diMinus) trend = 'BULLISH';
    else if (lastDI.diMinus > lastDI.diPlus) trend = 'BEARISH';
    
    let strength = 'WEAK';
    if (adx >= 50) strength = 'VERY_STRONG';
    else if (adx >= 35) strength = 'STRONG';
    else if (adx >= 25) strength = 'TRENDING';
    else if (adx >= 20) strength = 'WEAK_TREND';
    
    // DI crossover detection
    let crossover = null;
    if (prevDI.diPlus <= prevDI.diMinus && lastDI.diPlus > lastDI.diMinus) {
        crossover = 'BULLISH';
    } else if (prevDI.diPlus >= prevDI.diMinus && lastDI.diPlus < lastDI.diMinus) {
        crossover = 'BEARISH';
    }
    
    return {
        adx: isNaN(adx) ? 0 : adx,
        diPlus: isNaN(lastDI.diPlus) ? 0 : lastDI.diPlus,
        diMinus: isNaN(lastDI.diMinus) ? 0 : lastDI.diMinus,
        trend,
        strength,
        crossover,
        trending: adx >= 25
    };
}

// Calculate Stochastic RSI
function calcStochRSI(closes, rsiPeriod = 14, stochPeriod = 14, kPeriod = 3, dPeriod = 3) {
    if (!closes || closes.length < rsiPeriod + stochPeriod + kPeriod) {
        return { k: 50, d: 50, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate RSI values
    const rsiValues = [];
    for (let i = rsiPeriod; i < closes.length; i++) {
        const rsi = calcRSI(closes.slice(0, i + 1), rsiPeriod);
        rsiValues.push(rsi.value);
    }
    
    if (rsiValues.length < stochPeriod) {
        return { k: 50, d: 50, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate Stochastic of RSI
    const stochRSI = [];
    for (let i = stochPeriod - 1; i < rsiValues.length; i++) {
        const period = rsiValues.slice(i - stochPeriod + 1, i + 1);
        const minRSI = Math.min(...period);
        const maxRSI = Math.max(...period);
        const range = maxRSI - minRSI;
        
        if (range === 0) {
            stochRSI.push(50);
        } else {
            stochRSI.push(((rsiValues[i] - minRSI) / range) * 100);
        }
    }
    
    // Calculate %K (SMA of Stochastic RSI)
    const kValues = [];
    for (let i = kPeriod - 1; i < stochRSI.length; i++) {
        const sum = stochRSI.slice(i - kPeriod + 1, i + 1).reduce((a, b) => a + b, 0);
        kValues.push(sum / kPeriod);
    }
    
    // Calculate %D (SMA of %K)
    const dValues = [];
    for (let i = dPeriod - 1; i < kValues.length; i++) {
        const sum = kValues.slice(i - dPeriod + 1, i + 1).reduce((a, b) => a + b, 0);
        dValues.push(sum / dPeriod);
    }
    
    const k = kValues[kValues.length - 1] || 50;
    const d = dValues[dValues.length - 1] || 50;
    const prevK = kValues[kValues.length - 2] || 50;
    const prevD = dValues[dValues.length - 2] || 50;
    
    // Crossover detection
    let crossover = null;
    if (prevK <= prevD && k > d) crossover = 'BULLISH';
    else if (prevK >= prevD && k < d) crossover = 'BEARISH';
    
    let trend = 'NEUTRAL';
    if (k >= 80) trend = 'OVERBOUGHT';
    else if (k <= 20) trend = 'OVERSOLD';
    else if (k > d && k > 50) trend = 'BULLISH';
    else if (k < d && k < 50) trend = 'BEARISH';
    
    return { k, d, trend, crossover };
}

// Calculate On-Balance Volume (OBV) with trend
function calcOBV(klines) {
    if (!klines || klines.length < 20) {
        return { obv: 0, trend: 'NEUTRAL', divergence: null };
    }
    
    let obv = 0;
    const obvValues = [0];
    
    for (let i = 1; i < klines.length; i++) {
        if (klines[i].close > klines[i - 1].close) {
            obv += klines[i].volume;
        } else if (klines[i].close < klines[i - 1].close) {
            obv -= klines[i].volume;
        }
        obvValues.push(obv);
    }
    
    // Calculate OBV trend using EMA
    const len = obvValues.length;
    const shortEMA = obvValues.slice(-10).reduce((a, b) => a + b, 0) / 10;
    const longEMA = obvValues.slice(-20).reduce((a, b) => a + b, 0) / 20;
    
    let trend = 'NEUTRAL';
    if (shortEMA > longEMA * 1.05) trend = 'BULLISH';
    else if (shortEMA < longEMA * 0.95) trend = 'BEARISH';
    
    // Check for OBV divergence with price
    const recentOBV = obvValues.slice(-20);
    const recentClose = klines.slice(-20).map(k => k.close);
    
    const priceUp = recentClose[recentClose.length - 1] > recentClose[0];
    const obvUp = recentOBV[recentOBV.length - 1] > recentOBV[0];
    
    let divergence = null;
    if (priceUp && !obvUp) divergence = 'BEARISH'; // Price up, OBV down
    else if (!priceUp && obvUp) divergence = 'BULLISH'; // Price down, OBV up
    
    return {
        obv: obvValues[obvValues.length - 1],
        obvValues,
        trend,
        divergence,
        shortEMA,
        longEMA
    };
}

// Calculate Volume Metrics
function calcVolumeMetrics(klines) {
    if (!klines || klines.length < 25) {
        return { ratio: 1, spike: false, trend: 'NEUTRAL' };
    }
    
    const len = klines.length;
    const currentVolume = klines[len - 1].volume;
    
    // Average volume (20 period)
    const avgVolume = klines.slice(-21, -1).reduce((sum, k) => sum + k.volume, 0) / 20;
    
    const ratio = avgVolume > 0 ? currentVolume / avgVolume : 1;
    const spike = ratio >= 2.5;
    
    // Volume trend
    const recentAvg = klines.slice(-5).reduce((sum, k) => sum + k.volume, 0) / 5;
    const olderAvg = klines.slice(-15, -10).reduce((sum, k) => sum + k.volume, 0) / 5;
    
    let trend = 'NEUTRAL';
    if (recentAvg > olderAvg * 1.3) trend = 'INCREASING';
    else if (recentAvg < olderAvg * 0.7) trend = 'DECREASING';
    
    return {
        current: currentVolume,
        average: avgVolume,
        ratio,
        spike,
        trend,
        percentAboveAvg: ((ratio - 1) * 100)
    };
}


// Calculate EMA values
function calcEMA(closes, period) {
    if (!closes || closes.length < period) return null;
    
    const k = 2 / (period + 1);
    let ema = closes.slice(0, period).reduce((a, b) => a + b, 0) / period;
    
    for (let i = period; i < closes.length; i++) {
        ema = closes[i] * k + ema * (1 - k);
    }
    
    return ema;
}

// Get EMA Cross signals (9/21 for scalping, 50/200 for trend)
function getEMACross(closes) {
    if (!closes || closes.length < 200) {
        return { 
            ema9: 0, ema21: 0, ema50: 0, ema200: 0,
            shortCross: null, longCross: null, 
            priceVsEMA: 'NEUTRAL'
        };
    }
    
    const ema9 = calcEMA(closes, 9);
    const ema21 = calcEMA(closes, 21);
    const ema50 = calcEMA(closes, 50);
    const ema200 = calcEMA(closes, 200);
    const currentPrice = closes[closes.length - 1];
    
    // Calculate previous EMAs for crossover detection
    const prevCloses = closes.slice(0, -1);
    const prevEma9 = calcEMA(prevCloses, 9);
    const prevEma21 = calcEMA(prevCloses, 21);
    const prevEma50 = calcEMA(prevCloses, 50);
    const prevEma200 = calcEMA(prevCloses, 200);
    
    // Short-term cross (9/21)
    let shortCross = null;
    if (prevEma9 <= prevEma21 && ema9 > ema21) shortCross = 'BULLISH';
    else if (prevEma9 >= prevEma21 && ema9 < ema21) shortCross = 'BEARISH';
    
    // Long-term cross (50/200 - Golden/Death Cross)
    let longCross = null;
    if (prevEma50 <= prevEma200 && ema50 > ema200) longCross = 'GOLDEN';
    else if (prevEma50 >= prevEma200 && ema50 < ema200) longCross = 'DEATH';
    
    // Price position vs EMAs
    let priceVsEMA = 'NEUTRAL';
    if (currentPrice > ema9 && currentPrice > ema21 && currentPrice > ema50) {
        priceVsEMA = 'STRONG_BULLISH';
    } else if (currentPrice > ema9 && currentPrice > ema21) {
        priceVsEMA = 'BULLISH';
    } else if (currentPrice < ema9 && currentPrice < ema21 && currentPrice < ema50) {
        priceVsEMA = 'STRONG_BEARISH';
    } else if (currentPrice < ema9 && currentPrice < ema21) {
        priceVsEMA = 'BEARISH';
    }
    
    return {
        ema9, ema21, ema50, ema200,
        shortCross, longCross,
        priceVsEMA,
        aboveEMA200: currentPrice > ema200,
        aboveEMA50: currentPrice > ema50
    };
}

// Detect Divergence (Regular, Hidden, Compound)
function detectDivergence(klines, indicatorFn = 'rsi') {
    if (!klines || klines.length < 50) {
        return { type: null, strength: null, direction: null };
    }
    
    const closes = klines.map(k => k.close);
    const highs = klines.map(k => k.high);
    const lows = klines.map(k => k.low);
    
    // Find swing points in price
    const priceSwings = findSwingPoints(klines, 4, 4);
    
    // Calculate indicator values
    let indicatorValues = [];
    if (indicatorFn === 'rsi') {
        for (let i = 14; i < closes.length; i++) {
            indicatorValues.push({
                index: i,
                value: calcRSI(closes.slice(0, i + 1), 14).value
            });
        }
    } else if (indicatorFn === 'macd') {
        for (let i = 35; i < closes.length; i++) {
            indicatorValues.push({
                index: i,
                value: calcMACD(closes.slice(0, i + 1)).histogram
            });
        }
    }
    
    if (indicatorValues.length < 20 || priceSwings.highs.length < 2 || priceSwings.lows.length < 2) {
        return { type: null, strength: null, direction: null };
    }
    
    // Get indicator values at swing points
    const getIndicatorAtIndex = (idx) => {
        const found = indicatorValues.find(v => v.index === idx);
        if (found) return found.value;
        // Find closest
        const closest = indicatorValues.reduce((prev, curr) => 
            Math.abs(curr.index - idx) < Math.abs(prev.index - idx) ? curr : prev
        );
        return closest.value;
    };
    
    // Check for Regular Bullish Divergence (price lower low, indicator higher low)
    const recentLows = priceSwings.lows.slice(-4);
    for (let i = 0; i < recentLows.length - 1; i++) {
        const firstLow = recentLows[i];
        const secondLow = recentLows[i + 1];
        
        const ind1 = getIndicatorAtIndex(firstLow.index);
        const ind2 = getIndicatorAtIndex(secondLow.index);
        
        // Price makes lower low, indicator makes higher low
        if (secondLow.price < firstLow.price && ind2 > ind1) {
            // Check for compound (3+ swings)
            if (i > 0) {
                const thirdLow = recentLows[i - 1];
                const ind0 = getIndicatorAtIndex(thirdLow.index);
                if (thirdLow.price > firstLow.price && ind0 < ind1) {
                    return { type: 'COMPOUND', strength: 'STRONG', direction: 'BULLISH' };
                }
            }
            return { type: 'REGULAR', strength: 'MEDIUM', direction: 'BULLISH' };
        }
        
        // Hidden Bullish: price higher low, indicator lower low
        if (secondLow.price > firstLow.price && ind2 < ind1) {
            return { type: 'HIDDEN', strength: 'MEDIUM', direction: 'BULLISH' };
        }
    }
    
    // Check for Regular Bearish Divergence (price higher high, indicator lower high)
    const recentHighs = priceSwings.highs.slice(-4);
    for (let i = 0; i < recentHighs.length - 1; i++) {
        const firstHigh = recentHighs[i];
        const secondHigh = recentHighs[i + 1];
        
        const ind1 = getIndicatorAtIndex(firstHigh.index);
        const ind2 = getIndicatorAtIndex(secondHigh.index);
        
        // Price makes higher high, indicator makes lower high
        if (secondHigh.price > firstHigh.price && ind2 < ind1) {
            // Check for compound
            if (i > 0) {
                const thirdHigh = recentHighs[i - 1];
                const ind0 = getIndicatorAtIndex(thirdHigh.index);
                if (thirdHigh.price < firstHigh.price && ind0 > ind1) {
                    return { type: 'COMPOUND', strength: 'STRONG', direction: 'BEARISH' };
                }
            }
            return { type: 'REGULAR', strength: 'MEDIUM', direction: 'BEARISH' };
        }
        
        // Hidden Bearish: price lower high, indicator higher high
        if (secondHigh.price < firstHigh.price && ind2 > ind1) {
            return { type: 'HIDDEN', strength: 'MEDIUM', direction: 'BEARISH' };
        }
    }
    
    return { type: null, strength: null, direction: null };
}

// Detect Momentum Exhaustion
function detectExhaustion(klines, rsi, macd, volume) {
    if (!klines || klines.length < 20) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const isBullishCandle = currentCandle.close > currentCandle.open;
    
    // Bullish Exhaustion: RSI overbought + volume spike + small body or doji
    if (rsi.value >= 70 && volume.spike) {
        const body = Math.abs(currentCandle.close - currentCandle.open);
        const range = currentCandle.high - currentCandle.low;
        const bodyRatio = range > 0 ? body / range : 0;
        
        if (bodyRatio < 0.3) { // Small body (doji-like)
            return {
                detected: true,
                direction: 'BEARISH', // Bullish exhaustion = bearish signal
                reason: 'RSI OB + Vol spike + weak candle'
            };
        }
        
        // Check for shooting star / hanging man
        const upperWick = currentCandle.high - Math.max(currentCandle.open, currentCandle.close);
        if (upperWick > body * 2) {
            return {
                detected: true,
                direction: 'BEARISH',
                reason: 'Rejection candle at RSI OB'
            };
        }
    }
    
    // Bearish Exhaustion: RSI oversold + volume spike + small body
    if (rsi.value <= 30 && volume.spike) {
        const body = Math.abs(currentCandle.close - currentCandle.open);
        const range = currentCandle.high - currentCandle.low;
        const bodyRatio = range > 0 ? body / range : 0;
        
        if (bodyRatio < 0.3) {
            return {
                detected: true,
                direction: 'BULLISH', // Bearish exhaustion = bullish signal
                reason: 'RSI OS + Vol spike + weak candle'
            };
        }
        
        // Check for hammer
        const lowerWick = Math.min(currentCandle.open, currentCandle.close) - currentCandle.low;
        if (lowerWick > body * 2) {
            return {
                detected: true,
                direction: 'BULLISH',
                reason: 'Hammer candle at RSI OS'
            };
        }
    }
    
    // MACD histogram exhaustion
    if (macd.histogramTrend === 'BULLISH_CONTRACTING' && rsi.value > 65) {
        return {
            detected: true,
            direction: 'BEARISH',
            reason: 'MACD momentum fading'
        };
    }
    
    if (macd.histogramTrend === 'BEARISH_CONTRACTING' && rsi.value < 35) {
        return {
            detected: true,
            direction: 'BULLISH',
            reason: 'MACD momentum fading'
        };
    }
    
    return { detected: false };
}

// Calculate ATR for volatility
function calcATR(klines, period = 14) {
    if (!klines || klines.length < period + 1) return 0;
    
    const tr = [];
    for (let i = 1; i < klines.length; i++) {
        tr.push(Math.max(
            klines[i].high - klines[i].low,
            Math.abs(klines[i].high - klines[i - 1].close),
            Math.abs(klines[i].low - klines[i - 1].close)
        ));
    }
    
    // Wilder smoothing
    let atr = tr.slice(0, period).reduce((a, b) => a + b, 0) / period;
    
    for (let i = period; i < tr.length; i++) {
        atr = (atr * (period - 1) + tr[i]) / period;
    }
    
    return atr;
}

// MAIN MOMENTUM ANALYSIS FUNCTION
function performMomentumAnalysis(klines) {
    const result = {
        score: 0,
        direction: null,
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const closes = klines.map(k => k.close);
    
    // Calculate all indicators
    const rsi = calcRSI(closes, 14);
    result.details.rsi = rsi;
    
    const macd = calcMACD(closes);
    result.details.macd = macd;
    
    const adx = calcADX(klines, 14);
    result.details.adx = adx;
    
    const stochRSI = calcStochRSI(closes);
    result.details.stochRSI = stochRSI;
    
    const obv = calcOBV(klines);
    result.details.obv = obv;
    
    const volume = calcVolumeMetrics(klines);
    result.details.volume = volume;
    
    const emaCross = getEMACross(closes);
    result.details.emaCross = emaCross;
    
    const divergenceRSI = detectDivergence(klines, 'rsi');
    const divergenceMACD = detectDivergence(klines, 'macd');
    result.details.divergence = { rsi: divergenceRSI, macd: divergenceMACD };
    
    const exhaustion = detectExhaustion(klines, rsi, macd, volume);
    result.details.exhaustion = exhaustion;
    
    const atr = calcATR(klines);
    result.details.atr = atr;
    
    // SCORING
    let bullScore = 0;
    let bearScore = 0;
    
    // RSI (max 25 points)
    if (rsi.value <= 30) {
        bullScore += 25;
        result.factors.push(`RSI OS(${rsi.value.toFixed(0)})`);
    } else if (rsi.value <= 40) {
        bullScore += 12;
        result.factors.push(`RSI Low(${rsi.value.toFixed(0)})`);
    } else if (rsi.value >= 70) {
        bearScore += 25;
        result.factors.push(`RSI OB(${rsi.value.toFixed(0)})`);
    } else if (rsi.value >= 60) {
        bearScore += 12;
        result.factors.push(`RSI High(${rsi.value.toFixed(0)})`);
    }
    
    // MACD (max 20 points)
    if (macd.crossover === 'BULLISH') {
        bullScore += 20;
        result.factors.push('MACD Cross↑');
    } else if (macd.crossover === 'BEARISH') {
        bearScore += 20;
        result.factors.push('MACD Cross↓');
    } else if (macd.trend === 'BULLISH') {
        bullScore += 10;
        result.factors.push('MACD+');
    } else if (macd.trend === 'BEARISH') {
        bearScore += 10;
        result.factors.push('MACD-');
    }
    
    // MACD Histogram momentum
    if (macd.histogramTrend === 'BULLISH_EXPANDING') {
        bullScore += 8;
        result.factors.push('Hist↑↑');
    } else if (macd.histogramTrend === 'BEARISH_EXPANDING') {
        bearScore += 8;
        result.factors.push('Hist↓↓');
    }
    
    // ADX (max 15 points)
    if (adx.trending) {
        if (adx.trend === 'BULLISH') {
            bullScore += 15;
            result.factors.push(`ADX↑(${adx.adx.toFixed(0)})`);
        } else if (adx.trend === 'BEARISH') {
            bearScore += 15;
            result.factors.push(`ADX↓(${adx.adx.toFixed(0)})`);
        }
        
        if (adx.crossover === 'BULLISH') {
            bullScore += 8;
            result.factors.push('DI+ Cross');
        } else if (adx.crossover === 'BEARISH') {
            bearScore += 8;
            result.factors.push('DI- Cross');
        }
    } else {
        result.warnings.push('Weak trend (ADX<25)');
    }
    
    // Stochastic RSI (max 15 points)
    if (stochRSI.trend === 'OVERSOLD') {
        bullScore += 12;
        result.factors.push('StochRSI OS');
    } else if (stochRSI.trend === 'OVERBOUGHT') {
        bearScore += 12;
        result.factors.push('StochRSI OB');
    }
    
    if (stochRSI.crossover === 'BULLISH' && stochRSI.k < 30) {
        bullScore += 10;
        result.factors.push('StochRSI Cross↑');
    } else if (stochRSI.crossover === 'BEARISH' && stochRSI.k > 70) {
        bearScore += 10;
        result.factors.push('StochRSI Cross↓');
    }
    
    // OBV (max 10 points)
    if (obv.trend === 'BULLISH') {
        bullScore += 8;
        result.factors.push('OBV+');
    } else if (obv.trend === 'BEARISH') {
        bearScore += 8;
        result.factors.push('OBV-');
    }
    
    if (obv.divergence === 'BULLISH') {
        bullScore += 10;
        result.factors.push('OBV Div↑');
    } else if (obv.divergence === 'BEARISH') {
        bearScore += 10;
        result.factors.push('OBV Div↓');
    }
    
    // Volume (max 10 points)
    if (volume.spike) {
        result.factors.push(`Vol Spike(${volume.ratio.toFixed(1)}x)`);
        // Volume confirms direction
    }
    
    // EMA Cross (max 12 points)
    if (emaCross.shortCross === 'BULLISH') {
        bullScore += 12;
        result.factors.push('EMA 9/21↑');
    } else if (emaCross.shortCross === 'BEARISH') {
        bearScore += 12;
        result.factors.push('EMA 9/21↓');
    }
    
    if (emaCross.priceVsEMA === 'STRONG_BULLISH') {
        bullScore += 8;
    } else if (emaCross.priceVsEMA === 'STRONG_BEARISH') {
        bearScore += 8;
    }
    
    if (emaCross.longCross === 'GOLDEN') {
        bullScore += 15;
        result.factors.push('Golden Cross!');
    } else if (emaCross.longCross === 'DEATH') {
        bearScore += 15;
        result.factors.push('Death Cross!');
    }
    
    // Divergence (max 25 points)
    const div = divergenceRSI.type ? divergenceRSI : divergenceMACD;
    if (div.type) {
        const divPoints = div.type === 'COMPOUND' ? 25 : div.type === 'REGULAR' ? 18 : 10;
        if (div.direction === 'BULLISH') {
            bullScore += divPoints;
            result.factors.push(`${div.type} Div↑`);
        } else {
            bearScore += divPoints;
            result.factors.push(`${div.type} Div↓`);
        }
    }
    
    // Exhaustion (warning)
    if (exhaustion.detected) {
        result.warnings.push(exhaustion.reason);
        if (exhaustion.direction === 'BULLISH') {
            bullScore += 5;
        } else {
            bearScore += 5;
        }
    }
    
    // Determine direction
    if (bullScore > bearScore + 10) {
        result.direction = 'LONG';
        result.score = Math.min(100, bullScore);
    } else if (bearScore > bullScore + 10) {
        result.direction = 'SHORT';
        result.score = Math.min(100, bearScore);
    } else {
        result.direction = null;
        result.score = Math.min(100, Math.max(bullScore, bearScore) * 0.6);
        result.warnings.push('Mixed momentum signals');
    }
    
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════════
// END OF PART 3 - Momentum Analysis Complete
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// 🧠 SMART TRADE SYSTEM - 6 INTELLIGENT ENGINES
// ═══════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 1: SMART STOP LOSS
// Finds structure-based SL that avoids liquidity traps
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartSL(direction, currentPrice, klines, atr) {
    const result = {
        price: null,
        reason: '',
        riskPct: 0,
        trapAvoided: false,
        structureUsed: null,
        score: 0
    };
    
    if (!klines || klines.length < 50) {
        // Fallback to ATR-based SL
        result.price = direction === 'LONG' 
            ? currentPrice - (atr * 2)
            : currentPrice + (atr * 2);
        result.reason = 'ATR fallback';
        result.riskPct = ((Math.abs(currentPrice - result.price) / currentPrice) * 100).toFixed(2);
        return result;
    }
    
    // Get all structure data
    const swings = findSwingPoints(klines, 5, 5);
    const equalLevels = detectEqualLevels(klines, 0.002);
    const orderBlocks = detectOrderBlocks(klines, 50);
    
    // Collect candidate SL levels
    const candidates = [];
    
    if (direction === 'LONG') {
        // Find swing lows below current price
        swings.lows.filter(s => s.price < currentPrice).forEach(swing => {
            const dist = ((currentPrice - swing.price) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) { // Between 0.3% and 5%
                candidates.push({
                    price: swing.price * 0.998, // Buffer below
                    type: 'SWING',
                    dist: dist,
                    score: 50
                });
            }
        });
        
        // Find bullish OBs below current price (SL below OB low)
        orderBlocks.bullish.filter(ob => ob.low < currentPrice && ob.fresh).forEach(ob => {
            const dist = ((currentPrice - ob.low) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) {
                candidates.push({
                    price: ob.low * 0.997, // Buffer below OB
                    type: 'OB',
                    dist: dist,
                    score: ob.fresh ? 70 : 40
                });
            }
        });
        
        // Check for equal lows (TRAP ZONES - avoid these!)
        const trapZones = equalLevels.equalLows.filter(el => el.price < currentPrice);
        
        // Score and filter candidates
        candidates.forEach(c => {
            // Bonus for closer to entry (tighter SL = better R:R)
            if (c.dist < 1) c.score += 20;
            else if (c.dist < 1.5) c.score += 15;
            else if (c.dist < 2) c.score += 10;
            
            // Bonus for ATR validation (SL should be > 1x ATR from entry)
            const atrRatio = (currentPrice - c.price) / atr;
            if (atrRatio >= 1.5) c.score += 20;
            else if (atrRatio >= 1) c.score += 10;
            else c.score -= 10; // Penalty for SL tighter than ATR
            
            // Check if SL is ABOVE any trap zone (bad - will get hunted)
            trapZones.forEach(trap => {
                if (c.price > trap.price && c.price < trap.price * 1.01) {
                    c.score -= 30; // Penalty - SL in trap zone
                    c.inTrap = true;
                }
            });
            
            // Check if SL is BELOW trap zone (good - survives hunt)
            trapZones.forEach(trap => {
                if (c.price < trap.price * 0.995) {
                    c.score += 15; // Bonus - below trap
                    c.belowTrap = true;
                }
            });
        });
        
        // Select best candidate
        candidates.sort((a, b) => b.score - a.score);
        
        if (candidates.length > 0 && candidates[0].score >= 40) {
            const best = candidates[0];
            result.price = best.price;
            result.structureUsed = best.type;
            result.score = best.score;
            result.trapAvoided = best.belowTrap || false;
            
            if (best.type === 'SWING') {
                result.reason = best.belowTrap 
                    ? 'Below swing + avoids EQL trap'
                    : 'Below swing low';
            } else if (best.type === 'OB') {
                result.reason = best.belowTrap
                    ? 'Below OB + avoids EQL trap'
                    : 'Below fresh OB';
            }
        } else {
            // Fallback - check if we need to go below trap zones
            if (trapZones.length > 0) {
                const lowestTrap = Math.min(...trapZones.map(t => t.price));
                result.price = lowestTrap * 0.995; // Below all traps
                result.reason = 'Below liquidity trap zone';
                result.trapAvoided = true;
            } else {
                result.price = currentPrice - (atr * 2);
                result.reason = 'ATR-based (no structure)';
            }
        }
        
    } else { // SHORT
        // Find swing highs above current price
        swings.highs.filter(s => s.price > currentPrice).forEach(swing => {
            const dist = ((swing.price - currentPrice) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) {
                candidates.push({
                    price: swing.price * 1.002, // Buffer above
                    type: 'SWING',
                    dist: dist,
                    score: 50
                });
            }
        });
        
        // Find bearish OBs above current price
        orderBlocks.bearish.filter(ob => ob.high > currentPrice && ob.fresh).forEach(ob => {
            const dist = ((ob.high - currentPrice) / currentPrice) * 100;
            if (dist > 0.3 && dist < 5) {
                candidates.push({
                    price: ob.high * 1.003,
                    type: 'OB',
                    dist: dist,
                    score: ob.fresh ? 70 : 40
                });
            }
        });
        
        // Check for equal highs (TRAP ZONES)
        const trapZones = equalLevels.equalHighs.filter(eh => eh.price > currentPrice);
        
        candidates.forEach(c => {
            if (c.dist < 1) c.score += 20;
            else if (c.dist < 1.5) c.score += 15;
            else if (c.dist < 2) c.score += 10;
            
            const atrRatio = (c.price - currentPrice) / atr;
            if (atrRatio >= 1.5) c.score += 20;
            else if (atrRatio >= 1) c.score += 10;
            else c.score -= 10;
            
            trapZones.forEach(trap => {
                if (c.price < trap.price && c.price > trap.price * 0.99) {
                    c.score -= 30;
                    c.inTrap = true;
                }
            });
            
            trapZones.forEach(trap => {
                if (c.price > trap.price * 1.005) {
                    c.score += 15;
                    c.aboveTrap = true;
                }
            });
        });
        
        candidates.sort((a, b) => b.score - a.score);
        
        if (candidates.length > 0 && candidates[0].score >= 40) {
            const best = candidates[0];
            result.price = best.price;
            result.structureUsed = best.type;
            result.score = best.score;
            result.trapAvoided = best.aboveTrap || false;
            
            if (best.type === 'SWING') {
                result.reason = best.aboveTrap
                    ? 'Above swing + avoids EQH trap'
                    : 'Above swing high';
            } else if (best.type === 'OB') {
                result.reason = best.aboveTrap
                    ? 'Above OB + avoids EQH trap'
                    : 'Above fresh OB';
            }
        } else {
            if (trapZones.length > 0) {
                const highestTrap = Math.max(...trapZones.map(t => t.price));
                result.price = highestTrap * 1.005;
                result.reason = 'Above liquidity trap zone';
                result.trapAvoided = true;
            } else {
                result.price = currentPrice + (atr * 2);
                result.reason = 'ATR-based (no structure)';
            }
        }
    }
    
    // Calculate risk percentage
    result.riskPct = ((Math.abs(currentPrice - result.price) / currentPrice) * 100).toFixed(2);
    
    // Cap SL at max 3%
    if (parseFloat(result.riskPct) > 3) {
        result.price = direction === 'LONG'
            ? currentPrice * 0.97
            : currentPrice * 1.03;
        result.riskPct = '3.00';
        result.reason += ' (capped at 3%)';
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 2: SMART PULLBACK LEVELS
// Finds 2 best add levels between Entry and SL
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartPullbacks(direction, currentPrice, slPrice, klines, atr) {
    const result = {
        pullback1: null,
        pullback2: null,
        marketOnly: false,
        reason: ''
    };
    
    if (!klines || klines.length < 50) {
        result.marketOnly = true;
        result.reason = 'Insufficient data';
        return result;
    }
    
    const orderBlocks = detectOrderBlocks(klines, 50);
    const fvgs = detectFVG(klines, 30);
    const swings = findSwingPoints(klines, 4, 4);
    
    // Collect candidate pullback levels
    const candidates = [];
    const minGapFromSL = 0.005; // Min 0.5% above SL
    
    if (direction === 'LONG') {
        // Entry is above, SL is below. Find levels IN BETWEEN.
        const slBuffer = slPrice * (1 + minGapFromSL);
        
        // FIX: Include ALL bullish OBs, fresh ones get higher score
        orderBlocks.bullish.filter(ob => {
            return ob.high < currentPrice && ob.high > slBuffer;
        }).forEach(ob => {
            candidates.push({
                price: ob.high,
                type: 'OB',
                reason: ob.fresh ? 'Fresh bullish OB' : 'Bullish OB',
                dist: ((currentPrice - ob.high) / currentPrice) * 100,
                score: ob.fresh ? 80 : 55
            });
        });
        
        // FIX: Include ALL bullish FVGs, unfilled ones get higher score
        fvgs.bullish.filter(fvg => {
            return fvg.high < currentPrice && fvg.low > slBuffer;
        }).forEach(fvg => {
            candidates.push({
                price: fvg.high, // Enter at top of FVG
                type: 'FVG',
                reason: fvg.filled ? 'Bullish FVG' : 'Unfilled bullish FVG',
                dist: ((currentPrice - fvg.high) / currentPrice) * 100,
                score: fvg.filled ? 55 : 70
            });
        });
        
        // Swing lows between entry and SL
        swings.lows.filter(s => {
            return s.price < currentPrice && s.price > slBuffer;
        }).forEach(swing => {
            candidates.push({
                price: swing.price * 1.002, // Slightly above swing
                type: 'SWING',
                reason: 'Swing low support',
                dist: ((currentPrice - swing.price) / currentPrice) * 100,
                score: 55
            });
        });
        
    } else { // SHORT
        const slBuffer = slPrice * (1 - minGapFromSL);
        
        // FIX: Include ALL bearish OBs, fresh ones get higher score
        orderBlocks.bearish.filter(ob => {
            return ob.low > currentPrice && ob.low < slBuffer;
        }).forEach(ob => {
            candidates.push({
                price: ob.low,
                type: 'OB',
                reason: ob.fresh ? 'Fresh bearish OB' : 'Bearish OB',
                dist: ((ob.low - currentPrice) / currentPrice) * 100,
                score: ob.fresh ? 80 : 55
            });
        });
        
        // FIX: Include ALL bearish FVGs, unfilled ones get higher score
        fvgs.bearish.filter(fvg => {
            return fvg.low > currentPrice && fvg.high < slBuffer;
        }).forEach(fvg => {
            candidates.push({
                price: fvg.low,
                type: 'FVG',
                reason: fvg.filled ? 'Bearish FVG' : 'Unfilled bearish FVG',
                dist: ((fvg.low - currentPrice) / currentPrice) * 100,
                score: fvg.filled ? 55 : 70
            });
        });
        
        // Swing highs
        swings.highs.filter(s => {
            return s.price > currentPrice && s.price < slBuffer;
        }).forEach(swing => {
            candidates.push({
                price: swing.price * 0.998,
                type: 'SWING',
                reason: 'Swing high resistance',
                dist: ((swing.price - currentPrice) / currentPrice) * 100,
                score: 55
            });
        });
    }
    
    // Score adjustments
    candidates.forEach(c => {
        // Prefer levels 0.5% - 1.5% from entry (optimal pullback)
        if (c.dist >= 0.5 && c.dist <= 1.5) c.score += 20;
        else if (c.dist > 1.5 && c.dist <= 2.5) c.score += 10;
        else if (c.dist < 0.5) c.score -= 10; // Too close
        
        // OB + FVG confluence
        if (c.type === 'OB') {
            const hasFvgConfluence = candidates.some(other => 
                other.type === 'FVG' && 
                Math.abs(other.price - c.price) / c.price < 0.005
            );
            if (hasFvgConfluence) {
                c.score += 25;
                c.reason += ' + FVG confluence';
            }
        }
    });
    
    // Sort by score and remove duplicates (within 0.3% of each other)
    candidates.sort((a, b) => b.score - a.score);
    
    const uniqueCandidates = [];
    candidates.forEach(c => {
        const isDuplicate = uniqueCandidates.some(u => 
            Math.abs(u.price - c.price) / c.price < 0.003
        );
        if (!isDuplicate) uniqueCandidates.push(c);
    });
    
    // Select top 2 with minimum 0.5% gap between them
    if (uniqueCandidates.length >= 1) {
        result.pullback1 = {
            price: uniqueCandidates[0].price,
            type: uniqueCandidates[0].type,
            reason: uniqueCandidates[0].reason,
            distPct: uniqueCandidates[0].dist.toFixed(2),
            score: uniqueCandidates[0].score
        };
        
        // Find second pullback with min gap from first
        for (let i = 1; i < uniqueCandidates.length; i++) {
            const gap = Math.abs(uniqueCandidates[i].price - result.pullback1.price) / result.pullback1.price;
            if (gap >= 0.005) { // Min 0.5% gap
                result.pullback2 = {
                    price: uniqueCandidates[i].price,
                    type: uniqueCandidates[i].type,
                    reason: uniqueCandidates[i].reason,
                    distPct: uniqueCandidates[i].dist.toFixed(2),
                    score: uniqueCandidates[i].score
                };
                break;
            }
        }
    }
    
    if (!result.pullback1) {
        // FIX: ATR-based fallback pullbacks when no SMC structure found
        const atrValue = atr || (Math.abs(currentPrice - slPrice) * 0.3);
        
        if (direction === 'LONG') {
            // Pullback 1: 0.5 ATR below entry
            const pb1Price = currentPrice - (atrValue * 0.5);
            if (pb1Price > slPrice * 1.01) { // Must be above SL with buffer
                result.pullback1 = {
                    price: pb1Price,
                    type: 'ATR',
                    reason: 'ATR-based (0.5 ATR)',
                    distPct: ((currentPrice - pb1Price) / currentPrice * 100).toFixed(2),
                    score: 50
                };
                
                // Pullback 2: 1 ATR below entry
                const pb2Price = currentPrice - (atrValue * 1.0);
                if (pb2Price > slPrice * 1.01) {
                    result.pullback2 = {
                        price: pb2Price,
                        type: 'ATR',
                        reason: 'ATR-based (1.0 ATR)',
                        distPct: ((currentPrice - pb2Price) / currentPrice * 100).toFixed(2),
                        score: 45
                    };
                }
            }
        } else { // SHORT
            // Pullback 1: 0.5 ATR above entry
            const pb1Price = currentPrice + (atrValue * 0.5);
            if (pb1Price < slPrice * 0.99) { // Must be below SL with buffer
                result.pullback1 = {
                    price: pb1Price,
                    type: 'ATR',
                    reason: 'ATR-based (0.5 ATR)',
                    distPct: ((pb1Price - currentPrice) / currentPrice * 100).toFixed(2),
                    score: 50
                };
                
                // Pullback 2: 1 ATR above entry
                const pb2Price = currentPrice + (atrValue * 1.0);
                if (pb2Price < slPrice * 0.99) {
                    result.pullback2 = {
                        price: pb2Price,
                        type: 'ATR',
                        reason: 'ATR-based (1.0 ATR)',
                        distPct: ((pb2Price - currentPrice) / currentPrice * 100).toFixed(2),
                        score: 45
                    };
                }
            }
        }
        
        if (!result.pullback1) {
            result.marketOnly = true;
            result.reason = 'SL too tight for pullbacks';
        } else {
            result.reason = 'ATR fallback (no SMC structure)';
        }
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 3: SMART TAKE PROFITS
// Finds liquidity-based targets with probability
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartTPs(direction, currentPrice, slPrice, klines, zoneDetails) {
    const result = {
        tp1: null,
        tp2: null,
        tp3: null,
        fallbackUsed: false
    };
    
    if (!klines || klines.length < 50) {
        // Fallback to R:R based
        const risk = Math.abs(currentPrice - slPrice);
        result.tp1 = { price: direction === 'LONG' ? currentPrice + risk * 1.5 : currentPrice - risk * 1.5, reason: 'R:R fallback', probability: 60 };
        result.tp2 = { price: direction === 'LONG' ? currentPrice + risk * 2.5 : currentPrice - risk * 2.5, reason: 'R:R fallback', probability: 45 };
        result.tp3 = { price: direction === 'LONG' ? currentPrice + risk * 4 : currentPrice - risk * 4, reason: 'R:R fallback', probability: 30 };
        result.fallbackUsed = true;
        return result;
    }
    
    const equalLevels = detectEqualLevels(klines, 0.002);
    const orderBlocks = detectOrderBlocks(klines, 50);
    const risk = Math.abs(currentPrice - slPrice);
    
    // Collect target candidates
    const candidates = [];
    const minDist = 0.01; // Min 1% from entry
    const maxDist = 0.15; // Max 15% from entry
    
    if (direction === 'LONG') {
        // Equal Highs = Liquidity targets (highest probability)
        equalLevels.equalHighs.filter(eh => {
            const dist = (eh.price - currentPrice) / currentPrice;
            return dist > minDist && dist < maxDist;
        }).forEach(eh => {
            candidates.push({
                price: eh.price,
                type: 'EQH',
                reason: `Equal Highs (${eh.count} touches)`,
                dist: ((eh.price - currentPrice) / currentPrice) * 100,
                probability: 80, // High prob - liquidity always gets grabbed
                score: 90 + (eh.count * 5)
            });
        });
        
        // Bearish OBs = Reversal zones (medium probability)
        orderBlocks.bearish.filter(ob => {
            const dist = (ob.low - currentPrice) / currentPrice;
            return dist > minDist && dist < maxDist && ob.fresh;
        }).forEach(ob => {
            candidates.push({
                price: ob.low,
                type: 'BEAR_OB',
                reason: 'Bearish OB (reversal zone)',
                dist: ((ob.low - currentPrice) / currentPrice) * 100,
                probability: 65,
                score: 75
            });
        });
        
        // Resistance zones (medium probability)
        if (zoneDetails && zoneDetails.nearestResistance) {
            const res = zoneDetails.nearestResistance;
            const dist = (res.low - currentPrice) / currentPrice;
            if (dist > minDist && dist < maxDist) {
                candidates.push({
                    price: res.low,
                    type: 'RESISTANCE',
                    reason: 'Resistance zone',
                    dist: dist * 100,
                    probability: 60,
                    score: 60
                });
            }
        }
        
    } else { // SHORT
        // Equal Lows = Liquidity targets
        equalLevels.equalLows.filter(el => {
            const dist = (currentPrice - el.price) / currentPrice;
            return dist > minDist && dist < maxDist;
        }).forEach(el => {
            candidates.push({
                price: el.price,
                type: 'EQL',
                reason: `Equal Lows (${el.count} touches)`,
                dist: ((currentPrice - el.price) / currentPrice) * 100,
                probability: 80,
                score: 90 + (el.count * 5)
            });
        });
        
        // Bullish OBs = Reversal zones
        orderBlocks.bullish.filter(ob => {
            const dist = (currentPrice - ob.high) / currentPrice;
            return dist > minDist && dist < maxDist && ob.fresh;
        }).forEach(ob => {
            candidates.push({
                price: ob.high,
                type: 'BULL_OB',
                reason: 'Bullish OB (reversal zone)',
                dist: ((currentPrice - ob.high) / currentPrice) * 100,
                probability: 65,
                score: 75
            });
        });
        
        // Support zones
        if (zoneDetails && zoneDetails.nearestSupport) {
            const sup = zoneDetails.nearestSupport;
            const dist = (currentPrice - sup.high) / currentPrice;
            if (dist > minDist && dist < maxDist) {
                candidates.push({
                    price: sup.high,
                    type: 'SUPPORT',
                    reason: 'Support zone',
                    dist: dist * 100,
                    probability: 60,
                    score: 60
                });
            }
        }
    }
    
    // Sort by distance (closer first for TP1, further for TP3)
    candidates.sort((a, b) => a.dist - b.dist);
    
    // Select TPs with minimum 1.5% gap between them
    const selectedTPs = [];
    const minGap = 1.5;
    
    for (const c of candidates) {
        if (selectedTPs.length === 0) {
            // First TP - must be at least 1.5R
            const rrRatio = c.dist / (parseFloat(result.tp1?.dist) || (Math.abs(currentPrice - slPrice) / currentPrice * 100));
            selectedTPs.push(c);
        } else {
            // Check gap from last selected TP
            const lastTP = selectedTPs[selectedTPs.length - 1];
            const gap = Math.abs(c.dist - lastTP.dist);
            if (gap >= minGap && selectedTPs.length < 3) {
                // Reduce probability for further TPs
                c.probability = Math.max(30, c.probability - (selectedTPs.length * 15));
                selectedTPs.push(c);
            }
        }
        if (selectedTPs.length >= 3) break;
    }
    
    // Assign to result
    if (selectedTPs.length >= 1) {
        result.tp1 = {
            price: selectedTPs[0].price,
            type: selectedTPs[0].type,
            reason: selectedTPs[0].reason,
            distPct: selectedTPs[0].dist.toFixed(2),
            probability: selectedTPs[0].probability,
            rrRatio: (selectedTPs[0].dist / (Math.abs(currentPrice - slPrice) / currentPrice * 100)).toFixed(1)
        };
    }
    
    if (selectedTPs.length >= 2) {
        result.tp2 = {
            price: selectedTPs[1].price,
            type: selectedTPs[1].type,
            reason: selectedTPs[1].reason,
            distPct: selectedTPs[1].dist.toFixed(2),
            probability: selectedTPs[1].probability,
            rrRatio: (selectedTPs[1].dist / (Math.abs(currentPrice - slPrice) / currentPrice * 100)).toFixed(1)
        };
    }
    
    if (selectedTPs.length >= 3) {
        result.tp3 = {
            price: selectedTPs[2].price,
            type: selectedTPs[2].type,
            reason: selectedTPs[2].reason,
            distPct: selectedTPs[2].dist.toFixed(2),
            probability: selectedTPs[2].probability,
            rrRatio: (selectedTPs[2].dist / (Math.abs(currentPrice - slPrice) / currentPrice * 100)).toFixed(1)
        };
    }
    
    // Fallback for missing TPs
    if (!result.tp1) {
        result.tp1 = { price: direction === 'LONG' ? currentPrice + risk * 1.5 : currentPrice - risk * 1.5, reason: '1.5R (fallback)', probability: 65, distPct: ((risk * 1.5) / currentPrice * 100).toFixed(2) };
        result.fallbackUsed = true;
    }
    if (!result.tp2) {
        result.tp2 = { price: direction === 'LONG' ? currentPrice + risk * 2.5 : currentPrice - risk * 2.5, reason: '2.5R (fallback)', probability: 50, distPct: ((risk * 2.5) / currentPrice * 100).toFixed(2) };
    }
    if (!result.tp3) {
        result.tp3 = { price: direction === 'LONG' ? currentPrice + risk * 4 : currentPrice - risk * 4, reason: '4R (fallback)', probability: 35, distPct: ((risk * 4) / currentPrice * 100).toFixed(2) };
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 4: ENTRY GRADE CALCULATOR
// Grades entries from A+ to D based on SL distance, ATR, structure
// ─────────────────────────────────────────────────────────────────────────────────
function calculateEntryGrade(entryPrice, slPrice, atr, structureScore = 70) {
    const result = {
        grade: 'C',
        score: 50,
        slDistScore: 0,
        atrScore: 0,
        structureScore: 0,
        leverage: { safe: 5, max: 10 },
        size: '50%',
        confidence: 'MEDIUM'
    };
    
    const slDist = Math.abs(entryPrice - slPrice) / entryPrice * 100;
    const atrRatio = Math.abs(entryPrice - slPrice) / atr;
    
    // SL Distance Score (40% weight)
    if (slDist < 0.5) result.slDistScore = 100;
    else if (slDist < 0.75) result.slDistScore = 90;
    else if (slDist < 1.0) result.slDistScore = 80;
    else if (slDist < 1.25) result.slDistScore = 70;
    else if (slDist < 1.5) result.slDistScore = 60;
    else if (slDist < 2.0) result.slDistScore = 50;
    else if (slDist < 2.5) result.slDistScore = 40;
    else result.slDistScore = 25;
    
    // ATR Safety Score (30% weight) - SL should be 1-2x ATR
    if (atrRatio >= 2.0) result.atrScore = 100;
    else if (atrRatio >= 1.5) result.atrScore = 90;
    else if (atrRatio >= 1.2) result.atrScore = 75;
    else if (atrRatio >= 1.0) result.atrScore = 60;
    else if (atrRatio >= 0.7) result.atrScore = 40;
    else result.atrScore = 20; // Too tight, will get stopped
    
    // Structure Score (30% weight) - passed in
    result.structureScore = Math.min(100, Math.max(0, structureScore));
    
    // Calculate final score
    result.score = Math.round(
        (result.slDistScore * 0.4) +
        (result.atrScore * 0.3) +
        (result.structureScore * 0.3)
    );
    
    // Assign grade
    if (result.score >= 85) {
        result.grade = 'A+';
        result.leverage = { safe: 12, max: 20 };
        result.size = '100%';
        result.confidence = 'VERY HIGH';
    } else if (result.score >= 75) {
        result.grade = 'A';
        result.leverage = { safe: 10, max: 15 };
        result.size = '100%';
        result.confidence = 'HIGH';
    } else if (result.score >= 65) {
        result.grade = 'B+';
        result.leverage = { safe: 8, max: 12 };
        result.size = '75%';
        result.confidence = 'GOOD';
    } else if (result.score >= 55) {
        result.grade = 'B';
        result.leverage = { safe: 6, max: 10 };
        result.size = '75%';
        result.confidence = 'GOOD';
    } else if (result.score >= 45) {
        result.grade = 'C';
        result.leverage = { safe: 5, max: 7 };
        result.size = '50%';
        result.confidence = 'MEDIUM';
    } else {
        result.grade = 'D';
        result.leverage = { safe: 3, max: 5 };
        result.size = '25%';
        result.confidence = 'LOW';
    }
    
    result.slDistPct = slDist.toFixed(2);
    result.atrRatio = atrRatio.toFixed(2);
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 5: SMART ENTRY DECISION
// Decides MARKET / LIMIT / WAIT / SKIP
// ─────────────────────────────────────────────────────────────────────────────────
function determineSmartEntry(direction, grade, momentumData, candleData, pullbacks) {
    const result = {
        decision: 'MARKET',
        reason: '',
        sizing: {
            market: 25,
            pullback1: 50,
            pullback2: 25
        }
    };
    
    // Check if price is running (strong momentum)
    const isRunning = momentumData && (
        (direction === 'LONG' && momentumData.details.rsi && momentumData.details.rsi.value > 65) ||
        (direction === 'SHORT' && momentumData.details.rsi && momentumData.details.rsi.value < 35)
    );
    
    // Check if extended (overbought/oversold)
    const isExtended = momentumData && (
        (direction === 'LONG' && momentumData.details.rsi && momentumData.details.rsi.value > 75) ||
        (direction === 'SHORT' && momentumData.details.rsi && momentumData.details.rsi.value < 25)
    );
    
    // Check candle pattern
    const hasBullishPattern = candleData && candleData.patternSignal === 'BULLISH';
    const hasBearishPattern = candleData && candleData.patternSignal === 'BEARISH';
    const controlBuyers = candleData && candleData.behavior && candleData.behavior.control === 'BUYERS';
    const controlSellers = candleData && candleData.behavior && candleData.behavior.control === 'SELLERS';
    
    // Decision logic
    if (isExtended) {
        result.decision = 'WAIT';
        result.reason = 'Price extended - wait for pullback';
        result.sizing = { market: 0, pullback1: 60, pullback2: 40 };
    } else if (isRunning && grade.score >= 65) {
        result.decision = 'MARKET';
        result.reason = 'Strong momentum - enter now';
        result.sizing = { market: 50, pullback1: 35, pullback2: 15 };
    } else if (!isRunning && pullbacks.pullback1) {
        result.decision = 'LIMIT';
        result.reason = 'Moderate momentum - wait for pullback';
        result.sizing = { market: 25, pullback1: 50, pullback2: 25 };
    } else if (grade.grade === 'D') {
        result.decision = 'WAIT';
        result.reason = 'Low grade entry - wait for better setup';
        result.sizing = { market: 0, pullback1: 75, pullback2: 25 };
    } else {
        result.decision = 'MARKET';
        result.reason = 'Standard entry';
        result.sizing = { market: 25, pullback1: 50, pullback2: 25 };
    }
    
    // Adjust sizing based on grade
    if (grade.grade === 'A+' || grade.grade === 'A') {
        if (result.decision === 'MARKET') {
            result.sizing.market = Math.min(100, result.sizing.market + 25);
        }
    } else if (grade.grade === 'D') {
        result.sizing.market = Math.max(0, result.sizing.market - 15);
        result.sizing.pullback1 = Math.min(75, result.sizing.pullback1 + 10);
    }
    
    // Check for conflicting patterns
    if (direction === 'LONG' && hasBearishPattern) {
        result.decision = 'WAIT';
        result.reason = 'Bearish candle pattern - wait for confirmation';
    } else if (direction === 'SHORT' && hasBullishPattern) {
        result.decision = 'WAIT';
        result.reason = 'Bullish candle pattern - wait for confirmation';
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// ENGINE 6: SMART EXIT MONITOR
// Real-time monitoring for exit signals
// ─────────────────────────────────────────────────────────────────────────────────
function monitorTradeExit(direction, entryPrice, currentPrice, tpData, klines) {
    const result = {
        recommendation: 'HOLD',
        reason: '',
        tp1Prob: tpData.tp1 ? tpData.tp1.probability : 65,
        tp2Prob: tpData.tp2 ? tpData.tp2.probability : 50,
        tp3Prob: tpData.tp3 ? tpData.tp3.probability : 35,
        warnings: [],
        urgency: 'LOW'
    };
    
    if (!klines || klines.length < 10) return result;
    
    const recentKlines = klines.slice(-10);
    const candlePatterns = analyzeCandlePatterns(klines);
    const closes = klines.map(k => k.close);
    const rsi = calcRSI(closes, 14);
    const macd = calcMACD(closes);
    
    // Check for reversal candle patterns
    if (candlePatterns.patterns && candlePatterns.patterns.length > 0) {
        const recentPatterns = candlePatterns.patterns.filter(p => p.index >= klines.length - 3);
        
        for (const pattern of recentPatterns) {
            if (direction === 'LONG') {
                if (['Shooting Star', 'Bearish Engulfing', 'Evening Star', 'Hanging Man'].includes(pattern.name)) {
                    result.warnings.push(`${pattern.name} detected`);
                    result.tp2Prob = Math.max(15, result.tp2Prob - 20);
                    result.tp3Prob = Math.max(10, result.tp3Prob - 25);
                }
            } else {
                if (['Hammer', 'Bullish Engulfing', 'Morning Star', 'Inverted Hammer'].includes(pattern.name)) {
                    result.warnings.push(`${pattern.name} detected`);
                    result.tp2Prob = Math.max(15, result.tp2Prob - 20);
                    result.tp3Prob = Math.max(10, result.tp3Prob - 25);
                }
            }
        }
    }
    
    // Check for momentum divergence
    if (direction === 'LONG') {
        // Price making higher high but RSI lower high = bearish divergence
        const priceHigh = Math.max(...recentKlines.map(k => k.high));
        const prevPriceHigh = Math.max(...klines.slice(-20, -10).map(k => k.high));
        
        if (priceHigh > prevPriceHigh && rsi < 60) {
            result.warnings.push('RSI divergence forming');
            result.tp2Prob = Math.max(20, result.tp2Prob - 15);
            result.tp3Prob = Math.max(15, result.tp3Prob - 20);
        }
    } else {
        const priceLow = Math.min(...recentKlines.map(k => k.low));
        const prevPriceLow = Math.min(...klines.slice(-20, -10).map(k => k.low));
        
        if (priceLow < prevPriceLow && rsi > 40) {
            result.warnings.push('RSI divergence forming');
            result.tp2Prob = Math.max(20, result.tp2Prob - 15);
            result.tp3Prob = Math.max(15, result.tp3Prob - 20);
        }
    }
    
    // Check for volume dying
    const recentVol = recentKlines.slice(-3).reduce((s, k) => s + k.volume, 0) / 3;
    const avgVol = klines.slice(-20).reduce((s, k) => s + k.volume, 0) / 20;
    
    if (recentVol < avgVol * 0.6) {
        result.warnings.push('Volume declining');
        result.tp2Prob = Math.max(20, result.tp2Prob - 10);
        result.tp3Prob = Math.max(15, result.tp3Prob - 15);
    }
    
    // Check for failed breakout
    if (direction === 'LONG' && tpData.tp1) {
        const nearTP1 = Math.abs(currentPrice - tpData.tp1.price) / tpData.tp1.price < 0.005;
        if (nearTP1) {
            // Check if rejected
            const rejectionCandle = recentKlines[recentKlines.length - 1];
            const upperWick = rejectionCandle.high - Math.max(rejectionCandle.open, rejectionCandle.close);
            const body = Math.abs(rejectionCandle.close - rejectionCandle.open);
            
            if (upperWick > body * 2) {
                result.warnings.push('Rejection at TP1 level');
                result.tp2Prob = Math.max(15, result.tp2Prob - 25);
                result.tp3Prob = Math.max(10, result.tp3Prob - 30);
            }
        }
    }
    
    // Determine recommendation
    if (result.warnings.length >= 3) {
        result.recommendation = 'EXIT';
        result.reason = 'Multiple warning signals - exit recommended';
        result.urgency = 'HIGH';
    } else if (result.warnings.length >= 2) {
        result.recommendation = 'REDUCE';
        result.reason = 'Warning signals detected - consider reducing position';
        result.urgency = 'MEDIUM';
    } else if (result.warnings.length === 1) {
        result.recommendation = 'CAUTION';
        result.reason = 'Minor warning - monitor closely';
        result.urgency = 'LOW';
    } else {
        result.recommendation = 'HOLD';
        result.reason = 'No warning signals - trade on track';
    }
    
    // MACD cross check
    if (macd && macd.histogram) {
        const histLen = macd.histogram.length;
        if (histLen >= 2) {
            const currentHist = macd.histogram[histLen - 1];
            const prevHist = macd.histogram[histLen - 2];
            
            if (direction === 'LONG' && currentHist < prevHist && currentHist < 0) {
                result.warnings.push('MACD momentum weakening');
                result.tp2Prob = Math.max(20, result.tp2Prob - 10);
            } else if (direction === 'SHORT' && currentHist > prevHist && currentHist > 0) {
                result.warnings.push('MACD momentum weakening');
                result.tp2Prob = Math.max(20, result.tp2Prob - 10);
            }
        }
    }
    
    return result;
}

// ─────────────────────────────────────────────────────────────────────────────────
// MASTER FUNCTION: CALCULATE SMART TRADE LEVELS
// Combines all 6 engines into one comprehensive output
// ─────────────────────────────────────────────────────────────────────────────────
function calculateSmartTradeLevels(currentPrice, direction, atr, klines, zoneDetails, smcDetails, momentumData, candleData) {
    // Engine 1: Smart SL
    const smartSL = calculateSmartSL(direction, currentPrice, klines, atr);
    
    // Engine 2: Smart Pullbacks (needs SL)
    const smartPullbacks = calculateSmartPullbacks(direction, currentPrice, smartSL.price, klines, atr);
    
    // Engine 3: Smart TPs (needs SL)
    const smartTPs = calculateSmartTPs(direction, currentPrice, smartSL.price, klines, zoneDetails);
    
    // Calculate structure score for grade
    let structureScore = 50;
    if (smartSL.structureUsed === 'OB') structureScore += 20;
    if (smartSL.structureUsed === 'SWING') structureScore += 15;
    if (smartSL.trapAvoided) structureScore += 15;
    if (smartPullbacks.pullback1 && smartPullbacks.pullback1.type === 'OB') structureScore += 10;
    if (smartTPs.tp1 && smartTPs.tp1.type === 'EQH') structureScore += 10;
    
    // Engine 4: Entry Grade for Market entry
    const marketGrade = calculateEntryGrade(currentPrice, smartSL.price, atr, structureScore);
    
    // Entry grades for pullback levels
    let pb1Grade = null, pb2Grade = null;
    if (smartPullbacks.pullback1) {
        pb1Grade = calculateEntryGrade(smartPullbacks.pullback1.price, smartSL.price, atr, structureScore + 10);
    }
    if (smartPullbacks.pullback2) {
        pb2Grade = calculateEntryGrade(smartPullbacks.pullback2.price, smartSL.price, atr, structureScore + 15);
    }
    
    // Engine 5: Smart Entry Decision
    const entryDecision = determineSmartEntry(direction, marketGrade, momentumData, candleData, smartPullbacks);
    
    // Engine 6: Exit Monitor (initial state)
    const exitMonitor = monitorTradeExit(direction, currentPrice, currentPrice, smartTPs, klines);
    
    // Calculate average entry if all levels fill
    let avgEntry = currentPrice;
    if (smartPullbacks.pullback1 && smartPullbacks.pullback2) {
        avgEntry = (currentPrice * 0.25 + smartPullbacks.pullback1.price * 0.5 + smartPullbacks.pullback2.price * 0.25);
    } else if (smartPullbacks.pullback1) {
        avgEntry = (currentPrice * 0.4 + smartPullbacks.pullback1.price * 0.6);
    }
    
    // Calculate R:R from average entry
    const avgRisk = Math.abs(avgEntry - smartSL.price);
    const avgRewardTP2 = smartTPs.tp2 ? Math.abs(smartTPs.tp2.price - avgEntry) : avgRisk * 2.5;
    const avgRR = avgRisk > 0 ? (avgRewardTP2 / avgRisk).toFixed(2) : '0';
    
    return {
        // Entry Plan
        entry: {
            market: {
                price: currentPrice,
                grade: marketGrade,
                size: entryDecision.sizing.market + '%'
            },
            pullback1: smartPullbacks.pullback1 ? {
                price: smartPullbacks.pullback1.price,
                reason: smartPullbacks.pullback1.reason,
                distPct: smartPullbacks.pullback1.distPct,
                grade: pb1Grade,
                size: entryDecision.sizing.pullback1 + '%'
            } : null,
            pullback2: smartPullbacks.pullback2 ? {
                price: smartPullbacks.pullback2.price,
                reason: smartPullbacks.pullback2.reason,
                distPct: smartPullbacks.pullback2.distPct,
                grade: pb2Grade,
                size: entryDecision.sizing.pullback2 + '%'
            } : null,
            decision: entryDecision.decision,
            decisionReason: entryDecision.reason,
            avgEntry: avgEntry,
            marketOnly: smartPullbacks.marketOnly
        },
        
        // Stop Loss
        sl: {
            price: smartSL.price,
            reason: smartSL.reason,
            riskPct: smartSL.riskPct,
            trapAvoided: smartSL.trapAvoided,
            structureUsed: smartSL.structureUsed
        },
        
        // Take Profits
        tp1: smartTPs.tp1,
        tp2: smartTPs.tp2,
        tp3: smartTPs.tp3,
        
        // Risk/Reward
        rr: avgRR,
        avgEntry: avgEntry,
        
        // Exit Monitor
        exitMonitor: exitMonitor,
        
        // Legacy compatibility
        limitEntry: smartPullbacks.pullback1 ? smartPullbacks.pullback1.price : currentPrice * (direction === 'LONG' ? 0.995 : 1.005),
        limitType: smartPullbacks.pullback1 ? smartPullbacks.pullback1.type : 'ATR',
        limitConfidence: smartPullbacks.pullback1 ? smartPullbacks.pullback1.score : 50,
        limitRR: (smartPullbacks.pullback1 && smartTPs.tp2) ? 
            ((Math.abs(smartTPs.tp2.price - smartPullbacks.pullback1.price)) / (Math.abs(smartPullbacks.pullback1.price - smartSL.price))).toFixed(2) : avgRR,
        risk: Math.abs(currentPrice - smartSL.price),
        reward: smartTPs.tp2 ? Math.abs(smartTPs.tp2.price - currentPrice) : Math.abs(currentPrice - smartSL.price) * 2.5,
        riskPct: smartSL.riskPct
    };
}


// ═══════════════════════════════════════════════════════════════════════════════
// END OF SMART TRADE SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════════════
// MASTER INTEGRATION ENGINE - WEIGHTED AVERAGE SCORING
// ═══════════════════════════════════════════════════════════════════════════════

// HTF Bias Analysis
async function analyzeHTFBias(symbol, entryTF, direction) {
    const htfList = CONFIG.HTF_MAP[entryTF] || ['60', '240', 'D'];
    const result = {
        aligned: 0,
        total: htfList.length,
        bias: {},
        score: 0
    };
    
    for (const tf of htfList) {
        try {
            const klines = await fetchKlines(symbol, tf, 100);
            if (!klines || klines.length < 50) {
                result.bias[CONFIG.TF_LABELS[tf] || tf] = 'N/A';
                continue;
            }
            
            const closes = klines.map(k => k.close);
            const currentPrice = closes[closes.length - 1];
            
            // EMA 20 for trend
            const ema20 = calcEMA(closes, 20);
            // EMA 50 for stronger trend
            const ema50 = calcEMA(closes, 50);
            
            // Structure analysis
            const structure = detectStructure(klines);
            
            let bias = 'NEUTRAL';
            let biasStrength = 0;
            
            // Price above both EMAs = bullish
            if (currentPrice > ema20 && currentPrice > ema50 && structure.trend === 'BULLISH') {
                bias = 'BULLISH';
                biasStrength = 2;
            } else if (currentPrice > ema20 && currentPrice > ema50) {
                bias = 'BULLISH';
                biasStrength = 1;
            } else if (currentPrice < ema20 && currentPrice < ema50 && structure.trend === 'BEARISH') {
                bias = 'BEARISH';
                biasStrength = 2;
            } else if (currentPrice < ema20 && currentPrice < ema50) {
                bias = 'BEARISH';
                biasStrength = 1;
            }
            
            result.bias[CONFIG.TF_LABELS[tf] || tf] = bias;
            
            // Check alignment with entry direction
            if ((direction === 'LONG' && bias === 'BULLISH') ||
                (direction === 'SHORT' && bias === 'BEARISH')) {
                result.aligned++;
            }
            
            await sleep(50);
        } catch (e) {
            console.error(`HTF analysis error for ${tf}:`, e);
            result.bias[CONFIG.TF_LABELS[tf] || tf] = 'ERR';
        }
    }
    
    // Score based on alignment
    if (result.aligned === result.total) {
        result.score = 30; // Full alignment bonus
    } else if (result.aligned >= result.total - 1) {
        result.score = 20;
    } else if (result.aligned >= 1) {
        result.score = 10;
    }
    
    return result;
}

// Detect Conflicts between analyses
function detectConflicts(zone, smc, momentum) {
    const conflicts = [];
    let penalty = 0;
    
    // Zone vs SMC direction conflict
    if (zone.direction && smc.direction && zone.direction !== smc.direction) {
        conflicts.push('Zone vs SMC conflict');
        penalty += CONFIG.PENALTIES.ZONE_SMC_CONFLICT;
    }
    
    // SMC bullish but RSI overbought (exhaustion risk)
    if (smc.direction === 'LONG' && momentum.details.rsi && momentum.details.rsi.value >= 75) {
        conflicts.push('RSI exhaustion risk');
        penalty += CONFIG.PENALTIES.EXHAUSTION;
    }
    
    // SMC bearish but RSI oversold (exhaustion risk)
    if (smc.direction === 'SHORT' && momentum.details.rsi && momentum.details.rsi.value <= 25) {
        conflicts.push('RSI exhaustion risk');
        penalty += CONFIG.PENALTIES.EXHAUSTION;
    }
    
    // Divergence against trade direction
    const div = momentum.details.divergence;
    if (div) {
        if (smc.direction === 'LONG' && (div.rsi.direction === 'BEARISH' || div.macd.direction === 'BEARISH')) {
            conflicts.push('Divergence against long');
            penalty += CONFIG.PENALTIES.DIVERGENCE_AGAINST;
        }
        if (smc.direction === 'SHORT' && (div.rsi.direction === 'BULLISH' || div.macd.direction === 'BULLISH')) {
            conflicts.push('Divergence against short');
            penalty += CONFIG.PENALTIES.DIVERGENCE_AGAINST;
        }
    }
    
    return { conflicts, penalty };
}

// Calculate Trade Levels
function calculateTradeLevels(currentPrice, direction, atr, zoneDetails, smcDetails, adx) {
    let entry = currentPrice;
    let sl, tp1, tp2, tp3;
    
    const atrMultiplier = 2.0;
    
    // Calculate Smart Limit Entry
    const limitData = calculateSmartLimitEntry(currentPrice, direction, atr, zoneDetails, smcDetails, adx);
    
    if (direction === 'LONG') {
        // Stop loss below support or ATR-based
        if (zoneDetails.nearestSupport) {
            sl = Math.min(
                zoneDetails.nearestSupport.low * 0.998,
                currentPrice - atr * atrMultiplier
            );
        } else {
            sl = currentPrice - atr * atrMultiplier;
        }
        
        // Take profit levels
        const risk = entry - sl;
        tp1 = entry + risk * 1.5;  // 1:1.5 RR
        tp2 = entry + risk * 2.5;  // 1:2.5 RR
        tp3 = entry + risk * 4.0;  // 1:4 RR
        
        // Adjust TP if near resistance - ONLY if resistance is ABOVE calculated TP
        if (zoneDetails.nearestResistance && zoneDetails.nearestResistance.low > entry) {
            tp1 = Math.min(tp1, zoneDetails.nearestResistance.low * 0.998);
            // Ensure TP1 is still above entry
            if (tp1 <= entry) {
                tp1 = entry + risk * 1.5;
            }
        }
        
    } else { // SHORT
        // Stop loss above resistance or ATR-based
        if (zoneDetails.nearestResistance) {
            sl = Math.max(
                zoneDetails.nearestResistance.high * 1.002,
                currentPrice + atr * atrMultiplier
            );
        } else {
            sl = currentPrice + atr * atrMultiplier;
        }
        
        // Take profit levels
        const risk = sl - entry;
        tp1 = entry - risk * 1.5;
        tp2 = entry - risk * 2.5;
        tp3 = entry - risk * 4.0;
        
        // Adjust TP if near support - ONLY if support is BELOW calculated TP
        if (zoneDetails.nearestSupport && zoneDetails.nearestSupport.high < entry) {
            tp1 = Math.max(tp1, zoneDetails.nearestSupport.high * 1.002);
            // Ensure TP1 is still below entry
            if (tp1 >= entry) {
                tp1 = entry - risk * 1.5;
            }
        }
    }
    
    const risk = Math.abs(entry - sl);
    const reward = Math.abs(tp2 - entry);
    const rr = risk > 0 ? (reward / risk).toFixed(2) : '0';
    
    // Calculate R:R for limit entry
    const limitRisk = Math.abs(limitData.limitEntry - sl);
    const limitReward = Math.abs(tp2 - limitData.limitEntry);
    const limitRR = limitRisk > 0 ? (limitReward / limitRisk).toFixed(2) : '0';
    
    return {
        entry,
        limitEntry: limitData.limitEntry,
        limitType: limitData.entryType,
        limitConfidence: limitData.confidence,
        sl,
        tp1,
        tp2,
        tp3,
        rr,
        limitRR,
        risk,
        reward,
        riskPct: ((risk / entry) * 100).toFixed(2)
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// COIN RELATIVE STRENGTH (RS) - Compare coin performance vs BTC
// ═══════════════════════════════════════════════════════════════════════════════

async function calculateCoinRS(symbol, klines) {
    try {
        // Skip for BTC itself
        if (symbol === 'BTCUSDT') return 1.0;
        
        // Use cached BTC klines or fetch
        if (!STATE.btcKlines || STATE.btcKlines.length < 20) {
            STATE.btcKlines = await fetchKlines('BTCUSDT', '1h', 50);
        }
        
        if (!STATE.btcKlines || STATE.btcKlines.length < 20 || !klines || klines.length < 20) {
            return 1.0; // Default neutral RS
        }
        
        // Calculate 24h performance for both
        const coinStart = klines[klines.length - 25]?.close || klines[0].close;
        const coinEnd = klines[klines.length - 1].close;
        const coinChange = ((coinEnd - coinStart) / coinStart) * 100;
        
        const btcStart = STATE.btcKlines[STATE.btcKlines.length - 25]?.close || STATE.btcKlines[0].close;
        const btcEnd = STATE.btcKlines[STATE.btcKlines.length - 1].close;
        const btcChange = ((btcEnd - btcStart) / btcStart) * 100;
        
        // RS = coin performance / BTC performance
        // RS > 1 = outperforming BTC
        // RS < 1 = underperforming BTC
        
        // Handle zero/negative cases
        if (btcChange === 0) {
            return coinChange > 0 ? 1.5 : coinChange < 0 ? 0.5 : 1.0;
        }
        
        // Calculate relative strength ratio
        let rs;
        if (btcChange > 0 && coinChange > 0) {
            // Both up: coin/btc ratio
            rs = coinChange / btcChange;
        } else if (btcChange < 0 && coinChange < 0) {
            // Both down: inverse ratio (less down = stronger)
            rs = btcChange / coinChange;
        } else if (btcChange < 0 && coinChange > 0) {
            // BTC down, coin up = very strong
            rs = 1.5 + (coinChange / 10); // Bonus for going against BTC
        } else {
            // BTC up, coin down = very weak
            rs = 0.5 - (Math.abs(coinChange) / 20);
        }
        
        // Clamp to reasonable range (0.3 - 2.0)
        return Math.max(0.3, Math.min(2.0, rs));
        
    } catch (e) {
        console.warn('RS calculation error:', e);
        return 1.0; // Default neutral
    }
}

// MASTER SIGNAL ANALYSIS - Combines all three engines (V1 ULTIMATE)
async function analyzeSignal(symbol, tf) {
    try {
        // Fetch klines
        const klines = await fetchKlines(symbol, tf, 200);
        if (!klines || klines.length < 100) return null;
        
        const currentPrice = klines[klines.length - 1].close;
        const atr = calcATR(klines);
        
        // Run all three analyses
        const zoneAnalysis = await performZoneAnalysis(klines, symbol, tf, currentPrice);
        const smcAnalysis = performSMCAnalysis(klines, tf);
        const momentumAnalysis = performMomentumAnalysis(klines);
        
        // Run candle pattern analysis
        const candlePatterns = analyzeCandlePatterns(klines);
        
        // Determine primary direction (voting system)
        let votes = { LONG: 0, SHORT: 0 };
        
        // Track individual engine directions for agreement display
        // FIX: Added candle direction for completeness
        const candleDir = candlePatterns.patternSignal === 'BULLISH' ? 'LONG' : 
                          candlePatterns.patternSignal === 'BEARISH' ? 'SHORT' : 'NEUTRAL';
        const engineDirections = {
            zone: zoneAnalysis.direction,
            smc: smcAnalysis.direction,
            momentum: momentumAnalysis.direction,
            candle: candleDir
        };
        
        if (zoneAnalysis.direction === 'LONG') votes.LONG += 1.2; // Zone slightly higher weight
        else if (zoneAnalysis.direction === 'SHORT') votes.SHORT += 1.2;
        
        if (smcAnalysis.direction === 'LONG') votes.LONG += 1.2;
        else if (smcAnalysis.direction === 'SHORT') votes.SHORT += 1.2;
        
        if (momentumAnalysis.direction === 'LONG') votes.LONG += 1;
        else if (momentumAnalysis.direction === 'SHORT') votes.SHORT += 1;
        
        // Need at least 2 agreeing for a signal
        if (votes.LONG < 2 && votes.SHORT < 2) return null;
        
        const direction = votes.LONG > votes.SHORT ? 'LONG' : 'SHORT';
        
        // Count how many engines agree with final direction
        let agreed = 0;
        if (zoneAnalysis.direction === direction) agreed++;
        if (smcAnalysis.direction === direction) agreed++;
        if (momentumAnalysis.direction === direction) agreed++;
        
        // Get HTF bias
        const htfBias = await analyzeHTFBias(symbol, tf, direction);
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V1 ULTIMATE - NEW ENGINE INTEGRATIONS
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // 1. SEQUENCE VALIDATION (now with direction)
        const sequenceResult = validateSequence(smcAnalysis, zoneAnalysis, candlePatterns, klines, direction);
        
        // 2. PATTERN-AT-LEVEL CHECK (now with direction)
        const patternAtLevel = checkPatternAtLevel(candlePatterns, zoneAnalysis, smcAnalysis, currentPrice, direction);
        
        // 3. REJECTION SCORE
        const rejectionScore = calculateRejectionScore(klines, zoneAnalysis, smcAnalysis, direction);
        
        // 4. CONFLICT DETECTOR (Enhanced)
        const conflictResult = detectEngineConflicts(zoneAnalysis, smcAnalysis, momentumAnalysis, candlePatterns);
        
        // 5. ZONE OVERRIDE CHECK
        const zoneOverride = checkZoneOverride(zoneAnalysis, smcAnalysis, momentumAnalysis, direction, currentPrice);
        
        // 6. TRAP DETECTION (from candle patterns)
        // FIX #3: Improved trap detection logic
        // Bull Trap = Price broke up but will reverse down (traps longs)
        // Bear Trap = Price broke down but will reverse up (traps shorts)
        const trapPotential = candlePatterns.behavior?.trapPotential || 'LOW';
        const trapDetection = {
            isTrap: trapPotential === 'HIGH',
            type: trapPotential === 'HIGH' ? 
                  (direction === 'LONG' ? 'Bull Trap Risk' : 'Bear Trap Risk') : 'None',
            confidence: trapPotential === 'HIGH' ? 'HIGH' : 
                       trapPotential === 'MEDIUM' ? 'MEDIUM' : 'LOW',
            // Clear warning message
            warning: trapPotential === 'HIGH' ? 
                    `⚠️ HIGH ${direction === 'LONG' ? 'BULL' : 'BEAR'} TRAP RISK - ${direction} position may get trapped!` :
                    trapPotential === 'MEDIUM' ?
                    `⚠️ MEDIUM trap risk detected` : null
        };
        
        // 7. CHECK MANDATORY RULES
        const rulesResult = checkMandatoryRules(
            zoneAnalysis, smcAnalysis, momentumAnalysis, 
            htfBias, conflictResult, zoneOverride, trapDetection
        );
        
        // 8. RULE 5 CHECK (Momentum opposes with strength)
        const momDir = momentumAnalysis.direction || 'NEUTRAL';
        const momOpposing = (direction === 'LONG' && momDir === 'SHORT') || 
                           (direction === 'SHORT' && momDir === 'LONG');
        if (momOpposing && momentumAnalysis.score >= 50) {
            rulesResult.rules.rule5.passed = false;
            rulesResult.rules.rule5.reason = `Momentum ${momDir} opposes ${direction} with score ${momentumAnalysis.score}`;
            rulesResult.violations.push('RULE 5: Strong opposing momentum');
            if (rulesResult.verdict !== 'NO_TRADE') rulesResult.verdict = 'SKIP';
            rulesResult.allPassed = false;
        }
        
        // SKIP signal if rules say so (but still return for display with warning)
        const shouldSkip = rulesResult.verdict === 'SKIP' || rulesResult.verdict === 'NO_TRADE';
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // V1 ULTIMATE - NEW SCORING FORMULA
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // Check volume confirmation
        const avgVolume = klines.slice(-20).reduce((sum, k) => sum + k.volume, 0) / 20;
        const currentVolume = klines[klines.length - 1].volume;
        const volumeConfirmed = currentVolume > avgVolume * 1.2;
        
        // Calculate ULTIMATE score
        const ultimateScore = calculateUltimateScore(
            sequenceResult, rejectionScore, htfBias, momentumAnalysis, volumeConfirmed
        );
        
        // Use ULTIMATE score as total score
        let totalScore = ultimateScore.final;
        
        // Add pattern-at-level bonus
        totalScore += patternAtLevel.bonus;
        
        // Apply conflict penalty (if conflicts exist but not severe enough to skip)
        if (conflictResult.hasConflict && !shouldSkip) {
            totalScore -= conflictResult.conflictCount * 10;
        }
        
        // Ensure score is within bounds
        totalScore = Math.max(0, Math.min(100, Math.round(totalScore)));
        
        // If rules say NO_TRADE or SKIP, cap the score
        if (rulesResult.verdict === 'NO_TRADE') {
            totalScore = Math.min(totalScore, 30); // Cap at BREWING
        } else if (rulesResult.verdict === 'SKIP') {
            totalScore = Math.min(totalScore, 55); // Cap at HEATING
        }
        
        // Determine grade (V1 ULTIMATE thresholds: 90/75/60/45)
        let grade, status;
        if (totalScore >= CONFIG.GRADES.PERFECT) {
            grade = 'PERFECT';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.STRONG) {
            grade = 'STRONG';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.VALID) {
            grade = 'VALID';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.HEATING) {
            grade = 'HEATING';
            status = 'early';
        } else {
            grade = 'BREWING';
            status = 'early';
        }
        
        // Calculate trade levels using SMART TRADE SYSTEM
        const adxVal = momentumAnalysis.details.adx ? momentumAnalysis.details.adx.adx : 25;
        const smartLevels = calculateSmartTradeLevels(
            currentPrice, 
            direction, 
            atr, 
            klines, 
            zoneAnalysis.details, 
            smcAnalysis.details, 
            momentumAnalysis,
            candlePatterns
        );
        
        // Build levels object with backward compatibility
        const levels = {
            entry: smartLevels.entry.market.price,
            limitEntry: smartLevels.limitEntry,
            limitType: smartLevels.limitType,
            limitConfidence: smartLevels.limitConfidence,
            sl: smartLevels.sl.price,
            tp1: smartLevels.tp1.price,
            tp2: smartLevels.tp2.price,
            tp3: smartLevels.tp3.price,
            rr: smartLevels.rr,
            limitRR: smartLevels.limitRR,
            risk: smartLevels.risk,
            reward: smartLevels.reward,
            riskPct: smartLevels.riskPct,
            // NEW SMART DATA
            smart: smartLevels
        };
        
        // 🏦 FETCH INSTITUTIONAL DATA (Funding, OI, L/S Ratio)
        let instData = null;
        let instAnalysis = null;
        try {
            instData = await fetchInstitutionalData(symbol, currentPrice);
            instAnalysis = analyzeInstitutionalData(instData, direction);
        } catch(e) {
            console.log('Institutional data fetch skipped:', e.message);
        }
        
        // Combine all factors (MUST be declared BEFORE using)
        const allFactors = [
            ...zoneAnalysis.factors,
            ...smcAnalysis.factors,
            ...momentumAnalysis.factors
        ];
        
        // Add V1 ULTIMATE factors
        if (sequenceResult.completed >= 4) {
            allFactors.push(`Sequence ${sequenceResult.completed}/6 (${sequenceResult.quality})`);
        }
        if (patternAtLevel.atLevel) {
            allFactors.push(patternAtLevel.details);
        }
        if (rejectionScore.score >= 60) {
            allFactors.push(`Rejection Score ${rejectionScore.score}/100 (${rejectionScore.quality})`);
        }
        if (zoneOverride.eligible) {
            allFactors.push('Zone Override Active');
        }
        
        const allWarnings = [
            ...zoneAnalysis.warnings,
            ...smcAnalysis.warnings,
            ...momentumAnalysis.warnings
        ];
        
        // Add V1 ULTIMATE warnings
        if (conflictResult.hasConflict) {
            allWarnings.push(...conflictResult.conflicts);
        }
        if (!rulesResult.allPassed) {
            allWarnings.push(...rulesResult.violations);
        }
        if (sequenceResult.completed < 4) {
            allWarnings.push(`Sequence incomplete: ${sequenceResult.completed}/6`);
        }
        if (!patternAtLevel.atLevel && candlePatterns.patterns?.length > 0) {
            allWarnings.push('Pattern not at key level');
        }
        if (rejectionScore.score < 40 && rejectionScore.score > 0) {
            allWarnings.push(`Weak rejection: ${rejectionScore.score}/100`);
        }
        // Add trap warning if exists
        if (trapDetection.warning) {
            allWarnings.push(trapDetection.warning);
        }
        
        // Add institutional factors if available (AFTER declaration)
        if (instAnalysis && instAnalysis.factors) {
            allFactors.push(...instAnalysis.factors);
        }
        if (instAnalysis && instAnalysis.warnings) {
            allWarnings.push(...instAnalysis.warnings);
        }
        
        return {
            symbol,
            tf: CONFIG.TF_LABELS[tf] || tf,
            tfRaw: tf,
            price: currentPrice,
            direction,
            grade,
            status,
            score: totalScore,
            agreed,  // How many engines agreed (2 or 3)
            engineDirections,  // Individual engine directions
            scores: {
                zone: Math.round(zoneAnalysis.score),
                smc: Math.round(smcAnalysis.score),
                momentum: Math.round(momentumAnalysis.score),
                htf: htfBias.score,
                institutional: instAnalysis ? instAnalysis.score : 0,
                // V1 ULTIMATE scores
                sequence: sequenceResult.score,
                rejection: rejectionScore.score,
                patternAtLevel: patternAtLevel.bonus
            },
            // V1 ULTIMATE - Score breakdown
            ultimateScore: ultimateScore,
            zone: zoneAnalysis,
            smc: smcAnalysis,
            momentum: momentumAnalysis,
            candlePatterns: candlePatterns,
            htf: htfBias,
            levels,
            // 🏦 Institutional Data
            institutional: instData,
            instAnalysis: instAnalysis,
            factors: allFactors,
            warnings: allWarnings,
            conflicts: conflictResult.conflicts,
            atr,
            // ═══════════════════════════════════════════════════════════════════════════════
            // V1 ULTIMATE - NEW DATA
            // ═══════════════════════════════════════════════════════════════════════════════
            v1Ultimate: {
                sequence: sequenceResult,
                patternAtLevel: patternAtLevel,
                rejectionScore: rejectionScore,
                conflictDetector: conflictResult,
                zoneOverride: zoneOverride,
                trapDetection: trapDetection,
                rulesCheck: rulesResult,
                scoreBreakdown: ultimateScore.breakdown
            },
            // Coin Relative Strength (RS) vs BTC - calculated on the fly
            coinRS: await calculateCoinRS(symbol, klines)
        };
        
    } catch (error) {
        console.error(`Analysis error for ${symbol} ${tf}:`, error);
        return null;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MULTI-AI PROVIDER SYSTEM (v13 UPGRADE)
// ═══════════════════════════════════════════════════════════════════════════════

// Call Groq AI
async function callGroqAI(prompt) {
    console.log('🚀 Trying Groq AI...');
    
    // Get all valid keys to try
    const validKeys = GROQ_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.groq[item.index]);
    
    if (validKeys.length === 0) {
        console.log('❌ No Groq keys available');
        return null;
    }
    
    // Try each key until one works
    for (let attempt = 0; attempt < validKeys.length; attempt++) {
        const keyItem = validKeys[(currentGroqKeyIndex + attempt) % validKeys.length];
        const apiKey = keyItem.key;
        
        console.log(`🔑 Trying Groq Key #${keyItem.index + 1} (attempt ${attempt + 1}/${validKeys.length})`);
        
        try {
            const response = await fetch(CONFIG.GROQ_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + apiKey
                },
                body: JSON.stringify({
                    model: STATE.aiModel || 'llama-3.3-70b-versatile',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.3,
                    max_tokens: 2000
                })
            });
            
            if (response.status === 429) {
                console.log(`⏳ Groq Key #${keyItem.index + 1} rate limited, trying next key...`);
                KEY_STATUS.groq[keyItem.index] = false;  // Mark as temporarily failed
                continue;  // Try next key
            }
            
            const data = await response.json();
            if (data.error) {
                console.warn(`❌ Groq Key #${keyItem.index + 1} error:`, data.error.message);
                // Auth errors (invalid key) - mark as failed and try next
                if (data.error.code === 'invalid_api_key' || data.error.type === 'invalid_request_error') {
                    KEY_STATUS.groq[keyItem.index] = false;
                }
                continue;  // Try next key
            }
            
            if (data.choices && data.choices[0] && data.choices[0].message) {
                console.log(`✅ Groq Key #${keyItem.index + 1} success!`);
                KEY_STATUS.groq[keyItem.index] = true;  // Mark as working
                currentGroqKeyIndex = (currentGroqKeyIndex + attempt + 1) % validKeys.length;  // Update rotation
                return parseAIResponse(data.choices[0].message.content);
            }
        } catch (error) {
            console.error(`❌ Groq Key #${keyItem.index + 1} request failed:`, error);
            continue;  // Try next key
        }
    }
    
    console.log('❌ All Groq keys exhausted');
    return null;
}

// Call DeepSeek AI
async function callDeepSeekAI(prompt) {
    console.log('🚀 Trying DeepSeek AI...');
    
    // Get all valid keys to try
    const validKeys = DEEPSEEK_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.deepseek[item.index]);
    
    if (validKeys.length === 0) {
        console.log('❌ No DeepSeek keys available');
        return null;
    }
    
    // Try each key until one works
    for (let attempt = 0; attempt < validKeys.length; attempt++) {
        const keyItem = validKeys[(currentDeepSeekKeyIndex + attempt) % validKeys.length];
        const apiKey = keyItem.key;
        
        console.log(`🔑 Trying DeepSeek Key #${keyItem.index + 1} (attempt ${attempt + 1}/${validKeys.length})`);
        
        try {
            const response = await fetch(CONFIG.DEEPSEEK_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + apiKey
                },
                body: JSON.stringify({
                    model: 'deepseek-chat',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.3,
                    max_tokens: 2000
                })
            });
            
            if (response.status === 429) {
                console.log(`⏳ DeepSeek Key #${keyItem.index + 1} rate limited, trying next key...`);
                KEY_STATUS.deepseek[keyItem.index] = false;
                continue;  // Try next key
            }
            
            const data = await response.json();
            if (data.error) {
                console.warn(`❌ DeepSeek Key #${keyItem.index + 1} error:`, data.error.message);
                continue;  // Try next key
            }
            
            if (data.choices && data.choices[0] && data.choices[0].message) {
                console.log(`✅ DeepSeek Key #${keyItem.index + 1} success!`);
                KEY_STATUS.deepseek[keyItem.index] = true;
                currentDeepSeekKeyIndex = (currentDeepSeekKeyIndex + attempt + 1) % validKeys.length;
                return parseAIResponse(data.choices[0].message.content);
            }
        } catch (error) {
            console.error(`❌ DeepSeek Key #${keyItem.index + 1} request failed:`, error);
            continue;  // Try next key
        }
    }
    
    console.log('❌ All DeepSeek keys exhausted');
    return null;
}

// Call Gemini AI
async function callGeminiAI(prompt) {
    console.log('🚀 Trying Gemini AI...');
    
    // Get all valid keys to try
    const validKeys = GEMINI_KEYS.map((k, i) => ({ key: k, index: i }))
        .filter(item => item.key && item.key.trim() !== '' && KEY_ENABLED.gemini[item.index]);
    
    if (validKeys.length === 0) {
        console.log('❌ No Gemini keys available');
        return null;
    }
    
    // Models to try in order
    const models = [
        'gemini-2.0-flash',
        'gemini-1.5-flash',
        'gemini-1.5-flash-latest'
    ];
    
    // Try each key
    for (let keyAttempt = 0; keyAttempt < validKeys.length; keyAttempt++) {
        const keyItem = validKeys[(currentGeminiKeyIndex + keyAttempt) % validKeys.length];
        const apiKey = keyItem.key;
        
        console.log(`🔑 Trying Gemini Key #${keyItem.index + 1} (key ${keyAttempt + 1}/${validKeys.length})`);
        
        // Try each model with this key
        for (const model of models) {
            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                console.log(`🧠 Trying Gemini ${model}...`);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 2000
                        }
                    })
                });
                
                if (response.status === 429) {
                    console.log(`⏳ Gemini ${model} rate limited, trying next model...`);
                    continue;  // Try next model
                }
                
                if (response.status === 404) {
                    console.log(`⚠️ Model ${model} not found, trying next model...`);
                    continue;  // Try next model
                }
                
                const data = await response.json();
                if (data.error) {
                    console.warn(`❌ Gemini ${model} error:`, data.error.message);
                    // Auth errors mean key is bad, try next key
                    if (data.error.code === 400 || data.error.code === 401 || data.error.code === 403) {
                        KEY_STATUS.gemini[keyItem.index] = false;
                        break;  // Break to try next key
                    }
                    continue;  // Try next model
                }
                
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    console.log(`✅ Gemini ${model} with Key #${keyItem.index + 1} success!`);
                    KEY_STATUS.gemini[keyItem.index] = true;
                    currentGeminiKeyIndex = (currentGeminiKeyIndex + keyAttempt + 1) % validKeys.length;
                    // Update CONFIG to remember working model
                    CONFIG.GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
                    return parseAIResponse(data.candidates[0].content.parts[0].text);
                }
            } catch (error) {
                console.error(`❌ Gemini ${model} request failed:`, error);
                continue;  // Try next model
            }
        }
        // All models failed with this key, try next key
        console.log(`⚠️ All models failed with Key #${keyItem.index + 1}, trying next key...`);
    }
    
    console.log('❌ All Gemini keys and models exhausted');
    return null;
}

// Multi-AI with Auto-Failover (v13 Feature)
async function callMultiAI(prompt) {
    // NOTE: Lock is managed by caller (getAIAnalysis) - DO NOT double-lock here
    console.log('🧠 Multi-AI System Starting...');
    
    try {
        // Try Groq first (free, fast)
        let result = await callGroqAI(prompt);
        if (result) {
            result.aiProvider = 'Groq';
            return result;
        }
        
        // Fallback to DeepSeek (paid, best value)
        result = await callDeepSeekAI(prompt);
        if (result) {
            result.aiProvider = 'DeepSeek';
            return result;
        }
        
        // Final fallback to Gemini (free backup)
        result = await callGeminiAI(prompt);
        if (result) {
            result.aiProvider = 'Gemini';
            return result;
        }
        
        console.error('❌ All AI providers failed');
        toast('All AI providers unavailable', 'error');
        return null;
    } catch (e) {
        console.error('❌ Multi-AI error:', e);
        return null;
    }
}

// Legacy function for backwards compatibility
async function callAI(prompt) {
    return await callMultiAI(prompt);
}

function parseAIResponse(text) {
    console.log('🔄 Parsing AI response...');
    try {
        // Clean up response
        let clean = text.replace(/```json/gi, '').replace(/```/g, '').trim();
        const match = clean.match(/\{[\s\S]*\}/);
        
        if (match) {
            console.log('📋 Found JSON in response');
            const parsed = JSON.parse(match[0]);
            console.log('✅ JSON parsed successfully');
            console.log('📊 Parsed fields:', Object.keys(parsed).join(', '));
            
            return {
                // Core fields
                myDirection: parsed.myDirection || null,
                agreesWithScanner: parsed.agreesWithScanner !== undefined ? parsed.agreesWithScanner : true,
                confidence: Math.min(100, Math.max(0, parsed.confidence || 50)),
                verdict: ['NO_TRADE', 'TAKE', 'SKIP', 'WAIT'].includes(parsed.verdict) ? parsed.verdict : 'WAIT',
                entryType: parsed.entryType || 'NONE',
                
                // Rules check
                rulesCheck: parsed.rulesCheck || null,
                
                // Summary
                executiveSummary: parsed.executiveSummary || '',
                whyDisagree: parsed.whyDisagree || null,
                reasoning: parsed.executiveSummary || 'Analysis complete',
                
                // Confluence Counter
                confluenceCounter: parsed.confluenceCounter || null,
                
                // Trap Detection
                trapDetection: parsed.trapDetection || null,
                
                // Entry Timing
                entryTiming: parsed.entryTiming || null,
                
                // Zone Analysis
                zoneAnalysis: parsed.zoneAnalysis || null,
                
                // SMC Analysis
                smcAnalysis: parsed.smcAnalysis || null,
                
                // Momentum Analysis
                momentumAnalysis: parsed.momentumAnalysis || null,
                
                // Trade Plan (includes add-ons, leverage, size)
                tradePlan: parsed.tradePlan || null,
                
                // Risk Assessment
                riskAssessment: parsed.riskAssessment || null,
                
                // Action Plan
                actionPlan: parsed.actionPlan || null,
                
                // Legacy fields (keep for backward compatibility)
                candlePatternAnalysis: parsed.candlePatternAnalysis || null,
                leverageRecommendation: parsed.leverageRecommendation || null,
                professionalNotes: parsed.professionalNotes || '',
                marketContext: parsed.marketContext || '',
                tradeManagement: parsed.tradeManagement || null,
                risks: Array.isArray(parsed.risks) ? parsed.risks : [],
                suggestions: Array.isArray(parsed.suggestions) ? parsed.suggestions : [],
                leverageAdvice: parsed.leverageAdvice || '',
                
                // Saved Trade AI fields (for progress updates)
                commentary: parsed.commentary || null,
                recommendation: parsed.recommendation || null,
                moveSlToBE: parsed.moveSlToBE || false,
                warnings: Array.isArray(parsed.warnings) ? parsed.warnings : []
            };
        } else {
            console.warn('⚠️ No JSON found in response');
            console.log('📄 Raw text:', text.substring(0, 500));
        }
    } catch (e) {
        console.error('❌ AI parse error:', e);
        console.log('📄 Failed text:', text.substring(0, 500));
    }
    
    // Default response when parsing fails
    return {
        myDirection: null,
        agreesWithScanner: true,
        confidence: 50,
        verdict: 'WAIT',
        entryType: 'NONE',
        rulesCheck: null,
        reasoning: 'Could not parse AI response',
        executiveSummary: '',
        whyDisagree: null,
        confluenceCounter: null,
        trapDetection: null,
        entryTiming: null,
        zoneAnalysis: null,
        smcAnalysis: null,
        momentumAnalysis: null,
        tradePlan: null,
        riskAssessment: null,
        actionPlan: null,
        candlePatternAnalysis: null,
        leverageRecommendation: null,
        professionalNotes: '',
        marketContext: '',
        tradeManagement: null,
        risks: [],
        suggestions: [],
        leverageAdvice: '',
        // Saved Trade AI fields
        commentary: null,
        recommendation: null,
        moveSlToBE: false,
        warnings: []
    };
}

async function getAIAnalysis(signal) {
    if (!signal || !STATE.aiKey) return null;
    
    // SAFETY: Prevent concurrent AI calls
    if (STATE.aiCallInProgress) {
        console.warn('⚠️ AI call already in progress');
        toast('AI analysis in progress...', 'warning');
        return null;
    }
    
    STATE.aiCallInProgress = true;
    
    try {
        // Safe helper functions to prevent undefined errors
        const sf = (val, decimals = 2) => {
            if (val === undefined || val === null || isNaN(val)) return 'N/A';
            return Number(val).toFixed(decimals);
        };
        const ss = (val, fallback = 'N/A') => val !== undefined && val !== null ? val : fallback;
        
        // Safe object access
        const levels = signal.levels || {};
        const smc = signal.smc || {};
        const smcD = smc.details || {};
        const zone = signal.zone || {};
        const zoneD = zone.details || {};
        const mom = signal.momentum || {};
        const momD = mom.details || {};
        const htf = signal.htf || {};
        const scores = signal.scores || {};
        const candle = signal.candlePatterns || {};
        const candleC = candle.currentCandle || {};
        const candleB = candle.behavior || {};
        
        // Pre-calculate engine directions (treat score < 30 as NEUTRAL)
        const zoneDir = scores.zone >= 30 ? (zone.direction || 'NEUTRAL') : 'NEUTRAL';
        const smcDir = scores.smc >= 30 ? (smc.direction || 'NEUTRAL') : 'NEUTRAL';
        const momDir = scores.momentum >= 30 ? (mom.direction || 'NEUTRAL') : 'NEUTRAL';
        const candleDir = candle.patternSignal || 'NEUTRAL';
        
        // Count directions
        const dirs = [zoneDir, smcDir, momDir, candleDir];
        const longCount = dirs.filter(d => d === 'LONG' || d === 'BULLISH').length;
        const shortCount = dirs.filter(d => d === 'SHORT' || d === 'BEARISH').length;
        const neutralCount = dirs.filter(d => d === 'NEUTRAL' || d === null).length;
        
        // Pre-calculate conflicts
        const conflicts = [];
        if (zoneDir !== 'NEUTRAL' && zoneDir !== signal.direction) conflicts.push('Zone opposes scanner');
        if (smcDir !== 'NEUTRAL' && smcDir !== signal.direction) conflicts.push('SMC opposes scanner');
        if (momDir !== 'NEUTRAL' && momDir !== signal.direction) conflicts.push('Momentum opposes scanner');
        if (candleDir !== 'NEUTRAL' && candleDir !== signal.direction && candleDir !== 'BULLISH' && candleDir !== 'BEARISH') conflicts.push('Candle pattern opposes');
        
        // Pre-calculate rule violations
    const ruleViolations = [];
    if (scores.smc < 20) ruleViolations.push('RULE 1 VIOLATED: SMC < 20 (score: ' + scores.smc + ') → NO_TRADE');
    if (scores.smc >= 20 && scores.smc < 30) ruleViolations.push('RULE 2 WARNING: SMC < 30 (score: ' + scores.smc + ') → SKIP unless Zone Override');
    if (conflicts.length >= 2) ruleViolations.push('RULE 3 VIOLATED: 2+ engines conflict → SKIP');
    if (neutralCount >= 3) ruleViolations.push('RULE 4 WARNING: 2+ engines NEUTRAL → WAIT');
    if (momDir !== 'NEUTRAL' && momDir !== signal.direction && scores.momentum >= 50) ruleViolations.push('RULE 5 VIOLATED: Strong momentum opposes → SKIP');
    const htfPct = htf.total > 0 ? (htf.aligned / htf.total) * 100 : 0;
    if (htfPct < 50) ruleViolations.push('RULE 6 VIOLATED: HTF < 50% (' + htfPct.toFixed(0) + '%) → SKIP');
    
    // Check Zone Override eligibility
    const supportDist = zoneD.nearestSupport ? Math.abs(signal.price - zoneD.nearestSupport.price) / signal.price * 100 : 999;
    const resistDist = zoneD.nearestResistance ? Math.abs(signal.price - zoneD.nearestResistance.price) / signal.price * 100 : 999;
    const atSupport = supportDist <= 1;
    const atResistance = resistDist <= 1;
    const zoneOverrideEligible = scores.zone >= 75 && 
        ((signal.direction === 'LONG' && atSupport && (zoneD.nearestSupport?.touches || 0) >= 3) ||
         (signal.direction === 'SHORT' && atResistance && (zoneD.nearestResistance?.touches || 0) >= 3)) &&
        !(momDir !== 'NEUTRAL' && momDir !== signal.direction && scores.momentum >= 60);
    
    const prompt = `You are an INDEPENDENT institutional crypto trading analyst. You must form YOUR OWN opinion.

═══════════════════════════════════════════════════════════════════════════════
⚠️ CRITICAL: YOU ARE INDEPENDENT - DO NOT BLINDLY FOLLOW SCANNER
═══════════════════════════════════════════════════════════════════════════════

The scanner has suggested a direction. But YOU must:
1. Analyze ALL raw data independently
2. Form YOUR OWN direction based on evidence
3. DISAGREE with scanner if data doesn't support it
4. Follow the MANDATORY RULES below

═══════════════════════════════════════════════════════════════════════════════
MANDATORY RULES (YOU MUST FOLLOW - NO EXCEPTIONS)
═══════════════════════════════════════════════════════════════════════════════

RULE 1: SMC < 20 → NO_TRADE (unless Zone Override applies)
RULE 2: SMC < 30 → SKIP (unless Zone Override applies)
RULE 3: 2+ engines oppose scanner direction → SKIP
RULE 4: 2+ engines NEUTRAL (no direction) → WAIT
RULE 5: Momentum opposes scanner AND momentum score ≥ 50 → SKIP
RULE 6: HTF alignment < 50% → SKIP
RULE 7: Trap detected with HIGH confidence → NO_TRADE

ZONE OVERRIDE (Exception to Rules 1-2):
Can override IF ALL of these are true:
✓ Zone Score ≥ 75
✓ Price within 1% of zone
✓ Zone has 3+ touches
✓ Zone direction matches scanner
✓ Momentum NOT strongly opposing (score < 60 if opposing)

═══════════════════════════════════════════════════════════════════════════════
PRE-CALCULATED RULE CHECK (by scanner)
═══════════════════════════════════════════════════════════════════════════════
${ruleViolations.length > 0 ? '🚨 VIOLATIONS DETECTED:\n' + ruleViolations.map(r => '• ' + r).join('\n') : '✅ No rule violations detected'}

Zone Override Eligible: ${zoneOverrideEligible ? 'YES ✅' : 'NO ❌'}
${zoneOverrideEligible ? '→ Zone Override allows entry despite weak SMC' : ''}

═══════════════════════════════════════════════════════════════════════════════
ENGINE DIRECTIONS (Score < 30 = Treated as NEUTRAL)
═══════════════════════════════════════════════════════════════════════════════
┌──────────────┬───────────┬────────┬─────────────────────────────┐
│ Engine       │ Direction │ Score  │ Status                      │
├──────────────┼───────────┼────────┼─────────────────────────────┤
│ Zone         │ ${zoneDir.padEnd(9)} │ ${String(scores.zone || 0).padEnd(6)} │ ${scores.zone >= 30 ? 'Reliable' : '⚠️ Weak (ignored)'} │
│ SMC          │ ${smcDir.padEnd(9)} │ ${String(scores.smc || 0).padEnd(6)} │ ${scores.smc >= 30 ? 'Reliable' : scores.smc < 20 ? '⛔ Critical' : '⚠️ Weak'} │
│ Momentum     │ ${momDir.padEnd(9)} │ ${String(scores.momentum || 0).padEnd(6)} │ ${scores.momentum >= 30 ? 'Reliable' : '⚠️ Weak (ignored)'} │
│ Candle       │ ${candleDir.padEnd(9)} │ ${String(candle.strength || 0).padEnd(6)} │ ${candle.strength >= 30 ? 'Reliable' : 'Weak'} │
└──────────────┴───────────┴────────┴─────────────────────────────┘

Scanner Direction: ${signal.direction}
Agreement: LONG=${longCount} | SHORT=${shortCount} | NEUTRAL=${neutralCount}
Conflicts: ${conflicts.length > 0 ? conflicts.join(', ') : 'None'}

═══════════════════════════════════════════════════════════════════════════════
SIGNAL DATA
═══════════════════════════════════════════════════════════════════════════════
Asset: ${ss(signal.symbol)}
Timeframe: ${ss(signal.tf)}
Current Price: $${ss(signal.price)}
Overall Grade: ${ss(signal.grade)} (${ss(signal.score, 0)}/100)
Warnings: ${signal.warnings?.length > 0 ? signal.warnings.join(', ') : 'None'}

═══════════════════════════════════════════════════════════════════════════════
ZONE DATA
═══════════════════════════════════════════════════════════════════════════════
Zone Score: ${scores.zone}/100
Zone Status: ${ss(zone.status)} ${atSupport ? '🎯 AT SUPPORT!' : atResistance ? '🎯 AT RESISTANCE!' : ''}

Support: ${zoneD.nearestSupport ? '$' + sf(zoneD.nearestSupport.price, 4) + ' (Strength: ' + (zoneD.nearestSupport.strength || 'N/A') + ', Touches: ' + (zoneD.nearestSupport.touches || 'N/A') + ', Distance: ' + sf(supportDist, 2) + '%)' : 'N/A'}
Resistance: ${zoneD.nearestResistance ? '$' + sf(zoneD.nearestResistance.price, 4) + ' (Strength: ' + (zoneD.nearestResistance.strength || 'N/A') + ', Touches: ' + (zoneD.nearestResistance.touches || 'N/A') + ', Distance: ' + sf(resistDist, 2) + '%)' : 'N/A'}

═══════════════════════════════════════════════════════════════════════════════
SMC DATA
═══════════════════════════════════════════════════════════════════════════════
SMC Score: ${scores.smc}/100 ${scores.smc < 20 ? '⛔ CRITICAL - NO STRUCTURE' : scores.smc < 30 ? '⚠️ WEAK' : ''}
Structure: ${smcD.structure ? ss(smcD.structure.trend) : 'N/A'}
Trigger: ${ss(smc.trigger, 'None')}
Order Blocks: ${smcD.orderBlocks ? 'Bull: ' + (smcD.orderBlocks.bullish?.length || 0) + ' Bear: ' + (smcD.orderBlocks.bearish?.length || 0) : 'N/A'}
FVGs: ${smcD.fvg ? 'Bull: ' + (smcD.fvg.bullish?.length || 0) + ' Bear: ' + (smcD.fvg.bearish?.length || 0) : 'N/A'}

═══════════════════════════════════════════════════════════════════════════════
MOMENTUM DATA
═══════════════════════════════════════════════════════════════════════════════
Momentum Score: ${scores.momentum}/100
Momentum Direction: ${momDir} ${momDir !== 'NEUTRAL' && momDir !== signal.direction ? '⚠️ OPPOSES SCANNER!' : ''}
RSI: ${momD.rsi ? sf(momD.rsi.value, 1) + ' (' + ss(momD.rsi.trend) + ')' : 'N/A'}
MACD: ${momD.macd ? ss(momD.macd.trend) + (momD.macd.crossover ? ' ' + momD.macd.crossover : '') : 'N/A'}
StochRSI: ${momD.stochRSI ? 'K:' + sf(momD.stochRSI.k, 1) + ' D:' + sf(momD.stochRSI.d, 1) : 'N/A'}

═══════════════════════════════════════════════════════════════════════════════
CANDLE PATTERN DATA
═══════════════════════════════════════════════════════════════════════════════
Current Candle: ${ss(candleC.type, 'Unknown')}
Pattern Signal: ${candleDir} ${candleDir !== 'NEUTRAL' && candleDir !== signal.direction ? '⚠️ OPPOSES SCANNER!' : ''}
Patterns: ${candle.patterns?.length > 0 ? candle.patterns.map(p => p.name + ' (' + p.signal + ')').join(', ') : 'None'}
Who's In Control: ${ss(candleB.control, 'Unknown')}
controlBuyers: ${candle.controlBuyers ? 'TRUE ✅' : 'FALSE'}
controlSellers: ${candle.controlSellers ? 'TRUE ✅' : 'FALSE'}
Trap Potential: ${ss(candleB.trapPotential, 'Low')}
${signal.v1Ultimate?.trapDetection?.warning ? '🚨 ' + signal.v1Ultimate.trapDetection.warning : ''}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - SEQUENCE VALIDATION (NEW!)
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Sequence State: ${signal.v1Ultimate.sequence.state}
Sequence Score: ${signal.v1Ultimate.sequence.score}/100
Steps Completed: ${signal.v1Ultimate.sequence.completed}/${signal.v1Ultimate.sequence.total}
Sequence Quality: ${signal.v1Ultimate.sequence.quality}

Steps:
• Sweep: ${signal.v1Ultimate.sequence.steps.sweep ? '✅' : '❌'}
• BOS/CHoCH: ${signal.v1Ultimate.sequence.steps.bos ? '✅' : '❌'}
• FVG: ${signal.v1Ultimate.sequence.steps.fvg ? '✅' : '❌'}
• Order Block: ${signal.v1Ultimate.sequence.steps.ob ? '✅' : '❌'}
• Pullback to POI: ${signal.v1Ultimate.sequence.steps.pullback ? '✅' : '❌'}
• Pattern at POI: ${signal.v1Ultimate.sequence.steps.pattern ? '✅' : '❌'}
` : 'Sequence data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - PATTERN-AT-LEVEL (NEW!)
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Pattern at Level: ${signal.v1Ultimate.patternAtLevel.atLevel ? 'YES ✅' : 'NO ❌'}
Level Type: ${signal.v1Ultimate.patternAtLevel.levelType}
Distance: ${signal.v1Ultimate.patternAtLevel.distancePercent?.toFixed(2) || 'N/A'}%
Bonus Points: +${signal.v1Ultimate.patternAtLevel.bonus}
Details: ${signal.v1Ultimate.patternAtLevel.details}
` : 'Pattern-at-Level data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - REJECTION SCORE (NEW!)
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Rejection Score: ${signal.v1Ultimate.rejectionScore.score}/100
Rejection Quality: ${signal.v1Ultimate.rejectionScore.quality}

Breakdown:
• Wick Touch: +${signal.v1Ultimate.rejectionScore.breakdown.wickTouch}
• Body Closed: +${signal.v1Ultimate.rejectionScore.breakdown.bodyClosed}
• Wick Ratio: +${signal.v1Ultimate.rejectionScore.breakdown.wickRatio}
• Volume Confirm: +${signal.v1Ultimate.rejectionScore.breakdown.volumeConfirm}
• Follow Through: +${signal.v1Ultimate.rejectionScore.breakdown.followThrough}
` : 'Rejection Score data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - ZONE OVERRIDE STATUS
═══════════════════════════════════════════════════════════════════════════════
${signal.v1Ultimate ? `
Zone Override Eligible: ${signal.v1Ultimate.zoneOverride.eligible ? 'YES ✅' : 'NO ❌'}
Conditions Passed: ${signal.v1Ultimate.zoneOverride.passed}/${signal.v1Ultimate.zoneOverride.required}
Reason: ${signal.v1Ultimate.zoneOverride.reason}
` : 'Zone Override data not available'}

═══════════════════════════════════════════════════════════════════════════════
V1 ULTIMATE - SCORE BREAKDOWN
═══════════════════════════════════════════════════════════════════════════════
${signal.ultimateScore ? `
FINAL SCORE: ${signal.score}/100

Components:
• Sequence (40%): ${signal.ultimateScore.breakdown.sequence.raw} → ${signal.ultimateScore.breakdown.sequence.weighted}
• Rejection (25%): ${signal.ultimateScore.breakdown.rejection.raw} → ${signal.ultimateScore.breakdown.rejection.weighted}
• HTF (15%): ${signal.ultimateScore.breakdown.htf.raw} → ${signal.ultimateScore.breakdown.htf.weighted}
• Momentum (10%): ${signal.ultimateScore.breakdown.momentum.raw} → ${signal.ultimateScore.breakdown.momentum.weighted}
• Volume (10%): ${signal.ultimateScore.breakdown.volume.raw} → ${signal.ultimateScore.breakdown.volume.weighted}
` : 'Score breakdown not available'}

═══════════════════════════════════════════════════════════════════════════════
HTF BIAS
═══════════════════════════════════════════════════════════════════════════════
${htf.bias ? Object.entries(htf.bias).map(([t, b]) => t + ':' + b).join(' | ') : 'N/A'}
Alignment: ${ss(htf.aligned, 0)}/${ss(htf.total, 0)} (${htfPct.toFixed(0)}%) ${htfPct < 50 ? '⚠️ BELOW 50%!' : ''}

═══════════════════════════════════════════════════════════════════════════════
MARKET ENVIRONMENT (Global Conditions)
═══════════════════════════════════════════════════════════════════════════════
${signal.environment ? `
Environment Score: ${signal.environment.score}/100 (${signal.environment.verdict})

• BTC Trend: ${STATE.environment.btcTrend?.direction || 'N/A'} ${(signal.direction === 'LONG' && STATE.environment.btcTrend?.direction === 'BULLISH') || (signal.direction === 'SHORT' && STATE.environment.btcTrend?.direction === 'BEARISH') ? '✅ ALIGNED' : STATE.environment.btcTrend?.direction === 'FLAT' ? '⚠️ FLAT' : '❌ CONFLICTS'}
• BTC.D Trend: ${STATE.environment.btcDominance?.trend || 'N/A'} ${(signal.direction === 'LONG' && STATE.environment.btcDominance?.trend === 'FALLING') || (signal.direction === 'SHORT' && STATE.environment.btcDominance?.trend === 'RISING') ? '✅ FAVORABLE' : STATE.environment.btcDominance?.trend === 'FLAT' ? '⚠️ NEUTRAL' : '❌ UNFAVORABLE'}
• DXY: ${STATE.environment.dxy?.value?.toFixed(1) || 'N/A'} ${STATE.environment.dxy?.trend || 'N/A'} ${STATE.environment.dxy?.trend === 'FALLING' ? '✅ GOOD' : STATE.environment.dxy?.trend === 'RISING' ? '⚠️ RISK-OFF' : ''}
• BTC Structure: ${STATE.environment.btcStructure?.status || 'N/A'} ${STATE.environment.btcStructure?.status === 'INTACT' ? '✅' : STATE.environment.btcStructure?.status === 'BROKEN_DOWN' && signal.direction === 'LONG' ? '❌ DANGEROUS' : '⚠️'}
• BTC RSI: ${STATE.environment.btcRSI?.value || 'N/A'} (${STATE.environment.btcRSI?.status || 'N/A'}) ${STATE.environment.btcRSI?.status === 'HEALTHY' ? '✅' : '⚠️ EXTENDED'}
• Funding: ${STATE.environment.funding?.rate ? (STATE.environment.funding.rate * 100).toFixed(3) + '%' : 'N/A'} (${STATE.environment.funding?.status || 'N/A'}) ${STATE.environment.funding?.status === 'EXTREME' && ((signal.direction === 'LONG' && STATE.environment.funding?.rate > 0) || (signal.direction === 'SHORT' && STATE.environment.funding?.rate < 0)) ? '❌ EXTREME AGAINST' : STATE.environment.funding?.status === 'NORMAL' ? '✅' : '⚠️'}

ENVIRONMENT VERDICT: ${signal.environment.verdict} ${signal.environment.verdict === 'GO' ? '✅ Favorable for ' + signal.direction : signal.environment.verdict === 'CAUTION' ? '⚠️ Proceed with caution' : signal.environment.verdict === 'RISKY' ? '🟠 High risk' : '❌ Unfavorable'}
` : 'Environment data not available'}

YOU MUST FACTOR ENVIRONMENT INTO YOUR DECISION:
• If Environment is NO-GO and signal is otherwise valid → WAIT or SKIP
• If Environment conflicts (BTC against direction) → Reduce confidence
• If Funding is EXTREME against direction → Strong caution or SKIP

═══════════════════════════════════════════════════════════════════════════════
SCANNER TRADE LEVELS (for reference)
═══════════════════════════════════════════════════════════════════════════════
Entry: $${sf(levels.entry, 4)}
SL: $${sf(levels.sl, 4)} (${ss(levels.riskPct)}%)
TP1: $${sf(levels.tp1, 4)} | TP2: $${sf(levels.tp2, 4)} | TP3: $${sf(levels.tp3, 4)}
R:R = 1:${ss(levels.rr)}

═══════════════════════════════════════════════════════════════════════════════
YOUR TASK
═══════════════════════════════════════════════════════════════════════════════

STEP 1: Form YOUR OWN direction based on engine data (ignore scanner initially)
STEP 2: Check if any MANDATORY RULES are violated
STEP 3: If Zone Override applies, you may proceed despite weak SMC
STEP 4: Compare YOUR direction with scanner - agree or disagree
STEP 5: Give final verdict: NO_TRADE / SKIP / WAIT / TAKE

ADD-ON LEVELS RULE (CRITICAL):
• For LONG: Add-on levels must be BELOW entry (buy dips)
• For SHORT: Add-on levels must be ABOVE entry (sell rips)

ENTRY TYPE:
• ZONE ENTRY (at strong zone, before confirmation): 50% size, 3-5x leverage
• CONFIRMED ENTRY (all engines agree): 100% size, 5-10x leverage

Respond ONLY with this JSON:
{
  "myDirection": "LONG" or "SHORT" or "NO_TRADE",
  "agreesWithScanner": true or false,
  "confidence": 0-100,
  "verdict": "NO_TRADE" or "SKIP" or "WAIT" or "TAKE",
  "entryType": "ZONE_ENTRY" or "CONFIRMED" or "NONE",
  "rulesCheck": {
    "smcRule": "PASS/FAIL - explanation",
    "conflictRule": "PASS/FAIL - explanation",
    "htfRule": "PASS/FAIL - explanation",
    "zoneOverride": "APPLIED/NOT_NEEDED/NOT_ELIGIBLE"
  },
  "executiveSummary": "2-3 sentences explaining your decision",
  "whyDisagree": "if you disagree with scanner, explain why (or null)",
  "confluenceCounter": {
    "alignedFactors": ["factor1", "factor2"],
    "conflictingFactors": ["conflict1", "conflict2"],
    "score": "X aligned vs Y conflicting"
  },
  "trapDetection": {
    "isTrap": true or false,
    "trapType": "None/Bull Trap/Bear Trap/Fakeout",
    "warning": "explanation"
  },
  "entryTiming": {
    "timing": "OPTIMAL/GOOD/SUBOPTIMAL/TOO_LATE",
    "recommendation": "Enter now/Wait for pullback/Skip"
  },
  "zoneAnalysis": {
    "quality": "Strong/Moderate/Weak/None",
    "pricePosition": "At Support/At Resistance/Mid-range"
  },
  "smcAnalysis": {
    "validity": "Valid/Weak/Invalid",
    "assessment": "your assessment"
  },
  "momentumAnalysis": {
    "direction": "Bullish/Bearish/Neutral",
    "alignsWithTrade": true or false
  },
  "tradePlan": {
    "entry": "price or NONE",
    "sl": "price",
    "tp1": "price",
    "tp2": "price",
    "tp3": "price",
    "addOnLevels": ["price1 - reason", "price2 - reason"],
    "positionSize": "50% or 100%",
    "leverage": "Xx-Xx"
  },
  "environmentAssessment": {
    "agrees": true or false,
    "concerns": ["concern1", "concern2"],
    "recommendation": "How environment affects this trade"
  },
  "riskAssessment": {
    "level": "Low/Medium/High/Extreme",
    "risks": ["risk1", "risk2"],
    "invalidation": "price that kills the trade"
  },
  "actionPlan": {
    "action": "what to do now",
    "conditions": "conditions to meet",
    "avoid": "what NOT to do"
  }
}`;

        return await callMultiAI(prompt);
    } finally {
        // SAFETY: Always release AI lock
        STATE.aiCallInProgress = false;
    }
}
// ═══════════════════════════════════════════════════════════════════════════════
// SCANNER ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

async function runScanner() {
    // SAFETY: Prevent concurrent scans
    if (STATE.scanInProgress) {
        console.warn('⚠️ Scan already in progress');
        toast('Scan already running...', 'warning');
        return;
    }
    
    if (!STATE.scanning) return;
    
    STATE.scanInProgress = true;  // Lock
    
    try {
        // UPDATE ENVIRONMENT FIRST
        await updateEnvironment();
        
        // Store previous signals for comparison (for status badges)
        STATE.previousSignals = [...STATE.signals];
        
        const signals = [];
        const filteredSignals = [];  // Signals blocked by environment
        
        let coins = CONFIG.COINS.length > 0 ? CONFIG.COINS : CONFIG.ALL_COINS.slice(0, STATE.coinCount);
        
        // SAFETY: Limit max coins per scan
        const maxCoins = CONFIG.SAFETY?.MAX_COINS_PER_SCAN || 300;
        if (coins.length > maxCoins) {
            console.warn(`⚠️ Limiting coins from ${coins.length} to ${maxCoins}`);
            toast(`⚠️ Coin limit: Scanning ${maxCoins} of ${coins.length} selected coins`, 'warning');
            coins = coins.slice(0, maxCoins);
        }
        
        let timeframes;
        
        if (STATE.mode === 'SCALP') {
            timeframes = CONFIG.TF_SCALP;
        } else if (STATE.mode === 'SWING') {
            timeframes = CONFIG.TF_SWING;
        } else {
            timeframes = CONFIG.TF_ALL;
        }
        
        // Filter by enabled timeframes from settings
        timeframes = timeframes.filter(tf => STATE.tfEnabled[tf]);
        
        if (timeframes.length === 0) {
            toast('No timeframes enabled! Enable at least one in Settings.', 'error');
            STATE.scanning = false;
            STATE.scanInProgress = false;
            document.getElementById('scanBtn').className = 'btn';
            document.getElementById('scanIcon').textContent = '●';
            return;
        }
        
        const total = coins.length * timeframes.length;
        let current = 0;
        
        // Track previous signal count for alerts
        const prevSignalCount = STATE.signals.length;
        
        STATE.scanProgress = { current: 0, total, coin: '', tf: '' };
        
        for (const coin of coins) {
            if (!STATE.scanning) break;
            
            for (const tf of timeframes) {
                if (!STATE.scanning) break;
                
                current++;
                STATE.scanProgress = {
                    current,
                    total,
                    coin: coin.replace('USDT', ''),
                    tf: CONFIG.TF_LABELS[tf] || tf
                };
                
                updateScanStatus();
                
                try {
                    const signal = await analyzeSignal(coin, tf);
                    if (signal) {
                        // Add environment data to signal (pass signal for RS/HTF)
                        const envResult = calculateEnvironmentScore(signal.direction, signal);
                        signal.environment = {
                            score: envResult.score,
                            verdict: envResult.verdict,
                            details: envResult.details,
                            icons: getEnvIcons(signal)
                        };
                        
                        // Check if signal should be filtered
                        const filterResult = shouldFilterSignal(signal);
                        if (filterResult.filter) {
                            // Add to filtered list instead
                            signal.filterReason = filterResult.reason;
                            filteredSignals.push(signal);
                        } else {
                            signals.push(signal);
                        }
                    }
                } catch (e) {
                    console.error(`Scan error ${coin} ${tf}:`, e);
                }
                
                await sleep(CONFIG.SCAN_DELAY);
            }
        }
    
    // Sort by score descending
    signals.sort((a, b) => b.score - a.score);
    
    // Check for new high-grade signals and trigger alert
    const gradeOrder = ['PERFECT', 'STRONG', 'VALID', 'HEATING', 'BREWING'];
    const alertGradeIdx = gradeOrder.indexOf(STATE.alertGrade);
    
    // Get previous signal keys for comparison
    const prevSignalKeys = new Set(STATE.signals.map(s => `${s.symbol}-${s.tf}-${s.direction}`));
    
    const newHighGradeSignals = signals.filter(sig => {
        const sigGradeIdx = gradeOrder.indexOf(sig.grade);
        const isQualifying = sigGradeIdx <= alertGradeIdx && sigGradeIdx >= 0;
        const sigKey = `${sig.symbol}-${sig.tf}-${sig.direction}`;
        const isNew = !prevSignalKeys.has(sigKey);
        return isQualifying && isNew;
    });
    
    // Trigger alert if we have new qualifying signals
    if (newHighGradeSignals.length > 0) {
        console.log('🔔 New qualifying signal found:', newHighGradeSignals[0].symbol);
        triggerAlert(newHighGradeSignals[0]);
    }
    
    // SAFETY: Limit signals array size
    const maxSignals = CONFIG.SAFETY?.MAX_SIGNALS || 500;
    if (signals.length > maxSignals) {
        console.warn(`⚠️ Limiting signals from ${signals.length} to ${maxSignals}`);
        signals.splice(maxSignals);
    }
    
    STATE.signals = signals;
    STATE.filteredSignals = filteredSignals;
    STATE.filteredCount = filteredSignals.length;
    STATE.selected = null;
    STATE.current = null;
    STATE.aiResult = null;
    
    updateSignalList();
    updateCounts();
    updateMainPanel();
    
    const filteredMsg = filteredSignals.length > 0 ? ` (${filteredSignals.length} filtered)` : '';
    toast(`Scan complete: ${signals.length} signals${filteredMsg}`, 'success');
    
    // Auto-update saved trades with live prices
    updateAllSavedTradesLive();
    
    // Set progress bar to green (complete)
    setScanComplete();
    
    // Auto-rescan using configured interval
    if (STATE.scanning) {
        // SAFETY: Enforce minimum scan interval
        const minInterval = CONFIG.SAFETY?.MIN_SCAN_INTERVAL_MS || 30000;
        const interval = Math.max(STATE.scanInterval, minInterval);
        
        // Reset progress bar before next scan
        setTimeout(() => {
            resetScanProgress();
            runScanner();
        }, interval);
    }
    
    } catch (scanError) {
        console.error('🛑 Scan error:', scanError);
        toast('Scan error - retrying...', 'error');
    } finally {
        // SAFETY: Always release scan lock
        STATE.scanInProgress = false;
    }
}

function updateScanStatus() {
    const el = document.getElementById('signalList');
    if (!el) return;
    
    const p = STATE.scanProgress;
    const pct = p.total > 0 ? Math.round((p.current / p.total) * 100) : 0;
    
    // Update progress bar (background scan - don't hide signals!)
    const progressBar = document.getElementById('scanProgressBar');
    const progressFill = document.getElementById('scanProgressFill');
    const progressText = document.getElementById('scanProgressText');
    const progressPct = document.getElementById('scanProgressPct');
    
    if (progressBar && STATE.scanning && p.total > 0) {
        progressBar.classList.add('active');
        if (progressFill) {
            progressFill.style.width = pct + '%';
            progressFill.classList.add('scanning');
        }
        if (progressText) {
            progressText.innerHTML = `<span class="scan-text-glow">🔄 ${p.coin}</span> <span class="scan-text-amber">${p.tf}</span>`;
        }
        if (progressPct) {
            progressPct.innerHTML = `<span class="scan-text-amber">${p.current}/${p.total}</span>`;
        }
    } else if (progressBar) {
        progressBar.classList.remove('active');
        if (progressFill) progressFill.classList.remove('scanning');
    }
    
    // Only show loading if NO signals yet (first scan)
    if (STATE.signals.length === 0 && el) {
        el.innerHTML = `
            <div class="empty">
                <div class="rainbow-circle-container">
                    <div class="rainbow-circle-ring"></div>
                    <div class="rainbow-circle-inner">
                        <div class="rainbow-circle-coin">${p.coin || 'Loading'}</div>
                        <div class="rainbow-circle-tf">${p.tf || '...'}</div>
                        <div class="rainbow-circle-pct">${pct}%</div>
                        <div class="rainbow-circle-count">${p.current}/${p.total}</div>
                    </div>
                </div>
            </div>
        `;
    }
    // Otherwise, signals stay visible during rescan!
}

// ═══════════════════════════════════════════════════════════════════════════════
// UI RENDERING
// ═══════════════════════════════════════════════════════════════════════════════

function updateSignalList() {
    const el = document.getElementById('signalList');
    let filtered = [...STATE.signals];
    
    // Apply mode filter
    if (STATE.mode === 'SCALP') {
        filtered = filtered.filter(s => ['5m', '15m', '30m', '1H'].includes(s.tf));
    } else if (STATE.mode === 'SWING') {
        filtered = filtered.filter(s => ['1H', '4H', '1D'].includes(s.tf));
    }
    
    // Apply status filter
    if (STATE.filter === 'perfect') {
        filtered = filtered.filter(s => s.grade === 'PERFECT');
    } else if (STATE.filter === 'ready') {
        filtered = filtered.filter(s => s.status === 'ready');
    } else if (STATE.filter === 'early') {
        filtered = filtered.filter(s => s.status === 'early');
    }
    
    // Apply stats bar filter
    if (STATE.statsFilter === 'cream') {
        filtered = filtered.filter(s => isCreamSignal(s));
    } else if (STATE.statsFilter === 'perfect') {
        filtered = filtered.filter(s => s.grade === 'PERFECT');
    } else if (STATE.statsFilter === 'long') {
        filtered = filtered.filter(s => s.direction === 'LONG');
    } else if (STATE.statsFilter === 'short') {
        filtered = filtered.filter(s => s.direction === 'SHORT');
    } else if (STATE.statsFilter === 'agree3') {
        filtered = filtered.filter(s => s.agreed === 3);
    }
    
    if (filtered.length === 0) {
        el.innerHTML = `
            <div class="empty">
                <div class="empty-icon" style="font-size:36px;color:var(--amber)">📊</div>
                <div style="color:var(--text2)">${STATE.scanning ? 'Scanning...' : 'No signals found'}</div>
            </div>
        `;
        return;
    }
    
    el.innerHTML = filtered.map((sig, idx) => {
        const realIdx = STATE.signals.indexOf(sig);
        const isActive = STATE.selected === realIdx;
        const isScalp = ['5m', '15m', '30m', '1H'].includes(sig.tf);
        const htfOk = sig.htf && sig.htf.aligned >= 2;
        const agreementColor = sig.agreed === 3 ? 'var(--long)' : 'var(--amber)';
        const fullAgreeClass = sig.agreed === 3 ? 'full-agree' : '';
        const gradeClass = 'grade-' + sig.grade.toLowerCase();
        
        // Check if CREAM signal
        const isCream = isCreamSignal(sig);
        const creamBadge = isCream ? '<span style="color:#00ffcc;font-weight:700;text-shadow:0 0 8px #00ffcc;margin-left:4px">💎</span>' : '';
        
        // Calculate status badge (compare with previous scan)
        let statusBadge = '';
        const sigKey = sig.symbol + '_' + sig.tf;
        const prevSig = STATE.previousSignals.find(p => p.symbol === sig.symbol && p.tf === sig.tf);
        
        if (!prevSig) {
            statusBadge = '<span class="status-badge new">🆕 NEW</span>';
        } else {
            const scoreDiff = sig.score - prevSig.score;
            if (scoreDiff >= 5) {
                statusBadge = `<span class="status-badge up">⬆️+${scoreDiff}</span>`;
            } else if (scoreDiff <= -5) {
                statusBadge = `<span class="status-badge down">⬇️${scoreDiff}</span>`;
            }
        }
        
        // Generate environment icons if available
        const envIconsHtml = sig.environment ? generateEnvIconsHtml(sig) : '';
        
        return `
            <div class="signal-card ${sig.direction.toLowerCase()} ${gradeClass} ${fullAgreeClass} ${isActive ? 'active' : ''}" 
                 onclick="selectSignal(${realIdx})"${isCream ? ' style="border:2px solid #00ffcc;box-shadow:0 0 12px rgba(0,255,204,0.3)"' : ''}>
                <div class="signal-top">
                    <div class="signal-pair">
                        ${sig.symbol.replace('USDT', '')}${creamBadge}
                        <span class="dir-tag ${sig.direction.toLowerCase()}">${sig.direction}</span>
                        <span class="tf-tag">${sig.tf}</span>
                        <span style="font-size:11px;color:${agreementColor};font-weight:700">${sig.agreed}/3</span>
                        ${htfOk ? '<span style="font-size:11px;color:var(--cyan)">HTF✓</span>' : ''}
                        ${statusBadge}
                    </div>
                    <span class="grade ${sig.grade.toLowerCase()}">${sig.grade}</span>
                </div>
                <div class="signal-meta">
                    <span>📊 ${sig.score}</span>
                    <span>💰 $${fmtPrice(sig.price)}</span>
                    <span>R:R 1:${sig.levels.rr}</span>
                </div>
                <div class="signal-scores">
                    <span class="score-tag ${scoreClass(sig.scores.zone)}" title="Zone: ${sig.engineDirections.zone || 'N/A'}">Z:${sig.scores.zone}${sig.engineDirections.zone === sig.direction ? '✓' : ''}</span>
                    <span class="score-tag ${scoreClass(sig.scores.smc)}" title="SMC: ${sig.engineDirections.smc || 'N/A'}">S:${sig.scores.smc}${sig.engineDirections.smc === sig.direction ? '✓' : ''}</span>
                    <span class="score-tag ${scoreClass(sig.scores.momentum)}" title="Momentum: ${sig.engineDirections.momentum || 'N/A'}">M:${sig.scores.momentum}${sig.engineDirections.momentum === sig.direction ? '✓' : ''}</span>
                    <span class="score-tag" style="color:var(--cyan)">H:${sig.scores.htf}</span>
                </div>
                ${envIconsHtml}
            </div>
        `;
    }).join('');
}

function updateCounts() {
    let filtered = [...STATE.signals];
    
    if (STATE.mode === 'SCALP') {
        filtered = filtered.filter(s => ['5m', '15m', '30m', '1H'].includes(s.tf));
    } else if (STATE.mode === 'SWING') {
        filtered = filtered.filter(s => ['1H', '4H', '1D'].includes(s.tf));
    }
    
    // Update filter counts
    document.getElementById('cAll').textContent = filtered.length;
    document.getElementById('cPerfect').textContent = filtered.filter(s => s.grade === 'PERFECT').length;
    document.getElementById('cReady').textContent = filtered.filter(s => s.status === 'ready').length;
    document.getElementById('cEarly').textContent = filtered.filter(s => s.status === 'early').length;
    
    // Update dashboard stats bar
    document.getElementById('statTotal').textContent = filtered.length;
    document.getElementById('statCream').textContent = filtered.filter(s => isCreamSignal(s)).length;
    document.getElementById('statPerfect').textContent = filtered.filter(s => s.grade === 'PERFECT').length;
    document.getElementById('statLong').textContent = filtered.filter(s => s.direction === 'LONG').length;
    document.getElementById('statShort').textContent = filtered.filter(s => s.direction === 'SHORT').length;
    document.getElementById('statFullAgree').textContent = filtered.filter(s => s.agreed === 3).length;
}

// ═══════════════════════════════════════════════════════════════════════════════
// CREAM SIGNAL DETECTION (Ultimate Signal - All conditions perfect)
// ═══════════════════════════════════════════════════════════════════════════════

function isCreamSignal(signal) {
    if (!signal) return false;
    
    const env = STATE.environment || {};
    const dir = signal.direction;
    
    // Criteria 1: Engine Score >= 85
    if (signal.score < 85) return false;
    
    // Criteria 2: Full Agreement (3/3)
    if (signal.agreed !== 3) return false;
    
    // Criteria 3: BTC Trend aligned
    const btcTrend = env.btcTrend?.direction || 'FLAT';
    if (dir === 'LONG' && btcTrend !== 'BULLISH' && btcTrend !== 'FLAT') return false;
    if (dir === 'SHORT' && btcTrend !== 'BEARISH' && btcTrend !== 'FLAT') return false;
    
    // Criteria 4: BTC.D favorable
    const btcDTrend = env.btcDominance?.trend || 'FLAT';
    if (dir === 'LONG' && btcDTrend === 'RISING') return false;  // Bad for alts going long
    if (dir === 'SHORT' && btcDTrend === 'FALLING') return false; // Bad for shorting alts
    
    // Criteria 5: Environment Score >= 80 (GO verdict)
    const envScore = signal.environment?.score || 0;
    if (envScore < 80) return false;
    
    // Criteria 6: HTF Alignment >= 75%
    if (signal.htf) {
        const htfPct = signal.htf.total > 0 ? (signal.htf.aligned / signal.htf.total) * 100 : 0;
        if (htfPct < 75) return false;
    }
    
    // Criteria 7: BTC Structure intact
    const struct = env.btcStructure?.status || 'UNKNOWN';
    if (struct !== 'INTACT') return false;
    
    // Criteria 8: OI confirms direction (NOT a squeeze)
    const oiInterp = STATE.openInterest?.interpretation || 'NEUTRAL';
    if (oiInterp === 'SQUEEZE' || oiInterp === 'LIQUIDATION') return false;
    
    // All criteria passed = CREAM 💎
    return true;
}

function updateMainPanel() {
    const el = document.getElementById('mainPanel');
    
    if (!STATE.current) {
        el.innerHTML = `
            <div class="empty">
                <div class="empty-icon">👈</div>
                <div>Select a signal to view details</div>
            </div>
        `;
        return;
    }
    
    const sig = STATE.current;
    const ai = STATE.aiResult;
    
    // FIX: Saved Trade Comparison Banner (when viewing saved trade with fresh rescan)
    let savedComparisonHtml = '';
    if (sig.savedTrade) {
        const st = sig.savedTrade;
        // FIX: Safe division with null check
        const priceDiff = (st.savedEntry && st.savedEntry !== 0) 
            ? ((sig.price - st.savedEntry) / st.savedEntry * 100).toFixed(2) 
            : '0.00';
        const priceDirection = sig.price > st.savedEntry ? '📈' : sig.price < st.savedEntry ? '📉' : '➡️';
        const gradeChanged = sig.grade !== st.savedGrade;
        const dirChanged = sig.direction !== st.savedDirection;
        
        savedComparisonHtml = `
            <div style="background:linear-gradient(135deg, var(--purple-dim), var(--cyan-dim));border:2px solid var(--purple);border-radius:10px;padding:12px;margin-bottom:12px">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                    <span style="font-size:13px;font-weight:700;color:var(--purple)">📌 SAVED TRADE COMPARISON</span>
                    <span style="font-size:10px;color:var(--text3)">Saved ${new Date(st.savedAt).toLocaleString()}</span>
                </div>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:10px">
                    <div style="background:var(--bg3);border-radius:6px;padding:8px">
                        <div style="font-size:10px;color:var(--text3);margin-bottom:4px">📸 WHEN SAVED</div>
                        <div style="font-size:12px;color:var(--text)">Entry: $${st.savedEntry?.toFixed(4) || 'N/A'}</div>
                        <div style="font-size:11px;color:var(--text2)">Grade: <span style="color:var(--${st.savedGrade === 'PERFECT' ? 'long' : st.savedGrade === 'STRONG' ? 'cyan' : 'amber'})">${st.savedGrade}</span> (${st.savedScore})</div>
                        <div style="font-size:11px;color:var(--text2)">Dir: ${st.savedDirection}</div>
                    </div>
                    <div style="background:var(--bg3);border-radius:6px;padding:8px">
                        <div style="font-size:10px;color:var(--text3);margin-bottom:4px">📊 NOW (FRESH)</div>
                        <div style="font-size:12px;color:var(--text)">Price: $${sig.price?.toFixed(4) || 'N/A'} ${priceDirection}</div>
                        <div style="font-size:11px;color:var(--text2)">Grade: <span style="color:var(--${sig.grade === 'PERFECT' ? 'long' : sig.grade === 'STRONG' ? 'cyan' : 'amber'})">${sig.grade}</span> (${sig.score}) ${gradeChanged ? '⚠️' : '✅'}</div>
                        <div style="font-size:11px;color:var(--text2)">Dir: ${sig.direction} ${dirChanged ? '🔄 CHANGED!' : '✅'}</div>
                    </div>
                </div>
                
                <div style="display:flex;justify-content:space-between;font-size:11px;padding-top:8px;border-top:1px solid var(--border)">
                    <span style="color:var(--text3)">Price moved: <span style="color:${priceDiff >= 0 ? 'var(--long)' : 'var(--short)'};">${priceDiff >= 0 ? '+' : ''}${priceDiff}%</span></span>
                    ${dirChanged ? '<span style="color:var(--short);font-weight:700">⚠️ DIRECTION CHANGED!</span>' : ''}
                    ${gradeChanged ? '<span style="color:var(--amber)">Grade changed</span>' : '<span style="color:var(--long)">✓ Signal stable</span>'}
                </div>
            </div>
        `;
    }
    
    // HTF Box
    const htfHtml = `
        <div class="htf-box">
            <div class="htf-title">📈 HTF Bias (${sig.htf.aligned}/${sig.htf.total} Aligned)</div>
            <div class="htf-grid">
                ${Object.entries(sig.htf.bias).map(([tf, bias]) => `
                    <div class="htf-item">
                        <div class="htf-label">${tf}</div>
                        <div class="htf-value ${bias === 'BULLISH' ? 'bull' : bias === 'BEARISH' ? 'bear' : 'neutral'}">${bias}</div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    // AI Section - Expandable with Comprehensive Independent Analysis
    let aiHtml;
    if (ai) {
        const verdictClass = ai.verdict === 'TAKE' ? 'take' : ai.verdict === 'NO_TRADE' ? 'skip' : ai.verdict === 'SKIP' ? 'skip' : 'wait';
        const barColor = ai.verdict === 'TAKE' ? 'var(--long)' : (ai.verdict === 'SKIP' || ai.verdict === 'NO_TRADE') ? 'var(--short)' : 'var(--amber)';
        const agreementColor = ai.agreesWithScanner ? 'var(--long)' : 'var(--short)';
        const agreementText = ai.agreesWithScanner ? '✓ AGREES' : '✗ DISAGREES';
        const aiDirectionColor = ai.myDirection === 'LONG' ? 'var(--long)' : ai.myDirection === 'SHORT' ? 'var(--short)' : 'var(--text3)';
        const entryTypeColor = ai.entryType === 'ZONE_ENTRY' ? 'var(--gold)' : ai.entryType === 'CONFIRMED' ? 'var(--long)' : 'var(--text3)';
        
        // Helper to format nested objects safely
        const formatObj = (obj, color) => {
            if (!obj) return '';
            if (typeof obj === 'string') return '<div style="font-size:12px;color:var(--text2)">' + obj + '</div>';
            return '<div style="font-size:12px;color:var(--text2)">' + 
                Object.entries(obj).filter(([k,v]) => v && v !== 'N/A').map(([k,v]) => {
                    const label = k.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                    if (Array.isArray(v)) return '<div style="margin-bottom:4px"><b>' + label + ':</b> ' + v.join(', ') + '</div>';
                    return '<div style="margin-bottom:4px"><b>' + label + ':</b> ' + v + '</div>';
                }).join('') + '</div>';
        };
        
        // Get risks array (handles both old and new format)
        const getRisks = () => {
            if (ai.riskAssessment && ai.riskAssessment.risks && ai.riskAssessment.risks.length) return ai.riskAssessment.risks;
            if (ai.riskAssessment && ai.riskAssessment.primaryRisks && ai.riskAssessment.primaryRisks.length) return ai.riskAssessment.primaryRisks;
            if (ai.risks && ai.risks.length) return ai.risks;
            return [];
        };
        
        // Get summary (handles both formats)
        const getSummary = () => ai.executiveSummary || ai.reasoning || '';
        
        // Get leverage info from tradePlan or legacy field
        const getLeverage = () => {
            if (ai.tradePlan && (ai.tradePlan.leverage || ai.tradePlan.positionSize)) {
                return { leverage: ai.tradePlan.leverage, size: ai.tradePlan.positionSize };
            }
            return ai.leverageRecommendation || ai.leverageAdvice || null;
        };
        
        aiHtml = `
            <div class="ai-section">
                <div class="ai-header" onclick="toggleAIExpand()" style="cursor:pointer">
                    <span class="ai-title">🤖 AI Independent Analysis</span>
                    <div style="display:flex;align-items:center;gap:8px">
                        <span class="ai-verdict ${verdictClass}">${ai.verdict}</span>
                        <span style="font-size:14px">${STATE.aiExpanded ? '▼' : '▶'}</span>
                    </div>
                </div>
                
                <div class="ai-bar"><div class="ai-fill" style="width:${ai.confidence}%;background:${barColor}"></div></div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                    <span style="font-size:12px">Confidence: <b>${ai.confidence}%</b></span>
                    <span style="font-size:11px;color:${agreementColor};font-weight:700">${agreementText} with Scanner</span>
                </div>
                
                <div style="display:flex;gap:8px;margin-bottom:10px">
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px">
                        <div style="font-size:11px;color:var(--text3)">Scanner Says</div>
                        <div style="font-size:14px;font-weight:700;color:${sig.direction === 'LONG' ? 'var(--long)' : 'var(--short)'}">${sig.direction}</div>
                    </div>
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px;border:1px solid ${aiDirectionColor}">
                        <div style="font-size:11px;color:var(--text3)">AI Says</div>
                        <div style="font-size:14px;font-weight:700;color:${aiDirectionColor}">${ai.myDirection || 'N/A'}</div>
                    </div>
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px;border:1px solid ${entryTypeColor}">
                        <div style="font-size:11px;color:var(--text3)">Entry Type</div>
                        <div style="font-size:12px;font-weight:700;color:${entryTypeColor}">${ai.entryType === 'ZONE_ENTRY' ? '🎯 ZONE' : ai.entryType === 'CONFIRMED' ? '✅ CONFIRMED' : '❌ NONE'}</div>
                    </div>
                </div>
                
                ${!ai.agreesWithScanner && ai.whyDisagree ? '<div style="background:var(--short-dim);border:1px solid var(--short);border-radius:6px;padding:10px;margin-bottom:10px"><div style="font-size:11px;color:var(--short);font-weight:700;margin-bottom:4px">⚠️ WHY AI DISAGREES:</div><div style="font-size:12px;color:var(--text2)">' + ai.whyDisagree + '</div></div>' : ''}
                
                ${ai.rulesCheck ? '<div style="background:var(--bg4);border-radius:6px;padding:10px;margin-bottom:10px"><div style="font-size:11px;color:var(--cyan);font-weight:700;margin-bottom:6px">📋 RULES CHECK:</div><div style="font-size:11px;color:var(--text2)">' + Object.entries(ai.rulesCheck).map(([rule, result]) => '<div style="margin-bottom:2px"><b>' + rule + ':</b> ' + result + '</div>').join('') + '</div></div>' : ''}
                
                <div class="ai-text" style="background:var(--bg4);padding:10px;border-radius:6px;border-left:3px solid ${barColor}">${getSummary()}</div>
                
                <div id="aiExpandedContent" style="display:${STATE.aiExpanded ? 'block' : 'none'};margin-top:12px;border-top:1px solid var(--border);padding-top:12px">
                    
                    ${STATE.aiDisplayMode === 'detailed' ? `
                    <!-- DETAILED MODE: 13 Sections -->
                    
                    ${ai.confluenceCounter ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--cyan)"><div style="font-size:11px;color:var(--cyan);font-weight:700;margin-bottom:6px">🎯 CONFLUENCE COUNTER</div>' + formatObj(ai.confluenceCounter, 'cyan') + '</div>' : ''}
                    
                    ${ai.trapDetection ? '<div style="margin-bottom:12px;background:' + (ai.trapDetection.isTrap ? 'var(--short-dim)' : 'var(--bg4)') + ';padding:10px;border-radius:6px;border:1px solid ' + (ai.trapDetection.isTrap ? 'var(--short)' : 'var(--long)') + '"><div style="font-size:11px;color:' + (ai.trapDetection.isTrap ? 'var(--short)' : 'var(--long)') + ';font-weight:700;margin-bottom:6px">' + (ai.trapDetection.isTrap ? '⚠️ TRAP DETECTED!' : '✅ NO TRAP DETECTED') + '</div>' + formatObj(ai.trapDetection, ai.trapDetection.isTrap ? 'short' : 'long') + '</div>' : ''}
                    
                    ${ai.entryTiming ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--amber)"><div style="font-size:11px;color:var(--amber);font-weight:700;margin-bottom:6px">⏰ ENTRY TIMING</div>' + formatObj(ai.entryTiming, 'amber') + '</div>' : ''}
                    
                    ${ai.candlePatternAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:6px">🕯️ CANDLE & PATTERNS</div>' + formatObj(ai.candlePatternAnalysis, 'gold') + '</div>' : ''}
                    
                    ${ai.zoneAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:6px">📍 ZONE ANALYSIS</div>' + formatObj(ai.zoneAnalysis, 'gold') + '</div>' : ''}
                    
                    ${ai.smcAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">🎯 SMC ANALYSIS</div>' + formatObj(ai.smcAnalysis, 'purple') + '</div>' : ''}
                    
                    ${ai.momentumAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--blue);font-weight:700;margin-bottom:6px">⚡ MOMENTUM ANALYSIS</div>' + formatObj(ai.momentumAnalysis, 'blue') + '</div>' : ''}
                    
                    ${ai.tradePlan ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">💰 TRADE PLAN</div>' + formatObj(ai.tradePlan, 'long') + '</div>' : ''}
                    
                    ${(ai.riskAssessment || getRisks().length > 0) ? '<div style="margin-bottom:12px;background:var(--short-dim);padding:10px;border-radius:6px;border:1px solid var(--short)"><div style="font-size:11px;color:var(--short);font-weight:700;margin-bottom:6px">⚠️ RISK ASSESSMENT</div>' + (ai.riskAssessment ? formatObj(ai.riskAssessment, 'short') : '<div style="font-size:12px;color:var(--text2)">' + getRisks().map(r => '• ' + r).join('<br>') + '</div>') + '</div>' : ''}
                    
                    ${getLeverage() ? '<div style="margin-bottom:12px;background:var(--amber-dim);border:1px solid var(--amber);border-radius:6px;padding:10px"><div style="font-size:11px;color:var(--amber);font-weight:700;margin-bottom:6px">⚡ LEVERAGE & SIZING</div>' + formatObj(getLeverage(), 'amber') + '</div>' : ''}
                    
                    ${ai.actionPlan ? '<div style="margin-bottom:12px;background:linear-gradient(135deg,var(--long-dim),var(--cyan-dim));padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">🎯 ACTION PLAN</div>' + formatObj(ai.actionPlan, 'long') + '</div>' : ''}
                    
                    ${ai.professionalNotes ? '<div style="background:var(--bg4);padding:10px;border-radius:6px;border-left:3px solid var(--purple)"><div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">📝 PRO NOTES</div><div style="font-size:12px;color:var(--text2);font-style:italic">' + ai.professionalNotes + '</div></div>' : ''}
                    
                    ` : `
                    <!-- COMPACT MODE: 6 Grouped Sections -->
                    
                    <div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--cyan)">
                        <div style="font-size:11px;color:var(--cyan);font-weight:700;margin-bottom:6px">📊 VERDICT & CONFLUENCE</div>
                        ${ai.confluenceCounter ? formatObj(ai.confluenceCounter, 'cyan') : ''}
                        ${ai.entryTiming ? '<div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border)">' + formatObj(ai.entryTiming, 'amber') + '</div>' : ''}
                    </div>
                    
                    ${(ai.trapDetection || ai.riskAssessment || getRisks().length > 0) ? '<div style="margin-bottom:12px;background:var(--short-dim);padding:10px;border-radius:6px;border:1px solid var(--short)"><div style="font-size:11px;color:var(--short);font-weight:700;margin-bottom:6px">⚠️ WARNINGS & RISKS</div>' + (ai.trapDetection ? formatObj(ai.trapDetection, 'short') : '') + (ai.riskAssessment ? '<div style="margin-top:8px">' + formatObj(ai.riskAssessment, 'short') + '</div>' : '') + '</div>' : ''}
                    
                    <div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px">
                        <div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">🔍 TECHNICAL ANALYSIS</div>
                        ${ai.zoneAnalysis ? '<div style="margin-bottom:6px"><b style="color:var(--gold)">Zone:</b> ' + (typeof ai.zoneAnalysis === 'object' ? (ai.zoneAnalysis.zoneQuality || 'N/A') + ' - ' + (ai.zoneAnalysis.pricePosition || 'N/A') : ai.zoneAnalysis) + '</div>' : ''}
                        ${ai.smcAnalysis ? '<div style="margin-bottom:6px"><b style="color:var(--purple)">SMC:</b> ' + (typeof ai.smcAnalysis === 'object' ? (ai.smcAnalysis.structureValidity || 'N/A') + ' - ' + (ai.smcAnalysis.orderBlockQuality || 'N/A') : ai.smcAnalysis) + '</div>' : ''}
                        ${ai.momentumAnalysis ? '<div><b style="color:var(--blue)">Momentum:</b> ' + (typeof ai.momentumAnalysis === 'object' ? (ai.momentumAnalysis.trendStrength || 'N/A') + ' - ' + (ai.momentumAnalysis.entryTiming || 'N/A') : ai.momentumAnalysis) + '</div>' : ''}
                    </div>
                    
                    ${ai.candlePatternAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:6px">🕯️ PRICE ACTION</div>' + formatObj(ai.candlePatternAnalysis, 'gold') + '</div>' : ''}
                    
                    ${(ai.tradePlan || getLeverage()) ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">💰 TRADE SETUP</div>' + (ai.tradePlan ? formatObj(ai.tradePlan, 'long') : '') + (getLeverage() ? '<div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border)">' + formatObj(getLeverage(), 'amber') + '</div>' : '') + '</div>' : ''}
                    
                    ${ai.actionPlan ? '<div style="margin-bottom:12px;background:linear-gradient(135deg,var(--long-dim),var(--cyan-dim));padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">🎯 ACTION PLAN</div>' + formatObj(ai.actionPlan, 'long') + '</div>' : ''}
                    `}
                    
                </div>
                
                <div style="display:flex;gap:8px;margin-top:10px">
                    <button class="btn" onclick="toggleAIExpand()" style="flex:1">${STATE.aiExpanded ? '▲ Collapse' : '▼ Expand Details'}</button>
                    <button class="btn" onclick="askAI()" style="flex:1">🔄 Refresh AI</button>
                </div>
            </div>
        `;
    } else {
        aiHtml = `
            <div class="ai-section" style="text-align:center;padding:20px">
                <div style="font-size:32px;margin-bottom:8px">🧠</div>
                <div style="font-size:13px;font-weight:600;margin-bottom:4px">Independent AI Analysis</div>
                <div style="font-size:12px;color:var(--text2);margin-bottom:12px">AI will analyze raw data and give its own opinion</div>
                <button class="ai-btn" onclick="askAI()">🧠 Ask Multi-AI</button>
            </div>
        `;
    }
    
    // Analysis Grid
    const analysisHtml = `
        <div class="analysis-grid">
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">📍 Zone Analysis</span>
                    <span class="analysis-score" style="background:${scoreColor(sig.scores.zone)}20;color:${scoreColor(sig.scores.zone)}">${sig.scores.zone}</span>
                </div>
                ${sig.zone.details.nearestSupport ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Support</span>
                        <span class="analysis-value">$${fmtPrice(sig.zone.details.nearestSupport.price)}</span>
                    </div>
                ` : ''}
                ${sig.zone.details.nearestResistance ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Resistance</span>
                        <span class="analysis-value">$${fmtPrice(sig.zone.details.nearestResistance.price)}</span>
                    </div>
                ` : ''}
                <div class="analysis-row">
                    <span class="analysis-label">Status</span>
                    <span class="analysis-value">${sig.zone.status}</span>
                </div>
                <div class="factor-list">
                    ${sig.zone.factors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
            
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">🎯 SMC Analysis</span>
                    <span class="analysis-score" style="background:${scoreColor(sig.scores.smc)}20;color:${scoreColor(sig.scores.smc)}">${sig.scores.smc}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">Structure</span>
                    <span class="analysis-value">${sig.smc.details.trend || 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">P/D Zone</span>
                    <span class="analysis-value">${sig.smc.details.pdZone ? sig.smc.details.pdZone.zone : 'N/A'}</span>
                </div>
                ${sig.smc.trigger ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Trigger</span>
                        <span class="analysis-value" style="color:var(--gold)">${sig.smc.trigger}</span>
                    </div>
                ` : ''}
                <div class="factor-list">
                    ${sig.smc.factors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
            
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">📈 Momentum</span>
                    <span class="analysis-score" style="background:${scoreColor(sig.scores.momentum)}20;color:${scoreColor(sig.scores.momentum)}">${sig.scores.momentum}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">RSI</span>
                    <span class="analysis-value">${sig.momentum.details.rsi ? sig.momentum.details.rsi.value.toFixed(1) : 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">ADX</span>
                    <span class="analysis-value">${sig.momentum.details.adx ? sig.momentum.details.adx.adx.toFixed(1) : 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">MACD</span>
                    <span class="analysis-value">${sig.momentum.details.macd ? sig.momentum.details.macd.trend : 'N/A'}</span>
                </div>
                <div class="factor-list">
                    ${sig.momentum.factors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
        </div>
    `;
    
    // Warnings
    const warningsHtml = sig.warnings.length > 0 ? `
        <div style="background:var(--amber-dim);border:1px solid var(--amber);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="font-size:11px;color:var(--amber);font-weight:600;margin-bottom:4px">⚠️ Warnings</div>
            <div style="font-size:12px;color:var(--amber)">${sig.warnings.join(' • ')}</div>
        </div>
    ` : '';
    
    // Smart Trade Data
    const smart = sig.levels.smart || {};
    const entryData = smart.entry || {};
    const slData = smart.sl || {};
    const tp1Data = smart.tp1 || {};
    const tp2Data = smart.tp2 || {};
    const tp3Data = smart.tp3 || {};
    const marketGrade = entryData.market?.grade || {};
    const pb1 = entryData.pullback1;
    const pb2 = entryData.pullback2;
    
    // Entry Grade Color
    const gradeColors = {
        'A+': 'var(--long)', 'A': 'var(--long)', 
        'B+': 'var(--cyan)', 'B': 'var(--cyan)',
        'C': 'var(--amber)', 'D': 'var(--short)'
    };
    const gradeColor = gradeColors[marketGrade.grade] || 'var(--text2)';
    
    // Smart Entry Plan HTML
    const smartEntryHtml = `
        <div style="background:var(--bg4);border:1px solid var(--cyan);border-radius:8px;padding:12px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                <span style="font-size:12px;font-weight:700;color:var(--cyan)">🧠 SMART ENTRY PLAN</span>
                <span style="font-size:11px;padding:3px 8px;border-radius:4px;background:${gradeColor};color:var(--bg1);font-weight:700">${marketGrade.grade || 'B'} GRADE</span>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid var(--border);margin-bottom:8px">
                <span style="font-size:11px;color:var(--text3)">Entry Decision:</span>
                <span style="font-size:12px;font-weight:600;color:var(--cyan)">${entryData.decision || 'MARKET'}</span>
            </div>
            <div style="display:grid;grid-template-columns:${pb2 ? 'repeat(3,1fr)' : pb1 ? 'repeat(2,1fr)' : '1fr'};gap:8px">
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--cyan)">
                    <div style="font-size:10px;color:var(--text3)">MARKET (${entryData.market?.size || '25%'})</div>
                    <div style="font-size:13px;font-weight:700;color:var(--cyan)">$${fmtPrice(sig.levels.entry)}</div>
                    <div style="font-size:10px;color:${gradeColor}">Grade: ${marketGrade.grade || 'B'}</div>
                </div>
                ${pb1 ? `
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--purple)">
                    <div style="font-size:10px;color:var(--text3)">PULLBACK 1 (${pb1.size || '50%'})</div>
                    <div style="font-size:13px;font-weight:700;color:var(--purple)">$${fmtPrice(pb1.price)}</div>
                    <div style="font-size:9px;color:var(--purple)">${pb1.reason || 'OB'} • ${sig.direction === 'LONG' ? '-' : '+'}${pb1.distPct}%</div>
                    <div style="font-size:10px;color:${gradeColors[pb1.grade?.grade] || 'var(--text3)'}">Grade: ${pb1.grade?.grade || 'B+'}</div>
                </div>
                ` : ''}
                ${pb2 ? `
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--purple)">
                    <div style="font-size:10px;color:var(--text3)">PULLBACK 2 (${pb2.size || '25%'})</div>
                    <div style="font-size:13px;font-weight:700;color:var(--purple)">$${fmtPrice(pb2.price)}</div>
                    <div style="font-size:9px;color:var(--purple)">${pb2.reason || 'FVG'} • ${sig.direction === 'LONG' ? '-' : '+'}${pb2.distPct}%</div>
                    <div style="font-size:10px;color:${gradeColors[pb2.grade?.grade] || 'var(--text3)'}">Grade: ${pb2.grade?.grade || 'A'}</div>
                </div>
                ` : ''}
            </div>
            ${entryData.avgEntry ? `
            <div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border);display:flex;justify-content:space-between">
                <span style="font-size:10px;color:var(--text3)">Avg Entry (if all fill):</span>
                <span style="font-size:11px;font-weight:600;color:var(--text)">$${fmtPrice(entryData.avgEntry)}</span>
            </div>
            ` : ''}
        </div>
    `;
    
    // Smart SL HTML
    const smartSLHtml = `
        <div style="background:var(--short-dim);border:1px solid var(--short);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                <span style="font-size:11px;font-weight:600;color:var(--short)">🛑 SMART STOP LOSS</span>
                <span style="font-size:12px;font-weight:700;color:var(--short)">$${fmtPrice(sig.levels.sl)} (${slData.riskPct || sig.levels.riskPct}%)</span>
            </div>
            <div style="font-size:10px;color:var(--text2)">${slData.reason || 'Structure-based'}</div>
            ${slData.trapAvoided ? `<div style="font-size:10px;color:var(--long);margin-top:4px">✅ Liquidity trap avoided</div>` : ''}
        </div>
    `;
    
    // Smart TPs HTML - Direction-aware colors
    const tpColor = sig.direction === 'LONG' ? 'var(--long)' : 'var(--short)';
    const tpBgColor = sig.direction === 'LONG' ? 'var(--long-dim)' : 'var(--short-dim)';
    const tpSign = sig.direction === 'LONG' ? '+' : '-';
    
    const smartTPsHtml = `
        <div style="background:${tpBgColor};border:1px solid ${tpColor};border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="font-size:11px;font-weight:600;color:${tpColor};margin-bottom:8px">🎯 SMART TAKE PROFITS</div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px">
                <div style="background:var(--bg3);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">TP1</div>
                    <div style="font-size:12px;font-weight:700;color:${tpColor}">$${fmtPrice(sig.levels.tp1)}</div>
                    <div style="font-size:9px;color:${tpColor}">${tpSign}${tp1Data.distPct || ((Math.abs(sig.levels.tp1 - sig.levels.entry) / sig.levels.entry) * 100).toFixed(2)}%</div>
                    <div style="font-size:9px;color:var(--text2)">${tp1Data.probability || 70}% prob</div>
                    <div style="font-size:8px;color:var(--text3)">${tp1Data.reason || 'Liquidity'}</div>
                </div>
                <div style="background:var(--bg3);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">TP2</div>
                    <div style="font-size:12px;font-weight:700;color:${tpColor}">$${fmtPrice(sig.levels.tp2)}</div>
                    <div style="font-size:9px;color:${tpColor}">${tpSign}${tp2Data.distPct || ((Math.abs(sig.levels.tp2 - sig.levels.entry) / sig.levels.entry) * 100).toFixed(2)}%</div>
                    <div style="font-size:9px;color:var(--text2)">${tp2Data.probability || 55}% prob</div>
                    <div style="font-size:8px;color:var(--text3)">${tp2Data.reason || 'OB Target'}</div>
                </div>
                <div style="background:var(--bg3);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">TP3</div>
                    <div style="font-size:12px;font-weight:700;color:${tpColor}">$${fmtPrice(sig.levels.tp3)}</div>
                    <div style="font-size:9px;color:${tpColor}">${tpSign}${tp3Data.distPct || ((Math.abs(sig.levels.tp3 - sig.levels.entry) / sig.levels.entry) * 100).toFixed(2)}%</div>
                    <div style="font-size:9px;color:var(--text2)">${tp3Data.probability || 40}% prob</div>
                    <div style="font-size:8px;color:var(--text3)">${tp3Data.reason || 'HTF Level'}</div>
                </div>
            </div>
            <div style="margin-top:8px;display:flex;justify-content:space-between;padding-top:8px;border-top:1px solid var(--border)">
                <span style="font-size:10px;color:var(--text3)">R:R from Avg Entry:</span>
                <span style="font-size:11px;font-weight:700;color:${tpColor}">1:${sig.levels.rr}</span>
            </div>
        </div>
    `;
    
    // Leverage & Sizing HTML
    const leverageHtml = `
        <div style="background:var(--bg4);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="font-size:11px;font-weight:600;color:var(--gold);margin-bottom:8px">⚡ LEVERAGE & SIZING</div>
            <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px">
                <div style="text-align:center">
                    <div style="font-size:10px;color:var(--text3)">Safe Leverage</div>
                    <div style="font-size:14px;font-weight:700;color:var(--long)">${marketGrade.leverage?.safe || 5}x</div>
                </div>
                <div style="text-align:center">
                    <div style="font-size:10px;color:var(--text3)">Max Leverage</div>
                    <div style="font-size:14px;font-weight:700;color:var(--amber)">${marketGrade.leverage?.max || 10}x</div>
                </div>
            </div>
            <div style="margin-top:8px;text-align:center">
                <span style="font-size:10px;color:var(--text3)">Confidence: </span>
                <span style="font-size:11px;font-weight:600;color:${gradeColor}">${marketGrade.confidence || 'MEDIUM'}</span>
            </div>
        </div>
    `;
    
    // 🏦 Institutional Data HTML
    const inst = sig.institutional || {};
    const instA = sig.instAnalysis || {};
    const funding = inst.funding || {};
    const oi = inst.openInterest || {};
    const lsRatio = inst.longShortRatio || {};
    const squeeze = inst.squeezeRisk;
    const liqLevels = inst.liquidationLevels || {};
    
    // Institutional bias color
    const instBiasColor = inst.institutionalBias === 'BULLISH' ? 'var(--long)' :
                         inst.institutionalBias === 'BEARISH' ? 'var(--short)' :
                         inst.institutionalBias === 'SLIGHTLY_BULLISH' ? 'var(--cyan)' :
                         inst.institutionalBias === 'SLIGHTLY_BEARISH' ? 'var(--amber)' : 'var(--text2)';
    
    // Recommendation color
    const recColor = instA.recommendation === 'STRONG_CONFIRM' ? 'var(--long)' :
                    instA.recommendation === 'CONFIRM' ? 'var(--cyan)' :
                    instA.recommendation === 'AVOID' ? 'var(--short)' :
                    instA.recommendation === 'CAUTION' ? 'var(--amber)' : 'var(--text2)';
    
    const institutionalHtml = inst.funding ? `
        <div style="background:linear-gradient(135deg, var(--bg4) 0%, rgba(147, 112, 219, 0.1) 100%);border:1px solid var(--purple);border-radius:8px;padding:12px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                <span style="font-size:12px;font-weight:700;color:var(--purple)">🏦 INSTITUTIONAL DATA</span>
                <span style="font-size:11px;padding:3px 8px;border-radius:4px;background:${instBiasColor};color:var(--bg1);font-weight:700">${inst.institutionalBias || 'NEUTRAL'}</span>
            </div>
            
            <!-- Funding Rate -->
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px">
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">FUNDING RATE</div>
                    <div style="font-size:13px;font-weight:700;color:${parseFloat(funding.rate || 0) > 0 ? 'var(--short)' : parseFloat(funding.rate || 0) < 0 ? 'var(--long)' : 'var(--text)'}">${funding.ratePercent || '0.00'}%</div>
                    <div style="font-size:8px;color:var(--text3)">${funding.signal || ''}</div>
                </div>
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">OPEN INTEREST</div>
                    <div style="font-size:13px;font-weight:700;color:${parseFloat(oi.change4h || 0) > 0 ? 'var(--long)' : 'var(--short)'}">${oi.change4h || '0'}%</div>
                    <div style="font-size:8px;color:var(--text3)">${oi.trend || 'STABLE'}</div>
                </div>
                <div style="background:var(--bg3);border-radius:6px;padding:8px;text-align:center">
                    <div style="font-size:9px;color:var(--text3)">L/S RATIO</div>
                    <div style="font-size:13px;font-weight:700;color:${parseFloat(lsRatio.buyRatio || 50) > 55 ? 'var(--long)' : parseFloat(lsRatio.sellRatio || 50) > 55 ? 'var(--short)' : 'var(--text)'}">${lsRatio.buyRatio || '50'}%L</div>
                    <div style="font-size:8px;color:var(--text3)">${lsRatio.dominance || 'BALANCED'}</div>
                </div>
            </div>
            
            <!-- Squeeze Alert -->
            ${squeeze ? `
            <div style="background:${squeeze.type === 'LONG_SQUEEZE' ? 'var(--short-dim)' : 'var(--long-dim)'};border:1px solid ${squeeze.type === 'LONG_SQUEEZE' ? 'var(--short)' : 'var(--long)'};border-radius:6px;padding:8px;margin-bottom:10px">
                <div style="display:flex;justify-content:space-between;align-items:center">
                    <span style="font-size:11px;font-weight:700;color:${squeeze.type === 'LONG_SQUEEZE' ? 'var(--short)' : 'var(--long)'}">
                        ${squeeze.type === 'LONG_SQUEEZE' ? '🔻 LONG SQUEEZE RISK' : '🚀 SHORT SQUEEZE RISK'}
                    </span>
                    <span style="font-size:10px;padding:2px 6px;border-radius:3px;background:${squeeze.probability === 'HIGH' ? 'var(--short)' : 'var(--amber)'};color:var(--bg1);font-weight:600">${squeeze.probability}</span>
                </div>
                <div style="font-size:9px;color:var(--text2);margin-top:4px">${squeeze.reason}</div>
                <div style="font-size:9px;color:var(--text3);margin-top:2px">Trigger: $${fmtPrice(squeeze.trigger)}</div>
            </div>
            ` : ''}
            
            <!-- Liquidation Levels -->
            ${liqLevels.magnetLong ? `
            <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:8px">
                <div style="background:var(--short-dim);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--short)">LONG LIQⓁ MAGNET</div>
                    <div style="font-size:11px;font-weight:700;color:var(--short)">$${fmtPrice(liqLevels.magnetLong)}</div>
                    <div style="font-size:8px;color:var(--text3)">20x lev cluster</div>
                </div>
                <div style="background:var(--long-dim);border-radius:4px;padding:6px;text-align:center">
                    <div style="font-size:9px;color:var(--long)">SHORT LIQ MAGNET</div>
                    <div style="font-size:11px;font-weight:700;color:var(--long)">$${fmtPrice(liqLevels.magnetShort)}</div>
                    <div style="font-size:8px;color:var(--text3)">20x lev cluster</div>
                </div>
            </div>
            ` : ''}
            
            <!-- Institutional Recommendation -->
            <div style="display:flex;justify-content:space-between;align-items:center;padding-top:8px;border-top:1px solid var(--border)">
                <span style="font-size:10px;color:var(--text3)">Inst. Recommendation:</span>
                <span style="font-size:11px;font-weight:700;color:${recColor}">${instA.recommendation || 'NEUTRAL'} (${instA.score > 0 ? '+' : ''}${instA.score || 0})</span>
            </div>
        </div>
    ` : `
        <div style="background:var(--bg4);border:1px dashed var(--border);border-radius:8px;padding:12px;margin-bottom:12px;text-align:center">
            <span style="font-size:11px;color:var(--text3)">🏦 Institutional data loading...</span>
        </div>
    `;
    
    // Trade Levels (legacy format for compatibility)
    const tradeHtml = `
        <div class="trade-section">
            <div class="trade-title">📊 Trade Levels</div>
            ${smartEntryHtml}
            ${smartSLHtml}
            ${smartTPsHtml}
            ${leverageHtml}
            ${institutionalHtml}
            <div class="trade-meta">
                <span class="rr-tag">Market R:R 1:${sig.levels.rr} | Limit R:R 1:${sig.levels.limitRR}</span>
                <button class="save-btn" onclick="saveTrade()">💾 Save Trade</button>
            </div>
        </div>
    `;
    
    // Agreement Box
    const zoneAgree = sig.engineDirections.zone === sig.direction;
    const smcAgree = sig.engineDirections.smc === sig.direction;
    const momAgree = sig.engineDirections.momentum === sig.direction;
    // Use direction-appropriate color: GREEN for LONG, RED for SHORT
    const dirColor = sig.direction === 'LONG' ? 'var(--long)' : 'var(--short)';
    const agreementColor = sig.agreed === 3 ? dirColor : 'var(--amber)';
    
    const agreementHtml = `
        <div style="background:var(--bg4);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                <span style="font-size:11px;color:var(--text2)">🎯 Engine Agreement</span>
                <span style="font-size:14px;font-weight:700;color:${agreementColor}">${sig.agreed}/3 Agree</span>
            </div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px">
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${zoneAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">ZONE</div>
                    <div style="font-size:12px;font-weight:700;color:${zoneAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.zone || 'N/A'}</div>
                    <div style="font-size:11px;color:${zoneAgree ? dirColor : 'var(--text3)'}">${zoneAgree ? '✓ Agrees' : '✗ Differs'}</div>
                </div>
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${smcAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">SMC</div>
                    <div style="font-size:12px;font-weight:700;color:${smcAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.smc || 'N/A'}</div>
                    <div style="font-size:11px;color:${smcAgree ? dirColor : 'var(--text3)'}">${smcAgree ? '✓ Agrees' : '✗ Differs'}</div>
                </div>
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${momAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">MOMENTUM</div>
                    <div style="font-size:12px;font-weight:700;color:${momAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.momentum || 'N/A'}</div>
                    <div style="font-size:11px;color:${momAgree ? dirColor : 'var(--text3)'}">${momAgree ? '✓ Agrees' : '✗ Differs'}</div>
                </div>
            </div>
        </div>
    `;
    
    // Environment Panel HTML
    const envPanelHtml = sig.environment ? generateEnvPanelHtml(sig) : '';
    
    // Awareness Panel HTML (Session + News)
    const awarenessHtml = generateAwarenessHtml();
    
    el.innerHTML = `
        <div class="detail-box">
            <div class="detail-header">
                <div class="detail-title">
                    <span class="detail-pair">${sig.symbol.replace('USDT', '')}</span>
                    <span class="dir-tag ${sig.direction.toLowerCase()}" style="font-size:12px;padding:4px 10px">${sig.direction}</span>
                    <span class="grade ${sig.grade.toLowerCase()}" style="font-size:11px;padding:4px 10px">${sig.grade}</span>
                    <span class="tf-tag" style="font-size:12px">${sig.tf}</span>
                </div>
                <div class="detail-price">
                    <div class="detail-price-label">Current Price</div>
                    <div class="detail-price-value">$${fmtPrice(sig.price)}</div>
                </div>
            </div>
            ${savedComparisonHtml}
            ${awarenessHtml}
            ${envPanelHtml}
            ${agreementHtml}
            ${htfHtml}
            ${aiHtml}
            ${warningsHtml}
            ${analysisHtml}
            ${tradeHtml}
        </div>
    `;
}

function getFactorClass(factor) {
    const bullish = ['↑', 'Bull', 'Support', 'Discount', 'OS', 'MACD+', 'OBV+', 'Golden', '+'];
    const bearish = ['↓', 'Bear', 'Resist', 'Premium', 'OB', 'MACD-', 'OBV-', 'Death', '-'];
    
    for (const b of bullish) {
        if (factor.includes(b)) return 'bull';
    }
    for (const s of bearish) {
        if (factor.includes(s)) return 'bear';
    }
    return '';
}


// ═══════════════════════════════════════════════════════════════════════════════
// 💾 ENHANCED SAVED TRADES SYSTEM v2.0
// ═══════════════════════════════════════════════════════════════════════════════

// Status constants
const TRADE_STATUS = {
    STRONG_PROFIT: { label: 'STRONG PROFIT', emoji: '🚀', class: 'strong-profit' },
    IN_PROFIT: { label: 'IN PROFIT', emoji: '✅', class: 'in-profit' },
    TP1_HIT: { label: 'TP1 HIT!', emoji: '🎯', class: 'tp-hit' },
    TP2_HIT: { label: 'TP2 HIT!', emoji: '🎯🎯', class: 'tp-hit' },
    TP3_HIT: { label: 'TP3 HIT!', emoji: '🏆', class: 'tp-hit' },
    NEAR_ENTRY: { label: 'NEAR ENTRY', emoji: '⏳', class: 'near-entry' },
    SMALL_LOSS: { label: 'SMALL LOSS', emoji: '⚠️', class: 'small-loss' },
    AT_RISK: { label: 'AT RISK', emoji: '🔴', class: 'at-risk' },
    STOPPED_OUT: { label: 'STOPPED OUT', emoji: '💀', class: 'stopped-out' },
    LOADING: { label: 'LOADING', emoji: '⏳', class: 'loading' }
};

// Save current signal to saved trades - ENHANCED
function saveTrade() {
    const sig = STATE.current;
    if (!sig) {
        toast('No signal selected!', 'error');
        return;
    }
    
    // Check if already saved
    const exists = STATE.savedTrades.find(t => 
        t.symbol === sig.symbol && t.tf === sig.tf && t.direction === sig.direction
    );
    
    if (exists) {
        toast('Trade already saved!', 'warning');
        return;
    }
    
    // Enhanced saved trade structure
    const savedTrade = {
        id: Date.now(),
        symbol: sig.symbol,
        tf: sig.tf,
        tfRaw: sig.tfRaw,
        direction: sig.direction,
        
        // ORIGINAL DATA (never changes)
        original: {
            price: sig.price,
            entry: sig.levels.entry,
            sl: sig.levels.sl,
            tp1: sig.levels.tp1,
            tp2: sig.levels.tp2,
            tp3: sig.levels.tp3,
            rr: sig.levels.rr,
            riskPct: sig.levels.riskPct,
            grade: sig.grade,
            score: sig.score,
            agreed: sig.agreed,
            factors: sig.factors ? sig.factors.slice(0, 5) : [],
            warnings: sig.warnings ? sig.warnings.slice(0, 3) : [],
            smart: sig.levels.smart,
            institutional: sig.institutional,
            instAnalysis: sig.instAnalysis,
            zone: sig.zone,
            smc: sig.smc,
            momentum: sig.momentum,
            candlePatterns: sig.candlePatterns
        },
        
        // LIVE DATA (updates every scan)
        live: {
            currentPrice: sig.price,
            pnlAbsolute: 0,
            pnlPercent: 0,
            distanceToSL: 0,
            distanceToTP1: 0,
            distanceToTP2: 0,
            distanceToTP3: 0,
            progressPercent: 0,
            status: 'NEAR_ENTRY',
            structureValid: true,
            newPatterns: [],
            lastUpdated: Date.now()
        },
        
        // AI INTERPRETATION
        ai: {
            commentary: null,
            recommendation: null,
            moveSlToBE: false,
            warnings: [],
            confidence: 0,
            lastUpdated: null
        },
        
        savedAt: Date.now(),
        savedAtStr: new Date().toLocaleString()
    };
    
    // Calculate initial live data
    updateSavedTradeLiveData(savedTrade, sig.price);
    
    STATE.savedTrades.unshift(savedTrade);
    
    if (STATE.savedTrades.length > 50) {
        STATE.savedTrades = STATE.savedTrades.slice(0, 50);
    }
    
    saveSavedTrades();
    updateSavedTradesListEnhanced();
    
    toast(`💾 Saved ${sig.symbol.replace('USDT', '')} ${sig.direction}!`, 'success');
}

// Update live data for a saved trade
function updateSavedTradeLiveData(trade, currentPrice) {
    const orig = trade.original || trade;
    const isLong = trade.direction === 'LONG';
    
    // Protect against division by zero
    const entryPrice = orig.entry || 1;
    const currentP = currentPrice || entryPrice;
    
    const pnlAbsolute = isLong ? currentP - entryPrice : entryPrice - currentP;
    const pnlPercent = entryPrice > 0 ? (pnlAbsolute / entryPrice) * 100 : 0;
    
    const distanceToSL = currentP > 0 ? Math.abs(currentP - (orig.sl || 0)) / currentP * 100 : 0;
    const distanceToTP1 = currentP > 0 ? Math.abs((orig.tp1 || 0) - currentP) / currentP * 100 : 0;
    const distanceToTP2 = currentP > 0 ? Math.abs((orig.tp2 || 0) - currentP) / currentP * 100 : 0;
    const distanceToTP3 = currentP > 0 ? Math.abs((orig.tp3 || 0) - currentP) / currentP * 100 : 0;
    
    const totalDistance = Math.abs((orig.tp1 || 0) - entryPrice);
    const coveredDistance = isLong 
        ? Math.max(0, currentP - entryPrice)
        : Math.max(0, entryPrice - currentP);
    const progressPercent = totalDistance > 0 ? Math.min(100, (coveredDistance / totalDistance) * 100) : 0;
    
    // Determine status
    let status = 'NEAR_ENTRY';
    
    if (isLong && currentPrice <= orig.sl) status = 'STOPPED_OUT';
    else if (!isLong && currentPrice >= orig.sl) status = 'STOPPED_OUT';
    else if (isLong && currentPrice >= orig.tp3) status = 'TP3_HIT';
    else if (!isLong && currentPrice <= orig.tp3) status = 'TP3_HIT';
    else if (isLong && currentPrice >= orig.tp2) status = 'TP2_HIT';
    else if (!isLong && currentPrice <= orig.tp2) status = 'TP2_HIT';
    else if (isLong && currentPrice >= orig.tp1) status = 'TP1_HIT';
    else if (!isLong && currentPrice <= orig.tp1) status = 'TP1_HIT';
    else if (pnlPercent >= 2) status = 'STRONG_PROFIT';
    else if (pnlPercent > 0.3) status = 'IN_PROFIT';
    else if (pnlPercent >= -0.5) status = 'NEAR_ENTRY';
    else if (pnlPercent >= -1.5) status = 'SMALL_LOSS';
    else status = 'AT_RISK';
    
    trade.live = {
        currentPrice,
        pnlAbsolute,
        pnlPercent,
        distanceToSL,
        distanceToTP1,
        distanceToTP2,
        distanceToTP3,
        progressPercent,
        status,
        structureValid: trade.live?.structureValid ?? true,
        newPatterns: trade.live?.newPatterns ?? [],
        lastUpdated: Date.now()
    };
    
    return trade;
}

// Fetch current price for saved trade
async function fetchCurrentPriceForSaved(symbol) {
    try {
        const url = `${CONFIG.BYBIT_BASE}/v5/market/tickers?category=linear&symbol=${symbol}`;
        const data = await fetchJSON(url);
        if (data?.result?.list?.[0]) {
            return parseFloat(data.result.list[0].lastPrice);
        }
    } catch (e) {
        console.error(`Failed to fetch price for ${symbol}:`, e);
    }
    return null;
}

// Update all saved trades with live data
async function updateAllSavedTradesLive() {
    if (STATE.savedTrades.length === 0) return;
    
    console.log('📊 Updating saved trades live data...');
    
    for (const trade of STATE.savedTrades) {
        const currentPrice = await fetchCurrentPriceForSaved(trade.symbol);
        if (currentPrice) {
            updateSavedTradeLiveData(trade, currentPrice);
        }
    }
    
    saveSavedTrades();
    updateSavedTradesListEnhanced();
    console.log('✅ Saved trades updated');
}

// Refresh single saved trade
async function refreshSavedTrade(tradeId) {
    const trade = STATE.savedTrades.find(t => t.id === tradeId);
    if (!trade) return;
    
    toast(`🔄 Refreshing ${trade.symbol.replace('USDT', '')}...`, 'info');
    
    const currentPrice = await fetchCurrentPriceForSaved(trade.symbol);
    if (currentPrice) {
        updateSavedTradeLiveData(trade, currentPrice);
        saveSavedTrades();
        updateSavedTradesListEnhanced();
        toast(`✅ ${trade.symbol.replace('USDT', '')} updated!`, 'success');
    } else {
        toast(`❌ Failed to update`, 'error');
    }
}

// Get AI interpretation for saved trade
async function getAITradeInterpretation(tradeId) {
    const trade = STATE.savedTrades.find(t => t.id === tradeId);
    if (!trade) return;
    
    if (!STATE.aiKey) {
        toast('AI not configured. Add API key in settings.', 'warning');
        return;
    }
    
    // SAFETY: Prevent concurrent AI calls
    if (STATE.aiCallInProgress) {
        toast('AI analysis in progress...', 'warning');
        return;
    }
    
    STATE.aiCallInProgress = true;
    toast(`🤖 Getting AI analysis...`, 'info');
    
    try {
    const orig = trade.original || trade;
    const live = trade.live || {};
    const statusInfo = TRADE_STATUS[live.status] || TRADE_STATUS.LOADING;
    const hoursSinceSaved = ((Date.now() - trade.savedAt) / (1000 * 60 * 60)).toFixed(1);
    
    const prompt = `You are monitoring an ACTIVE crypto futures trade. Provide a brief progress update.

TRADE: ${trade.symbol} ${trade.direction} (${trade.tf})
Saved: ${hoursSinceSaved} hours ago

ORIGINAL:
- Entry: $${fmtPrice(orig.entry)} | SL: $${fmtPrice(orig.sl)} (${orig.riskPct}%)
- TP1: $${fmtPrice(orig.tp1)} | TP2: $${fmtPrice(orig.tp2)} | TP3: $${fmtPrice(orig.tp3)}
- Grade: ${orig.grade} (${orig.score}/100) | R:R: 1:${orig.rr}

CURRENT:
- Price: $${fmtPrice(live.currentPrice)} | P&L: ${live.pnlPercent >= 0 ? '+' : ''}${(live.pnlPercent || 0).toFixed(2)}%
- Status: ${statusInfo.label} | Progress to TP1: ${(live.progressPercent || 0).toFixed(0)}%
- Distance to SL: ${(live.distanceToSL || 0).toFixed(2)}% | to TP1: ${(live.distanceToTP1 || 0).toFixed(2)}%

TASK: Provide 2-3 sentence update on progress, concerns, and if SL should move to breakeven.

Respond ONLY with JSON:
{
    "commentary": "Your analysis here",
    "recommendation": "HOLD" or "TAKE_PROFIT" or "MOVE_SL_TO_BE" or "EXIT",
    "moveSlToBE": true/false,
    "warnings": [],
    "confidence": 0-100
}`;

        const response = await callMultiAI(prompt);
        
        if (response) {
            trade.ai = {
                commentary: response.commentary || response.executiveSummary || 'Analysis complete.',
                recommendation: response.recommendation || 'HOLD',
                moveSlToBE: response.moveSlToBE || false,
                warnings: response.warnings || [],
                confidence: response.confidence || 50,
                lastUpdated: Date.now()
            };
            
            saveSavedTrades();
            updateSavedTradesListEnhanced();
            toast(`🤖 AI analysis complete!`, 'success');
        } else {
            toast(`❌ AI analysis failed`, 'error');
        }
    } catch (e) {
        console.error('AI interpretation error:', e);
        toast(`❌ AI analysis failed`, 'error');
    } finally {
        // SAFETY: Always release AI lock
        STATE.aiCallInProgress = false;
    }
}

// Delete saved trade
function deleteSavedTrade(id) {
    STATE.savedTrades = STATE.savedTrades.filter(t => t.id !== id);
    saveSavedTrades();
    updateSavedTradesListEnhanced();
    toast('Trade deleted', 'success');
}

// View saved trade details
async function viewSavedTrade(id) {
    const trade = STATE.savedTrades.find(t => t.id === id);
    if (!trade) {
        toast('Trade not found', 'error');
        return;
    }
    
    // Get original data (handles both old and new format)
    const orig = trade.original || trade;
    
    // First check if signal exists in current scan results
    const matchingSignal = STATE.signals.find(s => 
        s.symbol === trade.symbol && s.tfRaw === trade.tfRaw
    );
    
    if (matchingSignal) {
        // Signal exists in current scan - use it directly
        // Add saved trade comparison data
        matchingSignal.savedTrade = {
            savedAt: trade.savedAt,
            savedEntry: orig.entry,
            savedSL: orig.sl,
            savedTP1: orig.tp1,
            savedTP2: orig.tp2,
            savedTP3: orig.tp3,
            savedDirection: trade.direction,
            savedGrade: orig.grade,
            savedScore: orig.score
        };
        selectSignal(STATE.signals.indexOf(matchingSignal));
        toast(`✅ ${trade.symbol} - Live data loaded`, 'success');
    } else {
        // Signal NOT in current scan - RESCAN to get full analysis
        toast(`🔄 Rescanning ${trade.symbol} ${trade.tf}...`, '');
        
        try {
            // Run full analysis on this specific coin/timeframe
            const freshSignal = await analyzeSignal(trade.symbol, trade.tfRaw);
            
            if (freshSignal) {
                // Add saved trade data for comparison
                freshSignal.savedTrade = {
                    savedAt: trade.savedAt,
                    savedEntry: orig.entry,
                    savedSL: orig.sl,
                    savedTP1: orig.tp1,
                    savedTP2: orig.tp2,
                    savedTP3: orig.tp3,
                    savedDirection: trade.direction,
                    savedGrade: orig.grade,
                    savedScore: orig.score
                };
                
                // Add to signals array temporarily so selectSignal works
                STATE.signals.unshift(freshSignal);
                
                // Limit signals array size (SAFETY)
                if (STATE.signals.length > 500) {
                    STATE.signals = STATE.signals.slice(0, 500);
                }
                
                // Select and display
                STATE.selected = 0;
                STATE.current = freshSignal;
                STATE.aiResult = null;  // Clear old AI result
                updateMainPanel();
                updateSignalList();
                
                toast(`✅ ${trade.symbol} - Fresh analysis loaded!`, 'success');
            } else {
                // Analysis failed - show saved data as fallback
                displaySavedTradeDetailEnhanced(trade);
                toast(`⚠️ Could not fetch live data - showing saved`, 'warning');
            }
        } catch (e) {
            console.error('Rescan error:', e);
            displaySavedTradeDetailEnhanced(trade);
            toast(`❌ Rescan failed - showing saved data`, 'error');
        }
    }
}


// ═══════════════════════════════════════════════════════════════════════════════
// TRADE TRACKING
// ═══════════════════════════════════════════════════════════════════════════════

function trackTrade() {
    if (!STATE.current) {
        toast('No signal selected!', 'error');
        return;
    }
    
    const sig = STATE.current;
    
    // Check if already tracking
    const exists = STATE.trades.find(t => t.symbol === sig.symbol && t.tf === sig.tf);
    if (exists) {
        toast('Already tracking this trade!', 'warning');
        return;
    }
    
    const trade = {
        id: Date.now(),
        symbol: sig.symbol,
        tf: sig.tf,
        direction: sig.direction,
        grade: sig.grade,
        entry: sig.levels.entry,
        sl: sig.levels.sl,
        tp1: sig.levels.tp1,
        tp2: sig.levels.tp2,
        tp3: sig.levels.tp3,
        rr: sig.levels.rr,
        currentPrice: sig.price,
        tp1Hit: false,
        tp2Hit: false,
        tp3Hit: false,
        slHit: false,
        timestamp: new Date().toISOString()
    };
    
    STATE.trades.push(trade);
    saveTrades();
    updateTradeList();
    
    toast(`📌 Tracking ${sig.symbol.replace('USDT', '')} ${sig.direction}!`, 'success');
}

function closeTrade(id) {
    const trade = STATE.trades.find(t => t.id === id);
    if (trade) {
        // Save to history before removing
        trade.closedAt = Date.now();
        trade.status = 'closed';
        
        // Calculate P&L if we have prices
        if (trade.currentPrice && trade.entry) {
            const pnlPercent = trade.direction === 'LONG' 
                ? ((trade.currentPrice - trade.entry) / trade.entry) * 100
                : ((trade.entry - trade.currentPrice) / trade.entry) * 100;
            trade.pnlPercent = pnlPercent.toFixed(2);
        }
        
        // Add to history
        STATE.tradeHistory = STATE.tradeHistory || [];
        STATE.tradeHistory.unshift(trade);
        
        // Keep only last 100 trades
        if (STATE.tradeHistory.length > 100) {
            STATE.tradeHistory = STATE.tradeHistory.slice(0, 100);
        }
        
        saveTradeHistory();
    }
    
    STATE.trades = STATE.trades.filter(t => t.id !== id);
    saveTrades();
    updateTradeList();
    toast('Trade closed & saved to history', 'success');
}

// Save trade history
function saveTradeHistory() {
    safeStorageSet('bybit_scanner_trade_history', STATE.tradeHistory || []);
}

// Load trade history
function loadTradeHistory() {
    const saved = safeStorageGet('bybit_scanner_trade_history', []);
    STATE.tradeHistory = Array.isArray(saved) ? saved : [];
}

// Get trade stats from history
function getTradeStats() {
    const history = STATE.tradeHistory || [];
    const total = history.length;
    const profitable = history.filter(t => parseFloat(t.pnlPercent || 0) > 0).length;
    const losing = history.filter(t => parseFloat(t.pnlPercent || 0) < 0).length;
    const winRate = total > 0 ? ((profitable / total) * 100).toFixed(1) : 0;
    
    let totalPnL = 0;
    history.forEach(t => {
        if (t.pnlPercent) totalPnL += parseFloat(t.pnlPercent);
    });
    
    return { profitable, losing, total, winRate, totalPnL: totalPnL.toFixed(2) };
}

function saveTrades() {
    safeStorageSet('bybit_scanner_trades', STATE.trades);
}

function loadTrades() {
    const saved = safeStorageGet('bybit_scanner_trades', []);
    STATE.trades = Array.isArray(saved) ? saved : [];
    // Also load history
    loadTradeHistory();
    // Also load saved trades
    loadSavedTrades();
}

// Display saved trade detail - Enhanced with 3 rows
function displaySavedTradeDetailEnhanced(trade) {
    const el = document.getElementById('mainPanel');
    const orig = trade.original || trade;
    const live = trade.live || {};
    const ai = trade.ai || {};
    
    const statusInfo = TRADE_STATUS[live.status] || TRADE_STATUS.LOADING;
    const pnlClass = (live.pnlPercent || 0) >= 0 ? 'profit' : 'loss';
    const statusBg = statusInfo.class.includes('profit') || statusInfo.class.includes('tp') ? 'var(--long-dim)' : 
                     statusInfo.class.includes('risk') || statusInfo.class.includes('stop') ? 'var(--short-dim)' : 'var(--amber-dim)';
    const statusBorder = statusInfo.class.includes('profit') || statusInfo.class.includes('tp') ? 'var(--long)' : 
                        statusInfo.class.includes('risk') || statusInfo.class.includes('stop') ? 'var(--short)' : 'var(--amber)';
    
    el.innerHTML = `
        <div class="detail-box">
            <div class="detail-header">
                <div class="detail-title">
                    <span class="detail-pair">${trade.symbol.replace('USDT', '')}</span>
                    <span class="dir-tag ${trade.direction.toLowerCase()}">${trade.direction}</span>
                    <span class="grade-badge ${(orig.grade || 'valid').toLowerCase()}">${orig.grade || 'VALID'}</span>
                    <span style="font-size:10px;color:var(--amber);margin-left:8px">💾 SAVED</span>
                </div>
                <div class="detail-sub">
                    <span>📊 ${trade.tf}</span>
                    <span>💯 Score: ${(orig.score || 0).toFixed(0)}</span>
                </div>
            </div>
            
            <!-- STATUS BANNER -->
            <div style="background:${statusBg};border:1px solid ${statusBorder};border-radius:6px;padding:12px;margin-bottom:12px;text-align:center">
                <div style="font-size:24px;margin-bottom:4px">${statusInfo.emoji}</div>
                <div style="font-size:14px;font-weight:700;color:${statusBorder}">${statusInfo.label}</div>
                <div style="font-size:20px;font-weight:700;margin-top:4px;color:${pnlClass === 'profit' ? 'var(--long)' : 'var(--short)'}">
                    ${(live.pnlPercent || 0) >= 0 ? '+' : ''}${(live.pnlPercent || 0).toFixed(2)}%
                </div>
                <div style="font-size:11px;color:var(--text3);margin-top:4px">
                    Current: $${fmtPrice(live.currentPrice || orig.entry)} | Saved: ${trade.savedAtStr}
                </div>
            </div>
            
            <!-- PROGRESS BAR -->
            <div style="background:var(--bg3);border-radius:6px;padding:12px;margin-bottom:12px">
                <div style="font-size:11px;color:var(--text3);margin-bottom:8px">📈 Progress to TP1</div>
                <div style="position:relative;height:30px;background:var(--bg4);border-radius:15px;overflow:visible;margin-bottom:8px">
                    <div style="position:absolute;left:0;top:0;height:100%;width:${Math.max(0, Math.min(100, live.progressPercent || 0))}%;
                                background:linear-gradient(90deg, ${pnlClass === 'profit' ? 'var(--long-dim), var(--long)' : 'var(--short), var(--short-dim)'});
                                border-radius:15px;transition:width 0.5s"></div>
                    <div style="position:absolute;left:0%;top:50%;transform:translate(-50%,-50%);background:var(--cyan);color:#000;font-size:9px;font-weight:700;padding:2px 6px;border-radius:3px;z-index:2">Entry</div>
                    <div style="position:absolute;left:${Math.max(5, Math.min(95, live.progressPercent || 0))}%;top:50%;transform:translate(-50%,-50%);background:var(--gold);color:#000;font-size:10px;font-weight:700;padding:3px 8px;border-radius:4px;z-index:3;box-shadow:0 0 10px var(--gold)">📍 NOW</div>
                    <div style="position:absolute;left:100%;top:50%;transform:translate(-50%,-50%);background:var(--long);color:#000;font-size:9px;font-weight:700;padding:2px 6px;border-radius:3px;z-index:2">TP1</div>
                </div>
                <div style="display:flex;justify-content:space-between;font-size:10px;color:var(--text3)">
                    <span>🛑 SL: ${(live.distanceToSL || 0).toFixed(1)}% away</span>
                    <span>${(live.progressPercent || 0).toFixed(0)}% complete</span>
                    <span>🎯 TP1: ${(live.distanceToTP1 || 0).toFixed(1)}% away</span>
                </div>
            </div>
            
            <!-- ORIGINAL LEVELS -->
            <div style="background:var(--bg3);border-radius:6px;padding:12px;margin-bottom:12px">
                <div style="font-size:11px;color:var(--text3);margin-bottom:8px">📸 Original Trade Levels</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px">
                    <div style="background:var(--bg4);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--cyan)">
                        <div style="font-size:10px;color:var(--text3)">ENTRY</div>
                        <div style="font-size:13px;font-weight:700;color:var(--cyan)">$${fmtPrice(orig.entry)}</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--short)">
                        <div style="font-size:10px;color:var(--text3)">STOP LOSS</div>
                        <div style="font-size:13px;font-weight:700;color:var(--short)">$${fmtPrice(orig.sl)}</div>
                        <div style="font-size:9px;color:var(--short)">${orig.riskPct || '?'}%</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:6px;padding:8px;text-align:center;border:1px solid var(--long)">
                        <div style="font-size:10px;color:var(--text3)">R:R</div>
                        <div style="font-size:13px;font-weight:700;color:var(--long)">1:${orig.rr || '?'}</div>
                    </div>
                </div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
                    <div style="background:var(--bg4);border-radius:4px;padding:6px;text-align:center">
                        <div style="font-size:9px;color:var(--text3)">TP1</div>
                        <div style="font-size:11px;font-weight:600;color:var(--long)">$${fmtPrice(orig.tp1)}</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:4px;padding:6px;text-align:center">
                        <div style="font-size:9px;color:var(--text3)">TP2</div>
                        <div style="font-size:11px;font-weight:600;color:var(--long)">$${fmtPrice(orig.tp2)}</div>
                    </div>
                    <div style="background:var(--bg4);border-radius:4px;padding:6px;text-align:center">
                        <div style="font-size:9px;color:var(--text3)">TP3</div>
                        <div style="font-size:11px;font-weight:600;color:var(--long)">$${fmtPrice(orig.tp3)}</div>
                    </div>
                </div>
            </div>
            
            <!-- AI INTERPRETATION -->
            <div style="background:linear-gradient(90deg, rgba(168,85,247,0.1) 0%, var(--bg3) 100%);border-radius:6px;padding:12px;margin-bottom:12px;border-left:3px solid var(--purple)">
                <div style="font-size:11px;color:var(--purple);margin-bottom:8px;font-weight:600">🤖 AI Interpretation</div>
                ${ai.commentary ? `
                    <div style="font-size:12px;color:var(--text);line-height:1.5;margin-bottom:8px">${ai.commentary}</div>
                    ${ai.recommendation ? `<div style="display:inline-block;padding:4px 10px;background:var(--purple-dim);border:1px solid var(--purple);border-radius:4px;font-size:10px;font-weight:600;color:var(--purple)">📋 ${ai.recommendation}</div>` : ''}
                    ${ai.moveSlToBE ? `<div style="margin-top:8px;padding:6px 10px;background:var(--long-dim);border:1px solid var(--long);border-radius:4px;font-size:11px;color:var(--long)">💡 Consider moving SL to breakeven ($${fmtPrice(orig.entry)})</div>` : ''}
                    ${ai.warnings?.length > 0 ? `<div style="margin-top:8px;padding:6px 10px;background:var(--amber-dim);border:1px solid var(--amber);border-radius:4px;font-size:11px;color:var(--amber)">⚠️ ${ai.warnings.join(' • ')}</div>` : ''}
                    <div style="font-size:9px;color:var(--text3);margin-top:8px">Last AI update: ${ai.lastUpdated ? new Date(ai.lastUpdated).toLocaleString() : 'Never'}</div>
                ` : `
                    <div style="text-align:center;padding:10px">
                        <div style="color:var(--text3);font-size:11px;margin-bottom:8px">No AI analysis yet</div>
                        <button onclick="getAITradeInterpretation(${trade.id})" style="padding:8px 16px;background:var(--purple-dim);border:1px solid var(--purple);color:var(--purple);border-radius:4px;font-size:11px;font-weight:600;cursor:pointer">🤖 Get AI Analysis</button>
                    </div>
                `}
            </div>
            
            ${orig.factors?.length > 0 ? `
            <div style="background:var(--bg3);border-radius:6px;padding:10px;margin-bottom:12px">
                <div style="font-size:11px;color:var(--text2);margin-bottom:6px">✅ Original Factors</div>
                <div style="display:flex;flex-wrap:wrap;gap:4px">${orig.factors.map(f => `<span style="font-size:10px;padding:3px 6px;background:var(--long-dim);color:var(--long);border-radius:3px">${f}</span>`).join('')}</div>
            </div>` : ''}
            
            <div style="display:flex;gap:8px;margin-top:12px">
                <button class="btn" onclick="refreshSavedTrade(${trade.id})" style="flex:1;background:var(--cyan-dim);border-color:var(--cyan);color:var(--cyan)">🔄 Refresh</button>
                <button class="btn" onclick="getAITradeInterpretation(${trade.id})" style="flex:1;background:var(--purple-dim);border-color:var(--purple);color:var(--purple)">🤖 AI</button>
            </div>
            <div style="display:flex;gap:8px;margin-top:8px">
                <button class="btn" onclick="rescanSavedTrade('${trade.symbol}', '${trade.tfRaw}')" style="flex:2;background:var(--long-dim);border-color:var(--long);color:var(--long)">📊 Full Rescan</button>
                <button class="btn" onclick="deleteSavedTrade(${trade.id})" style="flex:1;background:var(--short-dim);border-color:var(--short);color:var(--short)">🗑️</button>
            </div>
        </div>`;
}

// Rescan saved trade
async function rescanSavedTrade(symbol, tf) {
    toast(`📊 Scanning ${symbol}...`, 'info');
    try {
        const result = await analyzeSignal(symbol, tf);
        if (result) {
            const existingIdx = STATE.signals.findIndex(s => s.symbol === symbol && s.tf === result.tf);
            if (existingIdx >= 0) STATE.signals[existingIdx] = result;
            else STATE.signals.unshift(result);
            STATE.current = result;
            renderDetail(result);
            updateSignalList();
            toast(`✅ ${symbol} rescanned!`, 'success');
        } else {
            toast(`No signal for ${symbol}`, 'warning');
        }
    } catch (e) {
        console.error('Rescan error:', e);
        toast('Rescan failed', 'error');
    }
}

// Update saved trades list - Enhanced with 3 rows
function updateSavedTradesListEnhanced() {
    const el = document.getElementById('savedList');
    const countEl = document.getElementById('savedCount');
    if (!el || !countEl) return;
    
    countEl.textContent = STATE.savedTrades.length;
    
    if (STATE.savedTrades.length === 0) {
        el.innerHTML = `<div class="saved-empty"><div class="saved-empty-icon">💾</div><div class="saved-empty-text">No saved trades yet</div></div>`;
        return;
    }
    
    el.innerHTML = `<button class="saved-refresh-all" onclick="updateAllSavedTradesLive()">🔄 Refresh All Prices</button>` +
        STATE.savedTrades.map(trade => renderSavedTradeCardEnhanced(trade)).join('');
}

// Render single saved trade card with 3 rows
function renderSavedTradeCardEnhanced(trade) {
    const orig = trade.original || trade;
    const live = trade.live || { currentPrice: orig.price || orig.entry, pnlPercent: 0, progressPercent: 0, status: 'LOADING' };
    const ai = trade.ai || {};
    
    const statusInfo = TRADE_STATUS[live.status] || TRADE_STATUS.LOADING;
    const pnlClass = (live.pnlPercent || 0) >= 0 ? 'profit' : 'loss';
    
    const hoursAgo = Math.floor((Date.now() - trade.savedAt) / (1000 * 60 * 60));
    const timeAgo = hoursAgo < 1 ? 'Just now' : hoursAgo < 24 ? `${hoursAgo}h ago` : `${Math.floor(hoursAgo / 24)}d ago`;
    
    // FIX: Make header clickable to open full analysis
    return `
        <div class="saved-card-enhanced ${trade.direction.toLowerCase()}">
            <div class="saved-card-header" onclick="viewSavedTrade(${trade.id})" style="cursor:pointer" title="Click for full analysis">
                <div class="saved-card-pair">
                    ${trade.symbol.replace('USDT', '')}
                    <span class="saved-card-dir ${trade.direction.toLowerCase()}">${trade.direction}</span>
                    <span style="font-size:10px;color:var(--text3)">${trade.tf}</span>
                    <span style="font-size:9px;color:var(--cyan);margin-left:4px">📊 Tap for details</span>
                </div>
                <div class="saved-status-badge ${statusInfo.class}">${statusInfo.emoji} ${statusInfo.label}</div>
            </div>
            
            <!-- ROW 1: ORIGINAL -->
            <div class="saved-row original">
                <div class="saved-row-label"><span class="emoji">📸</span> SAVED</div>
                <div class="saved-original-grid">
                    <div class="saved-original-item"><div class="label">Entry</div><div class="value entry">$${fmtPrice(orig.entry)}</div></div>
                    <div class="saved-original-item"><div class="label">SL</div><div class="value sl">$${fmtPrice(orig.sl)}</div></div>
                    <div class="saved-original-item"><div class="label">TP1</div><div class="value tp">$${fmtPrice(orig.tp1)}</div></div>
                    <div class="saved-original-item"><div class="label">R:R</div><div class="value rr">1:${orig.rr}</div></div>
                </div>
            </div>
            
            <!-- ROW 2: LIVE -->
            <div class="saved-row live">
                <div class="saved-row-label"><span class="emoji">📊</span> NOW</div>
                <div class="saved-live-header">
                    <div class="saved-live-price">$${fmtPrice(live.currentPrice)}</div>
                    <div class="saved-live-pnl ${pnlClass}">${(live.pnlPercent || 0) >= 0 ? '+' : ''}${(live.pnlPercent || 0).toFixed(2)}%</div>
                </div>
                <div class="saved-progress-container">
                    <div class="saved-progress-bar">
                        <div class="saved-progress-fill ${pnlClass}" style="width:${Math.max(0, Math.min(100, live.progressPercent || 0))}%"></div>
                        <div class="saved-progress-marker current" style="left:${Math.max(5, Math.min(95, live.progressPercent || 0))}%">📍</div>
                    </div>
                    <div class="saved-progress-labels">
                        <span>SL: ${(live.distanceToSL || 0).toFixed(1)}%</span>
                        <span>${(live.progressPercent || 0).toFixed(0)}% to TP1</span>
                        <span>TP1: ${(live.distanceToTP1 || 0).toFixed(1)}%</span>
                    </div>
                </div>
            </div>
            
            <!-- ROW 3: AI -->
            <div class="saved-row ai">
                <div class="saved-row-label"><span class="emoji">🤖</span> AI</div>
                ${ai.commentary ? `
                    <div class="saved-ai-commentary">${ai.commentary}</div>
                    ${ai.moveSlToBE ? '<div class="saved-ai-suggestion">💡 Move SL to BE</div>' : ''}
                ` : `<div class="saved-ai-loading"><button class="saved-ai-btn" onclick="getAITradeInterpretation(${trade.id})">🤖 Get AI</button></div>`}
            </div>
            
            <div class="saved-card-actions">
                <button class="saved-action-btn refresh" onclick="refreshSavedTrade(${trade.id})" title="Refresh live data">🔄</button>
                <button class="saved-action-btn details" onclick="viewSavedTrade(${trade.id})" title="Full analysis">📊</button>
                <button class="saved-action-btn delete" onclick="deleteSavedTrade(${trade.id})" title="Delete">🗑️</button>
            </div>
            <div class="saved-last-updated">Saved ${timeAgo}</div>
        </div>`;
}

function formatTimeAgo(timestamp) {
    const seconds = Math.floor((Date.now() - timestamp) / 1000);
    if (seconds < 60) return 'just now';
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
    return `${Math.floor(seconds / 86400)}d ago`;
}

function saveSavedTrades() {
    try {
        // SAFETY: Limit saved trades before saving
        const maxTrades = CONFIG.SAFETY?.MAX_SAVED_TRADES || 50;
        if (STATE.savedTrades.length > maxTrades) {
            STATE.savedTrades = STATE.savedTrades.slice(0, maxTrades);
        }
        
        const data = JSON.stringify(STATE.savedTrades);
        
        // SAFETY: Check storage size (2MB limit)
        const maxSize = (CONFIG.SAFETY?.MAX_STORAGE_MB || 2) * 1024 * 1024;
        if (data.length > maxSize) {
            console.warn('⚠️ Storage data too large, truncating...');
            // Keep only half the trades
            STATE.savedTrades = STATE.savedTrades.slice(0, Math.floor(maxTrades / 2));
        }
        
        safeStorageSet('bybit_scanner_saved_trades', STATE.savedTrades);
    } catch (e) {
        console.error('Failed to save:', e);
        // SAFETY: If storage full, clear old data
        if (e.name === 'QuotaExceededError') {
            console.warn('⚠️ Storage full, clearing old trades...');
            STATE.savedTrades = STATE.savedTrades.slice(0, 10);
            safeStorageSet('bybit_scanner_saved_trades', STATE.savedTrades);
        }
    }
}

function loadSavedTrades() {
    const saved = safeStorageGet('bybit_scanner_saved_trades', []);
    STATE.savedTrades = Array.isArray(saved) ? saved : [];
    STATE.savedTrades = STATE.savedTrades.map(trade => {
        if (!trade.original) {
            return {
                ...trade,
                original: { price: trade.price, entry: trade.entry, sl: trade.sl, tp1: trade.tp1, tp2: trade.tp2, tp3: trade.tp3, rr: trade.rr, riskPct: trade.riskPct, grade: trade.grade, score: trade.score, agreed: trade.agreed, factors: trade.factors, warnings: trade.warnings },
                live: { currentPrice: trade.price || trade.entry, pnlPercent: 0, progressPercent: 0, status: 'LOADING', lastUpdated: null },
                ai: { commentary: null, lastUpdated: null }
            };
        }
        return trade;
    });
    updateSavedTradesListEnhanced();
}

function toggleSavedTrades() {
    const list = document.getElementById('savedList');
    const toggle = document.getElementById('savedToggle');
    if (list.style.display === 'none') { list.style.display = 'block'; toggle.classList.add('open'); }
    else { list.style.display = 'none'; toggle.classList.remove('open'); }
}

function updateSavedTradesList() { updateSavedTradesListEnhanced(); }

async function updateTradePrices() {
    for (const trade of STATE.trades) {
        try {
            const url = `${CONFIG.BYBIT_BASE}/v5/market/tickers?category=linear&symbol=${trade.symbol}`;
            const data = await fetchJSON(url);
            
            if (data && data.result && data.result.list && data.result.list[0]) {
                trade.currentPrice = parseFloat(data.result.list[0].lastPrice);
                
                // Check TP/SL hits
                if (trade.direction === 'LONG') {
                    if (trade.currentPrice >= trade.tp1) trade.tp1Hit = true;
                    if (trade.currentPrice >= trade.tp2) trade.tp2Hit = true;
                    if (trade.currentPrice >= trade.tp3) trade.tp3Hit = true;
                    if (trade.currentPrice <= trade.sl) trade.slHit = true;
                } else {
                    if (trade.currentPrice <= trade.tp1) trade.tp1Hit = true;
                    if (trade.currentPrice <= trade.tp2) trade.tp2Hit = true;
                    if (trade.currentPrice <= trade.tp3) trade.tp3Hit = true;
                    if (trade.currentPrice >= trade.sl) trade.slHit = true;
                }
            }
        } catch (e) {
            console.error(`Failed to update price for ${trade.symbol}:`, e);
        }
    }
    
    saveTrades();
    updateTradeList();
}

function updateTradeList() {
    const el = document.getElementById('activeList');
    const countEl = document.getElementById('activeCount');
    
    // Guard against missing elements (if Active Trades section removed)
    if (!el || !countEl) return;
    
    countEl.textContent = STATE.trades.length;
    
    if (STATE.trades.length === 0) {
        el.innerHTML = '<div style="text-align:center;color:var(--text3);font-size:12px;padding:8px">No active trades</div>';
        return;
    }
    
    el.innerHTML = STATE.trades.map(trade => {
        const pnl = trade.direction === 'LONG' 
            ? ((trade.currentPrice - trade.entry) / trade.entry) * 100
            : ((trade.entry - trade.currentPrice) / trade.entry) * 100;
        
        const pnlClass = pnl >= 0 ? 'profit' : 'loss';
        
        return `
            <div class="active-card ${trade.direction.toLowerCase()}">
                <div class="active-top">
                    <div class="active-pair">
                        ${trade.symbol.replace('USDT', '')}
                        <span class="dir-tag ${trade.direction.toLowerCase()}">${trade.direction}</span>
                    </div>
                    <span class="active-pnl ${pnlClass}">${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}%</span>
                </div>
                <div class="active-levels">
                    <div class="active-level">
                        <div class="active-level-label">Entry</div>
                        <div class="active-level-value" style="color:var(--cyan)">$${fmtPrice(trade.entry)}</div>
                    </div>
                    <div class="active-level ${trade.slHit ? 'stopped' : ''}">
                        <div class="active-level-label">SL</div>
                        <div class="active-level-value" style="color:var(--short)">$${fmtPrice(trade.sl)}</div>
                    </div>
                    <div class="active-level ${trade.tp1Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP1</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp1)}</div>
                    </div>
                    <div class="active-level ${trade.tp2Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP2</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp2)}</div>
                    </div>
                    <div class="active-level ${trade.tp3Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP3</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp3)}</div>
                    </div>
                </div>
                <div class="active-meta">
                    <span>${trade.grade} • ${trade.tf} • R:R 1:${trade.rr}</span>
                    <button class="close-btn" onclick="closeTrade(${trade.id})">✕ Close</button>
                </div>
            </div>
        `;
    }).join('');
}

// ═══════════════════════════════════════════════════════════════════════════════
// EVENT HANDLERS
// ═══════════════════════════════════════════════════════════════════════════════

function selectSignal(idx) {
    STATE.selected = idx;
    STATE.current = JSON.parse(JSON.stringify(STATE.signals[idx]));
    STATE.aiResult = null;
    
    updateSignalList();
    updateMainPanel();
}

function toggleScan() {
    STATE.scanning = !STATE.scanning;
    
    const btn = document.getElementById('scanBtn');
    const icon = document.getElementById('scanIcon');
    
    if (STATE.scanning) {
        btn.className = 'btn scanning';
        icon.textContent = '◉';
        resetScanProgress(); // Show rainbow progress bar immediately
        runScanner();
    } else {
        btn.className = 'btn';
        icon.textContent = '●';
    }
}

function setMode(mode) {
    STATE.mode = mode;
    STATE.selected = null;
    STATE.current = null;
    STATE.aiResult = null;
    
    document.getElementById('modeAll').className = 'mode-btn' + (mode === 'ALL' ? ' active' : '');
    document.getElementById('modeScalp').className = 'mode-btn' + (mode === 'SCALP' ? ' active' : '');
    document.getElementById('modeSwing').className = 'mode-btn' + (mode === 'SWING' ? ' active' : '');
    
    updateSignalList();
    updateCounts();
    updateMainPanel();
}

function setFilter(filter) {
    STATE.filter = filter;
    
    document.getElementById('filterAll').className = 'filter-btn' + (filter === 'all' ? ' active' : '');
    document.getElementById('filterPerfect').className = 'filter-btn' + (filter === 'perfect' ? ' active' : '');
    document.getElementById('filterReady').className = 'filter-btn' + (filter === 'ready' ? ' active' : '');
    document.getElementById('filterEarly').className = 'filter-btn' + (filter === 'early' ? ' active' : '');
    
    updateSignalList();
}

// AI Display Mode toggle (Detailed vs Compact)
function setAIDisplayMode(mode) {
    STATE.aiDisplayMode = mode;
    
    // Update button styles
    const detailedBtn = document.getElementById('aiModeDetailed');
    const compactBtn = document.getElementById('aiModeCompact');
    
    if (detailedBtn && compactBtn) {
        if (mode === 'detailed') {
            detailedBtn.style.background = 'var(--purple)';
            detailedBtn.style.color = 'white';
            compactBtn.style.background = 'var(--bg4)';
            compactBtn.style.color = 'var(--text2)';
        } else {
            compactBtn.style.background = 'var(--purple)';
            compactBtn.style.color = 'white';
            detailedBtn.style.background = 'var(--bg4)';
            detailedBtn.style.color = 'var(--text2)';
        }
    }
    
    // Re-render main panel if AI result exists
    if (STATE.aiResult) {
        updateMainPanel();
    }
    
    // Save to localStorage
    safeStorageSet('bybit_scanner_ai_display_mode', mode);
    
    toast('AI Display: ' + (mode === 'detailed' ? 'Detailed (13 sections)' : 'Compact (6 sections)'), 'success');
}

async function askAI() {
    console.log('🤖 askAI() called');
    
    if (!STATE.current) {
        console.warn('⚠️ No signal selected');
        toast('Select a signal first!', 'error');
        return;
    }
    
    console.log('📊 Current signal:', STATE.current.symbol, STATE.current.tf);
    
    if (!STATE.aiKey) {
        console.warn('⚠️ No API key configured');
        toast('Configure API key in Settings!', 'warning');
        showSettings();
        return;
    }
    
    console.log('🔑 API Key present:', STATE.aiKey.substring(0, 15) + '...');
    toast('🧠 Multi-AI Analyzing...', 'warning');
    
    try {
        const result = await getAIAnalysis(STATE.current);
        console.log('📦 AI Result:', result);
        
        if (result) {
            STATE.aiResult = result;
            STATE.aiExpanded = false; // Start collapsed
            updateMainPanel();
            
            const aiDot = document.getElementById('aiDot');
            const aiStatus = document.getElementById('aiStatus');
            if (aiDot) aiDot.className = 'ai-dot on';
            if (aiStatus) aiStatus.textContent = 'AI: ' + result.verdict;
            
            toast(`${result.aiProvider || 'AI'}: ${result.verdict} (${result.confidence}%)`, 'success');
        } else {
            console.error('❌ AI result is null');
            toast('AI analysis failed', 'error');
        }
    } catch (error) {
        console.error('❌ askAI error:', error);
        toast('AI error: ' + error.message, 'error');
    }
}

function toggleAIExpand() {
    STATE.aiExpanded = !STATE.aiExpanded;
    const content = document.getElementById('aiExpandedContent');
    if (content) {
        content.style.display = STATE.aiExpanded ? 'block' : 'none';
    }
    updateMainPanel();
}

// ═══════════════════════════════════════════════════════════════════════════════
// SETTINGS
// ═══════════════════════════════════════════════════════════════════════════════

function showSettings() {
    document.getElementById('settingsModal').className = 'modal-bg show';
    
    // Load all 11 API keys into input fields
    document.getElementById('groqKey1').value = GROQ_KEYS[0] || '';
    document.getElementById('groqKey2').value = GROQ_KEYS[1] || '';
    document.getElementById('groqKey3').value = GROQ_KEYS[2] || '';
    document.getElementById('groqKey4').value = GROQ_KEYS[3] || '';
    document.getElementById('groqKey5').value = GROQ_KEYS[4] || '';
    
    // Load Groq ON/OFF toggles
    document.getElementById('groqKey1On').checked = KEY_ENABLED.groq[0];
    document.getElementById('groqKey2On').checked = KEY_ENABLED.groq[1];
    document.getElementById('groqKey3On').checked = KEY_ENABLED.groq[2];
    document.getElementById('groqKey4On').checked = KEY_ENABLED.groq[3];
    document.getElementById('groqKey5On').checked = KEY_ENABLED.groq[4];
    
    document.getElementById('deepseekKey1').value = DEEPSEEK_KEYS[0] || '';
    document.getElementById('deepseekKey1On').checked = KEY_ENABLED.deepseek[0];
    
    document.getElementById('geminiKey1').value = GEMINI_KEYS[0] || '';
    document.getElementById('geminiKey2').value = GEMINI_KEYS[1] || '';
    document.getElementById('geminiKey3').value = GEMINI_KEYS[2] || '';
    document.getElementById('geminiKey4').value = GEMINI_KEYS[3] || '';
    document.getElementById('geminiKey5').value = GEMINI_KEYS[4] || '';
    
    // Load Gemini ON/OFF toggles
    document.getElementById('geminiKey1On').checked = KEY_ENABLED.gemini[0];
    document.getElementById('geminiKey2On').checked = KEY_ENABLED.gemini[1];
    document.getElementById('geminiKey3On').checked = KEY_ENABLED.gemini[2];
    document.getElementById('geminiKey4On').checked = KEY_ENABLED.gemini[3];
    document.getElementById('geminiKey5On').checked = KEY_ENABLED.gemini[4];
    
    // Update key status indicators and grid
    for (let i = 0; i < 5; i++) updateKeyIndicator('groq', i, KEY_STATUS.groq[i]);
    updateKeyIndicator('deepseek', 0, KEY_STATUS.deepseek[0]);
    for (let i = 0; i < 5; i++) updateKeyIndicator('gemini', i, KEY_STATUS.gemini[i]);
    updateKeyStatusGrid();
    
    document.getElementById('aiModelSelect').value = STATE.aiModel;
    
    // Load timeframe toggles
    document.getElementById('tf5m').checked = STATE.tfEnabled['5'];
    document.getElementById('tf15m').checked = STATE.tfEnabled['15'];
    document.getElementById('tf30m').checked = STATE.tfEnabled['30'];
    document.getElementById('tf1h').checked = STATE.tfEnabled['60'];
    document.getElementById('tf4h').checked = STATE.tfEnabled['240'];
    document.getElementById('tf1d').checked = STATE.tfEnabled['D'];
    
    // Load scan interval
    document.getElementById('scanInterval').value = STATE.scanInterval;
    
    // Load alert settings
    document.getElementById('alertSound').checked = STATE.alertSound;
    document.getElementById('alertVibrate').checked = STATE.alertVibrate;
    document.getElementById('alertGrade').value = STATE.alertGrade;
    
    // Load telegram settings
    document.getElementById('telegramEnabled').checked = STATE.telegramEnabled;
    document.getElementById('telegramToken').value = STATE.telegramToken;
    document.getElementById('telegramChatId').value = STATE.telegramChatId;
    
    // Load risk settings
    document.getElementById('riskAccount').value = STATE.riskAccount;
    document.getElementById('riskPercent').value = STATE.riskPercent;
    document.getElementById('riskLeverage').value = STATE.riskLeverage;
    document.getElementById('riskMaxPosition').value = STATE.riskMaxPosition;
    
    // Load weight settings
    document.getElementById('weightZone').value = CONFIG.WEIGHTS.zone * 100;
    document.getElementById('weightSMC').value = CONFIG.WEIGHTS.smc * 100;
    document.getElementById('weightMomentum').value = CONFIG.WEIGHTS.momentum * 100;
    updateWeightDisplay();
    
    // Load theme
    document.getElementById('oledTheme').checked = STATE.oledTheme;
    
    // Load timezone
    const tzSelect = document.getElementById('userTimezone');
    if (tzSelect) {
        tzSelect.value = STATE.awareness?.timezone || 'Australia/Melbourne';
        tzSelect.onchange = updateTimezonePreview;
    }
    updateTimezonePreview();
    
    // Render coin manager
    renderCoinManager();
    
    updateKeyStatus();
}

function hideSettings() {
    document.getElementById('settingsModal').className = 'modal-bg';
}

function updateKeyStatus() {
    const el = document.getElementById('keyStatus');
    const groqCount = GROQ_KEYS.filter(k => k && k.length > 5).length;
    const deepseekCount = DEEPSEEK_KEYS.filter(k => k && k.length > 5).length;
    const geminiCount = GEMINI_KEYS.filter(k => k && k.length > 5).length;
    const total = groqCount + deepseekCount + geminiCount;
    
    if (total > 0) {
        el.className = 'key-status valid';
        el.textContent = `✅ ${total}/11 API Keys configured (Groq: ${groqCount}, DeepSeek: ${deepseekCount}, Gemini: ${geminiCount})`;
    } else {
        el.className = 'key-status invalid';
        el.textContent = '❌ No API Key configured';
    }
}

function toggleKeyVis() {
    // Toggle visibility for all 11 key inputs
    const keyInputs = [
        'groqKey1', 'groqKey2', 'groqKey3', 'groqKey4', 'groqKey5',
        'deepseekKey1',
        'geminiKey1', 'geminiKey2', 'geminiKey3', 'geminiKey4', 'geminiKey5'
    ];
    const firstInput = document.getElementById('groqKey1');
    const newType = firstInput.type === 'password' ? 'text' : 'password';
    keyInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.type = newType;
    });
}

function clearKey() {
    // Clear all 11 key inputs
    const keyInputs = [
        'groqKey1', 'groqKey2', 'groqKey3', 'groqKey4', 'groqKey5',
        'deepseekKey1',
        'geminiKey1', 'geminiKey2', 'geminiKey3', 'geminiKey4', 'geminiKey5'
    ];
    keyInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '';
    });
    
    // Clear arrays
    GROQ_KEYS.fill('');
    DEEPSEEK_KEYS.fill('');
    GEMINI_KEYS.fill('');
    
    STATE.aiKey = '';
    STATE.deepseekKey = '';
    STATE.geminiKey = '';
    
    safeStorageRemove('bybit_scanner_groq_keys');
    safeStorageRemove('bybit_scanner_deepseek_keys');
    safeStorageRemove('bybit_scanner_gemini_keys');
    safeStorageRemove('bybit_scanner_key');
    safeStorageRemove('bybit_scanner_deepseek');
    safeStorageRemove('bybit_scanner_gemini');
    
    updateKeyStatus();
    toast('All API keys cleared', 'warning');
}

async function testKey() {
    await testAllKeys();
}

// Test single Groq key
async function testSingleGroqKey(key) {
    if (!key || key.length < 10) return false;
    try {
        const response = await fetch(CONFIG.GROQ_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
            body: JSON.stringify({ model: 'llama-3.3-70b-versatile', messages: [{ role: 'user', content: 'Hi' }], max_tokens: 5 })
        });
        return response.ok || response.status === 429;
    } catch (e) { return false; }
}

// Test single DeepSeek key
async function testSingleDeepSeekKey(key) {
    if (!key || key.length < 10) return false;
    try {
        const response = await fetch(CONFIG.DEEPSEEK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
            body: JSON.stringify({ model: 'deepseek-chat', messages: [{ role: 'user', content: 'Hi' }], max_tokens: 5 })
        });
        return response.ok || response.status === 429;
    } catch (e) { return false; }
}

// Test single Gemini key
async function testSingleGeminiKey(key) {
    if (!key || key.length < 10) {
        console.log('❌ Gemini key too short or empty');
        return false;
    }
    
    // Gemini keys should start with AIza
    if (!key.startsWith('AIza')) {
        console.log('❌ Gemini key should start with AIza, got:', key.substring(0, 10));
        return false;
    }
    
    // Try primary model first, then fallback
    const models = [
        'gemini-2.0-flash',
        'gemini-1.5-flash',
        'gemini-1.5-flash-latest'
    ];
    
    for (const model of models) {
        try {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;
            console.log(`🔌 Testing Gemini key with ${model}:`, key.substring(0, 15) + '...');
            
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    contents: [{ parts: [{ text: 'Say OK' }] }], 
                    generationConfig: { maxOutputTokens: 5 } 
                })
            });
            
            console.log(`📡 Gemini ${model} response status:`, response.status);
            
            if (response.ok) {
                console.log(`✅ Gemini key WORKS with ${model}!`);
                // Update CONFIG to use working model
                CONFIG.GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
                return true;
            } else if (response.status === 429) {
                console.log(`⚠️ Gemini ${model} rate limited but key is valid`);
                CONFIG.GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
                return true; // Key is valid, just rate limited
            } else if (response.status === 404) {
                console.log(`⚠️ Model ${model} not found, trying next...`);
                continue; // Try next model
            } else {
                const errorData = await response.json().catch(() => ({}));
                console.log(`❌ Gemini ${model} error:`, errorData.error?.message || response.status);
                // If it's an auth error, the key is bad - don't try other models
                if (response.status === 400 || response.status === 401 || response.status === 403) {
                    return false;
                }
                continue; // Try next model for other errors
            }
        } catch (e) { 
            console.error(`❌ Gemini ${model} network error:`, e.message);
            continue; // Try next model on network error
        }
    }
    
    console.log('❌ All Gemini models failed');
    return false;
}

// Update key status indicator
function updateKeyIndicator(provider, index, status) {
    const id = `${provider}Key${index + 1}Status`;
    const el = document.getElementById(id);
    if (el) {
        if (status === true) el.textContent = '✅';
        else if (status === false) el.textContent = '❌';
        else el.textContent = '⚪';
    }
}

// Update key status grid
function updateKeyStatusGrid() {
    const slots = document.querySelectorAll('#keyStatusGrid .key-slot');
    if (slots.length !== 11) return;
    
    // Groq keys (0-4)
    for (let i = 0; i < 5; i++) {
        const hasKey = GROQ_KEYS[i] && GROQ_KEYS[i].length > 5;
        const enabled = KEY_ENABLED.groq[i];
        const status = KEY_STATUS.groq[i];
        let cls = 'key-slot empty';
        let icon = '⚪';
        
        if (hasKey) {
            if (!enabled) { cls = 'key-slot off'; icon = '⏸️'; }
            else if (status === true) { cls = 'key-slot active'; icon = '✅'; }
            else if (status === false) { cls = 'key-slot error'; icon = '❌'; }
            else { cls = 'key-slot empty'; icon = '🟢'; }
        }
        
        slots[i].className = cls;
        slots[i].querySelector('.key-slot-icon').textContent = icon;
    }
    
    // DeepSeek (5)
    {
        const hasKey = DEEPSEEK_KEYS[0] && DEEPSEEK_KEYS[0].length > 5;
        const enabled = KEY_ENABLED.deepseek[0];
        const status = KEY_STATUS.deepseek[0];
        let cls = 'key-slot empty';
        let icon = '⚪';
        
        if (hasKey) {
            if (!enabled) { cls = 'key-slot off'; icon = '⏸️'; }
            else if (status === true) { cls = 'key-slot active'; icon = '✅'; }
            else if (status === false) { cls = 'key-slot error'; icon = '❌'; }
            else { cls = 'key-slot empty'; icon = '🔵'; }
        }
        
        slots[5].className = cls;
        slots[5].querySelector('.key-slot-icon').textContent = icon;
    }
    
    // Gemini keys (6-10)
    for (let i = 0; i < 5; i++) {
        const hasKey = GEMINI_KEYS[i] && GEMINI_KEYS[i].length > 5;
        const enabled = KEY_ENABLED.gemini[i];
        const status = KEY_STATUS.gemini[i];
        let cls = 'key-slot empty';
        let icon = '⚪';
        
        if (hasKey) {
            if (!enabled) { cls = 'key-slot off'; icon = '⏸️'; }
            else if (status === true) { cls = 'key-slot active'; icon = '✅'; }
            else if (status === false) { cls = 'key-slot error'; icon = '❌'; }
            else { cls = 'key-slot empty'; icon = '🟣'; }
        }
        
        slots[6 + i].className = cls;
        slots[6 + i].querySelector('.key-slot-icon').textContent = icon;
    }
}

// Test ALL keys
async function testAllKeys() {
    toast('🔌 Testing all API keys...', 'warning');
    
    let working = 0;
    let tested = 0;
    
    // Test Groq keys
    for (let i = 0; i < 5; i++) {
        const key = document.getElementById(`groqKey${i+1}`).value.trim();
        GROQ_KEYS[i] = key;
        KEY_ENABLED.groq[i] = document.getElementById(`groqKey${i+1}On`).checked;
        
        if (key && key.length > 5 && KEY_ENABLED.groq[i]) {
            updateKeyIndicator('groq', i, null);
            const result = await testSingleGroqKey(key);
            KEY_STATUS.groq[i] = result;
            updateKeyIndicator('groq', i, result);
            if (result) working++;
            tested++;
        }
    }
    
    // Test DeepSeek key
    {
        const key = document.getElementById('deepseekKey1').value.trim();
        DEEPSEEK_KEYS[0] = key;
        KEY_ENABLED.deepseek[0] = document.getElementById('deepseekKey1On').checked;
        
        if (key && key.length > 5 && KEY_ENABLED.deepseek[0]) {
            updateKeyIndicator('deepseek', 0, null);
            const result = await testSingleDeepSeekKey(key);
            KEY_STATUS.deepseek[0] = result;
            updateKeyIndicator('deepseek', 0, result);
            if (result) working++;
            tested++;
        }
    }
    
    // Test Gemini keys
    for (let i = 0; i < 5; i++) {
        const keyInput = document.getElementById(`geminiKey${i+1}`);
        const toggleInput = document.getElementById(`geminiKey${i+1}On`);
        
        if (!keyInput) {
            console.error(`Missing geminiKey${i+1} input`);
            continue;
        }
        
        const key = keyInput.value.trim();
        GEMINI_KEYS[i] = key;
        KEY_ENABLED.gemini[i] = toggleInput ? toggleInput.checked : true;
        
        console.log(`Gemini Key ${i+1}: ${key ? key.substring(0,10) + '...' : 'empty'}, enabled: ${KEY_ENABLED.gemini[i]}`);
        
        if (key && key.length > 5 && KEY_ENABLED.gemini[i]) {
            updateKeyIndicator('gemini', i, null);
            const result = await testSingleGeminiKey(key);
            console.log(`Gemini Key ${i+1} test result: ${result}`);
            KEY_STATUS.gemini[i] = result;
            updateKeyIndicator('gemini', i, result);
            if (result) working++;
            tested++;
        }
    }
    
    updateKeyStatusGrid();
    updateKeyStatus();
    
    const aiDot = document.getElementById('aiDot');
    const aiStatus = document.getElementById('aiStatus');
    
    if (working > 0) {
        toast(`✅ ${working}/${tested} keys working!`, 'success');
        if (aiDot) aiDot.className = 'ai-dot on';
        if (aiStatus) aiStatus.textContent = 'AI: Ready';
    } else if (tested > 0) {
        toast(`❌ 0/${tested} keys working`, 'error');
        if (aiDot) aiDot.className = 'ai-dot error';
        if (aiStatus) aiStatus.textContent = 'AI: Error';
    } else {
        toast('⚠️ No keys to test', 'warning');
    }
}

function saveSettings() {
    console.log('💾 saveSettings() called');
    
    // Save all 11 API keys
    // Groq Keys (5)
    GROQ_KEYS[0] = document.getElementById('groqKey1').value.trim();
    GROQ_KEYS[1] = document.getElementById('groqKey2').value.trim();
    GROQ_KEYS[2] = document.getElementById('groqKey3').value.trim();
    GROQ_KEYS[3] = document.getElementById('groqKey4').value.trim();
    GROQ_KEYS[4] = document.getElementById('groqKey5').value.trim();
    
    // Save Groq ON/OFF toggles
    KEY_ENABLED.groq[0] = document.getElementById('groqKey1On').checked;
    KEY_ENABLED.groq[1] = document.getElementById('groqKey2On').checked;
    KEY_ENABLED.groq[2] = document.getElementById('groqKey3On').checked;
    KEY_ENABLED.groq[3] = document.getElementById('groqKey4On').checked;
    KEY_ENABLED.groq[4] = document.getElementById('groqKey5On').checked;
    
    // DeepSeek Key (1)
    DEEPSEEK_KEYS[0] = document.getElementById('deepseekKey1').value.trim();
    KEY_ENABLED.deepseek[0] = document.getElementById('deepseekKey1On').checked;
    
    // Gemini Keys (5)
    GEMINI_KEYS[0] = document.getElementById('geminiKey1').value.trim();
    GEMINI_KEYS[1] = document.getElementById('geminiKey2').value.trim();
    GEMINI_KEYS[2] = document.getElementById('geminiKey3').value.trim();
    GEMINI_KEYS[3] = document.getElementById('geminiKey4').value.trim();
    GEMINI_KEYS[4] = document.getElementById('geminiKey5').value.trim();
    
    // Save Gemini ON/OFF toggles
    KEY_ENABLED.gemini[0] = document.getElementById('geminiKey1On').checked;
    KEY_ENABLED.gemini[1] = document.getElementById('geminiKey2On').checked;
    KEY_ENABLED.gemini[2] = document.getElementById('geminiKey3On').checked;
    KEY_ENABLED.gemini[3] = document.getElementById('geminiKey4On').checked;
    KEY_ENABLED.gemini[4] = document.getElementById('geminiKey5On').checked;
    
    // Set STATE keys for backward compatibility
    STATE.aiKey = GROQ_KEYS[0];
    STATE.deepseekKey = DEEPSEEK_KEYS[0];
    STATE.geminiKey = GEMINI_KEYS[0];
    STATE.aiModel = document.getElementById('aiModelSelect').value;
    
    // Count only ENABLED keys
    const groqCount = GROQ_KEYS.filter((k, i) => k && KEY_ENABLED.groq[i]).length;
    const geminiCount = GEMINI_KEYS.filter((k, i) => k && KEY_ENABLED.gemini[i]).length;
    const deepseekCount = DEEPSEEK_KEYS.filter((k, i) => k && KEY_ENABLED.deepseek[i]).length;
    
    console.log('💾 Keys captured:', {
        groq: groqCount + ' keys enabled',
        deepseek: deepseekCount + ' keys enabled',
        gemini: geminiCount + ' keys enabled',
        total: groqCount + deepseekCount + geminiCount + ' of 11 enabled'
    });
    
    // Update grid
    updateKeyStatusGrid();
    
    // Save timeframe toggles
    STATE.tfEnabled['5'] = document.getElementById('tf5m').checked;
    STATE.tfEnabled['15'] = document.getElementById('tf15m').checked;
    STATE.tfEnabled['30'] = document.getElementById('tf30m').checked;
    STATE.tfEnabled['60'] = document.getElementById('tf1h').checked;
    STATE.tfEnabled['240'] = document.getElementById('tf4h').checked;
    STATE.tfEnabled['D'] = document.getElementById('tf1d').checked;
    
    // Save scan interval
    STATE.scanInterval = parseInt(document.getElementById('scanInterval').value);
    
    // Save alert settings
    STATE.alertSound = document.getElementById('alertSound').checked;
    STATE.alertVibrate = document.getElementById('alertVibrate').checked;
    STATE.alertGrade = document.getElementById('alertGrade').value;
    
    // Save telegram settings
    STATE.telegramEnabled = document.getElementById('telegramEnabled').checked;
    STATE.telegramToken = document.getElementById('telegramToken').value.trim();
    STATE.telegramChatId = document.getElementById('telegramChatId').value.trim();
    
    // Save risk settings
    STATE.riskAccount = parseFloat(document.getElementById('riskAccount').value) || 1000;
    STATE.riskPercent = parseFloat(document.getElementById('riskPercent').value) || 2;
    STATE.riskLeverage = parseInt(document.getElementById('riskLeverage').value) || 10;
    STATE.riskMaxPosition = parseFloat(document.getElementById('riskMaxPosition').value) || 500;
    
    // Save weights
    CONFIG.WEIGHTS.zone = parseInt(document.getElementById('weightZone').value) / 100;
    CONFIG.WEIGHTS.smc = parseInt(document.getElementById('weightSMC').value) / 100;
    CONFIG.WEIGHTS.momentum = parseInt(document.getElementById('weightMomentum').value) / 100;
    
    // Save theme
    STATE.oledTheme = document.getElementById('oledTheme').checked;
    applyTheme();
    
    // Save timezone
    STATE.awareness.timezone = document.getElementById('userTimezone').value;
    
    // BUG FIX #2: Using safe localStorage functions
    // Save all 11 API keys
    safeStorageSet('bybit_scanner_groq_keys', GROQ_KEYS);
    safeStorageSet('bybit_scanner_deepseek_keys', DEEPSEEK_KEYS);
    safeStorageSet('bybit_scanner_gemini_keys', GEMINI_KEYS);
    
    // Save KEY_ENABLED states
    safeStorageSet('bybit_scanner_key_enabled', KEY_ENABLED);
    
    // Keep old keys for backward compatibility
    safeStorageSet('bybit_scanner_key', STATE.aiKey);
    safeStorageSet('bybit_scanner_model', STATE.aiModel);
    safeStorageSet('bybit_scanner_deepseek', STATE.deepseekKey);
    safeStorageSet('bybit_scanner_gemini', STATE.geminiKey);
    
    safeStorageSet('bybit_scanner_tf', STATE.tfEnabled);
    safeStorageSet('bybit_scanner_interval', STATE.scanInterval);
    safeStorageSet('bybit_scanner_alert_sound', STATE.alertSound);
    safeStorageSet('bybit_scanner_alert_vibrate', STATE.alertVibrate);
    safeStorageSet('bybit_scanner_alert_grade', STATE.alertGrade);
    safeStorageSet('bybit_scanner_telegram_enabled', STATE.telegramEnabled);
    safeStorageSet('bybit_scanner_telegram_token', STATE.telegramToken);
    safeStorageSet('bybit_scanner_telegram_chat', STATE.telegramChatId);
    safeStorageSet('bybit_scanner_risk_account', STATE.riskAccount);
    safeStorageSet('bybit_scanner_risk_percent', STATE.riskPercent);
    safeStorageSet('bybit_scanner_risk_leverage', STATE.riskLeverage);
    safeStorageSet('bybit_scanner_risk_max', STATE.riskMaxPosition);
    safeStorageSet('bybit_scanner_weights', CONFIG.WEIGHTS);
    safeStorageSet('bybit_scanner_oled', STATE.oledTheme);
    safeStorageSet('bybit_scanner_coins', CONFIG.COINS);
    safeStorageSet('bybit_scanner_coin_count', STATE.coinCount);
    safeStorageSet('bybit_scanner_timezone', STATE.awareness.timezone);
    console.log('💾 Settings saved to localStorage successfully!');
    
    const totalKeys = GROQ_KEYS.filter((k, i) => k && KEY_ENABLED.groq[i]).length + 
                     DEEPSEEK_KEYS.filter((k, i) => k && KEY_ENABLED.deepseek[i]).length + 
                     GEMINI_KEYS.filter((k, i) => k && KEY_ENABLED.gemini[i]).length;
    if (totalKeys > 0) {
        const aiDot = document.getElementById('aiDot');
        const aiStatus = document.getElementById('aiStatus');
        if (aiDot) aiDot.className = 'ai-dot on';
        if (aiStatus) aiStatus.textContent = 'AI: ' + totalKeys + '/11 enabled';
    }
    
    updateKeyStatus();
    hideSettings();
    toast('Settings saved! ' + totalKeys + ' API keys configured.', 'success');
}

function loadSettings() {
    // BUG FIX #2: Using safe localStorage functions
    // Load all 11 API keys
    const savedGroqKeys = safeStorageGet('bybit_scanner_groq_keys', null);
    const savedDeepseekKeys = safeStorageGet('bybit_scanner_deepseek_keys', null);
    const savedGeminiKeys = safeStorageGet('bybit_scanner_gemini_keys', null);
    
    if (savedGroqKeys && Array.isArray(savedGroqKeys)) {
        savedGroqKeys.forEach((k, i) => { if (i < 5) GROQ_KEYS[i] = k || ''; });
    }
    if (savedDeepseekKeys && Array.isArray(savedDeepseekKeys)) {
        savedDeepseekKeys.forEach((k, i) => { if (i < 1) DEEPSEEK_KEYS[i] = k || ''; });
    }
    if (savedGeminiKeys && Array.isArray(savedGeminiKeys)) {
        savedGeminiKeys.forEach((k, i) => { if (i < 5) GEMINI_KEYS[i] = k || ''; });
    }
    
    // Load KEY_ENABLED states
    const savedKeyEnabled = safeStorageGet('bybit_scanner_key_enabled', null);
    if (savedKeyEnabled) {
        if (savedKeyEnabled.groq) KEY_ENABLED.groq = savedKeyEnabled.groq;
        if (savedKeyEnabled.deepseek) KEY_ENABLED.deepseek = savedKeyEnabled.deepseek;
        if (savedKeyEnabled.gemini) KEY_ENABLED.gemini = savedKeyEnabled.gemini;
    }
    
    // Backward compatibility - load old single keys if no array saved
    if (!savedGroqKeys) {
        const oldKey = safeStorageGet('bybit_scanner_key', '');
        if (oldKey) GROQ_KEYS[0] = oldKey;
    }
    if (!savedDeepseekKeys) {
        const oldKey = safeStorageGet('bybit_scanner_deepseek', '');
        if (oldKey) DEEPSEEK_KEYS[0] = oldKey;
    }
    if (!savedGeminiKeys) {
        const oldKey = safeStorageGet('bybit_scanner_gemini', '');
        if (oldKey) GEMINI_KEYS[0] = oldKey;
    }
    
    // Set STATE for backward compatibility
    STATE.aiKey = GROQ_KEYS[0] || DEFAULT_KEY;
    STATE.deepseekKey = DEEPSEEK_KEYS[0] || '';
    STATE.geminiKey = GEMINI_KEYS[0] || '';
    STATE.aiModel = safeStorageGet('bybit_scanner_model', 'llama-3.3-70b-versatile');
    
    // Load AI Display Mode
    STATE.aiDisplayMode = safeStorageGet('bybit_scanner_ai_display_mode', 'detailed');
    
    const groqCount = GROQ_KEYS.filter((k, i) => k && KEY_ENABLED.groq[i]).length;
    const geminiCount = GEMINI_KEYS.filter((k, i) => k && KEY_ENABLED.gemini[i]).length;
    const deepseekCount = DEEPSEEK_KEYS.filter((k, i) => k && KEY_ENABLED.deepseek[i]).length;
    
    console.log('🔑 Keys loaded:', {
        groq: groqCount + ' keys enabled',
        deepseek: deepseekCount + ' keys enabled',
        gemini: geminiCount + ' keys enabled',
        total: groqCount + deepseekCount + geminiCount + ' of 11 enabled'
    });
    
    // Load timeframe toggles
    const savedTf = safeStorageGet('bybit_scanner_tf', null);
    if (savedTf) {
        STATE.tfEnabled = savedTf;
    }
    
    // Load scan interval
    const savedInterval = safeStorageGet('bybit_scanner_interval', null);
    if (savedInterval) STATE.scanInterval = parseInt(savedInterval);
    
    // Load alert settings
    const savedSound = safeStorageGet('bybit_scanner_alert_sound', null);
    const savedVibrate = safeStorageGet('bybit_scanner_alert_vibrate', null);
    const savedGrade = safeStorageGet('bybit_scanner_alert_grade', null);
    
    if (savedSound !== null) STATE.alertSound = savedSound === true || savedSound === 'true';
    if (savedVibrate !== null) STATE.alertVibrate = savedVibrate === true || savedVibrate === 'true';
    if (savedGrade) STATE.alertGrade = savedGrade;
    
    // Load telegram settings
    const telegramEnabledVal = safeStorageGet('bybit_scanner_telegram_enabled', false);
    STATE.telegramEnabled = telegramEnabledVal === true || telegramEnabledVal === 'true';
    STATE.telegramToken = safeStorageGet('bybit_scanner_telegram_token', '');
    STATE.telegramChatId = safeStorageGet('bybit_scanner_telegram_chat', '');
    
    // Load risk settings
    STATE.riskAccount = parseFloat(safeStorageGet('bybit_scanner_risk_account', 1000)) || 1000;
    STATE.riskPercent = parseFloat(safeStorageGet('bybit_scanner_risk_percent', 2)) || 2;
    STATE.riskLeverage = parseInt(safeStorageGet('bybit_scanner_risk_leverage', 10)) || 10;
    STATE.riskMaxPosition = parseFloat(safeStorageGet('bybit_scanner_risk_max', 500)) || 500;
    
    // Load weights
    const savedWeights = safeStorageGet('bybit_scanner_weights', null);
    if (savedWeights) {
        CONFIG.WEIGHTS = savedWeights;
    }
    
    // Load theme
    const oledVal = safeStorageGet('bybit_scanner_oled', false);
    STATE.oledTheme = oledVal === true || oledVal === 'true';
    applyTheme();
    
    // Load coins
    const savedCoins = safeStorageGet('bybit_scanner_coins', null);
    const savedCoinCount = safeStorageGet('bybit_scanner_coin_count', null);
    if (savedCoins && Array.isArray(savedCoins)) {
        CONFIG.COINS = savedCoins;
    } else {
        CONFIG.COINS = CONFIG.ALL_COINS.slice(0, 50);
    }
    if (savedCoinCount) STATE.coinCount = parseInt(savedCoinCount);
    
    // Load timezone
    if (!STATE.awareness) STATE.awareness = { timezone: 'auto', news: [] };
    STATE.awareness.timezone = safeStorageGet('bybit_scanner_timezone', 'Australia/Melbourne');
    
    if (STATE.aiKey || STATE.deepseekKey || STATE.geminiKey) {
        const aiDot = document.getElementById('aiDot');
        const aiStatus = document.getElementById('aiStatus');
        if (aiDot) aiDot.className = 'ai-dot on';
        if (aiStatus) aiStatus.textContent = 'AI: Ready';
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ALERT FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function triggerAlert(signal) {
    console.log('🔔 triggerAlert called for:', signal.symbol, signal.direction, signal.grade);
    
    // Play sound
    if (STATE.alertSound) {
        playAlertSound();
    }
    
    // Vibrate
    if (STATE.alertVibrate && navigator.vibrate) {
        navigator.vibrate([200, 100, 200, 100, 200]);
    }
    
    // Send Telegram alert
    if (STATE.telegramEnabled) {
        console.log('🔔 Telegram enabled, sending alert...');
        sendTelegramAlert(signal);
    } else {
        console.log('🔔 Telegram disabled, skipping telegram alert');
    }
    
    // Show notification toast
    toast(`🔔 ${signal.grade}: ${signal.symbol.replace('USDT', '')} ${signal.direction} on ${signal.tf}`, 'success');
}

function playAlertSound() {
    try {
        // Create audio context for alert beep
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        oscillator.frequency.value = 880; // A5 note
        oscillator.type = 'sine';
        gainNode.gain.value = 0.3;
        
        oscillator.start();
        
        // Beep pattern: beep-beep-beep
        setTimeout(() => { gainNode.gain.value = 0; }, 100);
        setTimeout(() => { gainNode.gain.value = 0.3; }, 150);
        setTimeout(() => { gainNode.gain.value = 0; }, 250);
        setTimeout(() => { gainNode.gain.value = 0.3; }, 300);
        setTimeout(() => { gainNode.gain.value = 0; }, 400);
        setTimeout(() => { oscillator.stop(); }, 450);
    } catch (e) {
        console.log('Audio not supported');
    }
}

function testAlert() {
    // FIX: Complete test signal with all required properties
    const testSignal = {
        symbol: 'BTCUSDT',
        direction: 'LONG',
        grade: 'PERFECT',
        tf: '1H',
        score: 95,
        agreed: 3,
        levels: {
            entry: 100000.00,
            sl: 98500.00,
            tp1: 101500.00,
            tp2: 103000.00,
            tp3: 105000.00,
            rr: '3.0'
        }
    };
    triggerAlert(testSignal);
}

// ═══════════════════════════════════════════════════════════════════════════════
// COIN MANAGER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function setCoinCount(count) {
    STATE.coinCount = count;
    CONFIG.COINS = CONFIG.ALL_COINS.slice(0, count);
    renderCoinManager();
    toast(`Set to Top ${count} coins`, 'success');
}

function addCoin() {
    const input = document.getElementById('addCoinInput');
    let coin = input.value.trim().toUpperCase();
    if (!coin) return;
    
    if (!coin.endsWith('USDT')) {
        coin = coin + 'USDT';
    }
    
    if (CONFIG.COINS.includes(coin)) {
        toast('Coin already in list!', 'warning');
        return;
    }
    
    CONFIG.COINS.push(coin);
    input.value = '';
    renderCoinManager();
    toast(`Added ${coin}`, 'success');
}

function removeCoin(coin) {
    CONFIG.COINS = CONFIG.COINS.filter(c => c !== coin);
    renderCoinManager();
}

function renderCoinManager() {
    const el = document.getElementById('coinManager');
    document.getElementById('coinCountDisplay').textContent = CONFIG.COINS.length;
    
    el.innerHTML = `<div class="coin-grid">${CONFIG.COINS.map(coin => `
        <div class="coin-chip">
            <span>${coin.replace('USDT', '')}</span>
            <span class="remove-coin" onclick="removeCoin('${coin}')">×</span>
        </div>
    `).join('')}</div>`;
}

// ═══════════════════════════════════════════════════════════════════════════════
// WEIGHT & THEME FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function updateWeightDisplay() {
    const zone = parseInt(document.getElementById('weightZone').value);
    const smc = parseInt(document.getElementById('weightSMC').value);
    const momentum = parseInt(document.getElementById('weightMomentum').value);
    
    document.getElementById('weightZoneVal').textContent = zone + '%';
    document.getElementById('weightSMCVal').textContent = smc + '%';
    document.getElementById('weightMomentumVal').textContent = momentum + '%';
    
    const total = zone + smc + momentum;
    const totalEl = document.getElementById('weightTotal');
    totalEl.textContent = total + '%';
    totalEl.style.color = total === 100 ? 'var(--long)' : 'var(--short)';
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENGINE LOCK SYSTEM - Prevents accidental changes when scrolling
// ═══════════════════════════════════════════════════════════════════════════════

const ENGINE_LOCKS = {
    zone: false,
    smc: false,
    momentum: false
};

function toggleEngineLock(engine) {
    ENGINE_LOCKS[engine] = !ENGINE_LOCKS[engine];
    updateLockUI(engine);
    saveLockState();
}

function updateLockUI(engine) {
    // Handle case sensitivity: 'smc' -> 'SMC', 'zone' -> 'Zone', 'momentum' -> 'Momentum'
    let idSuffix;
    if (engine === 'smc') {
        idSuffix = 'SMC';
    } else if (engine === 'zone') {
        idSuffix = 'Zone';
    } else if (engine === 'momentum') {
        idSuffix = 'Momentum';
    } else {
        idSuffix = engine.charAt(0).toUpperCase() + engine.slice(1);
    }
    
    const btn = document.getElementById('lock' + idSuffix);
    const slider = document.getElementById('weight' + idSuffix);
    const container = document.getElementById('slider' + idSuffix);
    
    if (ENGINE_LOCKS[engine]) {
        if (btn) {
            btn.textContent = '🔒';
            btn.classList.add('locked');
        }
        if (slider) slider.disabled = true;
        if (container) container.classList.add('locked');
    } else {
        if (btn) {
            btn.textContent = '🔓';
            btn.classList.remove('locked');
        }
        if (slider) slider.disabled = false;
        if (container) container.classList.remove('locked');
    }
}

function lockAllEngines() {
    ENGINE_LOCKS.zone = true;
    ENGINE_LOCKS.smc = true;
    ENGINE_LOCKS.momentum = true;
    updateLockUI('zone');
    updateLockUI('smc');
    updateLockUI('momentum');
    saveLockState();
    toast('🔒 All engines locked', 'success');
}

function unlockAllEngines() {
    ENGINE_LOCKS.zone = false;
    ENGINE_LOCKS.smc = false;
    ENGINE_LOCKS.momentum = false;
    updateLockUI('zone');
    updateLockUI('smc');
    updateLockUI('momentum');
    saveLockState();
    toast('🔓 All engines unlocked', 'success');
}

function saveLockState() {
    try {
        localStorage.setItem('bybit_scanner_engine_locks', JSON.stringify(ENGINE_LOCKS));
    } catch (e) {
        console.error('Failed to save lock state:', e);
    }
}

function loadLockState() {
    try {
        const saved = localStorage.getItem('bybit_scanner_engine_locks');
        if (saved) {
            const locks = JSON.parse(saved);
            ENGINE_LOCKS.zone = locks.zone || false;
            ENGINE_LOCKS.smc = locks.smc || false;
            ENGINE_LOCKS.momentum = locks.momentum || false;
        }
        updateLockUI('zone');
        updateLockUI('smc');
        updateLockUI('momentum');
    } catch (e) {
        console.error('Failed to load lock state:', e);
    }
}

function applyTheme() {
    if (STATE.oledTheme) {
        document.body.classList.add('oled');
    } else {
        document.body.classList.remove('oled');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// TELEGRAM FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

async function sendTelegramAlert(signal) {
    // FIX: Early validation with logging
    if (!STATE.telegramEnabled) {
        console.log('📱 Telegram: Disabled');
        return;
    }
    if (!STATE.telegramToken) {
        console.log('📱 Telegram: No token configured');
        return;
    }
    if (!STATE.telegramChatId) {
        console.log('📱 Telegram: No chat ID configured');
        return;
    }
    
    // FIX: Null check for signal properties
    if (!signal || !signal.symbol || !signal.direction) {
        console.error('📱 Telegram: Invalid signal object');
        return;
    }
    
    // FIX: Safe access to levels with fallbacks
    const levels = signal.levels || {};
    const entry = levels.entry ? levels.entry.toFixed(4) : 'N/A';
    const sl = levels.sl ? levels.sl.toFixed(4) : 'N/A';
    const tp1 = levels.tp1 ? levels.tp1.toFixed(4) : 'N/A';
    const tp2 = levels.tp2 ? levels.tp2.toFixed(4) : 'N/A';
    const tp3 = levels.tp3 ? levels.tp3.toFixed(4) : 'N/A';
    const rr = levels.rr || 'N/A';
    
    // Environment data
    const env = signal.environment || {};
    const envScore = env.score || 'N/A';
    const envVerdict = env.verdict || 'N/A';
    const btcTrend = STATE.environment?.btcTrend?.direction || '--';
    const btcD = STATE.environment?.btcDominance?.trend === 'FALLING' ? 'ALTS' : 
                 STATE.environment?.btcDominance?.trend === 'RISING' ? 'BTC' : '--';
    
    const envEmoji = envVerdict === 'GO' ? '🟢' : envVerdict === 'CAUTION' ? '🟡' : envVerdict === 'RISKY' ? '🟠' : '🔴';
    
    // Safe symbol name (remove any markdown-breaking characters)
    const safeSymbol = (signal.symbol || '').replace('USDT', '').replace(/[_*`]/g, '');
    
    const message = `🚨 *${signal.grade || 'SIGNAL'} SIGNAL*

📊 *${safeSymbol}/USDT* - ${signal.direction}
⏱️ Timeframe: ${signal.tf || 'N/A'}
📈 Score: ${signal.score || 0}/100
🎯 Agreement: ${signal.agreed || 0}/3

📊 *Environment:* ${envEmoji} ${envVerdict} (${envScore}/100)
• BTC: ${btcTrend} | Season: ${btcD}

💰 *Trade Levels:*
• Entry: $${entry}
• Stop Loss: $${sl}
• TP1: $${tp1}
• TP2: $${tp2}
• TP3: $${tp3}

⚖️ Risk:Reward = 1:${rr}

_BS Scanner V1 ULTIMATE_`;

    try {
        console.log('📱 Telegram: Sending alert for', signal.symbol);
        
        const url = `https://api.telegram.org/bot${STATE.telegramToken}/sendMessage`;
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: STATE.telegramChatId,
                text: message,
                parse_mode: 'Markdown'
            })
        });
        
        // FIX: Check response status
        if (response.ok) {
            const data = await response.json();
            if (data.ok) {
                console.log('📱 Telegram: ✅ Alert sent successfully!');
            } else {
                console.error('📱 Telegram: ❌ API Error:', data.description);
            }
        } else {
            const errorData = await response.json().catch(() => ({}));
            console.error('📱 Telegram: ❌ HTTP Error:', response.status, errorData.description || response.statusText);
            
            // Common error hints
            if (response.status === 401) {
                console.error('📱 Telegram: Invalid bot token! Check your token.');
            } else if (response.status === 400) {
                console.error('📱 Telegram: Bad request - check chat ID or message format.');
            }
        }
    } catch (e) {
        console.error('📱 Telegram: ❌ Network/Connection error:', e.message);
    }
}

async function testTelegram() {
    if (!document.getElementById('telegramToken').value || !document.getElementById('telegramChatId').value) {
        toast('Enter Bot Token and Chat ID first!', 'error');
        return;
    }
    
    const token = document.getElementById('telegramToken').value.trim();
    const chatId = document.getElementById('telegramChatId').value.trim();
    
    // Validate token format
    if (!token.includes(':')) {
        toast('❌ Invalid token format! Should be like: 123456789:ABCdefGHI...', 'error');
        return;
    }
    
    // BUG FIX #5: Save settings before testing so saved values match tested values
    STATE.telegramToken = token;
    STATE.telegramChatId = chatId;
    STATE.telegramEnabled = document.getElementById('telegramEnabled').checked;
    safeStorageSet('bybit_scanner_telegram_token', token);
    safeStorageSet('bybit_scanner_telegram_chat', chatId);
    safeStorageSet('bybit_scanner_telegram_enabled', STATE.telegramEnabled);
    
    toast('📱 Testing Telegram connection...', '');
    
    try {
        const url = `https://api.telegram.org/bot${token}/sendMessage`;
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: chatId,
                text: '✅ *BS Scanner V1 ULTIMATE Connected!*\n\n🚀 You will receive trading signals here.\n\n_Test successful!_',
                parse_mode: 'Markdown'
            })
        });
        
        const data = await response.json();
        
        if (response.ok && data.ok) {
            toast('✅ Telegram test sent & settings saved!', 'success');
            console.log('📱 Telegram test successful:', data);
        } else {
            // Detailed error messages
            const errorMsg = data.description || 'Unknown error';
            console.error('📱 Telegram test failed:', errorMsg);
            
            if (errorMsg.includes('chat not found')) {
                toast('❌ Chat ID not found! Make sure you started the bot first.', 'error');
            } else if (errorMsg.includes('bot was blocked')) {
                toast('❌ Bot was blocked! Unblock the bot and try again.', 'error');
            } else if (errorMsg.includes('Unauthorized')) {
                toast('❌ Invalid Bot Token! Check your token.', 'error');
            } else {
                toast(`❌ Telegram error: ${errorMsg}`, 'error');
            }
        }
    } catch (e) {
        console.error('📱 Telegram connection error:', e);
        toast('❌ Network error! Check your internet connection.', 'error');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// VIEW TOGGLE & HEAT MAP
// ═══════════════════════════════════════════════════════════════════════════════

function setView(view) {
    STATE.view = view;
    document.getElementById('viewList').className = 'view-btn' + (view === 'list' ? ' active' : '');
    document.getElementById('viewHeatmap').className = 'view-btn' + (view === 'heatmap' ? ' active' : '');
    
    if (view === 'list') {
        updateSignalList();
    } else {
        renderHeatMap();
    }
}

function renderHeatMap() {
    const el = document.getElementById('signalList');
    const coins = [...new Set(STATE.signals.map(s => s.symbol))].slice(0, 30);
    const tfs = ['5m', '15m', '30m', '1H', '4H', '1D'];
    
    if (coins.length === 0) {
        el.innerHTML = `<div class="empty"><div class="empty-icon">🌡️</div><div>No signals for heat map</div></div>`;
        return;
    }
    
    let html = `<div class="heat-map-container"><table class="heat-map-table">
        <thead><tr><th>Coin</th>${tfs.map(tf => `<th>${tf}</th>`).join('')}</tr></thead>
        <tbody>`;
    
    for (const coin of coins) {
        html += `<tr><td class="coin-name">${coin.replace('USDT', '')}</td>`;
        
        for (const tf of tfs) {
            const sig = STATE.signals.find(s => s.symbol === coin && s.tf === tf);
            if (sig) {
                const cellClass = sig.direction.toLowerCase() + (sig.grade === 'PERFECT' ? ' perfect' : '');
                html += `<td onclick="selectSignalByKey('${coin}','${tf}')">
                    <div class="heat-cell ${cellClass}">${sig.score}</div>
                </td>`;
            } else {
                html += `<td><div class="heat-cell none">-</div></td>`;
            }
        }
        html += '</tr>';
    }
    
    html += '</tbody></table></div>';
    el.innerHTML = html;
}

function selectSignalByKey(symbol, tf) {
    const idx = STATE.signals.findIndex(s => s.symbol === symbol && s.tf === tf);
    if (idx >= 0) {
        selectSignal(idx);
        setView('list');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// RISK CALCULATOR
// ═══════════════════════════════════════════════════════════════════════════════

function calculatePositionSize(signal) {
    if (!signal) return null;
    
    const account = STATE.riskAccount;
    const riskPct = STATE.riskPercent / 100;
    const leverage = STATE.riskLeverage;
    const maxPos = STATE.riskMaxPosition;
    
    const riskAmount = account * riskPct;
    const slDistance = Math.abs(signal.levels.entry - signal.levels.sl) / signal.levels.entry;
    
    let positionSize = riskAmount / slDistance;
    positionSize = Math.min(positionSize, maxPos);
    
    const margin = positionSize / leverage;
    
    return {
        positionSize: positionSize.toFixed(2),
        margin: margin.toFixed(2),
        riskAmount: riskAmount.toFixed(2),
        leverage: leverage
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// INITIALIZATION
// ═══════════════════════════════════════════════════════════════════════════════

async function init() {
    console.log('🚀 Bybit Scanner v1 Starting...');
    
    // Load saved data
    loadSettings();
    loadTrades();
    loadLockState();
    updateTradeList();
    
    // Restore panel states
    restoreBacktestState();
    restoreFlowState();
    
    // Fetch BTC price and all market data
    await fetchBTC();
    await fetchAllMarketData();
    
    // Fetch Open Interest data
    await fetchBTCOpenInterest();
    
    // Initialize environment system
    await updateEnvironment();
    
    // Fetch crypto news for awareness
    await fetchCryptoNews();
    
    // BUG FIX #4: Track intervals for cleanup
    if (!window.scannerIntervals) {
        window.scannerIntervals = [];
    }
    
    // Clear any existing intervals (prevents stacking on hot reload)
    window.scannerIntervals.forEach(id => clearInterval(id));
    window.scannerIntervals = [];
    
    // Start auto-refresh with tracked intervals
    window.scannerIntervals.push(setInterval(fetchBTC, 30000));
    window.scannerIntervals.push(setInterval(fetchAllMarketData, 60000));  // Update market badges every minute
    window.scannerIntervals.push(setInterval(updateTradePrices, 30000));
    window.scannerIntervals.push(setInterval(updateEnvironment, 60000));  // Update environment every minute
    window.scannerIntervals.push(setInterval(fetchBTCOpenInterest, 60000));  // Update OI every minute
    window.scannerIntervals.push(setInterval(fetchLiquidations, 120000)); // Update liquidations every 2 min
    window.scannerIntervals.push(setInterval(fetchCryptoNews, 3600000));  // Update news every hour
    
    // Start scanning
    STATE.scanning = true;
    document.getElementById('scanBtn').className = 'btn scanning';
    document.getElementById('scanIcon').textContent = '◉';
    
    runScanner();
    
    console.log('✅ Bybit Scanner v1 Ready');
}

// BUG FIX #4: Cleanup intervals on page unload
window.addEventListener('beforeunload', () => {
    if (window.scannerIntervals) {
        window.scannerIntervals.forEach(id => clearInterval(id));
    }
});

// Start when DOM is ready
document.addEventListener('DOMContentLoaded', init);

// ═══════════════════════════════════════════════════════════════════════════════
// PWA SERVICE WORKER (Offline Support + Install as App)
// ═══════════════════════════════════════════════════════════════════════════════

// Register Service Worker for PWA
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        // Create inline service worker
        const swCode = `
            const CACHE_NAME = 'bs-scanner-v1';
            const urlsToCache = ['/'];
            
            self.addEventListener('install', e => {
                e.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache)));
                self.skipWaiting();
            });
            
            self.addEventListener('fetch', e => {
                e.respondWith(
                    fetch(e.request).catch(() => caches.match(e.request))
                );
            });
            
            self.addEventListener('activate', e => {
                e.waitUntil(clients.claim());
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl).then(reg => {
            console.log('✅ PWA Service Worker registered');
        }).catch(err => {
            console.log('PWA registration skipped (local file)');
        });
    });
}

// PWA Install Prompt
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    console.log('📱 App can be installed! Use browser menu > Add to Home Screen');
});

// ═══════════════════════════════════════════════════════════════════════════════
// TRADE HISTORY FEATURE
// ═══════════════════════════════════════════════════════════════════════════════

function showTradeHistory() {
    const history = STATE.tradeHistory || [];
    const stats = getTradeStats();
    
    let historyItems = '';
    if (history.length === 0) {
        historyItems = '<div style="text-align:center;color:var(--text3);padding:20px">No trade history yet</div>';
    } else {
        history.forEach(t => {
            const pnl = parseFloat(t.pnlPercent || 0);
            const resultClass = pnl > 0 ? 'long' : pnl < 0 ? 'short' : 'text3';
            const resultIcon = pnl > 0 ? '✅' : pnl < 0 ? '❌' : '⏹️';
            const date = new Date(t.closedAt || t.timestamp).toLocaleDateString();
            const pnlStr = t.pnlPercent ? (pnl >= 0 ? '+' : '') + t.pnlPercent + '%' : '--';
            const dirClass = t.direction === 'LONG' ? 'long' : 'short';
            
            historyItems += '<div style="display:flex;align-items:center;gap:8px;padding:8px;background:var(--bg3);border-radius:6px;margin-bottom:6px;border-left:3px solid var(--' + resultClass + ')">' +
                '<span style="font-size:16px">' + resultIcon + '</span>' +
                '<div style="flex:1">' +
                    '<div style="font-weight:600;font-size:13px">' + t.symbol.replace('USDT', '') + ' <span style="color:var(--' + dirClass + ');font-size:11px">' + t.direction + '</span></div>' +
                    '<div style="font-size:10px;color:var(--text3)">' + t.tf + ' • ' + t.grade + ' • ' + date + '</div>' +
                '</div>' +
                '<div style="text-align:right">' +
                    '<div style="font-weight:700;color:var(--' + (pnl >= 0 ? 'long' : 'short') + ')">' + pnlStr + '</div>' +
                    '<div style="font-size:10px;color:var(--text3)">P&L</div>' +
                '</div>' +
            '</div>';
        });
    }
    
    const pnlColor = parseFloat(stats.totalPnL) >= 0 ? 'var(--long)' : 'var(--short)';
    const pnlSign = parseFloat(stats.totalPnL) >= 0 ? '+' : '';
    
    const modalHtml = '<div class="modal-bg show" id="historyModal" onclick="if(event.target.id===\'historyModal\')closeHistoryModal()">' +
        '<div class="modal" style="max-width:500px;max-height:80vh;overflow:hidden;display:flex;flex-direction:column">' +
            '<div class="modal-head">' +
                '<div class="modal-title">📊 Trade History</div>' +
                '<button class="modal-close" onclick="closeHistoryModal()">✕</button>' +
            '</div>' +
            '<div style="padding:12px;border-bottom:1px solid var(--border)">' +
                '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;text-align:center">' +
                    '<div style="background:var(--bg3);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:var(--gold)">' + stats.total + '</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Total</div>' +
                    '</div>' +
                    '<div style="background:var(--long-dim);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:var(--long)">' + stats.profitable + '</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Profit</div>' +
                    '</div>' +
                    '<div style="background:var(--short-dim);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:var(--short)">' + stats.losing + '</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Loss</div>' +
                    '</div>' +
                    '<div style="background:var(--bg3);padding:8px;border-radius:6px">' +
                        '<div style="font-size:18px;font-weight:700;color:' + pnlColor + '">' + pnlSign + stats.totalPnL + '%</div>' +
                        '<div style="font-size:10px;color:var(--text3)">Total P&L</div>' +
                    '</div>' +
                '</div>' +
            '</div>' +
            '<div style="flex:1;overflow-y:auto;padding:12px">' + historyItems + '</div>' +
            '<div class="modal-foot">' +
                '<button class="btn" onclick="clearTradeHistory()">🗑️ Clear</button>' +
                '<button class="btn primary" onclick="closeHistoryModal()">Close</button>' +
            '</div>' +
        '</div>' +
    '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeHistoryModal() {
    const modal = document.getElementById('historyModal');
    if (modal) modal.remove();
}

function clearTradeHistory() {
    if (confirm('Are you sure you want to clear all trade history?')) {
        STATE.tradeHistory = [];
        saveTradeHistory();
        closeHistoryModal();
        showTradeHistory();
        toast('Trade history cleared', 'success');
    }
}

</script>
</body>
</html>
